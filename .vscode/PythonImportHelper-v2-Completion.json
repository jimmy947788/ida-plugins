[
    {
        "label": "struct,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct.",
        "description": "struct.",
        "detail": "struct.",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "ida_funcs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_funcs",
        "description": "ida_funcs",
        "detail": "ida_funcs",
        "documentation": {}
    },
    {
        "label": "idautils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idautils",
        "description": "idautils",
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "FuncItems",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "CodeRefsTo",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "idc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idc",
        "description": "idc",
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "ida_bytes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_bytes",
        "description": "ida_bytes",
        "detail": "ida_bytes",
        "documentation": {}
    },
    {
        "label": "ida_name",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_name",
        "description": "ida_name",
        "detail": "ida_name",
        "documentation": {}
    },
    {
        "label": "ida_idaapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_idaapi",
        "description": "ida_idaapi",
        "detail": "ida_idaapi",
        "documentation": {}
    },
    {
        "label": "ida_kernwin",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_kernwin",
        "description": "ida_kernwin",
        "detail": "ida_kernwin",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "debug_print",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "debug_print",
        "description": "debug_print",
        "detail": "debug_print",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ida_gdl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_gdl",
        "description": "ida_gdl",
        "detail": "ida_gdl",
        "documentation": {}
    },
    {
        "label": "ida_xref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_xref",
        "description": "ida_xref",
        "detail": "ida_xref",
        "documentation": {}
    },
    {
        "label": "ida_graph",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_graph",
        "description": "ida_graph",
        "detail": "ida_graph",
        "documentation": {}
    },
    {
        "label": "ida_lines",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_lines",
        "description": "ida_lines",
        "detail": "ida_lines",
        "documentation": {}
    },
    {
        "label": "ida_moves",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_moves",
        "description": "ida_moves",
        "detail": "ida_moves",
        "documentation": {}
    },
    {
        "label": "ida_auto",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_auto",
        "description": "ida_auto",
        "detail": "ida_auto",
        "documentation": {}
    },
    {
        "label": "ida_ua",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_ua",
        "description": "ida_ua",
        "detail": "ida_ua",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "get_func_relation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "get_func_relation",
        "description": "get_func_relation",
        "detail": "get_func_relation",
        "documentation": {}
    },
    {
        "label": "tinfo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tinfo",
        "description": "tinfo",
        "detail": "tinfo",
        "documentation": {}
    },
    {
        "label": "cto_base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cto_base",
        "description": "cto_base",
        "detail": "cto_base",
        "documentation": {}
    },
    {
        "label": "icon",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "icon",
        "description": "icon",
        "detail": "icon",
        "documentation": {}
    },
    {
        "label": "syncui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "syncui",
        "description": "syncui",
        "detail": "syncui",
        "documentation": {}
    },
    {
        "label": "cto_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cto_utils",
        "description": "cto_utils",
        "detail": "cto_utils",
        "documentation": {}
    },
    {
        "label": "ida_nalt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_nalt",
        "description": "ida_nalt",
        "detail": "ida_nalt",
        "documentation": {}
    },
    {
        "label": "cache_data",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cache_data",
        "description": "cache_data",
        "detail": "cache_data",
        "documentation": {}
    },
    {
        "label": "jump",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jump",
        "description": "jump",
        "detail": "jump",
        "documentation": {}
    },
    {
        "label": "config_base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "config_base",
        "description": "config_base",
        "detail": "config_base",
        "documentation": {}
    },
    {
        "label": "comments",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "comments",
        "description": "comments",
        "detail": "comments",
        "documentation": {}
    },
    {
        "label": "xor_loop_detector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xor_loop_detector",
        "description": "xor_loop_detector",
        "detail": "xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "notable_mnem_finder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "notable_mnem_finder",
        "description": "notable_mnem_finder",
        "detail": "notable_mnem_finder",
        "documentation": {}
    },
    {
        "label": "notable_const_finder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "notable_const_finder",
        "description": "notable_const_finder",
        "detail": "notable_const_finder",
        "documentation": {}
    },
    {
        "label": "notable_inst_finder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "notable_inst_finder",
        "description": "notable_inst_finder",
        "detail": "notable_inst_finder",
        "documentation": {}
    },
    {
        "label": "ida_entry",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_entry",
        "description": "ida_entry",
        "detail": "ida_entry",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "sip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sip",
        "description": "sip",
        "detail": "sip",
        "documentation": {}
    },
    {
        "label": "qtutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "qtutils",
        "description": "qtutils",
        "detail": "qtutils",
        "documentation": {}
    },
    {
        "label": "ida_strlist",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_strlist",
        "description": "ida_strlist",
        "detail": "ida_strlist",
        "documentation": {}
    },
    {
        "label": "ida_segment",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_segment",
        "description": "ida_segment",
        "detail": "ida_segment",
        "documentation": {}
    },
    {
        "label": "ida_search",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_search",
        "description": "ida_search",
        "detail": "ida_search",
        "documentation": {}
    },
    {
        "label": "ida_typeinf",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_typeinf",
        "description": "ida_typeinf",
        "detail": "ida_typeinf",
        "documentation": {}
    },
    {
        "label": "ida_netnode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_netnode",
        "description": "ida_netnode",
        "detail": "ida_netnode",
        "documentation": {}
    },
    {
        "label": "ida_idp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_idp",
        "description": "ida_idp",
        "detail": "ida_idp",
        "documentation": {}
    },
    {
        "label": "cProfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cProfile",
        "description": "cProfile",
        "detail": "cProfile",
        "documentation": {}
    },
    {
        "label": "pstats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pstats",
        "description": "pstats",
        "detail": "pstats",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "loop_detector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "loop_detector",
        "description": "loop_detector",
        "detail": "loop_detector",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ida_hexrays",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "minsn_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "vd_printer_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mbl_array_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_d",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_n",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_stx",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_ldx",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_xdu",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_xds",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_z",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_fn",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_S",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_v",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "EQ_IGNSIZE",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_b",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopHistory",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "remove_segment_registers",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_histories",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopHistory",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_histories",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_block",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "make_2way_block_goto",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "update_blk_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "mba_deep_cleaning",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_child_has_an_unconditional_father",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_last_block_is_goto",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "create_block",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "make_2way_block_goto",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "is_conditional_jump",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_2way_block_conditional_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "get_block_serials_by_address",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_2way_block_conditional_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "duplicate_block",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_list",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "maturity_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "string_to_maturity",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "block_printer",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "mop_type_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "maturity_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "mop_type_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "get_all_possibles_values",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotResolvableFatherException",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotDuplicableFatherException",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "get_all_possibles_values",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "configure_mop_tracker_log_verbosity",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "restore_mop_tracker_log_verbosity",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "GenericUnflatteningRule",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherCollector",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericUnflatteningRule",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherBlockInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherBlockInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "signed_to_unsigned",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "signed_to_unsigned",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_cf",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_of",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_sub_of",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "ror",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_parity_flag",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "FlowOptimizationRule",
        "importPath": "d810.optimizers.flow.handler",
        "description": "d810.optimizers.flow.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "FlowOptimizationRule",
        "importPath": "d810.optimizers.flow.handler",
        "description": "d810.optimizers.flow.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "InstructionDefUseCollector",
        "importPath": "d810.hexrays_hooks",
        "description": "d810.hexrays_hooks",
        "isExtraImport": true,
        "detail": "d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "InstructionDefUseCollector",
        "importPath": "d810.hexrays_hooks",
        "description": "d810.hexrays_hooks",
        "isExtraImport": true,
        "detail": "d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "extract_num_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "extract_num_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_bypass_xdu",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_ignore_msb_cst",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_cst",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "is_check_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_cst",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "OPCODES_INFO",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MBA_RELATED_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "Z3_SPECIAL_OPERANDS",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MINSN_TO_AST_FORBIDDEN_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONDITIONAL_JUMP_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "OPCODES_INFO",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MATURITY_TO_STRING_DICT",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "STRING_TO_MATURITY_DICT",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MOP_TYPE_TO_STRING_DICT",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_ins_mop_size_are_ok",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_blk_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MSB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "idaapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idaapi",
        "description": "idaapi",
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "SEGPERM_READ",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "SEGPERM_WRITE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "xrefblk_t",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "getseg",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "segment_t",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "XREF_DATA",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "dr_W",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "is_loaded",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "getseg",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "get_qword",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "SEGPERM_WRITE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_OPENIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_CLOSEIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_TERMIDA",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_REMOVE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_reg",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_imm",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_far",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_near",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_mem",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_displ",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_OPENIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_CLOSEIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_TERMIDA",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_REMOVE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "plugin_t",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "PLUGIN_PROC",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "PLUGIN_OK",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "ast_generator",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "mop_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "mop_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "JumpOptimizationRule",
        "importPath": "d810.optimizers.flow.jumps.handler",
        "description": "d810.optimizers.flow.jumps.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "JumpOptimizationRule",
        "importPath": "d810.optimizers.flow.jumps.handler",
        "description": "d810.optimizers.flow.jumps.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "OptimizationRule",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FLOW_MATURITIES",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INSTRUCTION_MATURITIES",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "OptimizationRule",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "InstructionAnalysisRule",
        "importPath": "d810.optimizers.instructions.analysis.handler",
        "description": "d810.optimizers.instructions.analysis.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "get_possible_patterns",
        "importPath": "d810.optimizers.instructions.analysis.utils",
        "description": "d810.optimizers.instructions.analysis.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.analysis.utils",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "ChainSimplificationRule",
        "importPath": "d810.optimizers.instructions.chain.handler",
        "description": "d810.optimizers.instructions.chain.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.chain.handler",
        "documentation": {}
    },
    {
        "label": "EarlyRule",
        "importPath": "d810.optimizers.instructions.early.handler",
        "description": "d810.optimizers.instructions.early.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.early.handler",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "Z3Rule",
        "importPath": "d810.optimizers.instructions.z3.handler",
        "description": "d810.optimizers.instructions.z3.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "Z3Rule",
        "importPath": "d810.optimizers.instructions.z3.handler",
        "description": "d810.optimizers.instructions.z3.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "AstEvaluationException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Exception",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "AstEvaluationException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "ControlFlowException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationIndirectJumpException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "UnresolvedMopException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Exception",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Z3Exception",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_equality",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_equality",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_inequality",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "log_z3_instructions",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "PatternOptimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "ChainOptimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "Z3Optimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "EarlyOptimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "ProjectConfiguration",
        "importPath": "d810.conf",
        "description": "d810.conf",
        "isExtraImport": true,
        "detail": "d810.conf",
        "documentation": {}
    },
    {
        "label": "RuleConfiguration",
        "importPath": "d810.conf",
        "description": "d810.conf",
        "isExtraImport": true,
        "detail": "d810.conf",
        "documentation": {}
    },
    {
        "label": "D810Configuration",
        "importPath": "d810.conf",
        "description": "d810.conf",
        "isExtraImport": true,
        "detail": "d810.conf",
        "documentation": {}
    },
    {
        "label": "logging.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.config",
        "description": "logging.config",
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "ida_diskio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_diskio",
        "description": "ida_diskio",
        "detail": "ida_diskio",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "yara",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yara",
        "description": "yara",
        "detail": "yara",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "messages",
        "importPath": "pyexpat.errors",
        "description": "pyexpat.errors",
        "isExtraImport": true,
        "detail": "pyexpat.errors",
        "documentation": {}
    },
    {
        "label": "messages",
        "importPath": "pyexpat.errors",
        "description": "pyexpat.errors",
        "isExtraImport": true,
        "detail": "pyexpat.errors",
        "documentation": {}
    },
    {
        "label": "gepetto.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gepetto.config",
        "description": "gepetto.config",
        "detail": "gepetto.config",
        "documentation": {}
    },
    {
        "label": "gepetto.ida.handlers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "ExplainHandler",
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "isExtraImport": true,
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "RenameHandler",
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "isExtraImport": true,
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "SwapModelHandler",
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "isExtraImport": true,
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "gepetto.models.model_manager",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "instantiate_model",
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "isExtraImport": true,
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "instantiate_model",
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "isExtraImport": true,
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "load_available_models",
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "isExtraImport": true,
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "register_cli",
        "importPath": "gepetto.ida.cli",
        "description": "gepetto.ida.cli",
        "isExtraImport": true,
        "detail": "gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "groq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "groq",
        "description": "groq",
        "detail": "groq",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "GPT",
        "importPath": "gepetto.models.openai",
        "description": "gepetto.models.openai",
        "isExtraImport": true,
        "detail": "gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT",
        "importPath": "gepetto.models.openai",
        "description": "gepetto.models.openai",
        "isExtraImport": true,
        "detail": "gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "ollama",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ollama",
        "description": "ollama",
        "detail": "ollama",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "importPath": "gepetto.models.base",
        "description": "gepetto.models.base",
        "isExtraImport": true,
        "detail": "gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "importPath": "gepetto.models.base",
        "description": "gepetto.models.base",
        "isExtraImport": true,
        "detail": "gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "importPath": "gepetto.models.base",
        "description": "gepetto.models.base",
        "isExtraImport": true,
        "detail": "gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "together",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "together",
        "description": "together",
        "detail": "together",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "gettext",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gettext",
        "description": "gettext",
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "pefile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pefile",
        "description": "pefile",
        "detail": "pefile",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "DockHandler",
        "importPath": "binaryninjaui",
        "description": "binaryninjaui",
        "isExtraImport": true,
        "detail": "binaryninjaui",
        "documentation": {}
    },
    {
        "label": "Transform",
        "importPath": "binaryninja.transform",
        "description": "binaryninja.transform",
        "isExtraImport": true,
        "detail": "binaryninja.transform",
        "documentation": {}
    },
    {
        "label": "cutter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cutter",
        "description": "cutter",
        "detail": "cutter",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "java.io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "java.io",
        "description": "java.io",
        "detail": "java.io",
        "documentation": {}
    },
    {
        "label": "DefinedDataIterator",
        "importPath": "ghidra.program.util",
        "description": "ghidra.program.util",
        "isExtraImport": true,
        "detail": "ghidra.program.util",
        "documentation": {}
    },
    {
        "label": "MD5Utilities",
        "importPath": "ghidra.util",
        "description": "ghidra.util",
        "isExtraImport": true,
        "detail": "ghidra.util",
        "documentation": {}
    },
    {
        "label": "ida_ida",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_ida",
        "description": "ida_ida",
        "detail": "ida_ida",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageQt",
        "importPath": "PIL.ImageQt",
        "description": "PIL.ImageQt",
        "isExtraImport": true,
        "detail": "PIL.ImageQt",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPainter",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QMouseEvent",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QKeySequence",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFontDatabase",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QTextDocument",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPalette",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "PyQt5.QtCore",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QMimeData",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "pyqtSignal",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QItemSelection",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QItemSelectionModel",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QRectF",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QAbstractTableModel",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStyle",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAction",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QTableView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHeaderView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QInputDialog",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAbstractItemView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QDialog",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QTextEdit",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QScrollArea",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "idabincat.netnode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idabincat.netnode",
        "description": "idabincat.netnode",
        "detail": "idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "bytes",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "idabincat.npkgen",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idabincat.npkgen",
        "description": "idabincat.npkgen",
        "detail": "idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X64_GPR",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X86_GPR",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "GUI",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GUI",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "pybincat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pybincat",
        "description": "pybincat",
        "detail": "pybincat",
        "documentation": {}
    },
    {
        "label": "PyBinCATException",
        "importPath": "pybincat",
        "description": "pybincat",
        "isExtraImport": true,
        "detail": "pybincat",
        "documentation": {}
    },
    {
        "label": "pybincat.cfa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pybincat.cfa",
        "description": "pybincat.cfa",
        "detail": "pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "idabincat.hexview",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idabincat.hexview",
        "description": "idabincat.hexview",
        "detail": "idabincat.hexview",
        "documentation": {}
    },
    {
        "label": "dump_binary",
        "importPath": "idabincat.dump_binary",
        "description": "idabincat.dump_binary",
        "isExtraImport": true,
        "detail": "idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "parsers",
        "importPath": "pybincat.tools",
        "description": "pybincat.tools",
        "isExtraImport": true,
        "detail": "pybincat.tools",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "uEmu",
        "description": "uEmu",
        "isExtraImport": true,
        "detail": "uEmu",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn",
        "description": "unicorn",
        "isExtraImport": true,
        "detail": "unicorn",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.arm_const",
        "description": "unicorn.arm_const",
        "isExtraImport": true,
        "detail": "unicorn.arm_const",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.arm64_const",
        "description": "unicorn.arm64_const",
        "isExtraImport": true,
        "detail": "unicorn.arm64_const",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.mips_const",
        "description": "unicorn.mips_const",
        "isExtraImport": true,
        "detail": "unicorn.mips_const",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.x86_const",
        "description": "unicorn.x86_const",
        "isExtraImport": true,
        "detail": "unicorn.x86_const",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "ida_enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_enum",
        "description": "ida_enum",
        "detail": "ida_enum",
        "documentation": {}
    },
    {
        "label": "D810State",
        "importPath": "d810.manager",
        "description": "d810.manager",
        "isExtraImport": true,
        "detail": "d810.manager",
        "documentation": {}
    },
    {
        "label": "D810_LOG_DIR_NAME",
        "importPath": "d810.manager",
        "description": "d810.manager",
        "isExtraImport": true,
        "detail": "d810.manager",
        "documentation": {}
    },
    {
        "label": "configure_loggers",
        "importPath": "d810.log",
        "description": "d810.log",
        "isExtraImport": true,
        "detail": "d810.log",
        "documentation": {}
    },
    {
        "label": "clear_logs",
        "importPath": "d810.log",
        "description": "d810.log",
        "isExtraImport": true,
        "detail": "d810.log",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "HyaraIDA",
        "importPath": "hyara_lib.integration.ida_api",
        "description": "hyara_lib.integration.ida_api",
        "isExtraImport": true,
        "detail": "hyara_lib.integration.ida_api",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "threading,requests,json,zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading.requests.json.zlib",
        "description": "threading.requests.json.zlib",
        "detail": "threading.requests.json.zlib",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idapal_qt_interface",
        "description": "idapal_qt_interface",
        "isExtraImport": true,
        "detail": "idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "aidapal_context",
        "description": "aidapal_context",
        "isExtraImport": true,
        "detail": "aidapal_context",
        "documentation": {}
    },
    {
        "label": "context_juicer",
        "importPath": "aidapal_helpers",
        "description": "aidapal_helpers",
        "isExtraImport": true,
        "detail": "aidapal_helpers",
        "documentation": {}
    },
    {
        "label": "ida_kernwin,ida_hexrays,ida_funcs,ida_name,ida_bytes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_kernwin.ida_hexrays.ida_funcs.ida_name.ida_bytes",
        "description": "ida_kernwin.ida_hexrays.ida_funcs.ida_name.ida_bytes",
        "detail": "ida_kernwin.ida_hexrays.ida_funcs.ida_name.ida_bytes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "keystone",
        "description": "keystone",
        "isExtraImport": true,
        "detail": "keystone",
        "documentation": {}
    },
    {
        "label": "six",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "six",
        "description": "six",
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "ida_struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_struct",
        "description": "ida_struct",
        "detail": "ida_struct",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "MD5",
        "kind": 6,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "class MD5:\n    \"An implementation of the MD5 hash function in pure Python.\"\n    def __init__(self):\n        \"Initialisation.\"\n        # Initial 128 bit message digest (4 times 32 bit).\n        self.A = 0L\n        self.B = 0L\n        self.C = 0L\n        self.D = 0L\n        # Initial message length in bits(!).",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def F(x, y, z):\n    return (x & y) | ((~x) & z)\ndef G(x, y, z):\n    return (x & z) | (y & (~z))\ndef H(x, y, z):\n    return x ^ y ^ z\ndef I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def G(x, y, z):\n    return (x & z) | (y & (~z))\ndef H(x, y, z):\n    return x ^ y ^ z\ndef I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def H(x, y, z):\n    return x ^ y ^ z\ndef I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation\n    (now summed-up in one function).\n    \"\"\"",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "I",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation\n    (now summed-up in one function).\n    \"\"\"\n    res = 0L\n    res = res + a + func(b, c, d)",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "XX",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation\n    (now summed-up in one function).\n    \"\"\"\n    res = 0L\n    res = res + a + func(b, c, d)\n    res = res + x\n    res = res + ac",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def new(arg=None):\n    \"\"\"Return a new md5 object.\n    If arg is present, the method call update(arg) is made.\n    \"\"\"\n    md5 = MD5()\n    if arg:\n        md5.update(arg)\n    return md5\ndef md5(arg=None):\n    \"\"\"Same as new().",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "md5",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def md5(arg=None):\n    \"\"\"Same as new().\n    For backward compatibility reasons, this is an alternative\n    name for the new() function.\n    \"\"\"\n    return new(arg)",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "__version__ = 0.9\nimport struct, string, copy\n# ======================================================================\n# Bit-Manipulation helpers\n#\n#   _long2bytes() was contributed by Barry Warsaw\n#   and is reused here with tiny modifications.\n# ======================================================================\ndef _long2bytes(n, blocksize=0):\n    \"\"\"Convert a long integer to a byte string.",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "source_path",
        "kind": 5,
        "importPath": "modules.install",
        "description": "modules.install",
        "peekOfCode": "source_path = os.path.dirname(os.path.realpath(__file__))\nif install:\n    print (\"Installing python modules from %s to %s...\" % (source_path, py_module_path))\nelse:\n    print (\"Removing python modules from %s...\" % py_module_path)\nfor py_module in next(os.walk('.'))[1]:\n    src = os.path.join(source_path, py_module, py_module + '.py')\n    dst = os.path.join(py_module_path, py_module + '.py')\n    if install:\n        print (\"Installing %s...\" % py_module)",
        "detail": "modules.install",
        "documentation": {}
    },
    {
        "label": "context",
        "kind": 6,
        "importPath": "plugins.aidapal_context.context",
        "description": "plugins.aidapal_context.context",
        "peekOfCode": "class context:\n    '''\n    This class is a context manager that handles the setting and restoring of the context\n    window for aidapal.\n    The context window is a comment block that is inserted into the c style comment block\n    for each query to the model.\n    '''\n    context = []\n    def __init__(self):\n        self.context = []",
        "detail": "plugins.aidapal_context.context",
        "documentation": {}
    },
    {
        "label": "get_all_comments",
        "kind": 2,
        "importPath": "plugins.aidapal_helpers.context_juicer",
        "description": "plugins.aidapal_helpers.context_juicer",
        "peekOfCode": "def get_all_comments(ea):\n    '''\n    Helper to return both repeatable and non repeatable comments for a given address\n    returns empty string if no comment\n    '''\n    cmt = ida_bytes.get_cmt(ea,False)\n    r_cmt = ida_bytes.get_cmt(ea,True)\n    if cmt is None:\n        if r_cmt is None:\n            return ''",
        "detail": "plugins.aidapal_helpers.context_juicer",
        "documentation": {}
    },
    {
        "label": "gather_unique_data_references",
        "kind": 2,
        "importPath": "plugins.aidapal_helpers.context_juicer",
        "description": "plugins.aidapal_helpers.context_juicer",
        "peekOfCode": "def gather_unique_data_references(function_ea):\n    '''\n    Function to gather unique data references in a given function\n    returns a list of unique data references or empty list if none found\n    '''\n    try:\n        # Get the function object\n        func = ida_funcs.get_func(function_ea)\n        if not func:\n            logging.error(f\"Invalid function address: 0x{function_ea:X}\")",
        "detail": "plugins.aidapal_helpers.context_juicer",
        "documentation": {}
    },
    {
        "label": "cache_data",
        "kind": 6,
        "importPath": "plugins.cto.cache_data",
        "description": "plugins.cto.cache_data",
        "peekOfCode": "class cache_data(debug_print.debug):\n    def __init__(self, data_dict=None, config=None, debug=False):\n        #debug_print.debug.__init__(self, debug)\n        super(cache_data, self).__init__(debug)\n        self.idb_name = idc.get_idb_path()\n        self.dh = self.data_handler(self.idb_name, config, data_dict)\n    class data_handler(object):\n        class data_storage(object):\n            def __init__(self, config=None, data_dict=None):\n                if config is None:",
        "detail": "plugins.cto.cache_data",
        "documentation": {}
    },
    {
        "label": "comment_t",
        "kind": 6,
        "importPath": "plugins.cto.comments",
        "description": "plugins.cto.comments",
        "peekOfCode": "class comment_t(object):\n    def __init__(self, frules=os.path.join(os.path.dirname(__file__),\"cmt_rules.json\")):\n        with open(frules) as f:\n            rules = json.load(f)\n        self.rules = self.create_comment_rules(rules)\n    @staticmethod\n    def create_comment_rules(rules):\n        result = {}\n        for cmt_type in rules:\n            if cmt_type not in result:",
        "detail": "plugins.cto.comments",
        "documentation": {}
    },
    {
        "label": "_config_base",
        "kind": 6,
        "importPath": "plugins.cto.config_base",
        "description": "plugins.cto.config_base",
        "peekOfCode": "class _config_base(object):\n    def __init__(self):\n        self.get_default_config()\n    def __len__(self):\n        return len(self.__dict__)\n    def __repr__(self):\n        return str(self.__dict__)\n    def __str__(self):\n        return str(self.__dict__)\n    def __iter__(self):",
        "detail": "plugins.cto.config_base",
        "documentation": {}
    },
    {
        "label": "CallTreeOverviewer",
        "kind": 6,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "class CallTreeOverviewer(cto_base.cto_base, ida_graph.GraphViewer):\n    orig_title = \"CTO\"\n    DO_NOT_SKIP = 0\n    SKIP_CHILDREN = 1\n    SKIP_PARENTS = 2\n    def __init__(self, start_ea, end_ea=ida_idaapi.BADADDR, max_depth=1, cto_data=None, curr_view=None, close_open=True, title_postfix=\"\", parent=None, skip=DO_NOT_SKIP, debug=False, skip_lib=True, skip_api=True):\n        # generate title\n        self.title = self.orig_title\n        if title_postfix:\n            self.title += title_postfix",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "exec_cto",
        "kind": 2,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "def exec_cto(cto_data=None, curr_view=None, max_depth=1, debug=False):\n    if debug or (\"g_debug\" in globals() and g_debug):\n        debug = True\n    try:\n        r = ida_auto.auto_wait()\n        if r:\n            cto = CallTreeOverviewer(ida_kernwin.get_screen_ea(), cto_data=cto_data, curr_view=curr_view, max_depth=max_depth, debug=debug)\n        else:\n            ida_kernwin.msg(\"IDA is still in automatic analysis and you have canceled the plugin execution. Do it later again if you need.%s\" % (os.linesep))\n    except Exception as e:",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "def main():\n    global g_cto\n    g_cto = exec_cto()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "g_max_recursive",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "g_max_recursive = 10\nFT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_ACT\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_ACT\"):\n    setattr(ida_kernwin, \"CVNF_ACT\", 0x4) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_ACT\"):\n    setattr(ida_kernwin, \"CVNF_ACT\", 0x4) # 7.5 lacks the definition\nclass CallTreeOverviewer(cto_base.cto_base, ida_graph.GraphViewer):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "cto_base",
        "kind": 6,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "class cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()\n        self.decomp_avail = False\n        try:\n            import ida_hexrays",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()\n        self.decomp_avail = False",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()\n        self.decomp_avail = False\n        try:",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "MyFilterProxyModel",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:\n            # the option is available only 5.10 and above\n            self.setRecursiveFiltering(True)\n        except AttributeError:",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "limit_keywords_dialog",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class limit_keywords_dialog(QtWidgets.QDialog):\n    state_changed = QtCore.pyqtSignal(str)\n    def __init__(self, parent=None):\n        super().__init__()\n        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n        self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint)\n        self.v = QtWidgets.QVBoxLayout()\n        self.setLayout(self.v)\n        self.key_cboxes = {}\n    @QtCore.pyqtSlot(dict)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "MyWidget",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class MyWidget(QtWidgets.QTreeView):\n    key_pressed = QtCore.pyqtSignal(QtGui.QKeyEvent)\n    current_changed = QtCore.pyqtSignal(QtCore.QModelIndex, QtCore.QModelIndex)\n    state_changed = QtCore.pyqtSignal(str)\n    after_filtered = QtCore.pyqtSignal(str)\n    item_changed = QtCore.pyqtSignal(QtCore.QModelIndex, str, str)\n    builtin_exec = QtCore.pyqtSignal(str)\n    def __init__(self):\n        #super(MyWidget, self).__init__(self)\n        QtWidgets.QTreeView.__init__(self)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "cto_func_lister_t",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class cto_func_lister_t(cto_base.cto_base, ida_kernwin.PluginForm):\n    imports = {}\n    imports_ids = {}\n    exports = {}\n    exports_ids = {}\n    funcs = {}\n    func_ids = {}\n    callers = {}\n    caller_ids = {}\n    default_bg = None",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "exec_cto_function_lister",
        "kind": 2,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "def exec_cto_function_lister(cto_data=None, debug=False):\n    cto_func_lister = cto_func_lister_t(cto_data=cto_data, debug=debug)\n    r = cto_func_lister.show()\n    if r:\n        return cto_func_lister\n    return None\ndef main():\n    global cto_func_lister\n    try:\n        cto_func_lister.Close(0)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "def main():\n    global cto_func_lister\n    try:\n        cto_func_lister.Close(0)\n        del cto_func_lister\n        cto_func_lister = cto_func_lister_t()\n    except:\n        cto_func_lister = cto_func_lister_t()\n# --------------------------------------------------------------------------\nif __name__ == '__main__':",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:\n            # the option is available only 5.10 and above",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:\n            # the option is available only 5.10 and above\n            self.setRecursiveFiltering(True)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "get_strlist_items",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_strlist_items():\n    si = ida_strlist.string_info_t()\n    for i in range(ida_strlist.get_strlist_qty()):\n        if ida_strlist.get_strlist_item(si, i):\n            yield si\ndef get_str_content(si):\n    strbytes = ida_bytes.get_strlit_contents(si.ea, si.length, si.type, ida_bytes.STRCONV_ESCAPE)\n    if sys.version_info.major >= 3:\n         return strbytes.decode(\"UTF-8\", \"replace\")\n    else:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_str_content",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_str_content(si):\n    strbytes = ida_bytes.get_strlit_contents(si.ea, si.length, si.type, ida_bytes.STRCONV_ESCAPE)\n    if sys.version_info.major >= 3:\n         return strbytes.decode(\"UTF-8\", \"replace\")\n    else:\n         return strbytes\n    return strbytes\ndef get_str_content_by_ea(ea):\n    result = None\n    for si in get_strlist_items():",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_str_content_by_ea",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_str_content_by_ea(ea):\n    result = None\n    for si in get_strlist_items():\n        if si.ea == ea:\n            result = get_str_content(si)\n            break\n    return result\ndef deep_update(source, overrides):\n    \"\"\"\n    Update a nested dictionary or similar mapping.",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "deep_update",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def deep_update(source, overrides):\n    \"\"\"\n    Update a nested dictionary or similar mapping.\n    Modify ``source`` in place.\n    \"\"\"\n    for key, value in overrides.items():\n        if key in source and type(source[key]) != type(value):\n            print(\"Error! Couldn't merge because the types of source and dest values are different. Key:\", key, type(source[key]), type(value)) \n        elif isinstance(value, colls.Mapping):\n            if value:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_widget",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_widget(ida_view=g_wname, decomp_view=g_decomp_name, curr_view=None):\n    w = ida_kernwin.get_current_widget()\n    wt = ida_kernwin.BWN_UNKNOWN\n    if w:\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            pass\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:\n            pass\n        else:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_xrefs",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_xrefs(ea):\n    next_addr = ida_xref.get_first_cref_to(ea)\n    while next_addr != ida_idaapi.BADADDR:\n        yield next_addr\n        next_addr = ida_xref.get_next_cref_to(ea,next_addr)\ndef count_xref(ea):\n    return len(list(get_xrefs(ea)))\ndef count_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "count_xref",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def count_xref(ea):\n    return len(list(get_xrefs(ea)))\ndef count_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        #print(\"%x\" % ea, list(fc))\n        return len(list(fc))\n    return 0\ndef is_64bit(ea):",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "count_bbs",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def count_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        #print(\"%x\" % ea, list(fc))\n        return len(list(fc))\n    return 0\ndef is_64bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "is_64bit",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def is_64bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)\n    if seg and seg.use64():\n        flag = True\n    return flag\ndef is_32bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)\n    if seg:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "is_32bit",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def is_32bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)\n    if seg:\n        if hasattr(seg, \"use32\"):\n            if seg.use32():\n                flag = True\n        else:\n            if not is_64bit(ea):\n                flag = True",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "g_wname",
        "kind": 5,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "g_wname = \"IDA View-A\"\ng_decomp_name = \"Pseudocode-A\"\ndef get_widget(ida_view=g_wname, decomp_view=g_decomp_name, curr_view=None):\n    w = ida_kernwin.get_current_widget()\n    wt = ida_kernwin.BWN_UNKNOWN\n    if w:\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            pass\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "g_decomp_name",
        "kind": 5,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "g_decomp_name = \"Pseudocode-A\"\ndef get_widget(ida_view=g_wname, decomp_view=g_decomp_name, curr_view=None):\n    w = ida_kernwin.get_current_widget()\n    wt = ida_kernwin.BWN_UNKNOWN\n    if w:\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            pass\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:\n            pass",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 6,
        "importPath": "plugins.cto.debug_print",
        "description": "plugins.cto.debug_print",
        "peekOfCode": "class debug(object):\n    def __init__(self, frames=2, lines=20000, outfile=True, file_handle=None):\n        self.outfile = outfile\n        self.f = file_handle\n        self.output_lines = 0\n        self.max_output_lines = lines\n        self.trace_back_frames = frames\n    def _dbg_print(self, *msg):\n        if not self.f and self.outfile:\n            try:",
        "detail": "plugins.cto.debug_print",
        "documentation": {}
    },
    {
        "label": "qprofile",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result\n        finally:\n            s = io.StringIO()",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "l_dbg_print",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def l_dbg_print(*msg):\n    global g_fp\n    global g_lines\n    if True:\n        if not g_fp:\n            try:\n                g_fp = tempfile.NamedTemporaryFile(delete=False, buffering=0)\n            except TypeError:\n                g_fp = tempfile.NamedTemporaryFile(delete=False) # for python 2.7\n            if g_fp:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "funcs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def funcs(ea=0):\n    while ea != ida_idaapi.BADADDR:\n        f = ida_funcs.get_next_func(ea)\n        if f:\n            ea = f.start_ea\n            yield f\n        else:\n            break\ndef get_bbs(f):\n    bbs = {}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_bbs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_bbs(f):\n    bbs = {}\n    for block in f:\n        bbs[block.start_ea] = block\n    return bbs\ndef get_func_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        bbs = get_bbs(fc)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_bbs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        bbs = get_bbs(fc)\n        return f, bbs\n    return None, {}\ndef get_imports():\n    def imp_cb(ea, name, ordinal):\n        result.append((modname, ea, str(ordinal) if not name else name, ordinal))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_imports",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_imports():\n    def imp_cb(ea, name, ordinal):\n        result.append((modname, ea, str(ordinal) if not name else name, ordinal))\n        # True -> Continue enumeration\n        # False -> Stop enumeration\n        return True\n    nimps = ida_nalt.get_import_module_qty()\n    result = []\n    for i in range(nimps):\n        modname = ida_nalt.get_import_module_name(i)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_ea_in_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_ea_in_func(target_ea, bbs):\n    for bbea in bbs:\n        bb = bbs[bbea]\n        if bb.start_ea <= target_ea and target_ea < bb.end_ea:\n            return True\n    return False\nFT_UNK = 0    # unknown\nFT_GEN = 1    # for general internal calls\nFT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_type",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type\n    f = ida_funcs.get_func(func_ea)\n    if f is None:\n        return func_type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_info_by_name",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_info_by_name(name):\n    func_type = FT_UNK\n    func_name = \"\"\n    func_ea = ida_idaapi.BADADDR\n    ret = tinfo.get_tinfo_by_name(name)\n    if ret:\n        # for APIs\n        func_name = name\n        func_type = FT_API\n        func_ea = idc.get_name_ea_simple(func_name)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_info_by_cmt",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_info_by_cmt(ea):\n    func_type = FT_UNK\n    func_name = \"\"\n    func_ea = ida_idaapi.BADADDR\n    # get non-repeatable comment\n    cmt = ida_bytes.get_cmt(ea, 0)\n    cmts = []\n    if cmt is not None:\n        cmt = cmt.strip()\n        cmts.append(cmt)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_info_by_opstr",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_info_by_opstr(ea, opn):\n    func_type = FT_UNK\n    func_name = \"\"\n    func_ea = ida_idaapi.BADADDR\n    opstr = idc.print_operand(ea, opn)\n    # api name in structure offset\n    # e.g. call    [edi+BaseStructure.kernel32.GetVersionExA] \n    #           or [eax+struc_1.field_3B4_InternetSetOptionA]\n    if opstr.find('.') >= 0 and opstr.find(')') < 0:\n        member_names = opstr.split('+')[-1].split('.')[:-1]",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_offset_fptr",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_offset_fptr(v):\n    target_ea = ida_idaapi.BADADDR\n    flags = ida_bytes.get_full_flags(v)\n    # call    cs:off_180097558 -> offset free\n    if ida_bytes.is_qword(flags):\n        off_v = ida_bytes.get_qword(v)\n        flags = ida_bytes.get_full_flags(off_v)\n        if ida_bytes.is_code(flags):\n            target_ea = off_v\n        #.data:00007FF9648576A8 ; void __stdcall __noreturn FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_ref_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_ref_func(ea):\n    n = ida_netnode.netnode(\"$ vmm functions\")\n    r = n.altval(ea)\n    if r != ida_idaapi.BADADDR:\n        r -= 1\n    return r & ida_idaapi.BADADDR\ndef get_switch_info(ea):\n    si = ida_nalt.switch_info_t()\n    ida_nalt.get_switch_info(si, ea)\n    if si.startea != ida_idaapi.BADADDR:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_switch_info",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_switch_info(ea):\n    si = ida_nalt.switch_info_t()\n    ida_nalt.get_switch_info(si, ea)\n    if si.startea != ida_idaapi.BADADDR:\n        return si\n    return None\ndef is_indirect_jump_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_indirect_jump_insn(tmp):\n        return True",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_indirect_jump_insn",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_indirect_jump_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_indirect_jump_insn(tmp):\n        return True\n    return False\ndef is_call_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_call_insn(tmp):\n        return True\n    return False",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_call_insn",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_call_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_call_insn(tmp):\n        return True\n    return False\ndef guess_var_size(ea):\n    seg = ida_segment.getseg(ea)\n    if not seg:\n        return 0\n    next_ea = ida_bytes.next_head(ea, ea + seg.abytes()+1)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "guess_var_size",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def guess_var_size(ea):\n    seg = ida_segment.getseg(ea)\n    if not seg:\n        return 0\n    next_ea = ida_bytes.next_head(ea, ea + seg.abytes()+1)\n    sz = seg.abytes()\n    while sz > 0:\n        if ea + sz <= next_ea :\n            break\n        sz = sz // 2",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_var_value_with_guess",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_var_value_with_guess(ea):\n    sz = guess_var_size(ea)\n    if sz == 0:\n        return None\n    value = None\n    if sz == 8:\n        value = ida_bytes.get_qword(ea)\n    elif sz == 4:\n        value = ida_bytes.get_dword(ea)\n    elif sz == 2:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_var_value",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_var_value(ea):\n    value = None\n    flags = ida_bytes.get_full_flags(ea)\n    if ida_bytes.is_qword(flags):\n        value = ida_bytes.get_qword(ea)\n    elif ida_bytes.is_dword(flags):\n        value = ida_bytes.get_dword(ea)\n    elif ida_bytes.is_word(flags):\n        value = ida_bytes.get_word(ea)\n    elif ida_bytes.is_byte(flags):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_str",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_str(ea, v, string_eas):\n    data = ''\n    data_type = FT_VAR\n    vflags = ida_bytes.get_full_flags(v)\n    if ida_bytes.is_strlit(vflags):\n        data_type = FT_STR\n        if ea in string_eas:\n            data = string_eas[ea][1]\n        else:\n            sz = ida_bytes.get_item_size(v)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_funcptr_ea",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_funcptr_ea(ea, import_eas, string_eas):\n    target_ea = ida_idaapi.BADADDR\n    func_type = FT_UNK\n    func_name = \"\"\n    insn = ida_ua.insn_t()\n    inslen = ida_ua.decode_insn(insn, ea)\n    for i in range(inslen):\n        op = insn.ops[i]\n        optype = op.type\n        if ida_ua.o_void == optype:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_stroff_ea",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_stroff_ea(ea, import_eas):\n    target_ea = ida_idaapi.BADADDR\n    func_type = FT_UNK\n    func_name = \"\"\n    insn = ida_ua.insn_t()\n    inslen = ida_ua.decode_insn(insn, ea)\n    i = -1\n    for i in range(inslen):\n        op = insn.ops[i]\n        optype = op.type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_vtbl_methods",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_vtbl_methods(target_ea, vtbl):\n    ea = get_offset_fptr(target_ea)\n    orig_target_ea = target_ea\n    prev_target_ea = target_ea\n    item_diff = 8\n    seg = ida_segment.getseg(target_ea)\n    next_name_ea = idc.get_inf_attr(idc.INF_MAX_EA)\n    if seg:\n        item_diff = 1<<(seg.bitness+1)\n        # get next label that has a xref",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_children",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_children(f, import_eas, string_eas):\n    result = {}\n    apicalls = {}\n    gvars = {}\n    strings = {}\n    stroff = {}\n    vtbl = {}\n    if f is None:\n        return result, apicalls, gvars, strings, stroff, vtbl\n    for ea in f.code_items():",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_xrefs_from",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_xrefs_from(ea):\n    next_addr = ida_xref.get_first_fcref_from(ea)\n    while next_addr != ida_idaapi.BADADDR:\n        yield next_addr\n        next_addr = ida_xref.get_next_fcref_from(ea, next_addr)\ndef get_xrefs(ea):\n    result = {}\n    op = -1\n    next_addr = ida_xref.get_first_fcref_to(ea)\n    while next_addr != ida_idaapi.BADADDR:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_xrefs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_xrefs(ea):\n    result = {}\n    op = -1\n    next_addr = ida_xref.get_first_fcref_to(ea)\n    while next_addr != ida_idaapi.BADADDR:\n        f = ida_funcs.get_func(next_addr)\n        func_ea = ida_idaapi.BADADDR\n        func_type = FT_UNK\n        if f is not None:\n            func_ea = f.start_ea",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_xrefs_in_range",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_xrefs_in_range(ea=idc.get_inf_attr(idc.INF_MIN_EA), max_ea=idc.get_inf_attr(idc.INF_MAX_EA)):\n    flags = ida_bytes.get_flags(ea)\n    if ida_bytes.has_xref(flags):\n        yield ea\n    #print(hex(ea), hex(max_ea))\n    if ea == ida_idaapi.BADADDR:\n        return\n    next_ea = ida_bytes.next_that(ea, max_ea, ida_bytes.has_xref)\n    while next_ea != ida_idaapi.BADADDR:\n        yield next_ea",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_drefs_to",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_drefs_to(ea):\n    ea = ida_bytes.get_item_head(ea)\n    if ea >= idc.get_inf_attr(idc.INF_MAX_EA):\n        return\n    item_sz = ida_bytes.get_item_size(ea)\n    # for getting in the middle of the xrefs of a structure\n    for next_ea in get_xrefs_in_range(ea, ea+item_sz):\n        for next_ea in _get_drefs_to(next_ea):\n            yield next_ea\ndef _get_drefs_from(ea):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_drefs_from",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_drefs_from(ea):\n    ea = ida_bytes.get_item_head(ea)\n    if ea >= idc.get_inf_attr(idc.INF_MAX_EA):\n        return\n    item_sz = ida_bytes.get_item_size(ea)\n    # for getting in the middle of the xrefs of a structure\n    for next_ea in get_xrefs_in_range(ea, ea+item_sz):\n        for next_ea in _get_drefs_from(next_ea):\n            yield next_ea\ndef get_dref_belong_to_func(ea, vtbl_refs, dref_recursive=True, debug=False, dbg_print_func=None):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dref_belong_to_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dref_belong_to_func(ea, vtbl_refs, dref_recursive=True, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    for next_ea in get_drefs_to(ea):\n        if debug: dbg_print(\"dref_to: \", hex(next_ea).rstrip(\"L\"), hex(ea).rstrip(\"L\"))\n        f = ida_funcs.get_func(next_ea)\n        flags = ida_bytes.get_full_flags(next_ea)\n        if f is not None:\n            if debug: dbg_print(\"!!!!!! func\", hex(next_ea).rstrip(\"L\"), hex(f.start_ea).rstrip(\"L\"), hex(ida_idaapi.BADADDR).rstrip(\"L\"))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dref_from_belong_to_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dref_from_belong_to_func(ea, dref_recursive=True, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    ea_flags = ida_bytes.get_flags(ea)\n    for next_ea in get_drefs_from(ea):\n        if debug: dbg_print(\"dref_from: \", hex(next_ea).rstrip(\"L\"), hex(ea).rstrip(\"L\"))\n        #print(hex(next_ea).rstrip(\"L\"), hex(ea).rstrip(\"L\"))\n        f = ida_funcs.get_func(next_ea)\n        flags = ida_bytes.get_full_flags(next_ea)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_refed_strings",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_refed_strings():\n    result = {}\n    s = idautils.Strings()\n    s.setup([ida_nalt.STRTYPE_C, ida_nalt.STRTYPE_C_16], minlen=4)\n    #s.setup()\n    for i in s:\n        r = set(get_drefs_to(i.ea))\n        #print(\"%x: len=%d type=%d -> '%s'\" % (i.ea, i.length, i.strtype, str(i)))\n        if len(r) > 0:\n            for x in r:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dyn_apicalls_partial",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dyn_apicalls_partial(func_relations, ea):\n    if not ea in func_relations:\n        f = ida_funcs.get_func(ea)\n        if f:\n            ea = f.start_ea\n    if ea in func_relations:\n        for caller in func_relations[ea]['children']:\n            func_ea, func_type, op, func_name = func_relations[ea]['children'][caller]\n            if func_ea == ida_idaapi.BADADDR and func_name:\n                yield caller, func_name",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dyn_apicalls",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dyn_apicalls(func_relations):\n    result = {}\n    for callee in func_relations:\n        for caller, func_name in get_dyn_apicalls_partial(func_relations, callee):\n            result[caller] = func_name\n    return result\ndef get_entry_points():\n    n = ida_entry.get_entry_qty()\n    for i in range(n):\n        ordinal = ida_entry.get_entry_ordinal(i)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_entry_points",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_entry_points():\n    n = ida_entry.get_entry_qty()\n    for i in range(n):\n        ordinal = ida_entry.get_entry_ordinal(i)\n        ea = ida_entry.get_entry(ordinal)\n        if ea != ida_idaapi.BADADDR:\n            yield ea\ndef get_opnums(func_relations, keyword='children'):\n    opnums = {}\n    for func_ea in func_relations:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_opnums",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_opnums(func_relations, keyword='children'):\n    opnums = {}\n    for func_ea in func_relations:\n        for caller in func_relations[func_ea][keyword]:\n            callee, func_type, op, func_name = func_relations[func_ea][keyword][caller]\n            opnums[caller] = op\n    return opnums\n# for reverse lookup of vftable\ndef get_vtbl_refs(func_relations):\n    result = {}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_vtbl_refs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_vtbl_refs(func_relations):\n    result = {}\n    for func_ea in func_relations:\n        for vtbl_offset in func_relations[func_ea][\"vftables\"]:\n            for vfptr in func_relations[func_ea][\"vftables\"][vtbl_offset]:\n                result[vfptr] = vtbl_offset\n    return result\ndef get_strings_in_funcs():\n    strings = get_refed_strings()\n    strings_in_func = {}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_strings_in_funcs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_strings_in_funcs():\n    strings = get_refed_strings()\n    strings_in_func = {}\n    for ea in strings:\n        f = ida_funcs.get_func(ea)\n        if f:\n            if f.start_ea in strings_in_func:\n                strings_in_func[f.start_ea][ea] = strings[ea]\n            else:\n                strings_in_func[f.start_ea] = {ea:strings[ea]}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_matched",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_matched(text, regexes):\n    matched = False\n    for regex in regexes:\n        if regex.match(text):\n            matched = True\n            break\n    if matched:\n        return True\n    return False\ndef get_cmts_in_func(func_ea, regexes_rpt=None, regexes=None):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_cmts_in_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_cmts_in_func(func_ea, regexes_rpt=None, regexes=None):\n    result = {'cmt':{}, 'rcmt':{}}\n    f = ida_funcs.get_func(func_ea)\n    if not f:\n        rcmt = ida_bytes.get_cmt(func_ea, True)\n        cmt = ida_bytes.get_cmt(func_ea, False)\n        if cmt and is_matched(cmt, regexes):\n            result['cmt'][func_ea] = cmt\n        if rcmt and not is_matched(rcmt, regexes_rpt):\n            result['rcmt'][func_ea] = rcmt",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_family_members",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_family_members(ea, f, import_eas=None, string_eas=None):\n    if import_eas is None:\n        import_eas = []\n    if string_eas is None:\n        string_eas = {}\n    target_ea = ea\n    if f is not None:\n        target_ea = f.start_ea\n    parents = get_xrefs(target_ea)\n    children, apicalls, gvars, strings, stroff, vtbl = get_children(f, import_eas, string_eas)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_relation",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_relation(f, import_eas=None, string_eas=None):\n    if import_eas is None:\n        import_eas = []\n    if string_eas is None:\n        string_eas = {}\n    #fc = ida_gdl.FlowChart(f)\n    #bbs = get_bbs(fc)\n    parents, children, apicalls, gvars, strings, stroff, vtbl = get_family_members(f.start_ea, f, import_eas, string_eas)\n    func_type = get_func_type(f.start_ea, import_eas)\n    yield f.start_ea, parents, children, func_type, gvars, strings, stroff, vtbl",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_relation_in_all_funcs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_relation_in_all_funcs(import_eas=None, string_eas=None):\n    for f in funcs():\n        for ea, parents, children, func_type, gvars, strings, stroff, vtbl in get_func_relation(f, import_eas, string_eas):\n            yield ea, parents, children, func_type, gvars, strings, stroff, vtbl\ndef fix_parent(func_relations, vtbl_refs, func_ea):\n    if func_ea not in func_relations:\n        return\n    for parent_caller in func_relations[func_ea][\"parents\"]:\n        if parent_caller in vtbl_refs:\n            parent_callee = vtbl_refs[parent_caller]",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "fix_parent",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def fix_parent(func_relations, vtbl_refs, func_ea):\n    if func_ea not in func_relations:\n        return\n    for parent_caller in func_relations[func_ea][\"parents\"]:\n        if parent_caller in vtbl_refs:\n            parent_callee = vtbl_refs[parent_caller]\n            orig_callee, ft, opn, name = func_relations[func_ea][\"parents\"][parent_caller]\n            func_relations[func_ea][\"parents\"][parent_caller] = (parent_callee, FT_VTB, -1, \"\")\ndef fix_parents(func_relations, vtbl_refs):\n    for func_ea in func_relations:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "fix_parents",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def fix_parents(func_relations, vtbl_refs):\n    for func_ea in func_relations:\n        fix_parent(func_relations, vtbl_refs, func_ea)\n#@qprofile\ndef get_func_relations():\n    t1 = time.time()\n    result = {}\n    imports = get_imports()\n    #import_eas = set([x[1] for x in imports])\n    import_eas = dict.fromkeys([x[1] for x in imports])",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_relations",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_relations():\n    t1 = time.time()\n    result = {}\n    imports = get_imports()\n    #import_eas = set([x[1] for x in imports])\n    import_eas = dict.fromkeys([x[1] for x in imports])\n    string_eas = get_refed_strings()\n    for func_ea, parents, children, func_type, gvars, strings, stroff, vtbl in get_relation_in_all_funcs(import_eas, string_eas):\n        result[func_ea] = {\"parents\":parents, \"children\":children, \"func_type\":func_type, \"gvars\":gvars, \"strings\":strings, \"struct_offsets\": stroff, \"vftables\": vtbl}\n    vtbl_refs = get_vtbl_refs(result)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dref_type",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dref_type(func_ea, func_type, func_relations):\n    if func_type == FT_UNK:\n        if func_ea in func_relations:\n            func_type = func_relations[func_ea][\"func_type\"]\n        if func_type in [FT_UNK]:\n            func_type = FT_VAR\n            flags = ida_bytes.get_flags(func_ea)\n            if ida_bytes.is_strlit(flags):\n                func_type = FT_STR\n    return func_type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "drefs_wrapper",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def drefs_wrapper(drefs, func_relations, direction, vtbl_refs, dref_recursive=True, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    dref_dir = \"parents\"\n    if direction == \"parents\":\n        dref_dir = \"children\"\n    # for drefs\n    for ea, func_ea, dref_off_ea in drefs:\n        if debug: dbg_print(\"ea:\", hex(ea), \"func_ea:\", hex(func_ea), \"dref_off_ea:\", hex(dref_off_ea))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_drefs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_drefs(func_ea, ea, direction, vtbl_refs, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    drefs = []\n    if direction == \"parents\":\n        if func_ea == ida_idaapi.BADADDR:\n            drefs = list(get_dref_belong_to_func(ea, vtbl_refs, debug=debug, dbg_print_func=dbg_print_func))\n        else:\n            drefs = list(get_dref_belong_to_func(func_ea, vtbl_refs, debug=debug, dbg_print_func=dbg_print_func))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "append_result",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def append_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, func_relations):\n    append_exceeded = False\n    if next_func_ea in func_relations and len(func_relations[next_func_ea][direction]) > 0:\n    #if next_func_ea in func_relations and len([func_relations[next_func_ea][direction][x] for x in func_relations[next_func_ea][direction] if len(func_relations[next_func_ea][direction][x]) > 0 if func_relations[next_func_ea][direction][x][1] not in [FT_STO, FT_VAR, FT_STR]]) > 0:\n        append_exceeded = True\n    _append_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, func_relations, append_exceeded=append_exceeded)\ndef _pop_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, append_exceeded=False):\n    result.pop(-1)\n    if dref_off_ea != ida_idaapi.BADADDR and next_func_ea != ida_idaapi.BADADDR and dref_off_ea != next_func_ea:\n        if not idc.get_struc_name(dref_off_ea):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "pop_result",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def pop_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, func_relations):\n    append_exceeded = False\n    if next_func_ea in func_relations and len(func_relations[next_func_ea][direction]) > 0:\n    #if next_func_ea in func_relations and len([func_relations[next_func_ea][direction][x] for x in func_relations[next_func_ea][direction] if len(func_relations[next_func_ea][direction][x]) > 0 if func_relations[next_func_ea][direction][x][1] not in [FT_STO, FT_VAR, FT_STR]]) > 0:\n        append_exceeded = True\n    _pop_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, append_exceeded=append_exceeded)\ndef check_next_drefs(drefs, direction, vtbl_refs, func_ea, func_relations, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "check_next_drefs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def check_next_drefs(drefs, direction, vtbl_refs, func_ea, func_relations, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    next_drefs_flag = False\n    next_drefs_code_flag = False\n    if len(drefs) > 0:\n        for next_ea, next_func_ea, dref_off_ea in drefs:\n            if next_func_ea in func_relations:\n                if debug: dbg_print(\"next_dref_flag enabled pattern 0:\", hex(next_ea), hex(next_func_ea), hex(dref_off_ea))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "trace_func_calls",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def trace_func_calls(func_relations, ea, func_ea=ida_idaapi.BADADDR, target_ea=ida_idaapi.BADADDR, direction=\"parents\", vtbl_refs={}, result=None, force_trace=False, max_recursive=g_max_recursive, nrecursive=0, skip_lib=False, skip_api=False, filtered_nodes=None, finished=None, finished_in_path=None, finished_nodes_in_path=None, debug=False, dbg_print_func=None):\n    local_finished = set([])\n    # initialize default values\n    if result is None:\n        result = []\n    if filtered_nodes is None:\n        filtered_nodes = ()\n    if finished is None:\n        finished = set([])\n    if finished_in_path is None:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def main():\n    imports = get_imports()\n    import_eas = dict.fromkeys([x[1] for x in imports])\n    string_eas = get_refed_strings()\n    ea = idc.here()\n    #f, bbs = get_func_bbs(ea)\n    if f:\n        ea = f.start_ea\n    parents, children, apicalls, gvars, strings, stroff, vtbl = get_family_members(ea, f, import_eas, string_eas)\n    print(\"Parents  :\", [(hex(x).rstrip(\"L\"), hex(parents[x][0]).rstrip(\"L\")) for x in parents])",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_max_recursive",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_max_recursive = 100\nif \"g_debug\" not in globals():\n    g_debug = False\ng_fp = None\ng_max_lines = 20000\ng_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_fp",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_fp = None\ng_max_lines = 20000\ng_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_max_lines",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_max_lines = 20000\ng_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_lines",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_dont_record_mnems",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result\n        finally:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_UNK = 0    # unknown\nFT_GEN = 1    # for general internal calls\nFT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_GEN = 1    # for general internal calls\nFT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type\n    f = ida_funcs.get_func(func_ea)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type\n    f = ida_funcs.get_func(func_ea)\n    if f is None:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "icon_handler",
        "kind": 6,
        "importPath": "plugins.cto.icon",
        "description": "plugins.cto.icon",
        "peekOfCode": "class icon_handler(object):\n    def __init__(self, icon_data, hexify=False):\n        if hexify:\n            icon_data = self.ascii_to_hex(icon_data)\n        self.icon_data = icon_data\n    @staticmethod\n    def ascii_to_hex(icon_data_ascii):\n        return codecs.decode(b\"\".join(icon_data_ascii), 'hex')\n    @staticmethod\n    def icon_bg_change(icon_data, bg_change=False, bin_transform=False):",
        "detail": "plugins.cto.icon",
        "documentation": {}
    },
    {
        "label": "g_icon_data_ascii",
        "kind": 5,
        "importPath": "plugins.cto.icon",
        "description": "plugins.cto.icon",
        "peekOfCode": "g_icon_data_ascii = (\n    b\"89504E470D0A1A0A0000000D4948445200000020000000200806000000737A7A\",\n    b\"F4000000097048597300000EC300000EC301C76FA8640000001974455874536F\",\n    b\"667477617265007777772E696E6B73636170652E6F72679BEE3C1A0000036249\",\n    b\"4441545885ADD75B8855651407F0DF346383948E4E99A6537445C2ACB1521421\",\n    b\"8C28822E4418965009094120E5180411F6D08588EE3E48D4832464045D686648\",\n    b\"7CA8888AB2FBE5A507C12CA8C0ACD46CB2C6D3C3FA367BCF696F3DFB9C59B0F9\",\n    b\"F6FEBE75F99FF5ADDBE9D23A0D602596E242CC443FFEC66FD8830FF012BEAAA1\",\n    b\"F798342F29FD178D169F2D3871328C2FC1DE1A868BCF9B9D1A9F8BDFDB349E3D\",\n    b\"577402E0E50E8D37C4B53D86EEBAC64FC3F8240028C6442D5A5FA26417BE3C06\",",
        "detail": "plugins.cto.icon",
        "documentation": {}
    },
    {
        "label": "g_icon_data",
        "kind": 5,
        "importPath": "plugins.cto.icon",
        "description": "plugins.cto.icon",
        "peekOfCode": "g_icon_data = codecs.decode(b\"\".join(g_icon_data_ascii), 'hex')\nclass icon_handler(object):\n    def __init__(self, icon_data, hexify=False):\n        if hexify:\n            icon_data = self.ascii_to_hex(icon_data)\n        self.icon_data = icon_data\n    @staticmethod\n    def ascii_to_hex(icon_data_ascii):\n        return codecs.decode(b\"\".join(icon_data_ascii), 'hex')\n    @staticmethod",
        "detail": "plugins.cto.icon",
        "documentation": {}
    },
    {
        "label": "jump_to_func_ptr_line_pos",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jump_to_func_ptr_line_pos(text, func_name, w, tweak=0, add_x=False):\n    flag = False\n    idx = text.find(func_name)\n    #w = find_widget(wname)\n    if w is None:\n        return flag\n    # we are already at a certain point. but ida sometimes does not point to a function in the middle of the instruction.\n    # that's why I use position 0 of x first, and then move to the right position again.\n    if idx == 0:\n        pos, x, y = ida_kernwin.get_custom_viewer_place(w, 0)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_apiname_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_apiname_line(ea, wname=g_wname):\n    fn = idc.get_name(ea)\n    if not fn:\n        return None, None\n    fn, line, idx = get_funcname_line(ea)\n    if not fn:\n        return None, None\n    w = find_widget(wname)\n    if w is None:\n        return None, None",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jump_to_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jump_to_line(ea, i, w):\n    #w = find_widget(wname)\n    if w is None:\n        return False\n    pos, x, y = ida_kernwin.get_custom_viewer_place(w, 0)\n    pos.lnnum = i\n    ida_kernwin.jumpto(w, pos, x, y)\n    return True\n\"\"\"\ndef check_line(ea, i, fn, wname=g_wname):",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "check_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def check_line(ea, i, fn, wname=g_wname):\n    w = find_widget(wname)\n    if w is None:\n        return None, -1\n    pos, x, y = ida_kernwin.get_custom_viewer_place(w, 0)\n    pos.lnnum = i\n    ida_kernwin.jumpto(w, pos, x, y)\n    l = ida_kernwin.get_curline()\n    l_removed = ida_lines.tag_remove(l)\n    l_removed_content = l_removed.split(\";\")[0]",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_line_no_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_line_no_decomp(text, vu, max_trial=200):\n    line = \"\"\n    lineno = -1\n    x = -1\n    lnnum = 0\n    y = 0\n    for i, l in enumerate(vu.cfunc.get_pseudocode()):\n        if ida_lines.tag_remove(l.line).startswith(\"//\"):\n            y += 1\n            continue",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_funcname_line_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_funcname_line_decomp(ea, vu, max_trial=200):\n    func_decl_str = ida_lines.tag_remove(vu.cfunc.print_dcl())\n    f = ida_funcs.get_func(ea)\n    func_name = ida_funcs.get_func_name(f.start_ea)\n    func_name = ida_name.validate_name(func_name, ida_name.VNT_VISIBLE)\n    # for API thunk call (e.g. __WSADisSet -> _WSADisSet)\n    if func_decl_str.find(func_name) < 0 and func_name.startswith(\"_\"):\n        func_name = func_name[1:]\n    line, lineno, lnnum, x, y = get_line_no_decomp(func_name, vu)\n    return line, lineno, lnnum, x, y",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_line_no",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_line_no(ea, text, max_trial=200, chk_cmt=False):\n    _, disass = ida_lines.generate_disassembly(\n        ea,\n        max_trial,  # maximum number of lines\n        False,      # as_stack=False\n        True)       # notags\n    for i, l in enumerate(disass):\n        if chk_cmt:\n            l_content = ''\n            if l.find(\";\") >= 0:",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_funcname_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_funcname_line(ea, w, max_trial=200):\n    f = ida_funcs.get_func(ea)\n    if f:\n        func_ea = f.start_ea\n        fn = idc.get_func_name(func_ea)\n    else:\n        fn = ida_name.get_name(ea)\n    if fn:\n        fn = ida_name.validate_name(fn, ida_name.VNT_VISIBLE)\n        #print(fn)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "push_lochist_jump",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def push_lochist_jump(w):\n    r = False\n    if w is None:\n        return False\n    loc = ida_moves.lochist_entry_t()\n    r = ida_kernwin.get_custom_viewer_location(loc, w)\n    if r:\n        loc.renderer_info().pos.cx = 0\n        r = ida_kernwin.custom_viewer_jump(w, loc, ida_kernwin.CVNF_JUMP)\n    return False",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_name_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_name_decomp(ea, w):\n    try:\n        import ida_hexrays\n        ida_hexrays.init_hexrays_plugin()\n    except ImportError:\n        return\n    vu = ida_hexrays.get_widget_vdui(w)\n    #print(vu.cfunc)\n    if vu is None:\n        return",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_name",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_name(ea, w):\n    wt = ida_kernwin.get_widget_type(w)\n    if wt == ida_kernwin.BWN_DISASM:\n        jumpto_name_ida(ea, w)\n    elif wt == ida_kernwin.BWN_PSEUDOCODE:\n        jumpto_name_decomp(ea, w)\ndef jumpto_name_ida(ea, w):\n    flag = False\n    ida_kernwin.jumpto(ea)\n    func = ida_funcs.get_func(ea)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_name_ida",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_name_ida(ea, w):\n    flag = False\n    ida_kernwin.jumpto(ea)\n    func = ida_funcs.get_func(ea)\n    # for callee\n    if func:\n        #print(\"%x\" % func.start_ea)\n        fn, line, idx = get_funcname_line(func.start_ea, w)\n        if idx >= 0:\n            if w is None:",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_offset",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_offset(ea, w):\n    flag = False\n    wt = ida_kernwin.get_widget_type(w)\n    if wt == ida_kernwin.BWN_DISASM:\n        flag = jumpto_offset_ida(ea, w)\n    elif wt == ida_kernwin.BWN_PSEUDOCODE:\n        pass\n    return flag\ndef jumpto_offset_ida(ea, w):\n    curr_line = ida_lines.tag_remove(ida_kernwin.get_curline())",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_offset_ida",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_offset_ida(ea, w):\n    curr_line = ida_lines.tag_remove(ida_kernwin.get_curline())\n    search_key = \" offset \"\n    x = curr_line.find(search_key)\n    if x > 0:\n        x += len(search_key)\n        func_name = ida_name.extract_name(curr_line.split(search_key)[1], 0)\n        # sometimes mismatch actual function name and and validate name.\n        # to fix it, get name and compare its name with it.\n        off_v = ida_xref.get_first_dref_from(ea)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_opn",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_opn(ea, opn, w):\n    flag = False\n    if opn >= 0:\n        tweak = 0\n        #ida_kernwin.jumpto(ea, opn, ida_kernwin.UIJMP_DONTPUSH)\n        ida_kernwin.jumpto(ea, opn)\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            jumpto_opn_ida(ea, opn, w)\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_highlight_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_highlight_decomp(w):\n    vu = None\n    highlight = None\n    try:\n        import ida_hexrays\n        ida_hexrays.init_hexrays_plugin()\n    except ImportError:\n        return None, None\n    vu = ida_hexrays.get_widget_vdui(w)\n    #print(vu.cfunc)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_current_line_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_current_line_decomp(highlight, vu):\n    x, y = vu.cfunc.find_item_coords(highlight)\n    return ida_lines.tag_remove(list(vu.cfunc.get_pseudocode())[y].line)\ndef get_highlight_name_decomp(w):\n    highlight, vu = get_highlight_decomp(w)\n    if highlight and highlight.is_expr():\n        hl_str = highlight.print1(None)\n        return hl_str\n    return None\ndef jumpto_opn_decomp(ea, opn, w):",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_highlight_name_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_highlight_name_decomp(w):\n    highlight, vu = get_highlight_decomp(w)\n    if highlight and highlight.is_expr():\n        hl_str = highlight.print1(None)\n        return hl_str\n    return None\ndef jumpto_opn_decomp(ea, opn, w):\n    flag = False\n    try:\n        import ida_hexrays",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_opn_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_opn_decomp(ea, opn, w):\n    flag = False\n    try:\n        import ida_hexrays\n        ida_hexrays.init_hexrays_plugin()\n    except ImportError:\n        return False\n    highlight, vu = get_highlight_decomp(w)\n    if highlight and highlight.is_expr():\n        hl_str = highlight.print1(None)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_opn_ida",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_opn_ida(ea, opn, w):\n    flag = False\n    if True:\n        tweak = 0\n        op = idc.print_operand(ea, opn)\n        optype = idc.get_operand_type(ea, opn)\n        v = idc.get_operand_value(ea, opn)\n        f = ida_funcs.get_func(ea)\n        func_flags = idc.get_func_attr(ea, idc.FUNCATTR_FLAGS)\n        func_name = ida_funcs.get_func_name(ea)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "loop_detector",
        "kind": 6,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "class loop_detector(object):\n    def __init__(self, ea, quantity_limit=True, chunk_quantity=1000):\n        self.ea = ea\n        self.f = ida_gdl.FlowChart(ida_funcs.get_func(ea))\n        self.chunk_quantity = chunk_quantity\n        self.quantity_limit = quantity_limit\n        self.finished = set([])\n        self.recognized_loop = []\n    def get_bb(self, ea):\n        block = None",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "print_loops",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def print_loops(loops):\n    i = 0\n    for loop in loops:\n        if len(loop) > 0:\n            print(\"  found loop starting at %08x:\" % loop[0][0])\n            for lbb in loop:\n                print(\"    bb_start_ea: %08x\" % lbb[0])\n            i += 1\n    print(\"found %d loops!\" % i)\n\"\"\"",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "recognized_loop",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def recognized_loop(func_ea, chunk_quantity=1000, quantity_limit=True):\n    ld = loop_detector(func_ea, quantity_limit, chunk_quantity)\n    loops = ld.find_loops()\n    print(\"func addr: %08x\" % func_ea)\n    print_loops(loops)\n\"\"\"\ndef get_all_loops_in_all_funcs():\n    for func_ea in idautils.Functions():\n        ld = loop_detector(func_ea)\n        loops = ld.get_all_loops_in_func()",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "get_all_loops_in_all_funcs",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def get_all_loops_in_all_funcs():\n    for func_ea in idautils.Functions():\n        ld = loop_detector(func_ea)\n        loops = ld.get_all_loops_in_func()\n        yield func_ea, loops\ndef main():\n    for func_ea, loops in get_all_loops_in_all_funcs():\n        print(\"----------------- %x -------------------\" % func_ea)\n        print_loops(loops)\n\"\"\"",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def main():\n    for func_ea, loops in get_all_loops_in_all_funcs():\n        print(\"----------------- %x -------------------\" % func_ea)\n        print_loops(loops)\n\"\"\"\ndef main():\n    ea = ida_kernwin.get_screen_ea()\n    print(\"-----------------all loops in func -------------------\")\n    ld = loop_detector(ea)\n    loops = ld.get_all_loops_in_func()",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def main():\n    ea = ida_kernwin.get_screen_ea()\n    print(\"-----------------all loops in func -------------------\")\n    ld = loop_detector(ea)\n    loops = ld.get_all_loops_in_func()\n    print_loops(loops)\n\"\"\"\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "notable_const_t",
        "kind": 6,
        "importPath": "plugins.cto.notable_const_finder",
        "description": "plugins.cto.notable_const_finder",
        "peekOfCode": "class notable_const_t(object):\n    def __init__(self, frules=os.path.join(os.path.dirname(__file__),\"notable_consts.json\"), show_high_ent=False, cmt_prefix=\"NT_CON: \"):\n        with open(frules) as f:\n            consts = json.load(f)\n        self.consts = {}\n        for rule_name in consts:\n            if rule_name not in self.consts:\n                self.consts[rule_name] = {}\n            if rule_name == \"single\":\n                for val in consts[rule_name]:",
        "detail": "plugins.cto.notable_const_finder",
        "documentation": {}
    },
    {
        "label": "get_op_size",
        "kind": 2,
        "importPath": "plugins.cto.notable_const_finder",
        "description": "plugins.cto.notable_const_finder",
        "peekOfCode": "def get_op_size(dtyp):\n    if dtyp == ida_ua.dt_dword:\n        size = 4\n    elif dtyp == ida_ua.dt_word:\n        size = 2\n    elif dtyp == ida_ua.dt_byte:\n        size = 1\n    elif dtyp == ida_ua.dt_qword:\n        size = 8\n    else:",
        "detail": "plugins.cto.notable_const_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.notable_const_finder",
        "description": "plugins.cto.notable_const_finder",
        "peekOfCode": "def main():\n    c = notable_const_t()\n    for func_ea, const_ea, val, rule_name in c.collect_notable_consts():\n        print(\"%x %s: %x, %x, %s\" % (func_ea, idc.get_name(func_ea), const_ea, val, rule_name))\nif __name__ == \"__main__\":\n    main()",
        "detail": "plugins.cto.notable_const_finder",
        "documentation": {}
    },
    {
        "label": "notable_inst_t",
        "kind": 6,
        "importPath": "plugins.cto.notable_inst_finder",
        "description": "plugins.cto.notable_inst_finder",
        "peekOfCode": "class notable_inst_t(object):\n    def __init__(self, frules=os.path.join(os.path.dirname(__file__),\"notable_insts.json\"), show_high_ent=False, cmt_prefix=\"NT_INST: \"):\n        with open(frules) as f:\n            insts = json.load(f)\n        self.insts = {}\n        for rule_type in insts:\n            if rule_type not in self.insts:\n                self.insts[rule_type] = {}\n            if rule_type == \"single\":\n                for rule_name in insts[rule_type]:",
        "detail": "plugins.cto.notable_inst_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.notable_inst_finder",
        "description": "plugins.cto.notable_inst_finder",
        "peekOfCode": "def main():\n    i = notable_inst_t()\n    for func_ea, inst_ea, rule_name, disasm in i.collect_notable_insts():\n        print(\"%x %s: %x: %s: %s\" % (func_ea, idc.get_name(func_ea), inst_ea, rule_name, disasm))\nif __name__ == \"__main__\":\n    main()",
        "detail": "plugins.cto.notable_inst_finder",
        "documentation": {}
    },
    {
        "label": "notable_mnem_t",
        "kind": 6,
        "importPath": "plugins.cto.notable_mnem_finder",
        "description": "plugins.cto.notable_mnem_finder",
        "peekOfCode": "class notable_mnem_t(object):\n    def __init__(self, cmt_prefix=\"NT_MNEM: \"):\n        self.cmt_prefix = cmt_prefix\n    @staticmethod\n    def get_code_eas(ea=idc.get_inf_attr(idc.INF_MIN_EA), max_ea=idc.get_inf_attr(idc.INF_MAX_EA)):\n        flags = ida_bytes.get_flags(ea)\n        if ida_bytes.is_code(flags):\n            yield ea\n        ea = ida_bytes.next_that(ea, max_ea, ida_bytes.is_code)\n        while ea != ida_idaapi.BADADDR:",
        "detail": "plugins.cto.notable_mnem_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.notable_mnem_finder",
        "description": "plugins.cto.notable_mnem_finder",
        "peekOfCode": "def main():\n    c = notable_mnem_t()\n    for func_ea, ea, mnem_type, dst_ea in c.mnem_handlers():\n        print(\"%x %s: %x: %s, %x\" % (func_ea, idc.get_name(func_ea), ea, mnem_type, dst_ea))\nif __name__ == \"__main__\":\n    main()",
        "detail": "plugins.cto.notable_mnem_finder",
        "documentation": {}
    },
    {
        "label": "enable_toolbar_t",
        "kind": 6,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "class enable_toolbar_t(ida_kernwin.UI_Hooks):\n    def __init__(self, toolbar_name):\n        self.toolbar_name = toolbar_name\n        ida_kernwin.UI_Hooks.__init__(self)\n        self.hook()\n    def ready_to_run(self):\n        self.enable_toolbar()\n    def enable_toolbar(self):\n        widget = ida_kernwin.open_navband_window(ida_kernwin.get_screen_ea(),1)\n        set_toobar_visible(widget, self.toolbar_name)",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "can_use_qt",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def can_use_qt():\n    try:\n        import sip\n        from PyQt5 import QtCore\n        from PyQt5 import QtWidgets\n        from PyQt5 import QtGui\n    except ImportError:\n        return False\n    return True\ndef get_qver():",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "get_qver",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def get_qver():\n    from PyQt5 import QtCore\n    v = QtCore.qVersion()\n    maj, mnr, _ =[int(x) for x in v.split(\".\")]\n    return maj, mnr\ndef get_widget(w, widget_types=None, title=None, max_try=100):\n    import sip\n    from PyQt5 import QtWidgets\n    if widget_types is None:\n        widget_types = set([QtWidgets.QWidget,QtWidgets.QSplitter])",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "get_widget",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def get_widget(w, widget_types=None, title=None, max_try=100):\n    import sip\n    from PyQt5 import QtWidgets\n    if widget_types is None:\n        widget_types = set([QtWidgets.QWidget,QtWidgets.QSplitter])\n    widget = sip.wrapinstance(int(w), QtWidgets.QWidget)\n    i = 0\n    while i < max_try and widget and type(widget) != QtWidgets.QMainWindow:\n        if type(widget) in widget_types:\n            #print(widget.windowTitle(), type(widget))",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "get_qmain_window",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def get_qmain_window(w, max_try = 100):\n    if not can_use_qt():\n        return None\n    import sip\n    from PyQt5 import QtWidgets\n    if w is None:\n        return None\n    widget = sip.wrapinstance(int(w), QtWidgets.QWidget)\n    find_flag = False\n    i = 0",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "find_toolbar",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def find_toolbar(widget, toolbar_name):\n    if not can_use_qt():\n        return None\n    from PyQt5 import QtWidgets\n    for cwidget in widget.children():\n        if type(cwidget) == QtWidgets.QToolBar:\n            #print(cwidget.objectName())\n            #print(cwidget.accessibleName())\n            if cwidget.objectName() == toolbar_name:\n                return cwidget",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "set_toobar_visible",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def set_toobar_visible(w, toolbar_name):\n    if not can_use_qt():\n        return False\n    from PyQt5 import QtCore\n    widget = get_qmain_window(w)\n    if widget:\n        tb_widget = find_toolbar(widget, toolbar_name)\n        if tb_widget and not tb_widget.isVisible():\n            tb_widget.setEnabled(True)\n            tb_widget.setVisible(True)",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "sync_data",
        "kind": 6,
        "importPath": "plugins.cto.syncdata",
        "description": "plugins.cto.syncdata",
        "peekOfCode": "class sync_data(object):\n    g_data_name = \"g_cto_data\"\n    def get(self):\n        # this process should be the first instance of CTO related object\n        if not hasattr(sys.modules[\"__main__\"], self.g_data_name):\n            print(\"data is unavailable. extract data from idb or pickle\")\n            return None\n        else:\n            print(\"get data from global variable\")\n            # Read the global dict",
        "detail": "plugins.cto.syncdata",
        "documentation": {}
    },
    {
        "label": "my_ui_hooks_t",
        "kind": 6,
        "importPath": "plugins.cto.syncui",
        "description": "plugins.cto.syncui",
        "peekOfCode": "class my_ui_hooks_t(ida_kernwin.UI_Hooks):\n    def __init__(self, g):\n        ida_kernwin.UI_Hooks.__init__(self)\n        self.hook()\n        # let's use weakrefs, so as soon as the last ref to\n        # the 'CallTreeOverviewer' instance is dropped, the 'my_ui_hooks_t'\n        # instance hooks can be automatically un-hooked, and deleted.\n        # (in other words: avoid circular reference.)\n        import weakref\n        self.v = weakref.ref(g)",
        "detail": "plugins.cto.syncui",
        "documentation": {}
    },
    {
        "label": "my_view_hooks_t",
        "kind": 6,
        "importPath": "plugins.cto.syncui",
        "description": "plugins.cto.syncui",
        "peekOfCode": "class my_view_hooks_t(ida_kernwin.View_Hooks):\n    def __init__(self, g):\n        ida_kernwin.View_Hooks.__init__(self)\n        self.hook()\n        # let's use weakrefs, so as soon as the last ref to\n        # the 'CallTreeOverviewer' instance is dropped, the 'my_view_hooks_t'\n        # instance hooks can be automatically un-hooked, and deleted.\n        # (in other words: avoid circular reference.)\n        import weakref\n        self.v = weakref.ref(g)",
        "detail": "plugins.cto.syncui",
        "documentation": {}
    },
    {
        "label": "get_tinfo",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_tinfo(ea):\n    tif = ida_typeinf.tinfo_t()\n    result = ida_nalt.get_tinfo(tif, ea)\n    #if result and func_flag:\n    #    result = ida_typeinf.is_type_func(tif.get_realtype())\n    return tif if result else None\n#def get_tinfo_by_name(name, func_flag=True):\ndef get_tinfo_by_name(name):\n    tinfo = None\n    result = ida_typeinf.get_named_type(ida_typeinf.get_idati(), name, 0)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_tinfo_by_name",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_tinfo_by_name(name):\n    tinfo = None\n    result = ida_typeinf.get_named_type(ida_typeinf.get_idati(), name, 0)\n    if result:\n        tinfo = ida_typeinf.tinfo_t()\n        ret = tinfo.deserialize(ida_typeinf.get_idati(), result[1], result[2])\n        if not ret:\n            return None\n        #if ret and func_flag:\n        #    ret = ida_typeinf.is_type_func(tinfo.get_realtype())",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_local_tinfo_by_name",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_local_tinfo_by_name(name, func_flag=True):\n    ea = ida_name.get_name_ea(ida_idaapi.BADADDR, name)\n    if ea == ida_idaapi.BADADDR:\n        return None\n    tinfo = ida_typeinf.tinfo_t()\n    ret = ida_nalt.get_tinfo(tinfo, ea)\n    if not ret:\n        tinfo = None\n    if ret and func_flag:\n        #ret = ida_typeinf.is_type_func(tinfo.get_realtype())",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "apply_tinfo_to_ea",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def apply_tinfo_to_ea(tinfo, ea, opn=0):\n    if not tinfo:\n        return False\n    if not tinfo.is_funcptr():\n        tinfo.create_ptr(tinfo)\n    # why do we apply both apply_callee_tinfo & set_op_tinfo?\n    # it is because set_op_tinfo() causes change in hexrays decompilation\n    # apply_callee_tinfo() updates ida's stack analysis\n    ida_typeinf.apply_callee_tinfo(ea, tinfo)\n    # apply_callee_tinfo doesn't have return value, so we have to return the result of set_op_tinfo2.",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_op_tif",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_op_tif(ea, opn=0):\n    tif = ida_typeinf.tinfo_t()\n    result = ida_nalt.get_op_tinfo(tif, ea, opn)\n    return tif  if result else None\ndef comp_tifs(name, ea, opn=0):\n    tif = get_op_tif(ea, opn)\n    tif2 = get_tinfo_by_name(name)\n    if _comp_tifs(tif, tif2):\n        return True\n    return False",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "comp_tifs",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def comp_tifs(name, ea, opn=0):\n    tif = get_op_tif(ea, opn)\n    tif2 = get_tinfo_by_name(name)\n    if _comp_tifs(tif, tif2):\n        return True\n    return False\ndef _comp_tifs(tif, tif2):\n    tif2 = get_op_tif(ea, opn)\n    if not tif2.is_funcptr():\n        tif2.create_ptr(tif2)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "del_tinfo_from_ea",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def del_tinfo_from_ea(ea, opn=0):\n    ida_nalt.del_op_tinfo(ea, opn)\n    # remove comments and reset var names for the result of appy_callee_tinfo()?\n    #for ea in ida_typeinf.get_arg_addrs(caller):\n    #    print(hex(ea))\ng_api_name_postfix_regex = re.compile(r'(.*)_[0-9]+$')\ndef get_true_name(name):\n    r = g_api_name_postfix_regex.search(name)\n    if r:\n        grps = r.groups()",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_true_name",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_true_name(name):\n    r = g_api_name_postfix_regex.search(name)\n    if r:\n        grps = r.groups()\n        if len(grps) > 0:\n            return grps[0]\n    return name\ndef guess_true_names(name):\n    names = [name]\n    removed_postfix = get_true_name(name)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "guess_true_names",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def guess_true_names(name):\n    names = [name]\n    removed_postfix = get_true_name(name)\n    result = [name]\n    if name != removed_postfix:\n        names.append(removed_postfix)\n        result.append(removed_postfix)\n    for n in names:\n        for prefix in [\"_\", \"__\", \"Rtl\"]:\n            result.append(prefix+n)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_func_detail",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_func_detail(tif):\n    fi = ida_typeinf.func_type_data_t()\n    tif.get_func_details(fi)\n    return fi\ndef get_func_args(fi):\n    if not fi.empty():\n        #print fi\n        for i in fi:\n            yield i\ndef is_thiscall(cc):",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_func_args",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_func_args(fi):\n    if not fi.empty():\n        #print fi\n        for i in fi:\n            yield i\ndef is_thiscall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_THISCALL:\n        return True\n    return False\ndef is_fastcall(cc):",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "is_thiscall",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def is_thiscall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_THISCALL:\n        return True\n    return False\ndef is_fastcall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_FASTCALL:\n        return True\n    return False\n\"\"\"\ndef del_op_tinfo(func_relations, func_ea, ea):",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "is_fastcall",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def is_fastcall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_FASTCALL:\n        return True\n    return False\n\"\"\"\ndef del_op_tinfo(func_relations, func_ea, ea):\n    if func_ea in func_relations:\n        if ea in func_relations[func_ea]['children']:\n            callee, func_type, opn, func_name = func_relations[func_ea]['children'][ea]\n            if callee == ida_idaapi.BADADDR and func_name:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "del_op_tinfo",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def del_op_tinfo(func_relations, func_ea, ea):\n    if func_ea in func_relations:\n        if ea in func_relations[func_ea]['children']:\n            callee, func_type, opn, func_name = func_relations[func_ea]['children'][ea]\n            if callee == ida_idaapi.BADADDR and func_name:\n                ida_nalt.del_op_tinfo(ea, opn)\ndef get_callee_info(func_relations, caller_ea):\n    f = ida_funcs.get_func(caller_ea)\n    if f and f.start_ea in func_relations:\n        if caller_ea in func_relations[f.start_ea]['children']:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_callee_info",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_callee_info(func_relations, caller_ea):\n    f = ida_funcs.get_func(caller_ea)\n    if f and f.start_ea in func_relations:\n        if caller_ea in func_relations[f.start_ea]['children']:\n            callee, func_type, op, func_name =  func_relations[f.start_ea]['children'][caller_ea]\n            return callee, func_type, op, func_name\n    return None, None, None, None\ndef apply_tif(caller, func_name):\n    callee, func_type, opn, _func_name = get_callee_info(caller)\n    if callee is not None:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "apply_tif",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def apply_tif(caller, func_name):\n    callee, func_type, opn, _func_name = get_callee_info(caller)\n    if callee is not None:\n        tif = get_tinfo_by_name(func_name)\n        if tif:\n            apply_tinfo_to_ea(tif, caller, opn)\ndef update_caller_tif(ea, func_name=None):\n    callee_ea, func_type, opn, _func_name = get_callee_info(ea)\n    if callee_ea is not None:\n        if func_name is None:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "update_caller_tif",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def update_caller_tif(ea, func_name=None):\n    callee_ea, func_type, opn, _func_name = get_callee_info(ea)\n    if callee_ea is not None:\n        if func_name is None:\n            #if callee_ea == ida_idaapi.BADADDR and _func_name:\n            if _func_name:\n                func_name = _func_name\n            else:\n                func_name, func_type, v = get_func_relation.get_func_info_by_opstr(ea, opn)\n        ida_nalt.del_op_tinfo(ea, opn)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "g_api_name_postfix_regex",
        "kind": 5,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "g_api_name_postfix_regex = re.compile(r'(.*)_[0-9]+$')\ndef get_true_name(name):\n    r = g_api_name_postfix_regex.search(name)\n    if r:\n        grps = r.groups()\n        if len(grps) > 0:\n            return grps[0]\n    return name\ndef guess_true_names(name):\n    names = [name]",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "rename_func",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def rename_func(ea, xref_cnt, prefix='xorloop_', rename_prefix=g_rename_prefix, force=False):\n    name = idc.get_name(ea)\n    if name.find(prefix) >= 0:\n        return\n    rename_flag = False\n    for n in g_rename_prefix:\n        if name.startswith(n):\n            rename_flag = True\n    if force:\n        rename_flag = True",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "get_xor_insns_all_funcs",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def get_xor_insns_all_funcs():\n    for func_ea in idautils.Functions():\n        for ea in get_xor_insns(func_ea):\n            yield func_ea, ea\ndef get_xor_insns(func_ea):\n    for ea in idautils.FuncItems(func_ea):\n        mnem = idc.print_insn_mnem(ea)\n        if mnem == 'xor':\n            op1 = idc.print_operand(ea, 0)\n            op2 = idc.print_operand(ea, 1)",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "get_xor_insns",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def get_xor_insns(func_ea):\n    for ea in idautils.FuncItems(func_ea):\n        mnem = idc.print_insn_mnem(ea)\n        if mnem == 'xor':\n            op1 = idc.print_operand(ea, 0)\n            op2 = idc.print_operand(ea, 1)\n            if op1 != op2:\n                yield ea\ndef find_xor_loop(xor=False, comment=True, rename=False, cmt_prefix=\"CTO-\"):\n    to_rename_funcs = {}",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "find_xor_loop",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def find_xor_loop(xor=False, comment=True, rename=False, cmt_prefix=\"CTO-\"):\n    to_rename_funcs = {}\n    for func_ea, ea in get_xor_insns_all_funcs():\n        ld = loop_detector.loop_detector(func_ea)\n        bb = ld.get_bb(ea)\n        annotation_type = \"\"\n        # skip the candidate for xor loop if the basic block is function start or function end because it is not in a loop.\n        if len(tuple(bb.preds())) == 0 or len(tuple(bb.succs())) == 0:\n            if xor:\n                annotation_type = \"xor\"",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def main():\n    for func_ea, ea, annotation_type in find_xor_loop():\n        print(\"%x %s: %s, %x: %s\" % (func_ea, idc.get_name(func_ea), annotation_type, ea, idc.generate_disasm_line(ea, 0)))\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "g_rename_prefix",
        "kind": 5,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "g_rename_prefix = ('sub_',)\ndef rename_func(ea, xref_cnt, prefix='xorloop_', rename_prefix=g_rename_prefix, force=False):\n    name = idc.get_name(ea)\n    if name.find(prefix) >= 0:\n        return\n    rename_flag = False\n    for n in g_rename_prefix:\n        if name.startswith(n):\n            rename_flag = True\n    if force:",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "FixPredecessorOfConditionalJumpBlock",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "description": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "peekOfCode": "class FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):\n    DESCRIPTION = \"Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_PASSES = 100\n    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:\n        if len(pred_comparison_values) == 0:\n            return False, False\n        jmp_ins = jmp_blk.tail\n        compared_value = jmp_ins.r.nnn.value\n        compared_value_size = jmp_ins.r.size",
        "detail": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "description": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nJMP_OPCODE_HANDLED = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jge, m_jg, m_jl, m_jle]\nclass FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):\n    DESCRIPTION = \"Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_PASSES = 100\n    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:\n        if len(pred_comparison_values) == 0:\n            return False, False\n        jmp_ins = jmp_blk.tail",
        "detail": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "documentation": {}
    },
    {
        "label": "JMP_OPCODE_HANDLED",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "description": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "peekOfCode": "JMP_OPCODE_HANDLED = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jge, m_jg, m_jl, m_jle]\nclass FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):\n    DESCRIPTION = \"Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_PASSES = 100\n    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:\n        if len(pred_comparison_values) == 0:\n            return False, False\n        jmp_ins = jmp_blk.tail\n        compared_value = jmp_ins.r.nnn.value",
        "detail": "plugins.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherBlockInfo(object):\n    def __init__(self, blk, father=None):\n        self.blk = blk\n        self.ins = []\n        self.use_list = []\n        self.use_before_def_list = []\n        self.def_list = []\n        self.assume_def_list = []\n        self.comparison_value = None\n        self.compared_mop = None",
        "detail": "plugins.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherInfo(object):\n    def __init__(self, mba: mbl_array_t):\n        self.mba = mba\n        self.mop_compared = None\n        self.entry_block = None\n        self.comparison_values = []\n        self.dispatcher_internal_blocks = []\n        self.dispatcher_exit_blocks = []\n    def reset(self):\n        self.mop_compared = None",
        "detail": "plugins.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherCollector(minsn_visitor_t):\n    DISPATCHER_CLASS = GenericDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 2\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 2\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 2\n    def __init__(self):\n        super().__init__()\n        self.dispatcher_list = []\n        self.explored_blk_serials = []\n        self.dispatcher_min_internal_block = self.DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK",
        "detail": "plugins.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericUnflatteningRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericUnflatteningRule(FlowOptimizationRule):\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    def __init__(self):\n        super().__init__()\n        self.mba = None\n        self.cur_maturity = MMAT_ZERO\n        self.cur_maturity_pass = 0\n        self.last_pass_nb_patch_done = 0\n        self.maturities = self.DEFAULT_UNFLATTENING_MATURITIES\n    def check_if_rule_should_be_used(self, blk: mblock_t) -> bool:",
        "detail": "plugins.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherUnflatteningRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherUnflatteningRule(GenericUnflatteningRule):\n    DISPATCHER_COLLECTOR_CLASS = GenericDispatcherCollector\n    MOP_TRACKER_MAX_NB_BLOCK = 100\n    MOP_TRACKER_MAX_NB_PATH = 100\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 5\n    def __init__(self):\n        super().__init__()\n        self.dispatcher_collector = self.DISPATCHER_COLLECTOR_CLASS()\n        self.dispatcher_list = []",
        "detail": "plugins.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nclass GenericDispatcherBlockInfo(object):\n    def __init__(self, blk, father=None):\n        self.blk = blk\n        self.ins = []\n        self.use_list = []\n        self.use_before_def_list = []\n        self.def_list = []\n        self.assume_def_list = []\n        self.comparison_value = None",
        "detail": "plugins.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "OllvmDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "OllvmDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:\n            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)\n        self.dispatcher_internal_blocks.append(self.entry_block)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "OllvmDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class OllvmDispatcherCollector(GenericDispatcherCollector):\n    DISPATCHER_CLASS = OllvmDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 2\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 3\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 2\nclass Unflattener(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by OLLVM\"\n    DISPATCHER_COLLECTOR_CLASS = OllvmDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "Unflattener",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class Unflattener(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by OLLVM\"\n    DISPATCHER_COLLECTOR_CLASS = OllvmDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 5",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFLATTENING_JUMP_OPCODES = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jg, m_jge, m_jl, m_jle]\nclass OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "FLATTENING_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "FLATTENING_JUMP_OPCODES = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jg, m_jge, m_jl, m_jle]\nclass OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)\n        self.entry_block.parse()",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "UnflattenerFakeJump",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "peekOfCode": "class UnflattenerFakeJump(GenericUnflatteningRule):\n    DESCRIPTION = \"Check if a jump is always taken for each father blocks and remove them\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\n    DEFAULT_MAX_PASSES = None\n    def analyze_blk(self, blk: mblock_t) -> int:\n        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:\n            return 0\n        if blk.get_reginsn_qty() != 1:\n            return 0\n        if blk.tail.r.t != mop_n:",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFAKE_LOOP_OPCODES = [m_jz, m_jnz]\nclass UnflattenerFakeJump(GenericUnflatteningRule):\n    DESCRIPTION = \"Check if a jump is always taken for each father blocks and remove them\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\n    DEFAULT_MAX_PASSES = None\n    def analyze_blk(self, blk: mblock_t) -> int:\n        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:\n            return 0\n        if blk.get_reginsn_qty() != 1:",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "documentation": {}
    },
    {
        "label": "FAKE_LOOP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "peekOfCode": "FAKE_LOOP_OPCODES = [m_jz, m_jnz]\nclass UnflattenerFakeJump(GenericUnflatteningRule):\n    DESCRIPTION = \"Check if a jump is always taken for each father blocks and remove them\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\n    DEFAULT_MAX_PASSES = None\n    def analyze_blk(self, blk: mblock_t) -> int:\n        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:\n            return 0\n        if blk.get_reginsn_qty() != 1:\n            return 0",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "documentation": {}
    },
    {
        "label": "TigressIndirectDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)\n        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)\n        self.entry_block.parse()",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "TigressIndirectDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)\n        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:\n            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "TigressIndirectDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class TigressIndirectDispatcherCollector(GenericDispatcherCollector):\n    DISPATCHER_CLASS = TigressIndirectDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 0\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 0\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 0\nclass LabelTableInfo(object):\n    def __init__(self, sp_offset, mem_offset, nb_elt, ptr_size=8):\n        self.sp_offset = sp_offset\n        self.mem_offset = mem_offset\n        self.nb_elt = nb_elt",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "LabelTableInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class LabelTableInfo(object):\n    def __init__(self, sp_offset, mem_offset, nb_elt, ptr_size=8):\n        self.sp_offset = sp_offset\n        self.mem_offset = mem_offset\n        self.nb_elt = nb_elt\n        self.ptr_size = ptr_size\n    def update_mop_tracker(self, mba: mbl_array_t, mop_tracker: MopTracker):\n        stack_array_base_address = mba.stkoff_ida2vd(self.sp_offset)\n        for i in range(self.nb_elt):\n            tmp_mop = mop_t()",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "UnflattenerTigressIndirect",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class UnflattenerTigressIndirect(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"\"\n    DISPATCHER_COLLECTOR_CLASS = TigressIndirectDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_LOCOPT]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 1\n    def __init__(self):\n        super().__init__()\n        self.label_info = None\n        self.goto_table_info = {}",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "FLATTENING_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "FLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)\n        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "TigressSwitchDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)\n        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)\n        self.entry_block.parse()",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "TigressSwitchDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)\n        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:\n            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "TigressSwitchDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class TigressSwitchDispatcherCollector(GenericDispatcherCollector):\n    DISPATCHER_CLASS = TigressSwitchDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 0\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 4\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 4\nclass UnflattenerSwitchCase(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by Tigress with Switch case dispatcher\"\n    DISPATCHER_COLLECTOR_CLASS = TigressSwitchDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_GLBOPT1]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "UnflattenerSwitchCase",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class UnflattenerSwitchCase(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by Tigress with Switch case dispatcher\"\n    DISPATCHER_COLLECTOR_CLASS = TigressSwitchDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_GLBOPT1]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 5",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "FLATTENING_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "FLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)\n        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)",
        "detail": "plugins.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "UnflatteningException",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class UnflatteningException(Exception):\n    pass\nclass DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "DispatcherUnflatteningException",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotDuplicableFatherException",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:\n        tracker_logger.setLevel(logging.ERROR)\n        emulator_logger.setLevel(logging.ERROR)",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotResolvableFatherException",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:\n        tracker_logger.setLevel(logging.ERROR)\n        emulator_logger.setLevel(logging.ERROR)\n    return [tracker_log_level, emulator_log_level]\ndef restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "configure_mop_tracker_log_verbosity",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:\n        tracker_logger.setLevel(logging.ERROR)\n        emulator_logger.setLevel(logging.ERROR)\n    return [tracker_log_level, emulator_log_level]\ndef restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):\n    tracker_logger.setLevel(tracker_log_level)\n    emulator_logger.setLevel(emulator_log_level)",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "restore_mop_tracker_log_verbosity",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):\n    tracker_logger.setLevel(tracker_log_level)\n    emulator_logger.setLevel(emulator_log_level)\ndef get_all_possibles_values(mop_histories, searched_mop_list, verbose=False):\n    log_levels = configure_mop_tracker_log_verbosity(verbose)\n    mop_cst_values_list = []\n    for mop_history in mop_histories:\n        mop_cst_values_list.append([mop_history.get_mop_constant_value(searched_mop)\n                                    for searched_mop in searched_mop_list])\n    restore_mop_tracker_log_verbosity(*log_levels)",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "get_all_possibles_values",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def get_all_possibles_values(mop_histories, searched_mop_list, verbose=False):\n    log_levels = configure_mop_tracker_log_verbosity(verbose)\n    mop_cst_values_list = []\n    for mop_history in mop_histories:\n        mop_cst_values_list.append([mop_history.get_mop_constant_value(searched_mop)\n                                    for searched_mop in searched_mop_list])\n    restore_mop_tracker_log_verbosity(*log_levels)\n    return mop_cst_values_list\ndef check_if_all_values_are_found(mop_cst_values_list):\n    all_values_are_found = True",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "check_if_all_values_are_found",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def check_if_all_values_are_found(mop_cst_values_list):\n    all_values_are_found = True\n    for cst_list in mop_cst_values_list:\n        if None in cst_list:\n            all_values_are_found = False\n            break\n    return all_values_are_found",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "tracker_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "tracker_logger = logging.getLogger('D810.tracker')\nemulator_logger = logging.getLogger('D810.emulator')\nclass UnflatteningException(Exception):\n    pass\nclass DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "emulator_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "emulator_logger = logging.getLogger('D810.emulator')\nclass UnflatteningException(Exception):\n    pass\nclass DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass",
        "detail": "plugins.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "JumpOptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "class JumpOptimizationRule(InstructionOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = []\n    LEFT_PATTERN = None\n    RIGHT_PATTERN = None\n    REPLACEMENT_OPCODE = None\n    REPLACEMENT_LEFT_PATTERN = None\n    REPLACEMENT_RIGHT_PATTERN = None\n    FUZZ_PATTERNS = True\n    def __init__(self):\n        super().__init__()",
        "detail": "plugins.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "JumpFixer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "class JumpFixer(FlowOptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.known_rules = []\n        self.rules = []\n    def register_rule(self, rule: JumpOptimizationRule):\n        self.known_rules.append(rule)\n    def configure(self, kwargs):\n        super().configure(kwargs)\n        self.rules.clear()",
        "detail": "plugins.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "logger = logging.getLogger(\"D810.branch_fixer\")\noptimizer_logger = logging.getLogger('D810.optimizer')\nclass JumpOptimizationRule(InstructionOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = []\n    LEFT_PATTERN = None\n    RIGHT_PATTERN = None\n    REPLACEMENT_OPCODE = None\n    REPLACEMENT_LEFT_PATTERN = None\n    REPLACEMENT_RIGHT_PATTERN = None\n    FUZZ_PATTERNS = True",
        "detail": "plugins.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nclass JumpOptimizationRule(InstructionOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = []\n    LEFT_PATTERN = None\n    RIGHT_PATTERN = None\n    REPLACEMENT_OPCODE = None\n    REPLACEMENT_LEFT_PATTERN = None\n    REPLACEMENT_RIGHT_PATTERN = None\n    FUZZ_PATTERNS = True\n    def __init__(self):",
        "detail": "plugins.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "JnzRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_neg,\n                           AstNode(m_and,\n                                   AstNode(m_bnot,\n                                           AstLeaf(\"x_0\")),\n                                   AstConstant(\"1\", 1)))\n    RIGHT_PATTERN = AstLeaf(\"x_0\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule2(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_or,\n                           AstNode(m_bnot,\n                                   AstLeaf(\"x_0\")),\n                           AstConstant(\"1\", 1))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        if opcode == m_jnz:",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule3(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_xor,\n                           AstNode(m_xor,\n                                   AstLeaf(\"x_0\"),\n                                   AstConstant(\"c_1\")),\n                           AstNode(m_and,\n                                   AstLeaf(\"x_0\"),\n                                   AstConstant(\"c_2\")))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule4(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_sub,\n                           AstConstant(\"3\", 3),\n                           AstLeaf(\"x_0\"))\n    RIGHT_PATTERN = AstLeaf(\"x_0\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        if opcode == m_jnz:\n            self.jump_replacement_block_serial = self.jump_original_block_serial",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule5(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_xor,\n                           AstNode(m_sub,\n                                   AstConstant(\"3\", 3),\n                                   AstLeaf(\"x_0\")),\n                           AstLeaf(\"x_0\"))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule6",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule6(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_xor,\n                           AstNode(m_bnot,\n                                   AstNode(m_sub,\n                                           AstConstant(\"3\", 3),\n                                           AstLeaf(\"x_0\"))),\n                           AstNode(m_bnot,\n                                   AstLeaf(\"x_0\")))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule7",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule7(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstLeaf(\"x_0\"),\n                           AstConstant(\"c_1\"))\n    RIGHT_PATTERN = AstConstant(\"c_2\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        tmp = left_candidate[\"c_1\"].value & right_candidate[\"c_2\"].value\n        if tmp == right_candidate[\"c_2\"].value:",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule8",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule8(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"x_0\"),\n                      AstConstant(\"c_1\"))\n    RIGHT_PATTERN = AstConstant(\"c_2\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        tmp = left_candidate[\"c_1\"].value & right_candidate[\"c_2\"].value\n        if tmp == left_candidate[\"c_1\"].value:",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JbRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JbRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jb]\n    PATTERN = AstNode(m_xdu,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)))\n    RIGHT_PATTERN = AstConstant(\"2\", 2)\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        self.jump_replacement_block_serial = self.jump_original_block_serial",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JaeRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JaeRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jae]\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstConstant(\"c_1\"))\n    RIGHT_PATTERN = AstConstant(\"c_2\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        if left_candidate[\"c_1\"].value >= right_candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jge]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstNode(m_or, AstLeaf(\"xdu_x_0\"), AstConstant(\"c_2\")),\n                           AstNode(m_or,\n                                   AstNode(m_xor, AstLeaf(\"x_0\"), AstConstant(\"c_1\")),\n                                   AstNode(m_bnot, AstNode(m_sub, AstLeaf(\"x_0\"), AstConstant(\"c_1\")))))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_jl\n    REPLACEMENT_LEFT_PATTERN = AstLeaf(\"x_0\")",
        "detail": "plugins.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule2(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jge]\n    LEFT_PATTERN = AstNode(m_or,\n                           AstNode(m_xdu,\n                                   AstNode(m_and,\n                                           AstNode(m_bnot, AstLeaf(\"x_0\")), AstConstant(\"c_1\"))),\n                           AstNode(m_and,\n                                   AstNode(m_sub, AstLeaf('xdu_x_0'), AstConstant('xdu_c_1')),\n                                   AstNode(m_bnot, AstNode(m_xdu, AstNode(m_xor, AstLeaf('xdu1_x_0'), AstConstant('xdu_c_1'))))))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)",
        "detail": "plugins.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule3(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jge]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstNode(m_sub, AstLeaf('x_0'), AstConstant('c_1')),\n                           AstNode(m_bnot, AstLeaf(\"x_0\")))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_jg\n    REPLACEMENT_LEFT_PATTERN = AstLeaf(\"x_0\")\n    REPLACEMENT_RIGHT_PATTERN = AstLeaf(\"c_1\")\n    def check_candidate(self, opcode, left_candidate, right_candidate):",
        "detail": "plugins.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule4(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jl, m_jge]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstNode(m_or,\n                                   AstNode(m_bnot,\n                                           AstNode(m_sub,\n                                                   AstLeaf('x_0'),\n                                                   AstConstant('c_1'))),\n                                   AstNode(m_xor,\n                                           AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "FlowOptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.flow.handler",
        "description": "plugins.d810.optimizers.flow.handler",
        "peekOfCode": "class FlowOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = DEFAULT_FLOW_MATURITIES\n        self.use_whitelist = False\n        self.whitelisted_function_ea_list = []\n        self.use_blacklist = False\n        self.blacklisted_function_ea_list = []\n    def configure(self, kwargs):\n        super().configure(kwargs)",
        "detail": "plugins.d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.flow.handler",
        "description": "plugins.d810.optimizers.flow.handler",
        "peekOfCode": "logger = logging.getLogger('D810.optimizer')\nclass FlowOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = DEFAULT_FLOW_MATURITIES\n        self.use_whitelist = False\n        self.whitelisted_function_ea_list = []\n        self.use_blacklist = False\n        self.blacklisted_function_ea_list = []\n    def configure(self, kwargs):",
        "detail": "plugins.d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "InstructionAnalysisRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.analysis.handler",
        "description": "plugins.d810.optimizers.instructions.analysis.handler",
        "peekOfCode": "class InstructionAnalysisRule(InstructionOptimizationRule):\n    def analyze_instruction(self, blk, ins):\n        raise NotImplementedError\nclass InstructionAnalyzer(InstructionOptimizer):\n    RULE_CLASSES = [InstructionAnalysisRule]\n    def set_maturity(self, maturity: int):\n        self.cur_maturity = maturity\n        for rule in self.rules:\n            rule.set_maturity(self.cur_maturity)\n    def analyze(self, blk: mblock_t, ins: minsn_t):",
        "detail": "plugins.d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "InstructionAnalyzer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.analysis.handler",
        "description": "plugins.d810.optimizers.instructions.analysis.handler",
        "peekOfCode": "class InstructionAnalyzer(InstructionOptimizer):\n    RULE_CLASSES = [InstructionAnalysisRule]\n    def set_maturity(self, maturity: int):\n        self.cur_maturity = maturity\n        for rule in self.rules:\n            rule.set_maturity(self.cur_maturity)\n    def analyze(self, blk: mblock_t, ins: minsn_t):\n        if blk is not None:\n            self.cur_maturity = blk.mba.maturity\n        if self.cur_maturity not in self.maturities:",
        "detail": "plugins.d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.instructions.analysis.handler",
        "description": "plugins.d810.optimizers.instructions.analysis.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nclass InstructionAnalysisRule(InstructionOptimizationRule):\n    def analyze_instruction(self, blk, ins):\n        raise NotImplementedError\nclass InstructionAnalyzer(InstructionOptimizer):\n    RULE_CLASSES = [InstructionAnalysisRule]\n    def set_maturity(self, maturity: int):\n        self.cur_maturity = maturity\n        for rule in self.rules:\n            rule.set_maturity(self.cur_maturity)",
        "detail": "plugins.d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "ExampleGuessingRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.analysis.pattern_guess",
        "description": "plugins.d810.optimizers.instructions.analysis.pattern_guess",
        "peekOfCode": "class ExampleGuessingRule(InstructionAnalysisRule):\n    DESCRIPTION = \"Detect pattern with variable used multiple times and with multiple different opcodes\"\n    def __init__(self):\n        super().__init__()\n        self.maturities = DEFAULT_INSTRUCTION_MATURITIES\n        self.cur_maturity = None\n        self.min_nb_var = 1\n        self.max_nb_var = 3\n        self.min_nb_diff_opcodes = 3\n        self.max_nb_diff_opcodes = -1",
        "detail": "plugins.d810.optimizers.instructions.analysis.pattern_guess",
        "documentation": {}
    },
    {
        "label": "get_possible_patterns",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.analysis.utils",
        "description": "plugins.d810.optimizers.instructions.analysis.utils",
        "peekOfCode": "def get_possible_patterns(ast, min_nb_use=2, ref_ast_info_by_index=None, max_nb_pattern=64):\n    # max_nb_pattern is used to prevent memory explosion when very large patterns are parsed\n    if ast.is_leaf():\n        return [ast]\n    if ref_ast_info_by_index is None:\n        if ast.ast_index not in ast.sub_ast_info_by_index.keys():\n            ast.compute_sub_ast()\n        ref_ast_info_by_index = ast.sub_ast_info_by_index\n    possible_patterns = []\n    if ref_ast_info_by_index[ast.ast_index].number_of_use >= min_nb_use:",
        "detail": "plugins.d810.optimizers.instructions.analysis.utils",
        "documentation": {}
    },
    {
        "label": "ChainSimplification",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class ChainSimplification(object):\n    def __init__(self, opcode):\n        self.opcode = opcode\n        self.formatted_ins = \"\"\n        self.non_cst_mop_list = []\n        self.cst_mop_list = []\n        self._is_instruction_simplified = False\n    def add_mop(self, mop):\n        if (mop.t == mop_d) and (mop.d.opcode == self.opcode):\n            self.add_mop(mop.d.l)",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "ArithmeticChainSimplification",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class ArithmeticChainSimplification(object):\n    def __init__(self):\n        self.formatted_ins = \"\"\n        self.add_non_cst_mop_list = []\n        self.add_cst_mop_list = []\n        self.sub_non_cst_mop_list = []\n        self.sub_cst_mop_list = []\n        self.add_other_cst_list = []\n        self.sub_other_cst_list = []\n        self._is_instruction_simplified = False",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "XorChain",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class XorChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove XOR chains with common terms. E.g. x ^ 4 ^ y ^ 6 ^ 5 ^ x ==> y ^ 7\"\n    def check_and_replace(self, blk, ins):\n        xor_simplifier = ChainSimplification(m_xor)\n        new_ins = xor_simplifier.simplify(ins)\n        return new_ins\nclass AndChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove AND chains with common terms. E.g. x & 4 & y & 6 & 5 & x ==> x & y & 4\"\n    def check_and_replace(self, blk, ins):\n        and_simplifier = ChainSimplification(m_and)",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "AndChain",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class AndChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove AND chains with common terms. E.g. x & 4 & y & 6 & 5 & x ==> x & y & 4\"\n    def check_and_replace(self, blk, ins):\n        and_simplifier = ChainSimplification(m_and)\n        new_ins = and_simplifier.simplify(ins)\n        return new_ins\nclass OrChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove OR chains with common terms. E.g. x | 4 | y | 6 | 5 | x ==> x | y | 7\"\n    def check_and_replace(self, blk, ins):\n        or_simplifier = ChainSimplification(m_or)",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "OrChain",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class OrChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove OR chains with common terms. E.g. x | 4 | y | 6 | 5 | x ==> x | y | 7\"\n    def check_and_replace(self, blk, ins):\n        or_simplifier = ChainSimplification(m_or)\n        new_ins = or_simplifier.simplify(ins)\n        return new_ins\nclass ArithmeticChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove arithmetic chains with common terms. E.g. x + 4 + y - (6 + x - 5) ==>  y + 3\"\n    def check_and_replace(self, blk, ins):\n        arithmetic_simplifier = ArithmeticChainSimplification()",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "ArithmeticChain",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class ArithmeticChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove arithmetic chains with common terms. E.g. x + 4 + y - (6 + x - 5) ==>  y + 3\"\n    def check_and_replace(self, blk, ins):\n        arithmetic_simplifier = ArithmeticChainSimplification()\n        new_ins = arithmetic_simplifier.simplify(ins)\n        return new_ins",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "rules_chain_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "rules_chain_logger = logging.getLogger('D810.rules.chain')\nclass ChainSimplification(object):\n    def __init__(self, opcode):\n        self.opcode = opcode\n        self.formatted_ins = \"\"\n        self.non_cst_mop_list = []\n        self.cst_mop_list = []\n        self._is_instruction_simplified = False\n    def add_mop(self, mop):\n        if (mop.t == mop_d) and (mop.d.opcode == self.opcode):",
        "detail": "plugins.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "ChainSimplificationRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.handler",
        "description": "plugins.d810.optimizers.instructions.chain.handler",
        "peekOfCode": "class ChainSimplificationRule(InstructionOptimizationRule):\n    pass\nclass ChainOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [ChainSimplificationRule]",
        "detail": "plugins.d810.optimizers.instructions.chain.handler",
        "documentation": {}
    },
    {
        "label": "ChainOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.chain.handler",
        "description": "plugins.d810.optimizers.instructions.chain.handler",
        "peekOfCode": "class ChainOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [ChainSimplificationRule]",
        "detail": "plugins.d810.optimizers.instructions.chain.handler",
        "documentation": {}
    },
    {
        "label": "EarlyRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.early.handler",
        "description": "plugins.d810.optimizers.instructions.early.handler",
        "peekOfCode": "class EarlyRule(GenericPatternRule):\n    pass\nclass EarlyOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [EarlyRule]",
        "detail": "plugins.d810.optimizers.instructions.early.handler",
        "documentation": {}
    },
    {
        "label": "EarlyOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.early.handler",
        "description": "plugins.d810.optimizers.instructions.early.handler",
        "peekOfCode": "class EarlyOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [EarlyRule]",
        "detail": "plugins.d810.optimizers.instructions.early.handler",
        "documentation": {}
    },
    {
        "label": "SetGlobalVariablesToZero",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.early.mem_read",
        "description": "plugins.d810.optimizers.instructions.early.mem_read",
        "peekOfCode": "class SetGlobalVariablesToZero(EarlyRule):\n    DESCRIPTION = \"This rule can be used to patch memory read\"\n    PATTERN = AstNode(m_mov, AstLeaf(\"ro_dword\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def __init__(self):\n        super().__init__()\n        self.ro_dword_min_ea = None\n        self.ro_dword_max_ea = None\n    def configure(self, kwargs):\n        super().configure(kwargs)",
        "detail": "plugins.d810.optimizers.instructions.early.mem_read",
        "documentation": {}
    },
    {
        "label": "SetGlobalVariablesToZeroIfDetectedReadOnly",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.early.mem_read",
        "description": "plugins.d810.optimizers.instructions.early.mem_read",
        "peekOfCode": "class SetGlobalVariablesToZeroIfDetectedReadOnly(EarlyRule):\n    DESCRIPTION = \"WARNING: Use it only if you know what you are doing as it may patch data not related to obfuscation\"\n    PATTERN = AstNode(m_mov, AstLeaf(\"ro_dword\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def __init__(self):\n        super().__init__()\n        # If we optimized too early (in MMAT_GENERATED), we may replace something like\n        # 'mov     &($dword_10020CC8).4, eoff.4' by 'mov     #0.4, eoff.4'\n        # and this will lead to incorrect decompilation where MEMORY[0] is used\n        # Thus, we explicitly specify the MMAT_PREOPTIMIZED maturity.",
        "detail": "plugins.d810.optimizers.instructions.early.mem_read",
        "documentation": {}
    },
    {
        "label": "ReplaceMovHigh",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.experimental",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.experimental",
        "peekOfCode": "class ReplaceMovHigh(PatternMatchingRule):\n    PATTERN = AstNode(m_mov,\n                      AstConstant('c_0'))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstConstant(\"new_c_0\"), AstNode(m_and, AstLeaf(\"new_reg\"), AstConstant(\"mask\")))\n    def check_candidate(self, candidate):\n        # IDA does not do constant propagation for pattern such as:\n        # mov     #0x65A4.2, r6.2\n        # mov     #0x210F.2, r6^2.2\n        # jz      r0.4, r6.4\n        # Thus, we try to detect mov to r6^2 and replace by (or #0x210F0000.4, r6.4 & 0x0000ffff.4, r6.4",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.experimental",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class PatternMatchingRule(GenericPatternRule):\n    PATTERN = None\n    PATTERNS = None\n    FUZZ_PATTERN = True\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.fuzz_pattern = self.FUZZ_PATTERN\n    def configure(self, fuzz_pattern=None, **kwargs):\n        super().configure(kwargs)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "RulePatternInfo",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class RulePatternInfo(object):\n    def __init__(self, rule, pattern):\n        self.rule = rule\n        self.pattern = pattern\ndef signature_generator(ref_sig):\n    for i, x in enumerate(ref_sig):\n        if x not in [\"N\", \"L\"]:\n            for sig_suffix in signature_generator(ref_sig[i + 1:]):\n                yield ref_sig[:i] + [\"L\"] + sig_suffix\n    yield ref_sig",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternStorage",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class PatternStorage(object):\n    # The PatternStorage object is used to store patterns associated to rules\n    # A PatternStorage contains a dictionary (next_layer_patterns) where:\n    #  - keys are the signature of a pattern at a specific depth (i.e. the opcodes, the variable and constant)\n    #  - values are PatternStorage object for the next depth\n    # Additionally, it stores the rule objects which are resolved for the PatternStorage depth\n    def __init__(self, depth=1):\n        self.depth = depth\n        self.next_layer_patterns = {}\n        self.rule_resolved = []",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class PatternOptimizer(InstructionOptimizer):\n    # The main idea of PatternOptimizer is to generate/store all possible patterns associated to all known rules in a $\n    # dictionary-like object (PatternStorage) when the plugin is loaded.\n    # => it means that we generate a very large number of patterns\n    #\n    # At runtime, we transform the microcode instruction in a list of keys that we search in the PatternStorage object\n    # to speed up the checks\n    # => we don't want to test all patterns, so we use the PatternStorage object to (quickly) get the patterns\n    # which have the same shape as the microcode instruction\n    RULE_CLASSES = [PatternMatchingRule]",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "signature_generator",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def signature_generator(ref_sig):\n    for i, x in enumerate(ref_sig):\n        if x not in [\"N\", \"L\"]:\n            for sig_suffix in signature_generator(ref_sig[i + 1:]):\n                yield ref_sig[:i] + [\"L\"] + sig_suffix\n    yield ref_sig\nclass PatternStorage(object):\n    # The PatternStorage object is used to store patterns associated to rules\n    # A PatternStorage contains a dictionary (next_layer_patterns) where:\n    #  - keys are the signature of a pattern at a specific depth (i.e. the opcodes, the variable and constant)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "rec_get_all_binary_subtree_representation",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def rec_get_all_binary_subtree_representation(elt_list):\n    if len(elt_list) == 1:\n        return elt_list\n    if len(elt_list) == 2:\n        return [elt_list]\n    tmp_res = []\n    for i in range(1, len(elt_list)):\n        left_list = rec_get_all_binary_subtree_representation(elt_list[:i])\n        right_list = rec_get_all_binary_subtree_representation(elt_list[i:])\n        for l in left_list:",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "rec_get_all_binary_tree_representation",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def rec_get_all_binary_tree_representation(elt_list):\n    if len(elt_list) <= 1:\n        return elt_list\n    tmp = list(itertools.permutations(elt_list))\n    tmp2 = []\n    for perm_tmp in tmp:\n        tmp2 += rec_get_all_binary_subtree_representation(perm_tmp)\n    return tmp2\ndef get_all_binary_tree_representation(all_elt):\n    tmp = rec_get_all_binary_tree_representation(all_elt)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_all_binary_tree_representation",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_all_binary_tree_representation(all_elt):\n    tmp = rec_get_all_binary_tree_representation(all_elt)\n    return tmp\ndef generate_ast(opcode, leafs):\n    if isinstance(leafs, AstLeaf):\n        return leafs\n    if isinstance(leafs, AstNode):\n        return leafs\n    if len(leafs) == 1:\n        return leafs[0]",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "generate_ast",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def generate_ast(opcode, leafs):\n    if isinstance(leafs, AstLeaf):\n        return leafs\n    if isinstance(leafs, AstNode):\n        return leafs\n    if len(leafs) == 1:\n        return leafs[0]\n    if len(leafs) == 2:\n        return AstNode(opcode, generate_ast(opcode, leafs[0]), generate_ast(opcode, leafs[1]))\ndef get_addition_operands(ast_node):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_addition_operands",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_addition_operands(ast_node):\n    if not isinstance(ast_node, AstNode):\n        return [ast_node]\n    if ast_node.opcode == m_add:\n        return get_addition_operands(ast_node.left) + get_addition_operands(ast_node.right)\n    elif ast_node.opcode == m_sub:\n        tmp = get_addition_operands(ast_node.left)\n        for aaa in get_addition_operands(ast_node.right):\n            tmp.append(AstNode(m_neg, aaa))\n        return tmp",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_opcode_operands",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_opcode_operands(ref_opcode, ast_node):\n    if not isinstance(ast_node, AstNode):\n        return [ast_node]\n    if ast_node.opcode == ref_opcode:\n        return get_opcode_operands(ref_opcode, ast_node.left) + get_opcode_operands(ref_opcode, ast_node.right)\n    else:\n        return [ast_node]\ndef get_similar_opcode_operands(ast_node):\n    if ast_node.opcode in [m_add, m_sub]:\n        add_elts = get_addition_operands(ast_node)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_similar_opcode_operands",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_similar_opcode_operands(ast_node):\n    if ast_node.opcode in [m_add, m_sub]:\n        add_elts = get_addition_operands(ast_node)\n        all_add_ordering = get_all_binary_tree_representation(add_elts)\n        ast_res = []\n        for leaf_ordering in all_add_ordering:\n            ast_res.append(generate_ast(m_add, leaf_ordering))\n        return ast_res\n    elif ast_node.opcode in [m_xor, m_or, m_and, m_mul]:\n        same_elts = get_opcode_operands(ast_node.opcode, ast_node)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_ast_variations_with_add_sub",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_ast_variations_with_add_sub(opcode, left, right):\n    possible_ast = [AstNode(opcode, left, right)]\n    if opcode == m_add:\n        if isinstance(left, AstNode) and isinstance(right, AstNode):\n            if (left.opcode == m_neg) and (right.opcode == m_neg):\n                possible_ast.append(AstNode(m_neg, AstNode(m_add, left.left, right.left)))\n        if isinstance(right, AstNode) and (right.opcode == m_neg):\n            possible_ast.append(AstNode(m_sub, left, right.left))\n    return possible_ast\ndef ast_generator(ast_node, excluded_opcodes=None):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "ast_generator",
        "kind": 2,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def ast_generator(ast_node, excluded_opcodes=None):\n    if not isinstance(ast_node, AstNode):\n        return [ast_node]\n    res_ast = []\n    excluded_opcodes = excluded_opcodes if excluded_opcodes is not None else []\n    if ast_node.opcode not in excluded_opcodes:\n        if ast_node.opcode in [m_add, m_sub]:\n            similar_ast_list = get_similar_opcode_operands(ast_node)\n            for similar_ast in similar_ast_list:\n                sub_ast_left_list = ast_generator(similar_ast.left, excluded_opcodes=[m_add, m_sub])",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\npattern_search_logger = logging.getLogger('D810.pattern_search')\nclass PatternMatchingRule(GenericPatternRule):\n    PATTERN = None\n    PATTERNS = None\n    FUZZ_PATTERN = True\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.fuzz_pattern = self.FUZZ_PATTERN",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "pattern_search_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "pattern_search_logger = logging.getLogger('D810.pattern_search')\nclass PatternMatchingRule(GenericPatternRule):\n    PATTERN = None\n    PATTERNS = None\n    FUZZ_PATTERN = True\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.fuzz_pattern = self.FUZZ_PATTERN\n    def configure(self, fuzz_pattern=None, **kwargs):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_sub,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_1\")),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Add_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Add_HackersDelightRule_4(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_5(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstNode(m_or,\n                                              AstLeaf(\"x_0\"),\n                                              AstLeaf(\"x_1\")),\n                                      AstLeaf(\"x_2\"))),\n                      AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_SpecialConstantRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_SpecialConstantRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_2\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_SpecialConstantRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_SpecialConstantRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"val_ff\", 0xff)),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_SpecialConstantRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_SpecialConstantRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_2\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf('x_1'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_mul,\n                              AstConstant(\"val_fe\"),\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_mul,\n                              AstConstant(\"val_fe\"),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "AddXor_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class AddXor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"bnot_x_1\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "AddXor_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class AddXor_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_bnot,\n                                      AstNode(m_and,\n                                              AstLeaf(\"bnot_x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot, AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass And_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass And_HackersDelightRule_4(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))\nclass And_OllvmRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_OllvmRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_OllvmRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_OllvmRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_OllvmRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_OllvmRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_OllvmRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):\n        return equal_bnot_mop(candidate[\"x_1\"].mop, candidate[\"bnot_x_1\"].mop)\nclass And_FactorRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf('x_0'),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))\nclass AndBnot_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_HackersDelightRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_3(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_4(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_xor,\n                              AstLeaf('x_1'),\n                              AstLeaf('x_0')),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('bnot_x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndOr_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndOr_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_2\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_1\"),\n                              AstLeaf(\"x_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_or,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndXor_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndXor_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_2\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_1\"),\n                              AstLeaf(\"x_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And1_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And1_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_mul, AstLeaf(\"x_0\"), AstLeaf(\"x_0\")),\n                      AstConstant(\"3\", 3))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_1\", 1, candidate.size)\n        return True",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndGetUpperBits_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndGetUpperBits_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_mul,\n                      AstConstant(\"c_1\"),\n                      AstNode(m_and,\n                              AstNode(m_shr,\n                                      AstLeaf('x_0'),\n                                      AstConstant(\"c_2\")),\n                              AstConstant(\"c_3\")))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstConstant(\"c_res\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "Bnot_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_neg,\n                              AstLeaf(\"x_0\")),\n                      AstConstant(\"1\", 1))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\nclass Bnot_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstNode(m_or,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_1\"))\nclass Bnot_MbaRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\nclass Bnot_FactorRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\nclass Bnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstConstant(\"minus_1\"),\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\n    def check_candidate(self, candidate):\n        if candidate[\"minus_1\"].value != SUB_TABLE[candidate[\"minus_1\"].size] - 1:\n            return False\n        return True\nclass Bnot_FactorRule_3(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_bnot, AstLeaf('x_0')),\n                      AstNode(m_bnot, AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstLeaf(\"x_1\"))\nclass BnotXor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"bnot_x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('bnot_x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_Rule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')),\n                      AstNode(m_or,\n                              AstLeaf('bnot_x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\nclass BnotAnd_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\nclass BnotAnd_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_or,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"bnot_x_0\"),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\n    def check_candidate(self, candidate):\n        if not equal_bnot_mop(candidate[\"x_0\"].mop, candidate[\"bnot_x_0\"].mop):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotOr_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotOr_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\nclass BnotAdd_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAdd_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAdd_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"bnot_x_1\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_XorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_XorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_xor,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_1_1\")),\n                              AstConstant(\"c_2_1\")),\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_0\")),\n                      AstNode(m_mul,\n                              AstConstant(\"c_1\"),\n                              AstNode(m_sub,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_2\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_sub,\n                              AstConstant(\"c_1\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_add,\n                                          AstLeaf(\"x_1\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule5(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_1\"),\n                              AstConstant(\"c_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule6",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule6(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_2\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule7",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule7(PatternMatchingRule):\n    PATTERN = AstNode(m_shr,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_shr,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_2\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule8",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule8(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_res\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule9",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule9(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_and\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule10",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule10(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule11",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule11(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule12",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule12(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstConstant(\"c_1\"),\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule13",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule13(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstConstant(\"cst_1\"),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule14",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule14(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstNode(m_or,\n                                          AstLeaf(\"x_0\"),\n                                          AstLeaf(\"lnot_c_1\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule15",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule15(PatternMatchingRule):\n    PATTERN = AstNode(m_shr,\n                      AstNode(m_shr,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_shr, AstLeaf(\"x_0\"), AstConstant(\"c_res\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"c_res\", candidate[\"c_1\"].value + candidate[\"c_2\"].value, candidate[\"c_1\"].size)\n        return True",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule16",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule16(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstLeaf(\"x_0\"),\n                                  AstLeaf(\"bnot_c_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"bnot_c_1\", candidate[\"c_1\"].value ^ AND_TABLE[candidate[\"c_1\"].size],",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule17",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule17(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_bnot, AstLeaf(\"x_0\")),\n                                  AstLeaf(\"bnot_c_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"bnot_c_1\", candidate[\"c_1\"].value ^ AND_TABLE[candidate[\"c_1\"].size],",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule18",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule18(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_bnot, AstLeaf(\"x_0\")),\n                                  AstLeaf(\"bnot_c_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"bnot_c_1\", candidate[\"c_1\"].value ^ AND_TABLE[candidate[\"c_1\"].size],",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule19",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule19(PatternMatchingRule):\n    PATTERN = AstNode(m_sar,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstNode(m_shr, AstLeaf(\"x_0\"), AstConstant(\"c_2\")), AstConstant(\"c_res\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"c_res\", candidate[\"c_1\"].value >> candidate[\"c_2\"].value,\n                                    candidate[\"c_1\"].size)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule20",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule20(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf('bnot_x_0'),\n                              AstConstant('c_and_1')),\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_and_2')),\n                              AstConstant('c_xor')))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule21",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule21(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_and')),\n                              AstConstant('c_xor_1')),\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule22",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule22(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_and')),\n                              AstConstant('c_xor_1')),\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('bnot_x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "GetIdentRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "peekOfCode": "class GetIdentRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"x_0\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "documentation": {}
    },
    {
        "label": "GetIdentRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "peekOfCode": "class GetIdentRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"x_0\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "documentation": {}
    },
    {
        "label": "GetIdentRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "peekOfCode": "class GetIdentRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"x_0\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1')),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_mul,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_1')),\n                              AstLeaf('x_0')),\n                      AstNode(m_mul,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_1')),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_1'))),\n                      AstNode(m_mul,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\")),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_mul,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstConstant(\"2\", 2),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_add,\n                                      AstLeaf(\"x_1\"),\n                                      AstNode(m_or,\n                                              AstLeaf(\"x_0\"),\n                                              AstLeaf(\"bnot_x_1\")))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_neg,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_mul,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Neg_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class Neg_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstConstant(\"1\", 1))\n    REPLACEMENT_PATTERN = AstNode(m_neg, AstLeaf(\"x_0\"))\nclass Neg_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "Neg_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class Neg_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_neg, AstLeaf(\"x_0\"))\nclass NegAdd_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegAdd_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegAdd_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegAdd_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegAdd_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_1\"),\n                                      AstLeaf(\"x_2\"))),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegAdd_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegAdd_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstConstant('val_fe'),\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegOr_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegOr_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_or,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegXor_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegXor_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegXor_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegXor_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_mul,\n                              AstConstant('2', 2),\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "Or_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):\n        if not equal_bnot_mop(candidate[\"x_1\"].mop, candidate[\"bnot_x_1\"].mop):\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_HackersDelightRule_2_variant_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_HackersDelightRule_2_variant_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_HackersDelightRule_2_variant_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_neg, AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_MbaRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_MbaRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_MbaRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_add,\n                              AstNode(m_add,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1')),\n                              AstConstant('1', 1)),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf('x_1'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_MbaRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_MbaRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf('x_0'),\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstNode(m_bnot,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_FactorRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_1\"),\n                                      AstLeaf(\"x_2\"))),\n                      AstNode(m_xor,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"bnot_x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_OllvmRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_OllvmRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf(\"bnot_x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):\n        if not equal_bnot_mop(candidate[\"x_0\"].mop,  candidate[\"bnot_x_0\"].mop):\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf('bnot_x_0'),\n                                      AstLeaf('bnot_x_1'))),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass OrBnot_FactorRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_bnot,\n                                          AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_and,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass OrBnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstNode(m_bnot, AstLeaf(\"x_1\")))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstNode(m_bnot, AstLeaf(\"x_1\")))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value | candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value & candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_add,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2)),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2))),\n                      AstConstant(\"0\", 0))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule4(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_xor,\n                              AstNode(m_sub,\n                                      AstConstant(\"cst_1\"),\n                                      AstLeaf(\"x_0\")),\n                              AstLeaf(\"x_0\")),\n                      AstConstant(\"0\", 0))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule5(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_neg,\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),\n                                      AstConstant(\"1\", 1))),\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule6",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule6(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_add,\n                              AstNode(m_add,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_1\")),\n                              AstNode(m_and,\n                                      AstNode(m_add,\n                                              AstLeaf(\"x_0\"),\n                                              AstConstant(\"c_2\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule8",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule8(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_xor,\n                              AstNode(m_bnot,\n                                      AstNode(m_sub,\n                                              AstConstant(\"3\", 3),\n                                              AstLeaf(\"x_0\"))),\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\"))),\n                      AstConstant(\"0\", 0))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetzRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetzRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value | candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetzRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetzRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value & candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetzRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetzRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_add,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2)),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2))),\n                      AstConstant(\"0\", 0))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetbRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetbRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_setb,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        if candidate[\"c_1\"].value >= candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOdd1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOdd1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_mul,\n                              AstLeaf('x_0'),\n                              AstNode(m_sub,\n                                      AstLeaf('x_0'),\n                                      AstConstant('1', 1))),\n                      AstConstant('1', 1))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant('val_0'))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOdd2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOdd2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_mul,\n                              AstLeaf('x_0'),\n                              AstNode(m_add,\n                                      AstLeaf('x_0'),\n                                      AstConstant('1', 1))),\n                      AstConstant('1', 1))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant('val_0'))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_0\", 0, candidate.size)\n        return True\n# Pred0Rule2: (xdu(x_0 & 1) == 2) ==> 0",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule2(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_xdu,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_1\", 1))),\n                      AstConstant(\"c_2\", 2))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_0\", 0, candidate.size)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_0\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_0\", 0, candidate.size)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule4(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_0\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule5(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_0\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_ff\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_ff\", AND_TABLE[candidate.size], candidate.size)\n        return True\n# Pred1Rule2: (x_0 ^ x_1) | (~x_0 | x_1) ==> 0xff",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_ff\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_ff\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_ff\", AND_TABLE[candidate.size], candidate.size)",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule4(PatternMatchingRule):\n    DESCRIPTION = \"(x_0 | x_1) | (~(x_0 & x_1))  ==>  0xff\"\n    PATTERN = AstNode(m_or,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOr2_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOr2_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_bnot,\n                              AstNode(m_mul,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_0'))),\n                      AstConstant('3', 3))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_and,\n                                          AstNode(m_bnot, AstLeaf('x_0')),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOr1_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOr1_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf('x_0'),\n                      AstNode(m_add,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('1', 1)),\n                              AstConstant('1', 1)))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_add,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_1\")),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Sub_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"bnot_x_1\"))),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstNode(m_neg,\n                                      AstLeaf('x_0')),\n                              AstConstant('1', 1)),\n                      AstNode(m_mul,\n                              AstConstant('c_minus_2'),\n                              AstLeaf('x_0')))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstConstant(\"val_1\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstConstant(\"1\", 1))\nclass Sub1Add_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1Add_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1Add_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1And_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1And_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstLeaf(\"x_1\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1Or_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1Or_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1And1_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1And1_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstNode(m_bnot,\n                                      AstLeaf('x_0')),\n                              AstConstant(\"1\", 1)),\n                      AstLeaf('x_0'))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_and,\n                                          AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Xor_HackersDelightRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstNode(m_sub,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1')),\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_or,\n                                              AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_5(PatternMatchingRule):\n    FUZZ_PATTERN = False\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_sub,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_and,\n                                              AstLeaf(\"x_0\"),\n                                              AstLeaf(\"x_1\"))),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf('x_0'),\n                      AstNode(m_sub,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_and,\n                                              AstLeaf('x_1'),\n                                              AstNode(m_bnot,\n                                                      AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_MbaRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_MbaRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf('x_0'),\n                      AstNode(m_sub,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_and,\n                                              AstLeaf('x_0'),\n                                              AstLeaf('x_1'))),\n                              AstLeaf('x_1')))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_MbaRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_MbaRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf('x_0'),\n                      AstNode(m_mul,\n                              AstConstant('2', 2),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('bnot_x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Xor_SpecialConstantRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_SpecialConstantRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_SpecialConstantRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_SpecialConstantRule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_SpecialConstantRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstLeaf('x_0'),\n                      AstNode(m_add,\n                              AstNode(m_mul,\n                                      AstConstant('0xfe'),\n                                      AstNode(m_and,\n                                              AstLeaf('x_0'),\n                                              AstLeaf('x_1'))),\n                              AstLeaf('x_1')))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor1_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor1_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_bnot,\n                              AstLeaf('x_0')),\n                      AstNode(m_or,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstLeaf('x_0')),\n                              AstConstant('2', 2)))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstConstant(\"val_1\"))",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_2')),\n                              AstNode(m_xor,\n                                      AstLeaf('x_1'),\n                                      AstLeaf('bnot_x2'))),\n                      AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_2')),\n                              AstNode(m_xor,\n                                      AstLeaf('x_1'),\n                                      AstLeaf('x_2'))),\n                      AstNode(m_and,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstLeaf('x_0'),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_4_WithXdu",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_4_WithXdu(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"bnot_c_1\")),\n                      AstNode(m_and,\n                              AstNode(m_bnot, AstLeaf(\"x_0\")),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "XorAlmost_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class XorAlmost_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstNode(m_sub,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_NestedStuff",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_NestedStuff(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstNode(m_add,\n                                      AstLeaf('x_9'),\n                                      AstLeaf('x_10')),\n                              AstLeaf(\"x_11\")),\n                      AstNode(m_add,\n                              AstLeaf(\"x_14\"),\n                              AstNode(m_mul,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "WeirdRule1",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstNode(m_or,\n                                          AstLeaf(\"x_0\"),\n                                          AstNode(m_bnot, AstLeaf(\"x_1\"))),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule2",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_bnot, AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule3",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_bnot, AstLeaf(\"x_1\"))),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_add,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule4",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule5",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule5(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstNode(m_or,\n                                      AstLeaf(\"bnot_x_0\"),\n                                      AstNode(m_and,\n                                              AstLeaf(\"bnot_x_1\"),\n                                              AstLeaf(\"x_2\"))),\n                              AstNode(m_add,\n                                      AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule6",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule6(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstNode(m_bnot,\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "Z3ConstantOptimization",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.cst",
        "description": "plugins.d810.optimizers.instructions.z3.cst",
        "peekOfCode": "class Z3ConstantOptimization(Z3Rule):\n    DESCRIPTION = \"Detect and replace obfuscated constants\"\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"c_res\"))\n    def __init__(self):\n        super().__init__()\n        self.min_nb_opcode = 3\n        self.min_nb_constant = 3\n    def configure(self, kwargs):\n        super().configure(kwargs)\n        if \"min_nb_opcode\" in kwargs.keys():",
        "detail": "plugins.d810.optimizers.instructions.z3.cst",
        "documentation": {}
    },
    {
        "label": "Z3Rule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.handler",
        "description": "plugins.d810.optimizers.instructions.z3.handler",
        "peekOfCode": "class Z3Rule(GenericPatternRule):\n    pass\nclass Z3Optimizer(InstructionOptimizer):\n    RULE_CLASSES = [Z3Rule]",
        "detail": "plugins.d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "Z3Optimizer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.handler",
        "description": "plugins.d810.optimizers.instructions.z3.handler",
        "peekOfCode": "class Z3Optimizer(InstructionOptimizer):\n    RULE_CLASSES = [Z3Rule]",
        "detail": "plugins.d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "Z3setzRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3setzRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_setz check is always True or False\"\n    PATTERN = AstNode(m_setz,\n                      AstLeaf(\"x_0\"),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        if z3_check_mop_equality(candidate[\"x_0\"].mop, candidate[\"x_1\"].mop):\n            candidate.add_constant_leaf(\"val_res\", 1, candidate.size)\n            return True",
        "detail": "plugins.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "Z3setnzRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3setnzRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_setnz check is always True or False\"\n    PATTERN = AstNode(m_setnz,\n                      AstLeaf(\"x_0\"),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        if z3_check_mop_equality(candidate[\"x_0\"].mop, candidate[\"x_1\"].mop):\n            candidate.add_constant_leaf(\"val_res\", 0, candidate.size)\n            return True",
        "detail": "plugins.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "Z3lnotRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3lnotRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_lnot check is always True or False\"\n    PATTERN = AstNode(m_lnot,\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        val_0_mop = mop_t()\n        val_0_mop.make_number(0, candidate[\"x_0\"].size)\n        if z3_check_mop_equality(candidate[\"x_0\"].mop, val_0_mop):\n            candidate.add_constant_leaf(\"val_res\", 1, candidate.size)",
        "detail": "plugins.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "Z3SmodRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3SmodRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_setz check is always True or False\"\n    PATTERN = AstNode(m_smod,\n                      AstLeaf(\"x_0\"),\n                      AstConstant(\"2\", 2))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        cst_0_mop = mop_t()\n        cst_0_mop.make_number(0, candidate.size)\n        if z3_check_mop_equality(candidate.mop, cst_0_mop):",
        "detail": "plugins.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.handler",
        "description": "plugins.d810.optimizers.instructions.handler",
        "peekOfCode": "class InstructionOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = []\n    def check_and_replace(self, blk, ins):\n        return None\nclass GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None\n    PATTERNS = None\n    REPLACEMENT_PATTERN = None",
        "detail": "plugins.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.handler",
        "description": "plugins.d810.optimizers.instructions.handler",
        "peekOfCode": "class GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None\n    PATTERNS = None\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.pattern_candidates = [self.PATTERN]\n        if self.PATTERNS is not None:\n            self.pattern_candidates += self.PATTERNS\n    def check_candidate(self, candidate: AstNode):",
        "detail": "plugins.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.instructions.handler",
        "description": "plugins.d810.optimizers.instructions.handler",
        "peekOfCode": "class InstructionOptimizer(object):\n    RULE_CLASSES = []\n    NAME = None\n    def __init__(self, maturities: List[int], log_dir=None):\n        self.rules = set()\n        self.rules_usage_info = {}\n        self.maturities = maturities\n        self.log_dir = log_dir\n        self.cur_maturity = MMAT_PREOPTIMIZED\n    def add_rule(self, rule: InstructionOptimizationRule):",
        "detail": "plugins.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "d810_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.instructions.handler",
        "description": "plugins.d810.optimizers.instructions.handler",
        "peekOfCode": "d810_logger = logging.getLogger('D810')\noptimizer_logger = logging.getLogger('D810.optimizer')\nclass InstructionOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = []\n    def check_and_replace(self, blk, ins):\n        return None\nclass GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None",
        "detail": "plugins.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.instructions.handler",
        "description": "plugins.d810.optimizers.instructions.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nclass InstructionOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = []\n    def check_and_replace(self, blk, ins):\n        return None\nclass GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None\n    PATTERNS = None",
        "detail": "plugins.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "OptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.optimizers.handler",
        "description": "plugins.d810.optimizers.handler",
        "peekOfCode": "class OptimizationRule(object):\n    NAME = None\n    DESCRIPTION = None\n    def __init__(self):\n        self.maturities = []\n        self.config = {}\n        self.log_dir = None\n    def set_log_dir(self, log_dir):\n        self.log_dir = log_dir\n    def configure(self, kwargs):",
        "detail": "plugins.d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INSTRUCTION_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.handler",
        "description": "plugins.d810.optimizers.handler",
        "peekOfCode": "DEFAULT_INSTRUCTION_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_FLOW_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\nclass OptimizationRule(object):\n    NAME = None\n    DESCRIPTION = None\n    def __init__(self):\n        self.maturities = []\n        self.config = {}\n        self.log_dir = None\n    def set_log_dir(self, log_dir):",
        "detail": "plugins.d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FLOW_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.optimizers.handler",
        "description": "plugins.d810.optimizers.handler",
        "peekOfCode": "DEFAULT_FLOW_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\nclass OptimizationRule(object):\n    NAME = None\n    DESCRIPTION = None\n    def __init__(self):\n        self.maturities = []\n        self.config = {}\n        self.log_dir = None\n    def set_log_dir(self, log_dir):\n        self.log_dir = log_dir",
        "detail": "plugins.d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "AstInfo",
        "kind": 6,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "class AstInfo(object):\n    def __init__(self, ast: Union[AstNode, AstLeaf], number_of_use: int):\n        self.ast = ast\n        self.number_of_use = number_of_use\n    def __str__(self):\n        return \"{0} used {1} times: {2}\".format(self.ast, self.number_of_use, format_mop_t(self.ast.mop))\nclass AstNode(dict):\n    def __init__(self, opcode, left=None, right=None, dst=None):\n        super(dict, self).__init__()\n        self.opcode = opcode",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "kind": 6,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "class AstNode(dict):\n    def __init__(self, opcode, left=None, right=None, dst=None):\n        super(dict, self).__init__()\n        self.opcode = opcode\n        self.left = left\n        self.right = right\n        self.dst = dst\n        self.dst_mop = None\n        self.opcodes = []\n        self.mop = None",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "kind": 6,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "class AstLeaf(object):\n    def __init__(self, name):\n        self.name = name\n        self.ast_index = None\n        self.mop = None\n        self.z3_var = None\n        self.z3_var_name = None\n        self.dest_size = None\n        self.ea = None\n        self.sub_ast_info_by_index = {}",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "kind": 6,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "class AstConstant(AstLeaf):\n    def __init__(self, name, expected_value=None, expected_size=None):\n        super().__init__(name)\n        self.expected_value = expected_value\n        self.expected_size = expected_size\n    @property\n    def value(self):\n        return self.mop.nnn.value\n    def is_constant(self):\n        # An AstConstant is always constant, so return True",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "check_and_add_to_list",
        "kind": 2,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "def check_and_add_to_list(new_ast: Union[AstNode, AstLeaf], known_ast_list: List[Union[AstNode, AstLeaf]]):\n    is_new_ast_known = False\n    for existing_elt in known_ast_list:\n        if equal_mops_ignore_size(new_ast.mop, existing_elt.mop):\n            new_ast.ast_index = existing_elt.ast_index\n            is_new_ast_known = True\n            break\n    if not is_new_ast_known:\n        ast_index = len(known_ast_list)\n        new_ast.ast_index = ast_index",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "mop_to_ast_internal",
        "kind": 2,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "def mop_to_ast_internal(mop: mop_t, ast_list: List[Union[AstNode, AstLeaf]]) -> Union[None, AstNode, AstLeaf]:\n    if mop is None:\n        return None\n    if mop.t != mop_d or (mop.d.opcode not in MBA_RELATED_OPCODES):\n        tree = AstLeaf(format_mop_t(mop))\n        tree.mop = mop\n        dest_size = mop.size if mop.t != mop_d else mop.d.d.size\n        tree.dest_size = dest_size\n    else:\n        left_ast = mop_to_ast_internal(mop.d.l, ast_list)",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "mop_to_ast",
        "kind": 2,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "def mop_to_ast(mop: mop_t) -> Union[None, AstNode, AstLeaf]:\n    mop_ast = mop_to_ast_internal(mop, [])\n    mop_ast.compute_sub_ast()\n    return mop_ast\ndef minsn_to_ast(instruction: minsn_t) -> Union[None, AstNode, AstLeaf]:\n    try:\n        if instruction.opcode in MINSN_TO_AST_FORBIDDEN_OPCODES:\n            # To avoid error 50278\n            return None\n        ins_mop = mop_t()",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "kind": 2,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "def minsn_to_ast(instruction: minsn_t) -> Union[None, AstNode, AstLeaf]:\n    try:\n        if instruction.opcode in MINSN_TO_AST_FORBIDDEN_OPCODES:\n            # To avoid error 50278\n            return None\n        ins_mop = mop_t()\n        ins_mop.create_from_insn(instruction)\n        if instruction.opcode == m_mov:\n            tmp = AstNode(m_mov, mop_to_ast(ins_mop))\n            tmp.mop = ins_mop",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.ast",
        "description": "plugins.d810.ast",
        "peekOfCode": "logger = logging.getLogger('D810')\ndef check_and_add_to_list(new_ast: Union[AstNode, AstLeaf], known_ast_list: List[Union[AstNode, AstLeaf]]):\n    is_new_ast_known = False\n    for existing_elt in known_ast_list:\n        if equal_mops_ignore_size(new_ast.mop, existing_elt.mop):\n            new_ast.ast_index = existing_elt.ast_index\n            is_new_ast_known = True\n            break\n    if not is_new_ast_known:\n        ast_index = len(known_ast_list)",
        "detail": "plugins.d810.ast",
        "documentation": {}
    },
    {
        "label": "log_block_info",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def log_block_info(blk: mblock_t, logger_func=helper_logger.info):\n    if blk is None:\n        logger_func(\"Block is None\")\n        return\n    vp = block_printer()\n    blk._print(vp)\n    logger_func(\"Block {0} with successors {1} and predecessors {2}:\\n{3}\"\n                .format(blk.serial, [x for x in blk.succset], [x for x in blk.predset], vp.get_block_mc()))\ndef insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):\n    if blk.tail is not None:",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "insert_goto_instruction",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):\n    if blk.tail is not None:\n        goto_ins = minsn_t(blk.tail)\n    else:\n        goto_ins = minsn_t(blk.start)\n    if nop_previous_instruction:\n        blk.make_nop(blk.tail)\n    blk.insert_into_block(goto_ins, blk.tail)\n    # We nop instruction before setting it to goto to avoid error 52123\n    blk.make_nop(blk.tail)",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_call_block_successor",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def change_1way_call_block_successor(call_blk: mblock_t, call_blk_successor_serial: int) -> bool:\n    if call_blk.nsucc() != 1:\n        return False\n    mba = call_blk.mba\n    previous_call_blk_successor_serial = call_blk.succset[0]\n    previous_call_blk_successor = mba.get_mblock(previous_call_blk_successor_serial)\n    nop_blk = insert_nop_blk(call_blk)\n    insert_goto_instruction(nop_blk, call_blk_successor_serial, nop_previous_instruction=True)\n    is_ok = change_1way_block_successor(nop_blk, call_blk_successor_serial)\n    if not is_ok:",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def change_1way_block_successor(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 1:\n        return False\n    mba: mbl_array_t = blk.mba\n    previous_blk_successor_serial = blk.succset[0]\n    previous_blk_successor = mba.get_mblock(previous_blk_successor_serial)\n    if blk.tail is None:\n        # We add a goto instruction\n        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)\n    elif blk.tail.opcode == m_goto:",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_0way_block_successor",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def change_0way_block_successor(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 0:\n        return False\n    mba = blk.mba\n    if blk.tail.opcode == m_ijmp:\n        # We replace ijmp instruction with goto instruction\n        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)\n    else:\n        # We add a goto instruction\n        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_2way_block_conditional_successor",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def change_2way_block_conditional_successor(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 2:\n        return False\n    mba = blk.mba\n    previous_blk_conditional_successor_serial = blk.tail.d.b\n    previous_blk_conditional_successor = mba.get_mblock(previous_blk_conditional_successor_serial)\n    blk.tail.d = mop_t()\n    blk.tail.d.make_blkref(blk_successor_serial)\n    # Bookkeeping\n    blk.succset._del(previous_blk_conditional_successor_serial)",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "update_blk_successor",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def update_blk_successor(blk: mblock_t, old_successor_serial: int, new_successor_serial: int) -> int:\n    if blk.nsucc() == 1:\n        change_1way_block_successor(blk, new_successor_serial)\n    elif blk.nsucc() == 2:\n        if old_successor_serial == blk.serial + 1:\n            helper_logger.info(\"Can't update direct block successor: {0} - {1} - {2}\"\n                               .format(blk.serial, old_successor_serial, new_successor_serial))\n            return 0\n        else:\n            change_2way_block_conditional_successor(blk, new_successor_serial)",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "make_2way_block_goto",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def make_2way_block_goto(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 2:\n        return False\n    mba = blk.mba\n    previous_blk_successor_serials = [x for x in blk.succset]\n    previous_blk_successors = [mba.get_mblock(x) for x in previous_blk_successor_serials]\n    insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)\n    # Update block properties\n    blk.type = BLT_1WAY\n    blk.flags |= MBL_GOTO",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "create_block",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def create_block(blk: mblock_t, blk_ins: List[minsn_t], is_0_way: bool = False) -> mblock_t:\n    mba = blk.mba\n    new_blk = insert_nop_blk(blk)\n    for ins in blk_ins:\n        tmp_ins = minsn_t(ins)\n        tmp_ins.setaddr(new_blk.tail.ea)\n        new_blk.insert_into_block(tmp_ins, new_blk.tail)\n    if is_0_way:\n        new_blk.type = BLT_0WAY\n        # Bookkeeping",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "update_block_successors",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def update_block_successors(blk: mblock_t, blk_succ_serial_list: List[int]):\n    mba = blk.mba\n    if len(blk_succ_serial_list) == 0:\n        blk.type = BLT_0WAY\n    elif len(blk_succ_serial_list) == 1:\n        blk.type = BLT_1WAY\n    elif len(blk_succ_serial_list) == 2:\n        blk.type = BLT_2WAY\n    else:\n        raise",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "insert_nop_blk",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def insert_nop_blk(blk: mblock_t) -> mblock_t:\n    mba = blk.mba\n    nop_block = mba.copy_block(blk, blk.serial + 1)\n    cur_ins = nop_block.head\n    while cur_ins is not None:\n        nop_block.make_nop(cur_ins)\n        cur_ins = cur_ins.next\n    nop_block.type = BLT_1WAY\n    # We might have clone a block with multiple or no successor, thus we need to clean all\n    prev_successor_serials = [x for x in nop_block.succset]",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_last_block_is_goto",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def ensure_last_block_is_goto(mba: mbl_array_t) -> int:\n    last_blk = mba.get_mblock(mba.qty - 2)\n    if last_blk.nsucc() == 1:\n        change_1way_block_successor(last_blk, last_blk.succset[0])\n        return 1\n    elif last_blk.nsucc() == 0:\n        return 0\n    else:\n        raise ControlFlowException(\"Last block {0} is not one way (not supported yet)\".format(last_blk.serial))\ndef duplicate_block(block_to_duplicate: mblock_t) -> Tuple[mblock_t, mblock_t]:",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "duplicate_block",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def duplicate_block(block_to_duplicate: mblock_t) -> Tuple[mblock_t, mblock_t]:\n    mba = block_to_duplicate.mba\n    duplicated_blk = mba.copy_block(block_to_duplicate, mba.qty - 1)\n    helper_logger.debug(\"  Duplicated {0} -> {1}\".format(block_to_duplicate.serial, duplicated_blk.serial))\n    duplicated_blk_default = None\n    if (block_to_duplicate.tail is not None) and is_mcode_jcond(block_to_duplicate.tail.opcode):\n        block_to_duplicate_default_successor = mba.get_mblock(block_to_duplicate.serial + 1)\n        duplicated_blk_default = insert_nop_blk(duplicated_blk)\n        change_1way_block_successor(duplicated_blk_default, block_to_duplicate.serial + 1)\n        helper_logger.debug(\"  {0} is conditional, so created a default child {1} for {2} which goto {3}\"",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_block_address",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def change_block_address(block: mblock_t, new_ea: int):\n    # Can be used to fix error 50357\n    mb_curr = block.head\n    while mb_curr:\n        mb_curr.ea = new_ea\n        mb_curr = mb_curr.next\ndef is_conditional_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode in CONDITIONAL_JUMP_OPCODES\n    return False",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "is_conditional_jump",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def is_conditional_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode in CONDITIONAL_JUMP_OPCODES\n    return False\ndef is_indirect_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode == m_ijmp\n    return False\ndef get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "is_indirect_jump",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def is_indirect_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode == m_ijmp\n    return False\ndef get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):\n        blk = mba.get_mblock(i)\n        if blk.start == address:\n            blk_serial_list.append(i)",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "get_block_serials_by_address",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):\n        blk = mba.get_mblock(i)\n        if blk.start == address:\n            blk_serial_list.append(i)\n    return blk_serial_list\ndef get_block_serials_by_address_range(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "get_block_serials_by_address_range",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def get_block_serials_by_address_range(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):\n        blk = mba.get_mblock(i)\n        if blk.start <= address <= blk.end:\n            blk_serial_list.append(i)\n    return blk_serial_list\ndef mba_remove_simple_goto_blocks(mba: mbl_array_t) -> int:\n    last_block_index = mba.qty - 1\n    nb_change = 0",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "mba_remove_simple_goto_blocks",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def mba_remove_simple_goto_blocks(mba: mbl_array_t) -> int:\n    last_block_index = mba.qty - 1\n    nb_change = 0\n    for goto_blk_serial in range(last_block_index):\n        goto_blk: mblock_t = mba.get_mblock(goto_blk_serial)\n        if goto_blk.is_simple_goto_block():\n            goto_blk_dst_serial = goto_blk.tail.l.b\n            goto_blk_preset = [x for x in goto_blk.predset]\n            for father_serial in goto_blk_preset:\n                father_blk: mblock_t = mba.get_mblock(father_serial)",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "mba_deep_cleaning",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def mba_deep_cleaning(mba: mbl_array_t, call_mba_combine_block=True) -> int:\n    if mba.maturity < MMAT_CALLS:\n        # Doing this optimization before MMAT_CALLS may create blocks with call instruction (not last instruction)\n        # IDA does like that and will raise a 50864 error\n        return 0\n    if call_mba_combine_block:\n        # Ideally we want IDA to simplify the graph for us with combine_blocks\n        # However, We observe several crashes when this option is activated\n        # (especially when it is used during  O-LLVM unflattening)\n        # TODO: investigate the root cause of this issue",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_child_has_an_unconditional_father",
        "kind": 2,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "def ensure_child_has_an_unconditional_father(father_block: mblock_t, child_block: mblock_t) -> int:\n    if father_block is None:\n        return 0\n    mba = father_block.mba\n    if father_block.nsucc() == 1:\n        return 0\n    if father_block.tail.d.b == child_block.serial:\n        helper_logger.debug(\"Father {0} is a conditional jump to child {1}, creating a new father\"\n                            .format(father_block.serial, child_block.serial))\n        new_father_block = insert_nop_blk(mba.get_mblock(mba.qty - 2))",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "helper_logger",
        "kind": 5,
        "importPath": "plugins.d810.cfg_utils",
        "description": "plugins.d810.cfg_utils",
        "peekOfCode": "helper_logger = logging.getLogger('D810.helper')\ndef log_block_info(blk: mblock_t, logger_func=helper_logger.info):\n    if blk is None:\n        logger_func(\"Block is None\")\n        return\n    vp = block_printer()\n    blk._print(vp)\n    logger_func(\"Block {0} with successors {1} and predecessors {2}:\\n{3}\"\n                .format(blk.serial, [x for x in blk.succset], [x for x in blk.predset], vp.get_block_mc()))\ndef insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):",
        "detail": "plugins.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "kind": 6,
        "importPath": "plugins.d810.emulator",
        "description": "plugins.d810.emulator",
        "peekOfCode": "class MicroCodeInterpreter(object):\n    def __init__(self, global_environment=None):\n        self.global_environment = MicroCodeEnvironment() if global_environment is None else global_environment\n    def _eval_instruction_and_update_environment(self, blk: mblock_t, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:\n        environment.set_cur_flow(blk, ins)\n        res = self._eval_instruction(ins, environment)\n        if res is not None:\n            if (ins.d is not None) and ins.d.t != mop_z:\n                environment.assign(ins.d, res, auto_define=True)\n        return res",
        "detail": "plugins.d810.emulator",
        "documentation": {}
    },
    {
        "label": "MopMapping",
        "kind": 6,
        "importPath": "plugins.d810.emulator",
        "description": "plugins.d810.emulator",
        "peekOfCode": "class MopMapping(object):\n    def __init__(self):\n        self.mops = []\n        self.mops_values = []\n    def __setitem__(self, mop: mop_t, mop_value: int):\n        mop_index = get_mop_index(mop, self.mops)\n        mop_value &= AND_TABLE[mop.size]\n        if mop_index != -1:\n            self.mops_values[mop_index] = mop_value\n            return",
        "detail": "plugins.d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "kind": 6,
        "importPath": "plugins.d810.emulator",
        "description": "plugins.d810.emulator",
        "peekOfCode": "class MicroCodeEnvironment(object):\n    def __init__(self, parent: Union[None, MicroCodeEnvironment] = None):\n        self.parent = parent\n        self.mop_r_record = MopMapping()\n        self.mop_S_record = MopMapping()\n        self.cur_blk = None\n        self.cur_ins = None\n        self.next_blk = None\n        self.next_ins = None\n    def items(self):",
        "detail": "plugins.d810.emulator",
        "documentation": {}
    },
    {
        "label": "emulator_log",
        "kind": 5,
        "importPath": "plugins.d810.emulator",
        "description": "plugins.d810.emulator",
        "peekOfCode": "emulator_log = logging.getLogger('D810.emulator')\nclass MicroCodeInterpreter(object):\n    def __init__(self, global_environment=None):\n        self.global_environment = MicroCodeEnvironment() if global_environment is None else global_environment\n    def _eval_instruction_and_update_environment(self, blk: mblock_t, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:\n        environment.set_cur_flow(blk, ins)\n        res = self._eval_instruction(ins, environment)\n        if res is not None:\n            if (ins.d is not None) and ins.d.t != mop_z:\n                environment.assign(ins.d, res, auto_define=True)",
        "detail": "plugins.d810.emulator",
        "documentation": {}
    },
    {
        "label": "D810Exception",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class D810Exception(Exception):\n    pass\nclass AstException(D810Exception):\n    pass\nclass AstEvaluationException(AstException):\n    pass\nclass D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "AstException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class AstException(D810Exception):\n    pass\nclass AstEvaluationException(AstException):\n    pass\nclass D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "AstEvaluationException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class AstEvaluationException(AstException):\n    pass\nclass D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Z3Exception",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "ControlFlowException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea\n        self.dest_serial_list = dest_serial_list\nclass UnresolvedMopException(EmulationException):",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea\n        self.dest_serial_list = dest_serial_list\nclass UnresolvedMopException(EmulationException):\n    pass\nclass WritableMemoryReadException(EmulationException):",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationIndirectJumpException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea\n        self.dest_serial_list = dest_serial_list\nclass UnresolvedMopException(EmulationException):\n    pass\nclass WritableMemoryReadException(EmulationException):\n    pass\nclass UnsupportedInstructionException(EmulationException):",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "UnresolvedMopException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class UnresolvedMopException(EmulationException):\n    pass\nclass WritableMemoryReadException(EmulationException):\n    pass\nclass UnsupportedInstructionException(EmulationException):\n    pass",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "WritableMemoryReadException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class WritableMemoryReadException(EmulationException):\n    pass\nclass UnsupportedInstructionException(EmulationException):\n    pass",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "UnsupportedInstructionException",
        "kind": 6,
        "importPath": "plugins.d810.errors",
        "description": "plugins.d810.errors",
        "peekOfCode": "class UnsupportedInstructionException(EmulationException):\n    pass",
        "detail": "plugins.d810.errors",
        "documentation": {}
    },
    {
        "label": "mba_printer",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "class mba_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)\n        self.mc = []\n    def get_mc(self):\n        return self.mc\n    def _print(self, indent, line):\n        self.mc.append(\"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in line])+\"\\n\")\n        return 1\nclass block_printer(vd_printer_t):",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "block_printer",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "class block_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)\n        self.block_ins = []\n    def get_block_mc(self):\n        return \"\\n\".join(self.block_ins)\n    def _print(self, indent, line):\n        self.block_ins.append(\"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in line]))\n        return 1\ndef write_mc_to_file(mba: mbl_array_t, filename: str, mba_flags: int = 0) -> bool:",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def format_minsn_t(ins: minsn_t) -> str:\n    if ins is None:\n        return \"minsn_t is None\"\n    tmp = ins._print()\n    pp_ins = \"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in tmp])\n    return pp_ins\ndef format_mop_t(mop_in: mop_t) -> str:\n    if mop_in is None:\n        return \"mop_t is None\"\n    if mop_in.t > 15:",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def format_mop_t(mop_in: mop_t) -> str:\n    if mop_in is None:\n        return \"mop_t is None\"\n    if mop_in.t > 15:\n        # To avoid error 50581\n        return \"Unknown mop type {0}\".format(mop_in.t)\n    return mop_in.dstr()\ndef format_mop_list(mop_list: List[mop_t]) -> str:\n    return \", \".join([format_mop_t(x) for x in mop_list])\ndef maturity_to_string(maturity_level: int) -> str:",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_list",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def format_mop_list(mop_list: List[mop_t]) -> str:\n    return \", \".join([format_mop_t(x) for x in mop_list])\ndef maturity_to_string(maturity_level: int) -> str:\n    return MATURITY_TO_STRING_DICT.get(maturity_level, \"Unknown maturity: {0}\".format(maturity_level))\ndef string_to_maturity(maturity_string: str) -> int:\n    return STRING_TO_MATURITY_DICT.get(maturity_string)\ndef mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "maturity_to_string",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def maturity_to_string(maturity_level: int) -> str:\n    return MATURITY_TO_STRING_DICT.get(maturity_level, \"Unknown maturity: {0}\".format(maturity_level))\ndef string_to_maturity(maturity_string: str) -> int:\n    return STRING_TO_MATURITY_DICT.get(maturity_string)\ndef mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "string_to_maturity",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def string_to_maturity(maturity_string: str) -> int:\n    return STRING_TO_MATURITY_DICT.get(maturity_string)\ndef mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:\n        return \"Unknown opcode: {0}\".format(opcode)\nclass mba_printer(vd_printer_t):",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "mop_type_to_string",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:\n        return \"Unknown opcode: {0}\".format(opcode)\nclass mba_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:\n        return \"Unknown opcode: {0}\".format(opcode)\nclass mba_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)\n        self.mc = []\n    def get_mc(self):",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "write_mc_to_file",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def write_mc_to_file(mba: mbl_array_t, filename: str, mba_flags: int = 0) -> bool:\n    if not mba:\n        return False\n    vp = mba_printer()\n    mba.set_mba_flags(mba_flags)\n    mba._print(vp)\n    with open(filename, \"w\") as f:\n        f.writelines(vp.get_mc())\n    return True\ndef dump_microcode_for_debug(mba: mbl_array_t, log_dir_path: str, name: str = \"\"):",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "def dump_microcode_for_debug(mba: mbl_array_t, log_dir_path: str, name: str = \"\"):\n    mc_filename = os.path.join(log_dir_path, \"{0:x}_maturity_{1}_{2}.log\".format(mba.entry_ea, mba.maturity, name))\n    logger.info(\"Dumping microcode in file {0}...\".format(mc_filename))\n    write_mc_to_file(mba, mc_filename)",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_formatters",
        "description": "plugins.d810.hexrays_formatters",
        "peekOfCode": "logger = logging.getLogger('D810.helper')\ndef format_minsn_t(ins: minsn_t) -> str:\n    if ins is None:\n        return \"minsn_t is None\"\n    tmp = ins._print()\n    pp_ins = \"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in tmp])\n    return pp_ins\ndef format_mop_t(mop_in: mop_t) -> str:\n    if mop_in is None:\n        return \"mop_t is None\"",
        "detail": "plugins.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "equal_bnot_cst",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:\n        mop_size = lo.size\n    return lo.nnn.value ^ ro.nnn.value == AND_TABLE[mop_size]\ndef equal_bnot_mop(lo: mop_t, ro: mop_t, test_two_sides=True) -> bool:\n    if lo.t == mop_n:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def equal_bnot_mop(lo: mop_t, ro: mop_t, test_two_sides=True) -> bool:\n    if lo.t == mop_n:\n        return equal_bnot_cst(lo, ro)\n    # We first check for a bnot operand\n    if (lo.t == mop_d) and lo.d.opcode == m_bnot:\n        if equal_mops_ignore_size(lo.d.l, ro):\n            return True\n    # Otherwise Hexrays may have optimized using ~(-x) = x - 1\n    if (lo.t == mop_d) and lo.d.opcode == m_neg:\n        if (ro.t == mop_d) and ro.d.opcode == m_sub:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_ignore_msb_cst",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def equal_ignore_msb_cst(lo: mop_t, ro: mop_t) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    mask = AND_TABLE[lo.size] ^ MSB_TABLE[lo.size]\n    return lo.nnn.value & mask == ro.nnn.value & mask\ndef equal_mops_bypass_xdu(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):\n        return False",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_bypass_xdu",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def equal_mops_bypass_xdu(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):\n        return False\n    if (lo.t == mop_d) and (lo.d.opcode == m_xdu):\n        return equal_mops_bypass_xdu(lo.d.l, ro)\n    if (ro.t == mop_d) and (ro.d.opcode == m_xdu):\n        return equal_mops_bypass_xdu(lo, ro.d.l)\n    return equal_mops_ignore_size(lo, ro)\ndef equal_mops_ignore_size(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def equal_mops_ignore_size(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):\n        return False\n    if lo.t != ro.t:\n        return False\n    if lo.t == mop_z:\n        return True\n    elif lo.t == mop_fn:\n        return lo.fpc == ro.fpc\n    elif lo.t == mop_n:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "is_check_mop",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def is_check_mop(lo: mop_t) -> bool:\n    if lo.t != mop_d:\n        return False\n    if lo.d.opcode in CHECK_OPCODES:\n        return True\n    if lo.d.opcode in [m_xds, m_xdu]:\n        return is_check_mop(lo.d.l)\n    return False\ndef extract_num_mop(ins: minsn_t) -> Tuple[mop_t, mop_t]:\n    num_mop = None",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "extract_num_mop",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def extract_num_mop(ins: minsn_t) -> Tuple[mop_t, mop_t]:\n    num_mop = None\n    other_mop = None\n    if ins.l.t == mop_n:\n        num_mop = ins.l\n        other_mop = ins.r\n    if ins.r.t == mop_n:\n        num_mop = ins.r\n        other_mop = ins.l\n    return [num_mop, other_mop]",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_ins_mop_size_are_ok",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def check_ins_mop_size_are_ok(ins: minsn_t) -> bool:\n    \"\"\"\n    This function can be used to check if a created instruction has consistent mop size\n    Use it to avoid Hex-Rays decompilation errors when replacing instructions\n    :param ins:\n    :return:\n    \"\"\"\n    ins_dest_size = ins.d.size\n    if ins.opcode in [m_stx, m_ldx]:\n        if ins.r.t == mop_d:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_mop_is_result_of",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def check_mop_is_result_of(lo: mop_t, mc) -> bool:\n    if lo.t != mop_d:\n        return False\n    return lo.d.opcode == mc\ndef extract_by_opcode_type(ins: minsn_t, mc) -> Tuple[mop_t, mop_t]:\n    if check_mop_is_result_of(ins.l, mc):\n        return [ins.l, ins.r]\n    if check_mop_is_result_of(ins.r, mc):\n        return [ins.r, ins.l]\n    return [None, None]",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "extract_by_opcode_type",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def extract_by_opcode_type(ins: minsn_t, mc) -> Tuple[mop_t, mop_t]:\n    if check_mop_is_result_of(ins.l, mc):\n        return [ins.l, ins.r]\n    if check_mop_is_result_of(ins.r, mc):\n        return [ins.r, ins.l]\n    return [None, None]\ndef check_ins_have_same_operands(ins1: minsn_t, ins2: minsn_t, ignore_order=False) -> bool:\n    if equal_mops_ignore_size(ins1.l, ins2.l) and equal_mops_ignore_size(ins1.r, ins2.r):\n        return True\n    if not ignore_order:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_ins_have_same_operands",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def check_ins_have_same_operands(ins1: minsn_t, ins2: minsn_t, ignore_order=False) -> bool:\n    if equal_mops_ignore_size(ins1.l, ins2.l) and equal_mops_ignore_size(ins1.r, ins2.r):\n        return True\n    if not ignore_order:\n        return False\n    return equal_mops_ignore_size(ins1.l, ins2.r) and equal_mops_ignore_size(ins1.r, ins2.l)\ndef get_mop_index(searched_mop: mop_t, mop_list) -> int:\n    for i, test_mop in enumerate(mop_list):\n        if equal_mops_ignore_size(searched_mop, test_mop):\n            return i",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def get_mop_index(searched_mop: mop_t, mop_list) -> int:\n    for i, test_mop in enumerate(mop_list):\n        if equal_mops_ignore_size(searched_mop, test_mop):\n            return i\n    return -1\ndef append_mop_if_not_in_list(mop: mop_t, mop_list) -> bool:\n    mop_index = get_mop_index(mop, mop_list)\n    if mop_index == -1:\n        mop_list.append(mop)\n        return True",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def append_mop_if_not_in_list(mop: mop_t, mop_list) -> bool:\n    mop_index = get_mop_index(mop, mop_list)\n    if mop_index == -1:\n        mop_list.append(mop)\n        return True\n    return False\ndef get_blk_index(searched_blk: mblock_t, blk_list: List[mblock_t]) -> int:\n    blk_serial_list = [blk.serial for blk in blk_list]\n    try:\n        return blk_serial_list.index(searched_blk.serial)",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_blk_index",
        "kind": 2,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "def get_blk_index(searched_blk: mblock_t, blk_list: List[mblock_t]) -> int:\n    blk_serial_list = [blk.serial for blk in blk_list]\n    try:\n        return blk_serial_list.index(searched_blk.serial)\n    except ValueError:\n        return -1",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "OPCODES_INFO",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "OPCODES_INFO = {\n    m_nop: {\"name\": \"nop\", \"nb_operands\": 0, \"is_commutative\": True},\n    m_stx: {\"name\": \"stx\", \"nb_operands\": 2, \"is_commutative\": False},\n    m_ldx: {\"name\": \"ldx\", \"nb_operands\": 2, \"is_commutative\": False},\n    m_ldc: {\"name\": \"ldc\", \"nb_operands\": 1, \"is_commutative\": False},\n    m_mov: {\"name\": \"mov\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"\"},\n    m_neg: {\"name\": \"neg\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"-\"},\n    m_lnot: {\"name\": \"lnot\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"!\"},\n    m_bnot: {\"name\": \"bnot\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"~\"},\n    m_xds: {\"name\": \"xds\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"xds\"},",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MATURITY_TO_STRING_DICT",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "MATURITY_TO_STRING_DICT = {\n    MMAT_ZERO: \"MMAT_ZERO\",\n    MMAT_GENERATED: \"MMAT_GENERATED\",\n    MMAT_PREOPTIMIZED: \"MMAT_PREOPTIMIZED\",\n    MMAT_LOCOPT: \"MMAT_LOCOPT\",\n    MMAT_CALLS: \"MMAT_CALLS\",\n    MMAT_GLBOPT1: \"MMAT_GLBOPT1\",\n    MMAT_GLBOPT2: \"MMAT_GLBOPT2\",\n    MMAT_GLBOPT3: \"MMAT_GLBOPT3\",\n    MMAT_LVARS: \"MMAT_LVARS\",",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "STRING_TO_MATURITY_DICT",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "STRING_TO_MATURITY_DICT = {v: k for k, v in MATURITY_TO_STRING_DICT.items()}\nMOP_TYPE_TO_STRING_DICT = {\n    mop_z: \"mop_z\",\n    mop_r: \"mop_r\",\n    mop_n: \"mop_n\",\n    mop_str: \"mop_str\",\n    mop_d: \"mop_d\",\n    mop_S: \"mop_S\",\n    mop_v: \"mop_v\",\n    mop_b: \"mop_b\",",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MOP_TYPE_TO_STRING_DICT",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "MOP_TYPE_TO_STRING_DICT = {\n    mop_z: \"mop_z\",\n    mop_r: \"mop_r\",\n    mop_n: \"mop_n\",\n    mop_str: \"mop_str\",\n    mop_d: \"mop_d\",\n    mop_S: \"mop_S\",\n    mop_v: \"mop_v\",\n    mop_b: \"mop_b\",\n    mop_f: \"mop_f\",",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "Z3_SPECIAL_OPERANDS",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "Z3_SPECIAL_OPERANDS = [\"UDiv\", \"URem\", \"LShR\", \"UGT\", \"UGE\", \"ULT\", \"ULE\"]\nBOOLEAN_OPCODES = [m_lnot, m_bnot, m_or, m_and, m_xor]\nARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]\nBIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "BOOLEAN_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "BOOLEAN_OPCODES = [m_lnot, m_bnot, m_or, m_and, m_xor]\nARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]\nBIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "ARITHMETICAL_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "ARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]\nBIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "BIT_OPERATIONS_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "BIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CHECK_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "CHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MBA_RELATED_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "MBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONDITIONAL_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "CONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "UNCONDITIONAL_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "UNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "CONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MINSN_TO_AST_FORBIDDEN_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "MINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "SUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "AND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:\n        mop_size = lo.size",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MSB_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_helpers",
        "description": "plugins.d810.hexrays_helpers",
        "peekOfCode": "MSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:\n        mop_size = lo.size\n    return lo.nnn.value ^ ro.nnn.value == AND_TABLE[mop_size]",
        "detail": "plugins.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "InstructionDefUseCollector",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "class InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):\n        if is_target:\n            append_mop_if_not_in_list(op, self.target_mops)\n        else:",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizerManager",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "class InstructionOptimizerManager(optinsn_t):\n    def __init__(self, manager: D810Manager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))\n        super().__init__()\n        self.manager = manager\n        self.instruction_visitor = InstructionVisitorManager(self)\n        self._last_optimizer_tried = None\n        self.current_maturity = None\n        self.current_blk_serial = None\n        self.generate_z3_code = False",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "InstructionVisitorManager",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "class InstructionVisitorManager(minsn_visitor_t):\n    def __init__(self, optimizer: InstructionOptimizerManager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))\n        super().__init__()\n        self.instruction_optimizer = optimizer\n    def visit_minsn(self) -> bool:\n        return self.instruction_optimizer.optimize(self.blk, self.curins)\nclass BlockOptimizerManager(optblock_t):\n    def __init__(self, manager: D810Manager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "BlockOptimizerManager",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "class BlockOptimizerManager(optblock_t):\n    def __init__(self, manager: D810Manager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))\n        super().__init__()\n        self.manager = manager\n        self.cfg_rules = set()\n        self.current_maturity = None\n        self.cfg_rules_usage_info = {}\n    def func(self, blk: mblock_t):\n        self.log_info_on_input(blk)",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "HexraysDecompilationHook",
        "kind": 6,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "class HexraysDecompilationHook(Hexrays_Hooks):\n    def __init__(self, manager):\n        super().__init__()\n        self.manager = manager\n    def prolog(self, mba: mbl_array_t, fc, reachable_blocks, decomp_flags) -> \"int\":\n        main_logger.info(\"Starting decompilation of function at 0x{0:x}\".format(mba.entry_ea))\n        self.manager.instruction_optimizer.reset_rule_usage_statistic()\n        self.manager.block_optimizer.reset_rule_usage_statistic()\n        return 0\n    def glbopt(self, mba: mbl_array_t) -> \"int\":",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "main_logger",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "main_logger = logging.getLogger('D810')\noptimizer_logger = logging.getLogger('D810.optimizer')\nhelper_logger = logging.getLogger('D810.helper')\nDEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nhelper_logger = logging.getLogger('D810.helper')\nDEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "helper_logger",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "helper_logger = logging.getLogger('D810.helper')\nDEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_PATTERN_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_CHAIN_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_Z3_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_EARLY_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):\n        if is_target:",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ANALYZER_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.hexrays_hooks",
        "description": "plugins.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):\n        if is_target:\n            append_mop_if_not_in_list(op, self.target_mops)",
        "detail": "plugins.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "PluginConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.d810.ida_ui",
        "description": "plugins.d810.ida_ui",
        "peekOfCode": "class PluginConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        logger.debug(\"Initializing PluginConfigurationFileForm_t\")\n        super().__init__(parent)\n        self.state = state\n        self.log_dir_changed = False\n        self.log_dir = self.state.d810_config.get(\"log_dir\")\n        self.erase_logs_on_reload = self.state.d810_config.get(\"erase_logs_on_reload\")\n        self.generate_z3_code = self.state.d810_config.get(\"generate_z3_code\")\n        self.dump_intermediate_microcode = self.state.d810_config.get(\"dump_intermediate_microcode\")",
        "detail": "plugins.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "EditConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.d810.ida_ui",
        "description": "plugins.d810.ida_ui",
        "peekOfCode": "class EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        logger.debug(\"Initializing EditConfigurationFileForm_t\")\n        super().__init__(parent)\n        self.state = state\n        self.resize(1000, 500)\n        self.setWindowTitle(\"Rule Configuration Editor\")\n        # Main layout\n        self.config_layout = QtWidgets.QVBoxLayout(self)\n        # Configuration Name Selection Layout",
        "detail": "plugins.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "D810ConfigForm_t",
        "kind": 6,
        "importPath": "plugins.d810.ida_ui",
        "description": "plugins.d810.ida_ui",
        "peekOfCode": "class D810ConfigForm_t(ida_kernwin.PluginForm):\n    def __init__(self, state):\n        super().__init__()\n        self.state = state\n        self.shown = False\n        self.created = False\n        self.parent = None\n    def OnClose(self, form):\n        logger.debug(\"Calling OnClose\")\n        self.shown = False",
        "detail": "plugins.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "D810GUI",
        "kind": 6,
        "importPath": "plugins.d810.ida_ui",
        "description": "plugins.d810.ida_ui",
        "peekOfCode": "class D810GUI(object):\n    def __init__(self, state):\n        \"\"\"\n        Instanciate D-810 views\n        \"\"\"\n        logger.debug(\"Initializing D810GUI\")\n        self.state = state\n        self.d810_config_form = D810ConfigForm_t(self.state)\n        # XXX fix\n        idaapi.set_dock_pos(\"D-810\", \"IDA View-A\", idaapi.DP_TAB)",
        "detail": "plugins.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.ida_ui",
        "description": "plugins.d810.ida_ui",
        "peekOfCode": "logger = logging.getLogger('D810.ui')\nclass PluginConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        logger.debug(\"Initializing PluginConfigurationFileForm_t\")\n        super().__init__(parent)\n        self.state = state\n        self.log_dir_changed = False\n        self.log_dir = self.state.d810_config.get(\"log_dir\")\n        self.erase_logs_on_reload = self.state.d810_config.get(\"erase_logs_on_reload\")\n        self.generate_z3_code = self.state.d810_config.get(\"generate_z3_code\")",
        "detail": "plugins.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "clear_logs",
        "kind": 2,
        "importPath": "plugins.d810.log",
        "description": "plugins.d810.log",
        "peekOfCode": "def clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),\n                                                                  \"z3_log_filename\": z3_test_file.as_posix()})\n    z3_file_logger = logging.getLogger('D810.z3_test')",
        "detail": "plugins.d810.log",
        "documentation": {}
    },
    {
        "label": "configure_loggers",
        "kind": 2,
        "importPath": "plugins.d810.log",
        "description": "plugins.d810.log",
        "peekOfCode": "def configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),\n                                                                  \"z3_log_filename\": z3_test_file.as_posix()})\n    z3_file_logger = logging.getLogger('D810.z3_test')\n    z3_file_logger.info(\"from z3 import BitVec, BitVecVal, UDiv, URem, LShR, UGT, UGE, ULT, ULE, prove\\n\\n\")",
        "detail": "plugins.d810.log",
        "documentation": {}
    },
    {
        "label": "LOG_CONFIG_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.log",
        "description": "plugins.d810.log",
        "peekOfCode": "LOG_CONFIG_FILENAME = \"log.ini\"\nLOG_FILENAME = \"d810.log\"\nZ3_TEST_FILENAME = \"z3_check_instructions_substitution.py\"\ndef clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME",
        "detail": "plugins.d810.log",
        "documentation": {}
    },
    {
        "label": "LOG_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.log",
        "description": "plugins.d810.log",
        "peekOfCode": "LOG_FILENAME = \"d810.log\"\nZ3_TEST_FILENAME = \"z3_check_instructions_substitution.py\"\ndef clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),",
        "detail": "plugins.d810.log",
        "documentation": {}
    },
    {
        "label": "Z3_TEST_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.log",
        "description": "plugins.d810.log",
        "peekOfCode": "Z3_TEST_FILENAME = \"z3_check_instructions_substitution.py\"\ndef clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),\n                                                                  \"z3_log_filename\": z3_test_file.as_posix()})",
        "detail": "plugins.d810.log",
        "documentation": {}
    },
    {
        "label": "D810Manager",
        "kind": 6,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "class D810Manager(object):\n    def __init__(self, log_dir):\n        self.instruction_optimizer_rules = []\n        self.instruction_optimizer_config = {}\n        self.block_optimizer_rules = []\n        self.block_optimizer_config = {}\n        self.instruction_optimizer = None\n        self.block_optimizer = None\n        self.hx_decompiler_hook = None\n        self.log_dir = log_dir",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "D810State",
        "kind": 6,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "class D810State(object):\n    def __init__(self, d810_config: D810Configuration):\n        # For debugging purposes, to interact with this object from the console\n        # Type in IDA Python shell 'from d810.manager import d810_state' to access it\n        global d810_state\n        d810_state = self\n        reload_all_modules()\n        self.d810_config = d810_config\n        self.log_dir = os.path.join(self.d810_config.get(\"log_dir\"), D810_LOG_DIR_NAME)\n        self.manager = D810Manager(self.log_dir)",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "reload_all_modules",
        "kind": 2,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "def reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):\n    def __init__(self, log_dir):\n        self.instruction_optimizer_rules = []\n        self.instruction_optimizer_config = {}",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "d810_state",
        "kind": 5,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "d810_state = None\nD810_LOG_DIR_NAME = \"d810_logs\"\nMANAGER_INFO_FILENAME = \"manager_info.json\"\nlogger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "D810_LOG_DIR_NAME",
        "kind": 5,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "D810_LOG_DIR_NAME = \"d810_logs\"\nMANAGER_INFO_FILENAME = \"manager_info.json\"\nlogger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "MANAGER_INFO_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "MANAGER_INFO_FILENAME = \"manager_info.json\"\nlogger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):\n    def __init__(self, log_dir):",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.manager",
        "description": "plugins.d810.manager",
        "peekOfCode": "logger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):\n    def __init__(self, log_dir):\n        self.instruction_optimizer_rules = []",
        "detail": "plugins.d810.manager",
        "documentation": {}
    },
    {
        "label": "BlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "class BlockInfo(object):\n    def __init__(self, blk: mblock_t, ins=None):\n        self.blk = blk\n        self.ins_list = []\n        if ins is not None:\n            self.ins_list.append(ins)\n    def get_copy(self) -> BlockInfo:\n        new_block_info = BlockInfo(self.blk)\n        new_block_info.ins_list = [x for x in self.ins_list]\n        return new_block_info",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopHistory",
        "kind": 6,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "class MopHistory(object):\n    def __init__(self, searched_mop_list: List[mop_t]):\n        self.searched_mop_list = [mop_t(x) for x in searched_mop_list]\n        self.history = []\n        self.unresolved_mop_list = []\n        self._mc_interpreter = MicroCodeInterpreter()\n        self._mc_initial_environment = MicroCodeEnvironment()\n        self._mc_current_environment = self._mc_initial_environment.get_copy()\n        self._is_dirty = True\n    def add_mop_initial_value(self, mop: mop_t, value: int):",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "kind": 6,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "class MopTracker(object):\n    def __init__(self, searched_mop_list: List[mop_t], max_nb_block=-1, max_path=-1):\n        self.mba = None\n        self._unresolved_mops = []\n        self._memory_unresolved_mops = []\n        for searched_mop in searched_mop_list:\n            a, b = get_standard_and_memory_mop_lists(searched_mop)\n            self._unresolved_mops += a\n            self._memory_unresolved_mops += b\n        self.history = MopHistory(searched_mop_list)",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_standard_and_memory_mop_lists",
        "kind": 2,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "def get_standard_and_memory_mop_lists(mop_in: mop_t) -> Tuple[List[mop_t], List[mop_t]]:\n    if mop_in.t in [mop_r, mop_S]:\n        return [mop_in], []\n    elif mop_in.t == mop_v:\n        return [], [mop_in]\n    elif mop_in.t == mop_d:\n        ins_mop_info = InstructionDefUseCollector()\n        mop_in.d.for_all_ops(ins_mop_info)\n        return remove_segment_registers(ins_mop_info.unresolved_ins_mops), ins_mop_info.memory_unresolved_ins_mops\n    else:",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_block_with_multiple_predecessors",
        "kind": 2,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "def get_block_with_multiple_predecessors(var_histories: List[MopHistory]) -> Tuple[Union[None, mblock_t],\n                                                                                   Union[None, Dict[int, List[MopHistory]]]]:\n    for i, var_history in enumerate(var_histories):\n        pred_blk = var_history.block_path[0]\n        for block in var_history.block_path[1:]:\n            tmp_dict = {pred_blk.serial: [var_history]}\n            for j in range(i + 1, len(var_histories)):\n                blk_index = get_blk_index(block, var_histories[j].block_path)\n                if (blk_index - 1) >= 0:\n                    other_pred = var_histories[j].block_path[blk_index - 1]",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "try_to_duplicate_one_block",
        "kind": 2,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "def try_to_duplicate_one_block(var_histories: List[MopHistory]) -> Tuple[int, int]:\n    nb_duplication = 0\n    nb_change = 0\n    if (len(var_histories) == 0) or (len(var_histories[0].block_path) == 0):\n        return nb_duplication, nb_change\n    mba = var_histories[0].block_path[0].mba\n    block_to_duplicate, pred_dict = get_block_with_multiple_predecessors(var_histories)\n    if block_to_duplicate is None:\n        return nb_duplication, nb_change\n    logger.debug(\"Block to duplicate found: {0} with {1} successors\"",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_histories",
        "kind": 2,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "def duplicate_histories(var_histories: List[MopHistory], max_nb_pass: int = 10) -> Tuple[int, int]:\n    cur_pass = 0\n    total_nb_duplication = 0\n    total_nb_change = 0\n    logger.info(\"Trying to fix new var_history...\")\n    for i, var_history in enumerate(var_histories):\n        logger.info(\" start.{0}: {1}\".format(i, var_history.block_serial_path))\n    while cur_pass < max_nb_pass:\n        logger.debug(\"Current path {0}\".format(cur_pass))\n        nb_duplication, nb_change = try_to_duplicate_one_block(var_histories)",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_segment_register_indexes",
        "kind": 2,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "def get_segment_register_indexes(mop_list: List[mop_t]) -> List[int]:\n    # This is a very dirty and probably buggy\n    segment_register_indexes = []\n    for i, mop in enumerate(mop_list):\n        if mop.t == mop_r:\n            formatted_mop = format_mop_t(mop)\n            if formatted_mop in [\"ds.2\", \"cs.2\", \"es.2\", \"ss.2\"]:\n                segment_register_indexes.append(i)\n    return segment_register_indexes\ndef remove_segment_registers(mop_list: List[mop_t]) -> List[mop_t]:",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "remove_segment_registers",
        "kind": 2,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "def remove_segment_registers(mop_list: List[mop_t]) -> List[mop_t]:\n    # TODO: instead of doing that, we should add the segment registers to the (global?) emulation environment\n    segment_register_indexes = get_segment_register_indexes(mop_list)\n    if len(segment_register_indexes) == 0:\n        return mop_list\n    new_mop_list = []\n    for i, mop in enumerate(mop_list):\n        if i in segment_register_indexes:\n            pass\n        else:",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "logger = logging.getLogger('D810.tracker')\nclass BlockInfo(object):\n    def __init__(self, blk: mblock_t, ins=None):\n        self.blk = blk\n        self.ins_list = []\n        if ins is not None:\n            self.ins_list.append(ins)\n    def get_copy(self) -> BlockInfo:\n        new_block_info = BlockInfo(self.blk)\n        new_block_info.ins_list = [x for x in self.ins_list]",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "cur_mop_tracker_nb_path",
        "kind": 5,
        "importPath": "plugins.d810.tracker",
        "description": "plugins.d810.tracker",
        "peekOfCode": "cur_mop_tracker_nb_path = 0\nclass MopTracker(object):\n    def __init__(self, searched_mop_list: List[mop_t], max_nb_block=-1, max_path=-1):\n        self.mba = None\n        self._unresolved_mops = []\n        self._memory_unresolved_mops = []\n        for searched_mop in searched_mop_list:\n            a, b = get_standard_and_memory_mop_lists(searched_mop)\n            self._unresolved_mops += a\n            self._memory_unresolved_mops += b",
        "detail": "plugins.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_all_subclasses",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_all_subclasses(python_class):\n    python_class.__subclasses__()\n    subclasses = set()\n    check_these = [python_class]\n    while check_these:\n        parent = check_these.pop()\n        for child in parent.__subclasses__():\n            if child not in subclasses:\n                subclasses.add(child)\n                check_these.append(child)",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def unsigned_to_signed(unsigned_value, nb_bytes):\n    return CTYPE_SIGNED_TABLE[nb_bytes](unsigned_value).value\ndef signed_to_unsigned(signed_value, nb_bytes):\n    return CTYPE_UNSIGNED_TABLE[nb_bytes](signed_value).value\ndef get_msb(value, nb_bytes):\n    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)\ndef get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "signed_to_unsigned",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def signed_to_unsigned(signed_value, nb_bytes):\n    return CTYPE_UNSIGNED_TABLE[nb_bytes](signed_value).value\ndef get_msb(value, nb_bytes):\n    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)\ndef get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_msb",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_msb(value, nb_bytes):\n    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)\ndef get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)\ndef get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_cf",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)\ndef get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)\ndef get_sub_of(op1, op2, nb_bytes):",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_of",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)\ndef get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)\ndef get_sub_of(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)\ndef get_parity_flag(op1, op2, nb_bytes):",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_sub_cf",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)\ndef get_sub_of(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)\ndef get_parity_flag(op1, op2, nb_bytes):\n    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value\n    return (bin(tmp).count(\"1\") + 1) % 2\ndef ror(x, n, nb_bits=32):",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_sub_of",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_sub_of(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)\ndef get_parity_flag(op1, op2, nb_bytes):\n    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value\n    return (bin(tmp).count(\"1\") + 1) % 2\ndef ror(x, n, nb_bits=32):\n    mask = (2 ** n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (nb_bits - n))",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_parity_flag",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def get_parity_flag(op1, op2, nb_bytes):\n    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value\n    return (bin(tmp).count(\"1\") + 1) % 2\ndef ror(x, n, nb_bits=32):\n    mask = (2 ** n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (nb_bits - n))\ndef rol(x, n, nb_bits=32):\n    return ror(x, nb_bits - n, nb_bits)",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "ror",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def ror(x, n, nb_bits=32):\n    mask = (2 ** n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (nb_bits - n))\ndef rol(x, n, nb_bits=32):\n    return ror(x, nb_bits - n, nb_bits)",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "rol",
        "kind": 2,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "def rol(x, n, nb_bits=32):\n    return ror(x, nb_bits - n, nb_bits)",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "CTYPE_SIGNED_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "CTYPE_SIGNED_TABLE = {1: ctypes.c_int8, 2: ctypes.c_int16, 4: ctypes.c_int32, 8: ctypes.c_int64}\nCTYPE_UNSIGNED_TABLE = {1: ctypes.c_uint8, 2: ctypes.c_uint16, 4: ctypes.c_uint32, 8: ctypes.c_uint64}\ndef get_all_subclasses(python_class):\n    python_class.__subclasses__()\n    subclasses = set()\n    check_these = [python_class]\n    while check_these:\n        parent = check_these.pop()\n        for child in parent.__subclasses__():\n            if child not in subclasses:",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "CTYPE_UNSIGNED_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.utils",
        "description": "plugins.d810.utils",
        "peekOfCode": "CTYPE_UNSIGNED_TABLE = {1: ctypes.c_uint8, 2: ctypes.c_uint16, 4: ctypes.c_uint32, 8: ctypes.c_uint64}\ndef get_all_subclasses(python_class):\n    python_class.__subclasses__()\n    subclasses = set()\n    check_these = [python_class]\n    while check_these:\n        parent = check_these.pop()\n        for child in parent.__subclasses__():\n            if child not in subclasses:\n                subclasses.add(child)",
        "detail": "plugins.d810.utils",
        "documentation": {}
    },
    {
        "label": "create_z3_vars",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def create_z3_vars(leaf_list: List[AstLeaf]):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    known_leaf_list = []\n    known_leaf_z3_var_list = []\n    for leaf in leaf_list:\n        if not leaf.is_constant():\n            leaf_index = get_mop_index(leaf.mop, known_leaf_list)\n            if leaf_index == -1:\n                known_leaf_list.append(leaf.mop)",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "ast_to_z3_expression",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def ast_to_z3_expression(ast: Union[AstNode, AstLeaf], use_bitvecval=False):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    if isinstance(ast, AstLeaf):\n        if ast.is_constant():\n            return z3.BitVecVal(ast.value, 32)\n        return ast.z3_var\n    if ast.opcode == m_neg:\n        return -(ast_to_z3_expression(ast.left, use_bitvecval))\n    elif ast.opcode == m_lnot:",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "mop_list_to_z3_expression_list",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def mop_list_to_z3_expression_list(mop_list: List[mop_t]):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    ast_list = [mop_to_ast(mop) for mop in mop_list]\n    ast_leaf_list = []\n    for ast in ast_list:\n        ast_leaf_list += ast.get_leaf_list()\n    _ = create_z3_vars(ast_leaf_list)\n    return [ast_to_z3_expression(ast) for ast in ast_list]\ndef z3_check_mop_equality(mop1: mop_t, mop2: mop_t) -> bool:",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_equality",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def z3_check_mop_equality(mop1: mop_t, mop2: mop_t) -> bool:\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    z3_mop1, z3_mop2 = mop_list_to_z3_expression_list([mop1, mop2])\n    s = z3.Solver()\n    s.add(z3.Not(z3_mop1 == z3_mop2))\n    if s.check().r == -1:\n        return True\n    return False\ndef z3_check_mop_inequality(mop1: mop_t, mop2: mop_t) -> bool:",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_inequality",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def z3_check_mop_inequality(mop1: mop_t, mop2: mop_t) -> bool:\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    z3_mop1, z3_mop2 = mop_list_to_z3_expression_list([mop1, mop2])\n    s = z3.Solver()\n    s.add(z3_mop1 == z3_mop2)\n    if s.check().r == -1:\n        return True\n    return False\ndef rename_leafs(leaf_list: List[AstLeaf]) -> List[str]:",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "rename_leafs",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def rename_leafs(leaf_list: List[AstLeaf]) -> List[str]:\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    known_leaf_list = []\n    for leaf in leaf_list:\n        if not leaf.is_constant() and leaf.mop.t != mop_z:\n            leaf_index = get_mop_index(leaf.mop, known_leaf_list)\n            if leaf_index == -1:\n                known_leaf_list.append(leaf.mop)\n                leaf_index = len(known_leaf_list) - 1",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "log_z3_instructions",
        "kind": 2,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "def log_z3_instructions(original_ins: minsn_t, new_ins: minsn_t):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    orig_mba_tree = minsn_to_ast(original_ins)\n    new_mba_tree = minsn_to_ast(new_ins)\n    if orig_mba_tree is None or new_mba_tree is None:\n        return None\n    orig_leaf_list = orig_mba_tree.get_leaf_list()\n    new_leaf_list = new_mba_tree.get_leaf_list()\n    var_def_list = rename_leafs(orig_leaf_list + new_leaf_list)",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "logger = logging.getLogger('D810.plugin')\nz3_file_logger = logging.getLogger('D810.z3_test')\ntry:\n    import z3\n    Z3_INSTALLED = True\n    # Since version 4.8.2, when Z3 is creating a BitVec, it relies on _str_to_bytes which uses sys.stdout.encoding\n    # However, in IDA Pro (7.6sp1) sys.stdout is an object of type IDAPythonStdOut\n    # which doesn't have a 'encoding' attribute, thus we set it to something, so that Z3 works\n    import sys\n    try:",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_file_logger",
        "kind": 5,
        "importPath": "plugins.d810.z3_utils",
        "description": "plugins.d810.z3_utils",
        "peekOfCode": "z3_file_logger = logging.getLogger('D810.z3_test')\ntry:\n    import z3\n    Z3_INSTALLED = True\n    # Since version 4.8.2, when Z3 is creating a BitVec, it relies on _str_to_bytes which uses sys.stdout.encoding\n    # However, in IDA Pro (7.6sp1) sys.stdout is an object of type IDAPythonStdOut\n    # which doesn't have a 'encoding' attribute, thus we set it to something, so that Z3 works\n    import sys\n    try:\n        x = sys.stdout.encoding",
        "detail": "plugins.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "YaraSearchResultChooser",
        "kind": 6,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "class YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],\n                [\"String\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "Findcrypt_Plugin_t",
        "kind": 6,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "class Findcrypt_Plugin_t(idaapi.plugin_t):\n    comment = \"Findcrypt plugin for IDA Pro (using yara framework)\"\n    help = \"todo\"\n    wanted_name = \"Findcrypt\"\n    wanted_hotkey = \"Ctrl-Alt-F\"\n    flags = idaapi.PLUGIN_KEEP\n    def init(self):\n        global p_initialized\n        # register popup menu handlers\n        try:",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return Findcrypt_Plugin_t()",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "VERSION = \"0.2\"\nYARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "YARARULES_CFGFILE",
        "kind": 5,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "YARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod\n        def get_label(self):",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "p_initialized = False\nclass YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "GepettoCLI",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.cli",
        "description": "plugins.gepetto.ida.cli",
        "peekOfCode": "class GepettoCLI(ida_kernwin.cli_t):\n    flags = 0\n    sname = \"Gepetto\"\n    lname  = \"Gepetto - \" + _(\"LLM chat\")\n    hint = \"Gepetto\"\n    def OnExecuteLine(self, line):\n        MESSAGES.append({\"role\": \"user\", \"content\": line})\n        gepetto.config.model.query_model_async(MESSAGES, functools.partial(gepetto.ida.handlers.conversation_callback,\n                                                         memory=MESSAGES))\n        return True",
        "detail": "plugins.gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "cli_lifecycle_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.cli",
        "description": "plugins.gepetto.ida.cli",
        "peekOfCode": "def cli_lifecycle_callback(code, old=0):\n    if code == ida_idaapi.NW_OPENIDB:\n        CLI.register()\n    elif code == ida_idaapi.NW_CLOSEIDB or code == ida_idaapi.NW_TERMIDA:\n        CLI.unregister()\n# -----------------------------------------------------------------------------\ndef register_cli():\n    global CLI\n    if CLI:\n        CLI.unregister()",
        "detail": "plugins.gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "register_cli",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.cli",
        "description": "plugins.gepetto.ida.cli",
        "peekOfCode": "def register_cli():\n    global CLI\n    if CLI:\n        CLI.unregister()\n        cli_lifecycle_callback(ida_idaapi.NW_TERMIDA)\n    CLI = GepettoCLI()\n    if CLI.register():\n        ida_idaapi.notify_when(ida_idaapi.NW_TERMIDA | ida_idaapi.NW_OPENIDB | ida_idaapi.NW_CLOSEIDB, cli_lifecycle_callback)",
        "detail": "plugins.gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "ExplainHandler",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "class ExplainHandler(idaapi.action_handler_t):\n    \"\"\"\n    This handler is tasked with querying the model for an explanation of the\n    given function. Once the reply is received, it is added as a function\n    comment.\n    \"\"\"\n    def __init__(self):\n        idaapi.action_handler_t.__init__(self)\n    def activate(self, ctx):\n        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "RenameHandler",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "class RenameHandler(idaapi.action_handler_t):\n    \"\"\"\n    This handler requests new variable names from the model and updates the\n    decompiler's output.\n    \"\"\"\n    def __init__(self):\n        idaapi.action_handler_t.__init__(self)\n    def activate(self, ctx):\n        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())\n        v = ida_hexrays.get_widget_vdui(ctx.widget)",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "SwapModelHandler",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "class SwapModelHandler(idaapi.action_handler_t):\n    \"\"\"\n    This handler replaces the model currently in use with another one selected by the user,\n    and updates the configuration.\n    \"\"\"\n    def __init__(self, new_model, plugin):\n        self.new_model = new_model\n        self.plugin = plugin\n    def activate(self, ctx):\n        try:",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "comment_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "def comment_callback(address, view, response):\n    \"\"\"\n    Callback that sets a comment at the given address.\n    :param address: The address of the function to comment\n    :param view: A handle to the decompiler window\n    :param response: The comment to add\n    \"\"\"\n    response = \"\\n\".join(textwrap.wrap(response, 80, replace_whitespace=False))\n    # Add the response as a comment in IDA, but preserve any existing non-Gepetto comment\n    comment = idc.get_func_cmt(address, 0)",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "conversation_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "def conversation_callback(response, memory):\n    \"\"\"\n    Callback that simply prints the model's response in IDA's output window.\n    :param response: The response returned by the model\n    :param memory: The list of messages exchanged so far, so that it can be updated.\n    :return:\n    \"\"\"\n    memory.append({\"role\": \"assistant\", \"content\": response})\n    print()\n    for line in response.split(\"\\n\"):",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "rename_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "def rename_callback(address, view, response):\n    \"\"\"\n    Callback that extracts a JSON array of old names and new names from the\n    response and sets them in the pseudocode.\n    :param address: The address of the function to work on\n    :param view: A handle to the decompiler window\n    :param response: The response from the model\n    \"\"\"\n    names = json.loads(response)\n    # The rename function needs the start address of the function",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "GepettoPlugin",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.ui",
        "description": "plugins.gepetto.ida.ui",
        "peekOfCode": "class GepettoPlugin(idaapi.plugin_t):\n    flags = 0\n    explain_action_name = \"gepetto:explain_function\"\n    explain_menu_path = \"Edit/Gepetto/\" + _(\"Explain function\")\n    rename_action_name = \"gepetto:rename_function\"\n    rename_menu_path = \"Edit/Gepetto/\" + _(\"Rename variables\")\n    wanted_name = 'Gepetto'\n    wanted_hotkey = ''\n    comment = _(\"Uses {model} to enrich the decompiler's output\").format(model=str(gepetto.config.model))\n    help = _(\"See usage instructions on GitHub\")",
        "detail": "plugins.gepetto.ida.ui",
        "documentation": {}
    },
    {
        "label": "ContextMenuHooks",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.ui",
        "description": "plugins.gepetto.ida.ui",
        "peekOfCode": "class ContextMenuHooks(idaapi.UI_Hooks):\n    def finish_populating_widget_popup(self, form, popup):\n        # Add actions to the context menu of the Pseudocode view\n        if idaapi.get_widget_type(form) == idaapi.BWN_PSEUDOCODE:\n            idaapi.attach_action_to_popup(form, popup, GepettoPlugin.explain_action_name, \"Gepetto/\")\n            idaapi.attach_action_to_popup(form, popup, GepettoPlugin.rename_action_name, \"Gepetto/\")",
        "detail": "plugins.gepetto.ida.ui",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "kind": 6,
        "importPath": "plugins.gepetto.models.base",
        "description": "plugins.gepetto.models.base",
        "peekOfCode": "class LanguageModel(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def query_model_async(self, query, cb, additional_model_options) -> None:\n        pass\n    def __eq__(self, other):\n        return self.get_menu_name() == other.get_menu_name()\n    def __hash__(self):\n        return self.get_menu_name().__hash__()\n    @staticmethod\n    @abc.abstractmethod",
        "detail": "plugins.gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "Groq",
        "kind": 6,
        "importPath": "plugins.gepetto.models.groq",
        "description": "plugins.gepetto.models.groq",
        "peekOfCode": "class Groq(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Groq\"\n    @staticmethod\n    def supported_models():\n        return [GROQ_MODEL_NAME]\n    def __init__(self, model):\n        try:\n            super().__init__(model)",
        "detail": "plugins.gepetto.models.groq",
        "documentation": {}
    },
    {
        "label": "GROQ_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.groq",
        "description": "plugins.gepetto.models.groq",
        "peekOfCode": "GROQ_MODEL_NAME = \"llama-3.1-70b-versatile\"\nclass Groq(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Groq\"\n    @staticmethod\n    def supported_models():\n        return [GROQ_MODEL_NAME]\n    def __init__(self, model):\n        try:",
        "detail": "plugins.gepetto.models.groq",
        "documentation": {}
    },
    {
        "label": "Ollama",
        "kind": 6,
        "importPath": "plugins.gepetto.models.local_ollama",
        "description": "plugins.gepetto.models.local_ollama",
        "peekOfCode": "class Ollama(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Ollama\"\n    @staticmethod\n    def supported_models():\n        global OLLAMA_MODELS\n        if OLLAMA_MODELS is None:\n            try:\n                OLLAMA_MODELS = [m[\"name\"] for m in create_client().list()[\"models\"]]",
        "detail": "plugins.gepetto.models.local_ollama",
        "documentation": {}
    },
    {
        "label": "create_client",
        "kind": 2,
        "importPath": "plugins.gepetto.models.local_ollama",
        "description": "plugins.gepetto.models.local_ollama",
        "peekOfCode": "def create_client():\n    host = gepetto.config.get_config(\"Ollama\", \"HOST\", default=\"http://localhost:11434\")\n    return ollama.Client(host=host)\nclass Ollama(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Ollama\"\n    @staticmethod\n    def supported_models():\n        global OLLAMA_MODELS",
        "detail": "plugins.gepetto.models.local_ollama",
        "documentation": {}
    },
    {
        "label": "OLLAMA_MODELS",
        "kind": 5,
        "importPath": "plugins.gepetto.models.local_ollama",
        "description": "plugins.gepetto.models.local_ollama",
        "peekOfCode": "OLLAMA_MODELS = None\ndef create_client():\n    host = gepetto.config.get_config(\"Ollama\", \"HOST\", default=\"http://localhost:11434\")\n    return ollama.Client(host=host)\nclass Ollama(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Ollama\"\n    @staticmethod\n    def supported_models():",
        "detail": "plugins.gepetto.models.local_ollama",
        "documentation": {}
    },
    {
        "label": "register_model",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def register_model(model: LanguageModel):\n    if not issubclass(model, LanguageModel):\n        return\n    if any(existing.get_menu_name() == model.get_menu_name() for existing in MODEL_LIST):\n        return\n    MODEL_LIST.append(model)\ndef list_models():\n    return MODEL_LIST\ndef instantiate_model(model):\n    \"\"\"",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "list_models",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def list_models():\n    return MODEL_LIST\ndef instantiate_model(model):\n    \"\"\"\n    Instantiates a model based on its name\n    :param model: The model to use\n    :return:\n    \"\"\"\n    for m in MODEL_LIST:\n        if model in m.supported_models():",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "instantiate_model",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def instantiate_model(model):\n    \"\"\"\n    Instantiates a model based on its name\n    :param model: The model to use\n    :return:\n    \"\"\"\n    for m in MODEL_LIST:\n        if model in m.supported_models():\n            return m(model)\n    # If nothing was found, use the default model.",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "load_available_models",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def load_available_models():\n    folder = pathlib.Path(os.path.dirname(__file__))\n    for py_file in folder.glob(\"*.py\"):\n        module_name = py_file.stem  # Get the file name without extension\n        spec = importlib.util.spec_from_file_location(module_name, py_file)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "FALLBACK_MODEL",
        "kind": 5,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "FALLBACK_MODEL = \"gpt-4o\"\ndef register_model(model: LanguageModel):\n    if not issubclass(model, LanguageModel):\n        return\n    if any(existing.get_menu_name() == model.get_menu_name() for existing in MODEL_LIST):\n        return\n    MODEL_LIST.append(model)\ndef list_models():\n    return MODEL_LIST\ndef instantiate_model(model):",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "GPT",
        "kind": 6,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "class GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]\n    def __init__(self, model):\n        self.model = model\n        # Get API key",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT3_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "GPT3_MODEL_NAME = \"gpt-3.5-turbo-0125\"\nGPT4_MODEL_NAME = \"gpt-4-turbo\"\nGPT4o_MODEL_NAME = \"gpt-4o\"\nclass GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT4_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "GPT4_MODEL_NAME = \"gpt-4-turbo\"\nGPT4o_MODEL_NAME = \"gpt-4o\"\nclass GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]\n    def __init__(self, model):",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT4o_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "GPT4o_MODEL_NAME = \"gpt-4o\"\nclass GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]\n    def __init__(self, model):\n        self.model = model",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "Together",
        "kind": 6,
        "importPath": "plugins.gepetto.models.together",
        "description": "plugins.gepetto.models.together",
        "peekOfCode": "class Together(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Together\"\n    @staticmethod\n    def supported_models():\n        return [MISTRAL_MODEL_NAME]\n    def __init__(self, model):\n        try:\n            super().__init__(model)",
        "detail": "plugins.gepetto.models.together",
        "documentation": {}
    },
    {
        "label": "MISTRAL_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.together",
        "description": "plugins.gepetto.models.together",
        "peekOfCode": "MISTRAL_MODEL_NAME = \"mistralai/Mixtral-8x22B-Instruct-v0.1\"\nclass Together(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Together\"\n    @staticmethod\n    def supported_models():\n        return [MISTRAL_MODEL_NAME]\n    def __init__(self, model):\n        try:",
        "detail": "plugins.gepetto.models.together",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "def load_config():\n    \"\"\"\n    Loads the configuration of the plugin from the INI file. Sets up the correct locale and language model.\n    Also prepares an OpenAI client configured accordingly to the user specifications.\n    :return:\n    \"\"\"\n    global model, parsed_ini\n    parsed_ini = configparser.RawConfigParser()\n    parsed_ini.read(os.path.join(os.path.abspath(os.path.dirname(__file__)), \"config.ini\"))\n    # Set up translations",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "def get_config(section, option, environment_variable=None, default=None):\n    \"\"\"\n    Returns a value from the configuration, by looking successively in the configuration file and the environment\n    variables, returning the default value provided if nothing can be found.\n    :param section: The section containing the option.\n    :param option: The requested option.\n    :param environment_variable: The environment variable possibly containing the value.\n    :param default: Default value to return if nothing can be found.\n    :return: The value of the requested option.\n    \"\"\"",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "update_config",
        "kind": 2,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "def update_config(section, option, new_value):\n    \"\"\"\n    Updates a single entry in the configuration.\n    :param section: The section in which the option is located\n    :param option: The option to update\n    :param new_value: The new value to set\n    :return:\n    \"\"\"\n    path = os.path.join(os.path.abspath(os.path.dirname(__file__)), \"config.ini\")\n    config = configparser.RawConfigParser()",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "model = None\nparsed_ini = None\ndef load_config():\n    \"\"\"\n    Loads the configuration of the plugin from the INI file. Sets up the correct locale and language model.\n    Also prepares an OpenAI client configured accordingly to the user specifications.\n    :return:\n    \"\"\"\n    global model, parsed_ini\n    parsed_ini = configparser.RawConfigParser()",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "parsed_ini",
        "kind": 5,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "parsed_ini = None\ndef load_config():\n    \"\"\"\n    Loads the configuration of the plugin from the INI file. Sets up the correct locale and language model.\n    Also prepares an OpenAI client configured accordingly to the user specifications.\n    :return:\n    \"\"\"\n    global model, parsed_ini\n    parsed_ini = configparser.RawConfigParser()\n    parsed_ini.read(os.path.join(os.path.abspath(os.path.dirname(__file__)), \"config.ini\"))",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "HyaraBinaryNinja",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "description": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "peekOfCode": "class HyaraBinaryNinja(HyaraGUI):\n    def __init__(self):\n        super(HyaraBinaryNinja, self).__init__()\n    @property\n    def bv(self):\n        return binja_get_bv_from_dock()\n    def get_disasm(self, start_address, end_address) -> list:\n        result = []\n        bv = self.bv\n        while start_address < end_address:",
        "detail": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "documentation": {}
    },
    {
        "label": "binja_get_bv_from_dock",
        "kind": 2,
        "importPath": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "description": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "peekOfCode": "def binja_get_bv_from_dock():\n    dh = DockHandler.getActiveDockHandler()\n    if not dh:\n        return None\n    vf = dh.getViewFrame()\n    if not vf:\n        return None\n    vi = vf.getCurrentViewInterface()\n    bv = vi.getData()\n    return bv",
        "detail": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "documentation": {}
    },
    {
        "label": "HyaraCutter",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.cutter_api",
        "description": "plugins.hyara_lib.integration.cutter_api",
        "peekOfCode": "class HyaraCutter(HyaraGUI):\n    def __init__(self):\n        super(HyaraCutter, self).__init__()\n    def get_disasm(self, start_address, end_address) -> list:\n        length = end_address - start_address\n        return cutter.cmd(f\"pI {length} @ {start_address}\").split(\"\\n\")\n    def get_hex(self, start_address, end_address) -> str:\n        length = end_address - start_address\n        return cutter.cmd(f\"p8 {length} @ {start_address}\").strip()\n    def get_comment_hex(self, start_address, end_address) -> list:",
        "detail": "plugins.hyara_lib.integration.cutter_api",
        "documentation": {}
    },
    {
        "label": "HyaraGhidra",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.ghidra_api",
        "description": "plugins.hyara_lib.integration.ghidra_api",
        "peekOfCode": "class HyaraGhidra(HyaraGUI):\n    def __init__(self):\n        super(HyaraGhidra, self).__init__()\n    def get_disasm(self, start_address, end_address) -> list:\n        result = []\n        current_address = toAddr(start_address)\n        while int(current_address.toString(), 16) < end_address:\n            data = getInstructionAt(current_address)\n            result.append(data.toString())\n            current_address = data.getNext().getMinAddress()",
        "detail": "plugins.hyara_lib.integration.ghidra_api",
        "documentation": {}
    },
    {
        "label": "HyaraIDA",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.ida_api",
        "description": "plugins.hyara_lib.integration.ida_api",
        "peekOfCode": "class HyaraIDA(HyaraGUI):\n    def __init__(self):\n        super(HyaraIDA, self).__init__()\n    def get_disasm(self, start_address, end_address) -> list:\n        result = []\n        current_start = start_address\n        while current_start < end_address:\n            # https://github.com/idapython/src/blob/master/python/idautils.py#L202\n            result.append(idc.GetDisasm(current_start))\n            current_start = ida_bytes.next_head(current_start, ida_ida.cvar.inf.max_ea)",
        "detail": "plugins.hyara_lib.integration.ida_api",
        "documentation": {}
    },
    {
        "label": "YaraChecker",
        "kind": 6,
        "importPath": "plugins.hyara_lib.plugins.yara_checker",
        "description": "plugins.hyara_lib.plugins.yara_checker",
        "peekOfCode": "class YaraChecker(QtWidgets.QDialog):\n    def __init__(self, rule_text):\n        super(YaraChecker, self).__init__()\n        self.setObjectName(\"YaraChecker\")\n        self.setWindowTitle(\"YaraChecker\")\n        self.rule_text = rule_text\n    def _ui_init(self):\n        self._ui_setting()\n        self._ui_init_layout()\n        self._ui_clicked_connect()",
        "detail": "plugins.hyara_lib.plugins.yara_checker",
        "documentation": {}
    },
    {
        "label": "YaraDetector",
        "kind": 6,
        "importPath": "plugins.hyara_lib.plugins.yara_detector",
        "description": "plugins.hyara_lib.plugins.yara_detector",
        "peekOfCode": "class YaraDetector(QtWidgets.QDialog):\n    def __init__(self, rule_text, file_path, jump_to):\n        super(YaraDetector, self).__init__()\n        self.setObjectName(\"YaraDetector\")\n        self.setWindowTitle(\"YaraDetector\")\n        self.rule_text = rule_text\n        self.file_path = file_path\n        self.jump_to = jump_to\n    def _ui_init(self):\n        try:",
        "detail": "plugins.hyara_lib.plugins.yara_detector",
        "documentation": {}
    },
    {
        "label": "YaraIcon",
        "kind": 6,
        "importPath": "plugins.hyara_lib.plugins.yara_icon",
        "description": "plugins.hyara_lib.plugins.yara_icon",
        "peekOfCode": "class YaraIcon(QtWidgets.QDialog):\n    def __init__(self, file_path, rule_list, _ui_populate_table):\n        super(YaraIcon, self).__init__()\n        self.setObjectName(\"YaraIcon\")\n        self.setWindowTitle(\"YaraIcon\")\n        self.file_path = file_path\n        self.rule_list = rule_list\n        self._ui_populate_table = _ui_populate_table\n    def _ui_init(self):\n        self._ui_setting()",
        "detail": "plugins.hyara_lib.plugins.yara_icon",
        "documentation": {}
    },
    {
        "label": "ICON_HEADER",
        "kind": 5,
        "importPath": "plugins.hyara_lib.plugins.yara_icon",
        "description": "plugins.hyara_lib.plugins.yara_icon",
        "peekOfCode": "ICON_HEADER = (\n    b\"\\x00\\x00\\x01\\x00\\x01\\x00\\x30\\x30\\x00\\x00\\x01\\x00\\x08\\x00\\xA8\\x0E\\x00\\x00\\x16\\x00\\x00\\x00\"\n)\nclass YaraIcon(QtWidgets.QDialog):\n    def __init__(self, file_path, rule_list, _ui_populate_table):\n        super(YaraIcon, self).__init__()\n        self.setObjectName(\"YaraIcon\")\n        self.setWindowTitle(\"YaraIcon\")\n        self.file_path = file_path\n        self.rule_list = rule_list",
        "detail": "plugins.hyara_lib.plugins.yara_icon",
        "documentation": {}
    },
    {
        "label": "WildcardPlainTextEdit",
        "kind": 6,
        "importPath": "plugins.hyara_lib.ui.settings",
        "description": "plugins.hyara_lib.ui.settings",
        "peekOfCode": "class WildcardPlainTextEdit(QtWidgets.QPlainTextEdit):\n    def __init__(self, parent=None):\n        QtWidgets.QPlainTextEdit.__init__(self, parent)\n    def contextMenuEvent(self, event):\n        menu = QtWidgets.QMenu(self)\n        wildcard_action = menu.addAction(\"Modify the values to &wild-cards\")\n        action = menu.exec_(self.mapToGlobal(event.pos()))\n        if action == wildcard_action:\n            self._wildcard_trigger()\n    def _wildcard_trigger(self):",
        "detail": "plugins.hyara_lib.ui.settings",
        "documentation": {}
    },
    {
        "label": "MainGUI",
        "kind": 6,
        "importPath": "plugins.hyara_lib.ui.settings",
        "description": "plugins.hyara_lib.ui.settings",
        "peekOfCode": "class MainGUI:\n    def __init__(self):\n        self.layout = QtWidgets.QVBoxLayout()\n        self.rule_list = {}\n        self._ui_init()\n    def _ui_init(self):\n        self._ui_setting()\n        self._ui_init_layout()\n        self._ui_init_table()\n    def _ui_setting(self):",
        "detail": "plugins.hyara_lib.ui.settings",
        "documentation": {}
    },
    {
        "label": "HyaraGUI",
        "kind": 6,
        "importPath": "plugins.hyara_lib.ui.settings",
        "description": "plugins.hyara_lib.ui.settings",
        "peekOfCode": "class HyaraGUI(MainGUI):\n    __metaclass__ = ABCMeta\n    def __init__(self):\n        super(HyaraGUI, self).__init__()\n        self._ui_clicked_connect()\n    @abstractmethod\n    def get_disasm(self, start_address, end_address) -> list:\n        pass\n    @abstractmethod\n    def get_hex(self, start_address, end_address) -> list:",
        "detail": "plugins.hyara_lib.ui.settings",
        "documentation": {}
    },
    {
        "label": "ColorTheme",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.colortheme",
        "description": "plugins.idabincat.hexview.colortheme",
        "peekOfCode": "class ColorTheme(object):\n    \"\"\" interface \"\"\"\n    def get_accent(self, index):\n        \"\"\"\n        :rtype: PyQt5.QtGui.QColor\n        \"\"\"\n        raise NotImplementedError()\nclass LightPastelColorTheme(ColorTheme):\n    \"\"\"\n    #####  Color Palette by Paletton.com",
        "detail": "plugins.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "LightPastelColorTheme",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.colortheme",
        "description": "plugins.idabincat.hexview.colortheme",
        "peekOfCode": "class LightPastelColorTheme(ColorTheme):\n    \"\"\"\n    #####  Color Palette by Paletton.com\n    #####  Palette URL: http://paletton.com/#uid=75a0u0kcglL4Zvw8Eq6eXhmkwen\n    *** Primary color:\n       shade 0 = #8B5674 = rgb(139, 86,116) = rgba(139, 86,116,1) = rgb0(0.545,0.337,0.455)\n       shade 1 = #C9AABC = rgb(201,170,188) = rgba(201,170,188,1) = rgb0(0.788,0.667,0.737)\n       shade 2 = #A77A93 = rgb(167,122,147) = rgba(167,122,147,1) = rgb0(0.655,0.478,0.576)\n       shade 3 = #6F3B58 = rgb(111, 59, 88) = rgba(111, 59, 88,1) = rgb0(0.435,0.231,0.345)\n       shade 4 = #5C2142 = rgb( 92, 33, 66) = rgba( 92, 33, 66,1) = rgb0(0.361,0.129,0.259)",
        "detail": "plugins.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "SolarizedColorTheme",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.colortheme",
        "description": "plugins.idabincat.hexview.colortheme",
        "peekOfCode": "class SolarizedColorTheme(ColorTheme):\n    \"\"\"\n    via http://ethanschoonover.com/solarized\n    solarized accent colors:\n        $yellow:    #b58900;\n        $orange:    #cb4b16;\n        $red:       #dc322f;\n        $magenta:   #d33682;\n        $violet:    #6c71c4;\n        $blue:      #268bd2;",
        "detail": "plugins.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "LoggingObject",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.common",
        "description": "plugins.idabincat.hexview.common",
        "peekOfCode": "class LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):\n        FUNCTION_NAME_INDEX = 3\n        return inspect.stack()[3][FUNCTION_NAME_INDEX]\n    def _formatFormatString(self, args):\n        return [self._getCallerFunction() + \": \" + args[0]] + [a for a in args[1:]]\n    def d(self, *args, **kwargs):",
        "detail": "plugins.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 2,
        "importPath": "plugins.idabincat.hexview.common",
        "description": "plugins.idabincat.hexview.common",
        "peekOfCode": "def h(i):\n    return hex(i).strip(\"L\")\ndef one(s):\n    for c in s:\n        return c\nclass LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):",
        "detail": "plugins.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "one",
        "kind": 2,
        "importPath": "plugins.idabincat.hexview.common",
        "description": "plugins.idabincat.hexview.common",
        "peekOfCode": "def one(s):\n    for c in s:\n        return c\nclass LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):\n        FUNCTION_NAME_INDEX = 3\n        return inspect.stack()[3][FUNCTION_NAME_INDEX]",
        "detail": "plugins.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "HexItemDelegate",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexItemDelegate(QStyledItemDelegate):\n    pixcache = {}\n    def __init__(self, model, parent, *args):\n        super(HexItemDelegate, self).__init__(parent)\n        # compute size hint for hex view\n        dh = QTextDocument()\n        dh.setHtml(\"<font color='green'>DF</font>\")\n        self.hex_hint = QtCore.QSize(int(dh.idealWidth()-dh.documentMargin()), 22)\n        # compute size hint for char view\n        dc = QTextDocument()",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexTableModel",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexTableModel(QAbstractTableModel):\n    FILTER = ''.join(\n        [(len(repr(chr(x))) == 3 or chr(x) == \"\\\\\") and chr(x) or\n         '.' for x in range(256)])\n    def __init__(self, meminfo, parent=None, *args):\n        super(HexTableModel, self).__init__(parent, *args)\n        self._meminfo = None\n        self._rowcount = None\n        self.setNewMem(meminfo)\n    def setNewMem(self, meminfo):",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexItemSelectionModel",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexItemSelectionModel(QItemSelectionModel):\n    selectionRangeChanged = pyqtSignal([int])\n    def __init__(self, model, view):\n        \"\"\"\n        :type view: HexTableView\n        \"\"\"\n        super(HexItemSelectionModel, self).__init__(model)\n        self._model = model\n        self._view = view\n        self._start_qindex = None",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexTableView",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexTableView(QTableView, LoggingObject):\n    \"\"\" table view that handles click events for better selection handling \"\"\"\n    leftMousePressed = pyqtSignal([QMouseEvent])\n    leftMousePressedIndex = pyqtSignal([QModelIndex])\n    leftMouseMoved = pyqtSignal([QMouseEvent])\n    leftMouseMovedIndex = pyqtSignal([QModelIndex])\n    leftMouseReleased = pyqtSignal([QMouseEvent])\n    leftMouseReleasedIndex = pyqtSignal([QModelIndex])\n    moveKeyPressed = pyqtSignal([QKeySequence])\n    selectKeyPressed = pyqtSignal([QKeySequence])",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexViewWidget",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexViewWidget(QWidget, HexViewBase, LoggingObject):\n    originsChanged = pyqtSignal()\n    newOverride = pyqtSignal(int, int, bool)\n    def __init__(self, meminfo, parent=None):\n        super(HexViewWidget, self).__init__()\n        self.setupUi(self)\n        self._meminfo = meminfo\n        self._model = HexTableModel(self._meminfo)\n        self._origins = []\n        # ripped from pyuic5 ui/hexview.ui",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "bc_log = logging.getLogger('bincat.hexview')\nbc_log.setLevel(logging.DEBUG)\nclass HexItemDelegate(QStyledItemDelegate):\n    pixcache = {}\n    def __init__(self, model, parent, *args):\n        super(HexItemDelegate, self).__init__(parent)\n        # compute size hint for hex view\n        dh = QTextDocument()\n        dh.setHtml(\"<font color='green'>DF</font>\")\n        self.hex_hint = QtCore.QSize(int(dh.idealWidth()-dh.documentMargin()), 22)",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "Origin",
        "kind": 5,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "Origin = namedtuple(\"Origin\", [\"offset\", \"name\"])\nclass HexViewWidget(QWidget, HexViewBase, LoggingObject):\n    originsChanged = pyqtSignal()\n    newOverride = pyqtSignal(int, int, bool)\n    def __init__(self, meminfo, parent=None):\n        super(HexViewWidget, self).__init__()\n        self.setupUi(self)\n        self._meminfo = meminfo\n        self._model = HexTableModel(self._meminfo)\n        self._origins = []",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "Ui_Form",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview_auto",
        "description": "plugins.idabincat.hexview.hexview_auto",
        "peekOfCode": "class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(\"Form\")\n        Form.resize(400, 300)\n        self.verticalLayout = QtWidgets.QVBoxLayout(Form)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.mainLayout = QtWidgets.QVBoxLayout()\n        self.mainLayout.setObjectName(\"mainLayout\")\n        self.statusLabel = QtWidgets.QLabel(Form)\n        self.statusLabel.setMaximumSize(QtCore.QSize(16777215, 15))",
        "detail": "plugins.idabincat.hexview.hexview_auto",
        "documentation": {}
    },
    {
        "label": "pesection_t",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),\n                (\"s_lnnoptr\", ctypes.c_int),\n                (\"s_nreloc\", ctypes.c_ushort),\n                (\"s_nlnno\", ctypes.c_ushort),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "elf_ph_t",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class elf_ph_t(ctypes.Structure):\n    _fields_ = [(\"p_type\", ctypes.c_uint),\n                (\"p_flags\", ctypes.c_uint),\n                (\"p_offset\", ctypes.c_ulonglong),\n                (\"p_vaddr\", ctypes.c_ulonglong),\n                (\"p_paddr\", ctypes.c_ulonglong),\n                (\"p_filesz\", ctypes.c_ulonglong),\n                (\"p_memsz\", ctypes.c_ulonglong),\n                (\"p_align\", ctypes.c_ulonglong)]\nclass ConfigHelpers(object):",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class ConfigHelpers(object):\n    \"\"\"\n    Holds helpers, that transform data obtained from ida API.\n    Used to generate default configuration.\n    \"\"\"\n    ftypes = {idaapi.f_PE: \"pe\",\n              idaapi.f_ELF: \"elf\",\n              idaapi.f_MACHO: \"macho\"}\n    @staticmethod\n    def get_file_type():",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "InitialState",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class InitialState(object):\n    \"\"\"\n    Stores the initial state configuration:\n        * registers\n        * memory\n    \"\"\"\n    def __init__(self, entrypoint=None, config=None):\n        if config:\n            arch = config.get('program', 'architecture')\n            self.mem = []",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class AnalyzerConfig(object):\n    \"\"\"\n    Handles configuration files for the analyzer.\n    \"\"\"\n    def __init__(self, config=None):\n        self.version = \"0.0\"\n        if config:\n            self._config = config\n            self.init_state = InitialState(config=config)\n        else:",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class AnalyzerConfigurations(object):\n    def __init__(self, state):\n        self._state = state\n        self._netnode = idabincat.netnode.Netnode()\n        #: name -> serialized AnalyzerConfig\n        self._configs = {}\n        #: address (int) -> name\n        self._prefs = {}\n        #: list of functions to be called prior to updating overrides\n        self.pre_callbacks = []",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "bc_log = logging.getLogger('bincat-cfg')\nbc_log.setLevel(logging.INFO)\nX64_GPR = ['rax', 'rcx', 'rdx', 'rbx', 'rbp', 'rsi', 'rdi', 'rsp']+[\"r%d\" % d for d in range(8, 16)]\nX86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X64_GPR",
        "kind": 5,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "X64_GPR = ['rax', 'rcx', 'rdx', 'rbx', 'rbp', 'rsi', 'rdi', 'rsp']+[\"r%d\" % d for d in range(8, 16)]\nX86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X86_GPR",
        "kind": 5,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "X86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),\n                (\"s_lnnoptr\", ctypes.c_int),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerUnavailable",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class AnalyzerUnavailable(Exception):\n    pass\nclass BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "BincatPlugin",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(BincatPlugin, self).__init__()",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class Analyzer(object):\n    def __init__(self, path, finish_cb):\n        self.path = path\n        self.finish_cb = finish_cb\n    def generate_tnpk(self, fname=None, destfname=None):\n        \"\"\"\n        Generates TNPK file for provided fname. If None, generate one for the\n        binary that is currently being analyzed in IDA, using IDA-provided\n        headers.\n        Returns file path to generated tnpk (string), or None if generation was",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzerTimer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class LocalAnalyzerTimer(object):\n    \"\"\"\n    IDA timer used to kill the BinCAT analyzer if the user\n    cancels the analysis\n    \"\"\"\n    def __init__(self, qprocess):\n        self.interval = 500  # ms\n        self.qprocess = qprocess\n        self.timer = idaapi.register_timer(self.interval, self)\n        if self.timer is None:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class LocalAnalyzer(Analyzer, QtCore.QProcess):\n    \"\"\"\n    Runs BinCAT locally using QProcess.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        QtCore.QProcess.__init__(self)\n        Analyzer.__init__(self, *args, **kwargs)\n        # Qprocess signal handlers\n        self.error.connect(self.procanalyzer_on_error)\n        self.stateChanged.connect(self.procanalyzer_on_state_change)",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "WebAnalyzer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class WebAnalyzer(Analyzer):\n    API_VERSION = \"1.2\"\n    def __init__(self, *args, **kwargs):\n        Analyzer.__init__(self, *args, **kwargs)\n        self.server_url = PluginOptions.get(\"server_url\").rstrip(\"/\")\n        self.reachable_server = False\n        self.check_version()  # raises exception if server is unreachable\n        self.reachable_server = True\n    def check_version(self):\n        try:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class State(object):\n    \"\"\"\n    Container for (static) plugin state related data & methods.\n    \"\"\"\n    def __init__(self):\n        self.current_ea = None\n        self.cfa = None\n        self.current_node = None\n        #: list of node ids (int)\n        self.current_node_ids = []",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "CallbackWrappedList",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class CallbackWrappedList(MutableSequence):\n    \"\"\"\n    Acts as a List object, wraps write access with calls to properly invalidate\n    models associated with View GUI objects.\n    Should store only immutable objects.\n    \"\"\"\n    def __init__(self):\n        self._data = []\n        #: list of functions to be called prior to updating list\n        self.pre_callbacks = []",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "dedup_loglines",
        "kind": 2,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "def dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:\n                return True\n        if n == 2:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return BincatPlugin()",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "bc_log = logging.getLogger('bincat.plugin')\nbc_log.setLevel(logging.INFO)\ndef dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "dump_binary",
        "kind": 2,
        "importPath": "plugins.idabincat.dump_binary",
        "description": "plugins.idabincat.dump_binary",
        "peekOfCode": "def dump_binary(path):\n    sections = []\n    current_offset = 0\n    with open(path, 'wb+') as f:\n        # over all segments\n        for n in range(ida_segment.get_segm_qty()):\n            seg = ida_segment.getnseg(n)\n            start_ea = seg.start_ea\n            end_ea = seg.end_ea\n            size = end_ea - start_ea",
        "detail": "plugins.idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "dump_log",
        "kind": 5,
        "importPath": "plugins.idabincat.dump_binary",
        "description": "plugins.idabincat.dump_binary",
        "peekOfCode": "dump_log = logging.getLogger('bincat.plugin.dump_binary')\ndump_log.setLevel(logging.DEBUG)\n# Dumps a remapped binary (as seen in IDA to disk)\n# returns a list of sections\n# [(name, va, vasize, raw_addr, raw_size)]\ndef dump_binary(path):\n    sections = []\n    current_offset = 0\n    with open(path, 'wb+') as f:\n        # over all segments",
        "detail": "plugins.idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "EditConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()\n        self.configtxt.setSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                     QtWidgets.QSizePolicy.Expanding)\n        self.btn_save = QtWidgets.QPushButton('&Save', self)\n        self.btn_save.clicked.connect(self.use_config)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATOptionsForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATOptionsForm_t(QtWidgets.QDialog):\n    def __init__(self, state):\n        super(BinCATOptionsForm_t, self).__init__()\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        lbl_default_bhv = QtWidgets.QLabel(\"Default behaviour\")\n        # Save config in IDB by default\n        self.chk_save = QtWidgets.QCheckBox('Save &configuration to IDB')\n        self.chk_load = QtWidgets.QCheckBox('&Load configuration from IDB')\n        btn_start = QtWidgets.QPushButton('&Save', self)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "Meminfo",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class Meminfo(object):\n    \"\"\"\n    Helper class to access memory as a str\n    \"\"\"\n    def __init__(self, unrel, region, ranges):\n        self.unrel = unrel\n        self.region = region\n        #: list of ranges: [[begin int, end int], ...]\n        self.ranges = ranges\n        self.start = ranges[0][0]",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATMemForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATMemForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT memory display form.\n    \"\"\"\n    def __init__(self, state):\n        super(BinCATMemForm_t, self).__init__()\n        self.s = state\n        self.shown = False\n        self.created = False\n        self.hexwidget = None",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATConfigForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATConfigForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT initial configuration form\n    This form allows the definition and edition of\n    initial registers and memory\n    \"\"\"\n    def __init__(self, state, cfgregmodel, cfgmemmodel):\n        super(BinCATConfigForm_t, self).__init__()\n        self.s = state\n        self.cfgregmodel = cfgregmodel",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATDebugForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATDebugForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Debug form: display IL and instruction bytes, if present in BinCAT\n    output.\n    \"\"\"\n    def __init__(self, state):\n        super(BinCATDebugForm_t, self).__init__()\n        self.s = state\n        self.shown = False\n        self.created = False",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "RegisterItemDelegate",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class RegisterItemDelegate(QtWidgets.QStyledItemDelegate):\n    \"\"\"\n    http://stackoverflow.com/questions/35397943/how-to-make-a-fast-qtableview-with-html-formatted-and-clickable-cells\n    Represents tainted data with colors in the BinCATRegistersForm_t\n    \"\"\"\n    def paint(self, painter, options, index):\n        self.initStyleOption(options, index)\n        painter.save()\n        doc = QtGui.QTextDocument()\n        doc.setHtml(options.text)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATRegistersForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATRegistersForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Register values form\n    This form displays the values of tainted registers\n    \"\"\"\n    def __init__(self, state, regsinfo_model):\n        super(BinCATRegistersForm_t, self).__init__()\n        self.s = state\n        self.regsinfo_model = regsinfo_model\n        self.shown = False",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "InitConfigMemModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class InitConfigMemModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATConfigForm_t TableView memory widget.\n    Contains tainting and values for memory\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(InitConfigMemModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"region\", \"address\", \"value\"]\n        #: list of Value (addresses)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "InitConfigRegModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class InitConfigRegModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATConfigForm_t TableView register's widget.\n    Contains tainting and values for registers\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(InitConfigRegModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"register\", \"value\", \"top\", \"taint\"]\n        #: list of Value (addresses)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "RegistersInfoModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class RegistersInfoModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATRegistersForm TableView widgets.\n    Contains tainting and values for registers\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(RegistersInfoModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"register\", \"value\"]\n        self.colswidths = [90, 90]",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATOverridesForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATOverridesForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Overrides display form\n    Displays taint overrides defined by the user.\n    An override is defined by:\n    * an address\n    * a register name (memory: not supported yet)\n    * a taint value\n    \"\"\"\n    def __init__(self, state, overrides_model, nops_model, skips_model):",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "OverridesModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class OverridesModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(OverridesModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"eip\", \"addr or reg\", \"[value][!taint]\"]\n    def data(self, index, role):\n        if role not in (Qt.ForegroundRole, Qt.DisplayRole,\n                        Qt.EditRole, Qt.ToolTipRole):\n            return",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATTableView",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATTableView(QtWidgets.QTableView):\n    def __init__(self, model, parent=None):\n        super(BinCATTableView, self).__init__(parent)\n        self.m = model\n        self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)\n    def contextMenuEvent(self, event):\n        if (self.m.rowCount(None) == 0 or\n                len(self.selectedIndexes()) == 0):\n            return",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "SkipsModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class SkipsModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(SkipsModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"address or function name\", \"arg_nb\", \"ret_val\"]\n    def data(self, index, role):\n        if role not in (Qt.DisplayRole, Qt.EditRole, Qt.ToolTipRole):\n            return\n        col = index.column()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "NopsModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class NopsModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(NopsModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"address or function name\"]\n    def data(self, index, role):\n        if role not in (Qt.DisplayRole, Qt.EditRole, Qt.ToolTipRole):\n            return\n        row = index.row()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleAnalyzeHere",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleAnalyzeHere(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/ Taint from here\n    base class is not a newstyle class...\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        self.s.gui.BinCATConfigForm.launch_analysis()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleAddOverride",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleAddOverride(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Add Override\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        v = ida_kernwin.get_current_viewer()\n        thing = ida_kernwin.get_highlight(v)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleNopThisInstruction",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleNopThisInstruction(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Replace this instruction with nop\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        self.s.nops.append([\"0x%x\" % self.s.current_ea])\n        return 1",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleSkipThisFunction",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleSkipThisFunction(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Skip this function...\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        argret, res = QtWidgets.QInputDialog.getText(\n            None,",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleOptions",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleOptions(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Options\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        # display config window\n        bc_conf_form = BinCATOptionsForm_t(self.s)\n        bc_conf_form.exec_()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleRemap",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleRemap(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Options\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        # display config window\n        fname = ConfigHelpers.askfile(\"*.*\", \"Save to binary\")\n        if fname:",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleShowWindows",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleShowWindows(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Show windows\n    \"\"\"\n    def __init__(self, gui):\n        self.gui = gui\n    def activate(self, ctx):\n        self.gui.show_windows()\n        return 1\n    def update(self, ctx):",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    \"\"\"\n    Class Hooks for BinCAT menu\n    \"\"\"\n    def __init__(self, state, gui):\n        super(Hooks, self).__init__()\n        self.s = state\n        self.gui = gui\n    def ready_to_run(self):\n        self.gui.show_windows()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GUI",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class GUI(object):\n    def __init__(self, state):\n        \"\"\"\n        Instanciate BinCAT views\n        \"\"\"\n        self.s = state\n        self.regsinfo_model = RegistersInfoModel(state)\n        self.configregmodel = InitConfigRegModel(state)\n        self.configmemmodel = InitConfigMemModel(state)\n        self.BinCATRegistersForm = BinCATRegistersForm_t(state, self.regsinfo_model)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "kind": 2,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "def taint_color(n):\n    r, g, b = COLS[n % len(COLS)]\n    return b | g << 8 | r << 16\nclass EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()\n        self.configtxt.setSizePolicy(QtWidgets.QSizePolicy.Expanding,",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "bc_log = logging.getLogger('bincat.gui')\nbc_log.setLevel(logging.DEBUG)\nGREENS = [\n    (169, 241, 100),\n    (207, 207, 154),\n    (192, 195, 188),\n    (158, 199, 191),\n    (195, 238, 153),\n    (179, 179, 135),\n    (118, 155, 148),",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GREENS",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "GREENS = [\n    (169, 241, 100),\n    (207, 207, 154),\n    (192, 195, 188),\n    (158, 199, 191),\n    (195, 238, 153),\n    (179, 179, 135),\n    (118, 155, 148),\n    (195, 207, 184),\n    (241, 242, 184),",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BLUES_AND_YELLOWS",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "BLUES_AND_YELLOWS = [\n    (173, 109,   0),\n    (  2,  28,  66),\n    (173, 170,   0),\n    ( 41,   2,  67),\n    (140,  88,   0),\n    (  4,  68, 162),\n    (246, 241,   0),\n    ( 57,   2,  94),\n    (207, 130,   0),",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "COLS",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "COLS = GREENS  # BLUES_AND_YELLOWS\ndef taint_color(n):\n    r, g, b = COLS[n % len(COLS)]\n    return b | g << 8 | r << 16\nclass EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "NetnodeCorruptError",
        "kind": 6,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "class NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2\n    Conceptually, this netnode class represents is a key-value store",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "Netnode",
        "kind": 6,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "class Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2\n    Conceptually, this netnode class represents is a key-value store\n      uniquely identified by a namespace.\n    This class abstracts over some of the peculiarities of the low-level",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "BLOB_SIZE",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "BLOB_SIZE = 1024\nOUR_NETNODE = \"$ com.bincat\"\nINT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "OUR_NETNODE",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "OUR_NETNODE = \"$ com.bincat\"\nINT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "INT_KEYS_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "INT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "STR_KEYS_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "STR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "STR_TO_INT_MAP_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "STR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "INT_TO_INT_MAP_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "INT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "NpkGenException",
        "kind": 6,
        "importPath": "plugins.idabincat.npkgen",
        "description": "plugins.idabincat.npkgen",
        "peekOfCode": "class NpkGenException(Exception):\n    pass\nclass NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later\n        self.structs = set()\n        # add missing #defines",
        "detail": "plugins.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "NpkGen",
        "kind": 6,
        "importPath": "plugins.idabincat.npkgen",
        "description": "plugins.idabincat.npkgen",
        "peekOfCode": "class NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later\n        self.structs = set()\n        # add missing #defines\n        self.imports.append(\"#define __cdecl\")\n        nimps = idaapi.get_import_module_qty()",
        "detail": "plugins.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "npk_log",
        "kind": 5,
        "importPath": "plugins.idabincat.npkgen",
        "description": "plugins.idabincat.npkgen",
        "peekOfCode": "npk_log = logging.getLogger('bincat.plugin.npkgen')\nnpk_log.setLevel(logging.INFO)\nclass NpkGenException(Exception):\n    pass\nclass NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later",
        "detail": "plugins.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "kind": 6,
        "importPath": "plugins.idabincat.plugin_options",
        "description": "plugins.idabincat.plugin_options",
        "peekOfCode": "class PluginOptions(object):\n    _options = None\n    @classmethod\n    def init(cls):\n        # Configuration files path\n        idausr = ida_diskio.get_user_idadir()\n        cls.config_path = os.path.join(idausr, \"plugins\", \"idabincat\")\n        # Plugin options\n        def_options = {\n            \"save_to_idb\": \"False\",  # config only - results are always saved",
        "detail": "plugins.idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.plugin_options",
        "description": "plugins.idabincat.plugin_options",
        "peekOfCode": "bc_log = logging.getLogger('bincat.gui.pluginoptions')\nbc_log.setLevel(logging.DEBUG)\nclass PluginOptions(object):\n    _options = None\n    @classmethod\n    def init(cls):\n        # Configuration files path\n        idausr = ida_diskio.get_user_idadir()\n        cls.config_path = os.path.join(idausr, \"plugins\", \"idabincat\")\n        # Plugin options",
        "detail": "plugins.idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "plugins.pybincat.tools.parsers",
        "description": "plugins.pybincat.tools.parsers",
        "peekOfCode": "def memoize(f):\n    \"\"\" Memoization decorator for a function taking a single argument \"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n@memoize\ndef parse_val(s):\n    if s[0] not in '0123456789_?' or '_bincat_tmp' in s:",
        "detail": "plugins.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "parse_val",
        "kind": 2,
        "importPath": "plugins.pybincat.tools.parsers",
        "description": "plugins.pybincat.tools.parsers",
        "peekOfCode": "def parse_val(s):\n    if s[0] not in '0123456789_?' or '_bincat_tmp' in s:\n        # it's a register\n        return s, 0, 0\n    tbvals = dict.fromkeys([\"?\", \"_\"], 0)\n    val = None\n    bdict = {\"0x\": (16, \"f\"),\n             \"0o\": (8, \"7\"),\n             \"0b\": (2, \"1\")}\n    for p in s.split(\",\"):",
        "detail": "plugins.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "val2str",
        "kind": 2,
        "importPath": "plugins.pybincat.tools.parsers",
        "description": "plugins.pybincat.tools.parsers",
        "peekOfCode": "def val2str(val, vtop, vbot, length, base=None, merged=False):\n    if base == 16 or not base:\n        if length == 0 or length is None:\n            fstring = '{0:X}'\n        else:\n            if length % 4 == 0:\n                length = length / 4\n            else:\n                length = (length / 4)+1\n            fstring = ('{0:0>%dX}' % length)",
        "detail": "plugins.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "PyBinCATParseError",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]\n    _valcache = {}\n    arch = None",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "CFA",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]\n    _valcache = {}\n    arch = None\n    def __init__(self, addr_nodes, edges, nodes, taintsrcs):\n        #: Value (address) -> [node_id]. Nodes marked \"final\" come first.",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class Node(object):\n    \"\"\"\n    Stores node data for a given node_id.\n    1 or more Unrel may be stored, each containg regaddrs, regtypes\n    \"\"\"\n    __slots__ = ['address', 'node_id', 'final', 'statements', 'bytes',\n                 'tainted', 'taintsrc', 'unrels']\n    def __init__(self, node_id, address=None, lazy_init=None):\n        self.address = address\n        #: str",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Value",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class Value(object):\n    __slots__ = ['vtop', 'vbot', 'taint', 'ttop', 'tbot', 'length', 'value', 'region']\n    def __init__(self, region, value, length=None, vtop=0, vbot=0, taint=0,\n                 ttop=0, tbot=0):\n        self.region = region.lower()\n        self.value = value\n        if not length and region == 'reg':\n            self.length = reg_len(value)\n        else:\n            self.length = length",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Unrel",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class Unrel(object):\n    \"\"\"\n    Contains memory & registers status for a given (Node, unrel_id)\n    bincat output format examples:\n    reg [eax] = 0xfff488!0\n    111  222    33333333333\n    mem[0x1234, 0x1236] = 0x20, 0x0\n    111 2222222222222222  33333 3333 <-- list of 2 valtaint\n    mem[0x24*32] = 0b????1111!0b????0000\n    111 22222222   3333333333333333333333 <-- list of 1 valtaint",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "reg_len",
        "kind": 2,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "def reg_len(regname):\n    \"\"\"\n    Returns register length in bits. CFA.arch must have been set, either\n    manually or by parsing a bincat output file.\n    \"\"\"\n    if CFA.arch == \"armv8\":\n        return {\n            \"x0\": 64, \"x1\": 64, \"x2\": 64, \"x3\": 64, \"x4\": 64, \"x5\": 64,\n            \"x6\": 64, \"x7\": 64, \"x8\": 64, \"x9\": 64, \"x10\": 64, \"x11\": 64,\n            \"x12\": 64, \"x13\": 64, \"x14\": 64, \"x15\": 64, \"x16\": 64, \"x17\": 64,",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "PRETTY_REGIONS",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "PRETTY_REGIONS = {'': 'global', 'h': 'heap',\n                  'b': 'bottom', 't': 'top'}  # used for pointers only\n#: split src region + address (left of '=')\nRE_REGION_ADDR = re.compile(r\"(?P<region>reg|mem|h[0-9]+)\\[(?P<addr>[^]]+)\\]\")\n#: split value\nRE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_REGION_ADDR",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "RE_REGION_ADDR = re.compile(r\"(?P<region>reg|mem|h[0-9]+)\\[(?P<addr>[^]]+)\\]\")\n#: split value\nRE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_VALTAINT",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "RE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_NODE_UNREL",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "RE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "MyEmuPlugin",
        "kind": 6,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "class MyEmuPlugin(uEmuPlugin):\n    ### uEmuPlugin methods override\n    def __init__(self):\n        hooks = uEmuExtensionHooks()\n        hooks.init_context = self.hook_init_context\n        hooks.trace_log = self.hook_trace_log\n        hooks.emu_step = self.hook_emu_step\n        super(MyEmuPlugin, self).__init__(\"MyEmu\", hooks)\n    def add_custom_menu(self):\n        self.MENU_ITEMS.append(UEMU_HELPERS.MenuItem(self.plugin_name + \":myemu_test\", self.myemu_test,  \"MyEmu\",  \"MyEmu\",  None,  True  ))",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "myemu_log",
        "kind": 2,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "def myemu_log(entry):\n    uemu_log(entry, name = \"MyEmu\")\nclass MyEmuPlugin(uEmuPlugin):\n    ### uEmuPlugin methods override\n    def __init__(self):\n        hooks = uEmuExtensionHooks()\n        hooks.init_context = self.hook_init_context\n        hooks.trace_log = self.hook_trace_log\n        hooks.emu_step = self.hook_emu_step\n        super(MyEmuPlugin, self).__init__(\"MyEmu\", hooks)",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return MyEmuPlugin()\nif MYEMU_USE_AS_SCRIPT:\n    if __name__ == '__main__':\n        MyEmu = MyEmuPlugin()\n        MyEmu.init()\n        MyEmu.run()",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "MYEMU_USE_AS_SCRIPT",
        "kind": 5,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "MYEMU_USE_AS_SCRIPT = True    # Set to `False` if you want to load MyEmu automatically as IDA Plugin\ndef myemu_log(entry):\n    uemu_log(entry, name = \"MyEmu\")\nclass MyEmuPlugin(uEmuPlugin):\n    ### uEmuPlugin methods override\n    def __init__(self):\n        hooks = uEmuExtensionHooks()\n        hooks.init_context = self.hook_init_context\n        hooks.trace_log = self.hook_trace_log\n        hooks.emu_step = self.hook_emu_step",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "UEMU_CONFIG",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class UEMU_CONFIG:\n    IDAViewColor_PC     = 0x00B3CBFF\n    IDAViewColor_Reset  = 0xFFFFFFFF\n    UnicornPageSize     = 0x1000\n# === Helpers\nclass UEMU_HELPERS:\n    # Menu\n    MenuItem = collections.namedtuple(\"MenuItem\", [\"action\", \"handler\", \"title\", \"tooltip\", \"shortcut\", \"popup\"])\n    class IdaMenuActionHandler(action_handler_t):\n        def __init__(self, handler, action):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "UEMU_HELPERS",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class UEMU_HELPERS:\n    # Menu\n    MenuItem = collections.namedtuple(\"MenuItem\", [\"action\", \"handler\", \"title\", \"tooltip\", \"shortcut\", \"popup\"])\n    class IdaMenuActionHandler(action_handler_t):\n        def __init__(self, handler, action):\n            action_handler_t.__init__(self)\n            self.action_handler = handler\n            self.action_type = action\n        def activate(self, ctx):\n            if ctx.form_type == BWN_DISASM:",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuInitView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuInitView(object):\n    def __init__(self, owner):\n        super(uEmuInitView, self).__init__()\n        self.owner = owner\n# === uEmuCpuContextView\nclass uEmuCpuContextView(simplecustviewer_t):\n    def __init__(self, owner, extended):\n        super(uEmuCpuContextView, self).__init__()\n        self.hooks = None\n        self.owner = owner",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuCpuContextView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuCpuContextView(simplecustviewer_t):\n    def __init__(self, owner, extended):\n        super(uEmuCpuContextView, self).__init__()\n        self.hooks = None\n        self.owner = owner\n        self.extended = extended\n        self.lastAddress = None\n        self.lastContext = {}\n        self.lastArch = None\n        self.columns = None",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMemoryRangeDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMemoryRangeDialog(Form):\n    def __init__(self):\n        Form.__init__(self, r\"\"\"STARTITEM {id:mem_addr}\nBUTTON YES* Add\nBUTTON CANCEL Cancel\nShow Memory Range\nSpecify start address and size of new memory range.\n<##Address\\::{mem_addr}> <##Size\\::{mem_size}>\n<##Comment\\::{mem_cmnt}>\n\"\"\", {",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMemoryView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMemoryView(simplecustviewer_t):\n    def __init__(self, owner, address, size):\n        super(uEmuMemoryView, self).__init__()\n        self.owner = owner\n        self.viewid = address\n        self.address = address\n        self.size = size\n        self.lastContent = []\n    def Create(self, title):\n        if not simplecustviewer_t.Create(self, title):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuStackView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuStackView(simplecustviewer_t):\n    stack_prelines = 12\n    stack_postlines = 52\n    def __init__(self, owner):\n        super(uEmuStackView, self).__init__()\n        self.owner = owner\n        arch = UEMU_HELPERS.get_arch()\n        _, self.uc_reg_sp = UEMU_HELPERS.get_stack_register(arch)\n    def Create(self, title):\n        if not simplecustviewer_t.Create(self, title):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuControlView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuControlView(PluginForm):\n    def __init__(self, owner):\n        self.owner = owner\n        PluginForm.__init__(self)\n    def OnCreate(self, form):\n        self.parent = self.FormToPyQtWidget(form)\n        self.PopulateForm()\n    def PopulateForm(self):\n        btnStart = QPushButton(\"Start\")\n        btnRun = QPushButton(\"Run\")",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMappeduMemoryView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMappeduMemoryView(IDAAPI_Choose):\n    def __init__(self, owner, memory, flags=0, width=None, height=None, embedded=False):\n        IDAAPI_Choose.__init__(\n            self,\n            \"uEmu Mapped Memory\",\n            [ [\"Start\", 20], [\"End\", 20], [\"Permissions\", 10] ],\n            flags = flags,\n            width = width,\n            height = height,\n            embedded = embedded)",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuSettingsDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuSettingsDialog(Form):\n    def __init__(self):\n        Form.__init__(self, r\"\"\"STARTITEM {id:chk_followpc}\nBUTTON YES* Save\nBUTTON CANCEL Cancel\nuEmu Settings\n<Follow PC:{chk_followpc}>\n<Convert to Code automatically:{chk_forcecode}>\n<Trace instructions:{chk_trace}>\n<Lazy mapping:{chk_lazymapping}>{emu_group}>",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuRegisterValueDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuRegisterValueDialog(Form):\n    def __init__(self, regName):\n        Form.__init__(self, r\"\"\"STARTITEM {id:reg_val}\nBUTTON YES* Save\nBUTTON CANCEL Cancel\nRegister Value\n{reg_label}\n<##:{reg_val}>\n\"\"\", {\n        'reg_label': Form.StringLabel(\"Enter hex value for [ \" + regName + \" ]\"),",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuRegisterValueLHDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuRegisterValueLHDialog(Form):\n    def __init__(self, regName):\n        Form.__init__(self, r\"\"\"STARTITEM {id:reg_valh}\nBUTTON YES* Save\nBUTTON CANCEL Cancel\nRegister Value\n{reg_label}\n<##High\\::{reg_valh}>\n<##Low\\: :{reg_vall}>\n\"\"\", {",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMapBinaryFileDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMapBinaryFileDialog(Form):\n    def __init__(self, address):\n        Form.__init__(self, r\"\"\"STARTITEM {id:file_name}\nBUTTON YES* Map\nBUTTON CANCEL Cancel\nMap Binary File\n{form_change_cb}\n<#Select file to open#File\\::{file_name}>\n{note_label}\n<##Address\\:    :{mem_addr}>",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuContextInitDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuContextInitDialog(IDAAPI_Choose):\n    def __init__(self, regs, flags=0, width=None, height=None, embedded=False):\n        IDAAPI_Choose.__init__(\n            self,\n            \"uEmu CPU Context Edit\",\n            [ [\"Register\", 10], [\"Value\", 30] ],\n            flags = flags,\n            width = width,\n            height = height,\n            embedded = embedded)",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuUnicornEngine",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuUnicornEngine(object):\n    mu = None\n    pc = BADADDR\n    emuActive       = False\n    emuRunning      = False\n    emuThread       = None\n    kStepCount_Run  = 0\n    emuStepCount    = 1\n    fix_context     = None\n    extended        = False",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuExtensionHooks",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuExtensionHooks:\n    init_context = None\n    trace_log = None\n    emu_step = None\nclass uEmuPlugin(plugin_t, UI_Hooks):\n    popup_menu_hook = None\n    flags = PLUGIN_HIDE\n    comment = \"\"\n    help = \"Tiny cute emulator\"\n    wanted_name = \"uEmu\"",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuPlugin",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuPlugin(plugin_t, UI_Hooks):\n    popup_menu_hook = None\n    flags = PLUGIN_HIDE\n    comment = \"\"\n    help = \"Tiny cute emulator\"\n    wanted_name = \"uEmu\"\n    plugin_name = \"uEmu\"\n    wanted_hotkey = \"\"\n    ext_hooks = None\n    # --- PLUGIN DATA",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uemu_log",
        "kind": 2,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "def uemu_log(entry, name=\"uEmu\"):\n    msg(\"[\" + name + \"]: \" + entry + \"\\n\")\n# === uEmuInitView\nclass uEmuInitView(object):\n    def __init__(self, owner):\n        super(uEmuInitView, self).__init__()\n        self.owner = owner\n# === uEmuCpuContextView\nclass uEmuCpuContextView(simplecustviewer_t):\n    def __init__(self, owner, extended):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return uEmuPlugin()\nif UEMU_USE_AS_SCRIPT:\n    if __name__ == '__main__':\n        uEmu = uEmuPlugin()\n        uEmu.init()\n        uEmu.run()",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "apply_callee_type_plugin_t",
        "kind": 6,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "class apply_callee_type_plugin_t(idaapi.plugin_t):\n    flags = 0\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = \"\"\n    def init(self):\n        idaapi.msg('apply_callee_type_plugin:init\\n')\n        installMenu()\n        return idaapi.PLUGIN_OK",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "installMenuIda7",
        "kind": 2,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "def installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1\n        def update(self, ctx):\n            return idaapi.AST_ENABLE_FOR_WIDGET if ctx.widget_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_WIDGET\n    ret = idaapi.register_action(idaapi.action_desc_t(\n            ACTION_NAME,            # Name. Acts as an ID. Must be unique.\n            PLUGIN_NAME,            # Label. That's what users see.",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "installMenu",
        "kind": 2,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "def installMenu():\n    #hack -> stashing a flag under idaapi to prevent multiple menu items from appearing\n    if hasattr(sys.modules['idaapi'], '_apply_callee_type_plugin_installFlag'):\n        #print('Skipping menu install: already present')\n        return\n    if using_ida7api:\n        return installMenuIda7()\n    global ex_addmenu_item_ctx\n    ex_addmenu_item_ctx = idaapi.add_menu_item(\n        MENU_PATH, ",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    try:\n        return apply_callee_type_plugin_t()\n    except Exception as err:\n        import traceback\n        msg(\"Error: %s\\n%s\" % (str(err), traceback.format_exc()))\n        raise\ndef doApplyCallee(*args):\n    #idaapi.msg('doApplyCallee:Calling now\\n')\n    flare.apply_callee_type.main()",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "doApplyCallee",
        "kind": 2,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "def doApplyCallee(*args):\n    #idaapi.msg('doApplyCallee:Calling now\\n')\n    flare.apply_callee_type.main()",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HELP",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "PLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"ApplyCalleeType\"\nPREFERRED_SHORTCUT = \"Alt-J\"\nPLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None ",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "PLUGIN_NAME = \"ApplyCalleeType\"\nPREFERRED_SHORTCUT = \"Alt-J\"\nPLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PREFERRED_SHORTCUT",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "PREFERRED_SHORTCUT = \"Alt-J\"\nPLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_COMMENT",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "PLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "ACTION_NAME",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "ACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "MENU_PATH",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "MENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1\n        def update(self, ctx):\n            return idaapi.AST_ENABLE_FOR_WIDGET if ctx.widget_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_WIDGET\n    ret = idaapi.register_action(idaapi.action_desc_t(",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "ex_addmenu_item_ctx",
        "kind": 5,
        "importPath": "plugins.apply_callee_type_plugin",
        "description": "plugins.apply_callee_type_plugin",
        "peekOfCode": "ex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1\n        def update(self, ctx):\n            return idaapi.AST_ENABLE_FOR_WIDGET if ctx.widget_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_WIDGET\n    ret = idaapi.register_action(idaapi.action_desc_t(\n            ACTION_NAME,            # Name. Acts as an ID. Must be unique.",
        "detail": "plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "AutoLibcFlags",
        "kind": 6,
        "importPath": "plugins.autolibcflags",
        "description": "plugins.autolibcflags",
        "peekOfCode": "class AutoLibcFlags(idaapi.plugin_t):\n    comment = \"Print comment on Flags enum/explanation near libc function call\"\n    help = \"AutoLibcFlags Help\"\n    wanted_name = \"AutoLibcFlags\"\n    flags = idaapi.PLUGIN_KEEP | idaapi.PLUGIN_MOD | idaapi.PLUGIN_PROC\n    wanted_hotkey= \"Ctrl+Shift+F1\"\n    def init(self):\n        global p_initialized\n        if p_initialized is False:\n            p_initialized = True",
        "detail": "plugins.autolibcflags",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.autolibcflags",
        "description": "plugins.autolibcflags",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return AutoLibcFlags()",
        "detail": "plugins.autolibcflags",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.autolibcflags",
        "description": "plugins.autolibcflags",
        "peekOfCode": "p_initialized = False\n#--------------------------------------------------------------------------\n# Plugin\n#--------------------------------------------------------------------------\nclass AutoLibcFlags(idaapi.plugin_t):\n    comment = \"Print comment on Flags enum/explanation near libc function call\"\n    help = \"AutoLibcFlags Help\"\n    wanted_name = \"AutoLibcFlags\"\n    flags = idaapi.PLUGIN_KEEP | idaapi.PLUGIN_MOD | idaapi.PLUGIN_PROC\n    wanted_hotkey= \"Ctrl+Shift+F1\"",
        "detail": "plugins.autolibcflags",
        "documentation": {}
    },
    {
        "label": "AutoReIDPHooks",
        "kind": 6,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "class AutoReIDPHooks(idaapi.IDP_Hooks):\n    \"\"\"\n    Hooks to keep view updated if some function is updated\n    \"\"\"\n    def __init__(self, view, *args):\n        super(AutoReIDPHooks, self).__init__(*args)\n        self._view = view\n    def __on_rename(self, ea, new_name):\n        if not self._view:\n            return",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "AutoREView",
        "kind": 6,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "class AutoREView(idaapi.PluginForm):\n    ADDR_ROLE = QtCore.Qt.UserRole + 1\n    OPT_FORM_PERSIST = idaapi.PluginForm.FORM_PERSIST if hasattr(idaapi.PluginForm, 'FORM_PERSIST') else idaapi.PluginForm.WOPN_PERSIST\n    OPT_FORM_NO_CONTEXT = idaapi.PluginForm.FORM_NO_CONTEXT if hasattr(idaapi.PluginForm, 'FORM_NO_CONTEXT') else idaapi.PluginForm.WCLS_NO_CONTEXT\n    def __init__(self, data):\n        super(AutoREView, self).__init__()\n        self._data = data\n        self.tv = None\n        self._model = None\n        self._idp_hooks = None",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "auto_re_t",
        "kind": 6,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "class auto_re_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"\"\n    help = \"\"\n    wanted_name = \"Auto RE\"\n    wanted_hotkey = \"Ctrl+Shift+M\"\n    _PREFIX_NAME = 'au_re_'\n    _MIN_MAX_MATH_OPS_TO_ALLOW_RENAME = 10\n    _CALLEE_NODE_NAMES = {\n        idaapi.PLFM_MIPS: '$ mips',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "inf_is_64bit",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:\n        insn = idaapi.insn_t()\n        if idaapi.decode_insn(insn, ea) > 0:\n            return insn\n    else:",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "get_addr_width",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:\n        insn = idaapi.insn_t()\n        if idaapi.decode_insn(insn, ea) > 0:\n            return insn\n    else:\n        if idaapi.decode_insn(ea):\n            return idaapi.cmd.copy()",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "decode_insn",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:\n        insn = idaapi.insn_t()\n        if idaapi.decode_insn(insn, ea) > 0:\n            return insn\n    else:\n        if idaapi.decode_insn(ea):\n            return idaapi.cmd.copy()\ndef force_name(ea, new_name):\n    if not ea or ea == idaapi.BADADDR:",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "force_name",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def force_name(ea, new_name):\n    if not ea or ea == idaapi.BADADDR:\n        return\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idaapi.force_name(ea, new_name, idaapi.SN_NOCHECK)\n    return idaapi.do_name_anyway(ea, new_name, 0)\nclass AutoReIDPHooks(idaapi.IDP_Hooks):\n    \"\"\"\n    Hooks to keep view updated if some function is updated\n    \"\"\"",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return auto_re_t()",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "__author__ = 'Trafimchuk Aliaksandr'\n__version__ = '1.9'\nfrom collections import defaultdict\nimport idaapi\nfrom idautils import FuncItems, CodeRefsTo\nfrom idaapi import o_reg, o_imm, o_far, o_near, o_mem, o_displ\nimport os\nimport re\nimport sys\nimport traceback",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "__version__ = '1.9'\nfrom collections import defaultdict\nimport idaapi\nfrom idautils import FuncItems, CodeRefsTo\nfrom idaapi import o_reg, o_imm, o_far, o_near, o_mem, o_displ\nimport os\nimport re\nimport sys\nimport traceback\nHAS_PYSIDE = idaapi.IDA_SDK_VERSION < 690",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "HAS_PYSIDE",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "HAS_PYSIDE = idaapi.IDA_SDK_VERSION < 690\nif HAS_PYSIDE:\n    from PySide import QtGui, QtCore\n    from PySide.QtGui import QTreeView, QVBoxLayout, QLineEdit, QMenu, QInputDialog, QAction, QTabWidget\nelse:\n    from PyQt5 import QtGui, QtCore\n    from PyQt5.QtWidgets import QTreeView, QVBoxLayout, QLineEdit, QMenu, QInputDialog, QAction, QTabWidget\ntry:\n    # Python 2.\n    xrange",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG = False\n# adjust this value to be a full path to a debug egg\nRDEBUG_EGG = r'c:\\Program Files\\JetBrains\\PyCharm 2017.1.4\\debug-eggs\\pycharm-debug.egg'\nRDEBUG_HOST = 'localhost'\nRDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG_EGG",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG_EGG = r'c:\\Program Files\\JetBrains\\PyCharm 2017.1.4\\debug-eggs\\pycharm-debug.egg'\nRDEBUG_HOST = 'localhost'\nRDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG_HOST",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG_HOST = 'localhost'\nRDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG_PORT",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'\n}",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "TAGS_IGNORE_LIST",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "TAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'\n}\nTAGS = {",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "IGNORE_CALL_LIST",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "IGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'\n}\nTAGS = {\n    'net': ['WSAStartup', 'socket', 'recv', 'recvfrom', 'send', 'sendto', 'acccept', 'bind', 'listen', 'select',\n            'setsockopt', 'ioctlsocket', 'closesocket', 'WSAAccept', 'WSARecv', 'WSARecvFrom', 'WSASend', 'WSASendTo',\n            'WSASocket', 'WSAConnect', 'ConnectEx', 'TransmitFile', 'HTTPOpenRequest', 'HTTPSendRequest',\n            'URLDownloadToFile', 'InternetCrackUrl', 'InternetOpen', 'InternetOpen', 'InternetConnect',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "TAGS = {\n    'net': ['WSAStartup', 'socket', 'recv', 'recvfrom', 'send', 'sendto', 'acccept', 'bind', 'listen', 'select',\n            'setsockopt', 'ioctlsocket', 'closesocket', 'WSAAccept', 'WSARecv', 'WSARecvFrom', 'WSASend', 'WSASendTo',\n            'WSASocket', 'WSAConnect', 'ConnectEx', 'TransmitFile', 'HTTPOpenRequest', 'HTTPSendRequest',\n            'URLDownloadToFile', 'InternetCrackUrl', 'InternetOpen', 'InternetOpen', 'InternetConnect',\n            'InternetOpenUrl', 'InternetQueryOption', 'InternetSetOption', 'InternetReadFile', 'InternetWriteFile',\n            'InternetGetConnectedState', 'InternetSetStatusCallback', 'DnsQuery', 'getaddrinfo', 'GetAddrInfo',\n            'GetAdaptersInfo', 'GetAdaptersAddresses', 'HttpQueryInfo', 'ObtainUserAgentString', 'WNetGetProviderName',\n            'GetBestInterfaceEx', 'gethostbyname', 'getsockname', 'connect', 'WinHttpOpen', 'WinHttpSetTimeouts',\n            'WinHttpSendRequest', 'WinHttpConnect', 'WinHttpCrackUrl', 'WinHttpReadData', 'WinHttpOpenRequest',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "STRICT_TAG_NAME_CHECKING",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "STRICT_TAG_NAME_CHECKING = {'file'}\nblacklist = {'@__security_check_cookie@4', '__SEH_prolog4', '__SEH_epilog4'}\nreplacements = [\n    ('??3@YAXPAX@Z', 'alloc'),\n    ('?', '')\n]\ndef inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "blacklist",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "blacklist = {'@__security_check_cookie@4', '__SEH_prolog4', '__SEH_epilog4'}\nreplacements = [\n    ('??3@YAXPAX@Z', 'alloc'),\n    ('?', '')\n]\ndef inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "replacements",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "replacements = [\n    ('??3@YAXPAX@Z', 'alloc'),\n    ('?', '')\n]\ndef inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "AnalyzerUnavailable",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class AnalyzerUnavailable(Exception):\n    pass\nclass BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "BincatPlugin",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(BincatPlugin, self).__init__()",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class Analyzer(object):\n    def __init__(self, path, finish_cb):\n        self.path = path\n        self.finish_cb = finish_cb\n    def generate_tnpk(self, fname=None, destfname=None):\n        \"\"\"\n        Generates TNPK file for provided fname. If None, generate one for the\n        binary that is currently being analyzed in IDA, using IDA-provided\n        headers.\n        Returns file path to generated tnpk (string), or None if generation was",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzerTimer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class LocalAnalyzerTimer(object):\n    \"\"\"\n    IDA timer used to kill the BinCAT analyzer if the user\n    cancels the analysis\n    \"\"\"\n    def __init__(self, qprocess):\n        self.interval = 500  # ms\n        self.qprocess = qprocess\n        self.timer = idaapi.register_timer(self.interval, self)\n        if self.timer is None:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class LocalAnalyzer(Analyzer, QtCore.QProcess):\n    \"\"\"\n    Runs BinCAT locally using QProcess.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        QtCore.QProcess.__init__(self)\n        Analyzer.__init__(self, *args, **kwargs)\n        # Qprocess signal handlers\n        self.error.connect(self.procanalyzer_on_error)\n        self.stateChanged.connect(self.procanalyzer_on_state_change)",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "WebAnalyzer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class WebAnalyzer(Analyzer):\n    API_VERSION = \"1.2\"\n    def __init__(self, *args, **kwargs):\n        Analyzer.__init__(self, *args, **kwargs)\n        self.server_url = PluginOptions.get(\"server_url\").rstrip(\"/\")\n        self.reachable_server = False\n        self.check_version()  # raises exception if server is unreachable\n        self.reachable_server = True\n    def check_version(self):\n        try:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class State(object):\n    \"\"\"\n    Container for (static) plugin state related data & methods.\n    \"\"\"\n    def __init__(self):\n        self.current_ea = None\n        self.cfa = None\n        self.current_node = None\n        #: list of node ids (int)\n        self.current_node_ids = []",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "CallbackWrappedList",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class CallbackWrappedList(MutableSequence):\n    \"\"\"\n    Acts as a List object, wraps write access with calls to properly invalidate\n    models associated with View GUI objects.\n    Should store only immutable objects.\n    \"\"\"\n    def __init__(self):\n        self._data = []\n        #: list of functions to be called prior to updating list\n        self.pre_callbacks = []",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "dedup_loglines",
        "kind": 2,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "def dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:\n                return True\n        if n == 2:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return BincatPlugin()",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "bc_log = logging.getLogger('bincat.plugin')\nbc_log.setLevel(logging.INFO)\ndef dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "cto_func_lister_plugin_t",
        "kind": 6,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "class cto_func_lister_plugin_t(ida_idaapi.plugin_t):\n    flags = ida_idaapi.PLUGIN_KEEP\n    comment = \"CTO Function Lister\"\n    toolbar_displayed_name = cto_base.cto_base.orig_title\n    toolbar_name = toolbar_displayed_name + 'Toolbar'\n    wanted_name = comment\n    wanted_hotkey = \"Alt-Shift-F\"\n    help = \"Press '\" + wanted_hotkey + \"' to display the \" + comment + \" widget.\"\n    action_name = \"cto_func_lister:execute\"\n    menu_path = \"Edit/Plugins/\"",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return cto_func_lister_plugin_t()\ndef main():\n    global g_cto_func_lister\n    g_cto_func_lister = cto_func_lister.exec_cto_function_lister()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "def main():\n    global g_cto_func_lister\n    g_cto_func_lister = cto_func_lister.exec_cto_function_lister()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "dirpath",
        "kind": 5,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "dirpath = os.path.dirname(os.path.abspath(__file__))\ncto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto_func_lister\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nclass cto_func_lister_plugin_t(ida_idaapi.plugin_t):",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "cto_dir",
        "kind": 5,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "cto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto_func_lister\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nclass cto_func_lister_plugin_t(ida_idaapi.plugin_t):\n    flags = ida_idaapi.PLUGIN_KEEP",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "cto_plugin_t",
        "kind": 6,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "class cto_plugin_t(ida_idaapi.plugin_t):\n    flags = ida_idaapi.PLUGIN_KEEP\n    comment = \"Call Tree Overviewer\"\n    toolbar_displayed_name = cto_base.cto_base.orig_title\n    toolbar_name = toolbar_displayed_name + 'Toolbar'\n    wanted_name = cto.CallTreeOverviewer.orig_title\n    wanted_hotkey = \"Alt-Shift-C\"\n    help = \"Press '\" + wanted_hotkey + \"' to display the \" + wanted_name + \" widget. Then press 'H' to see the help after setting focus to the widget.\"\n    action_name = \"cto:execute\"\n    menu_path = \"Edit/Plugins/\"",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return cto_plugin_t()\ndef main():\n    global g_cto\n    g_cto = cto.exec_cto()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "def main():\n    global g_cto\n    g_cto = cto.exec_cto()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "dirpath",
        "kind": 5,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "dirpath = os.path.dirname(os.path.abspath(__file__))\ncto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nida_idaapi.require(\"get_func_relation\")",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "cto_dir",
        "kind": 5,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "cto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nida_idaapi.require(\"get_func_relation\")\nclass cto_plugin_t(ida_idaapi.plugin_t):",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "D810Plugin",
        "kind": 6,
        "importPath": "plugins.D810",
        "description": "plugins.D810",
        "peekOfCode": "class D810Plugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"D-810\"\n    wanted_hotkey = \"Ctrl-Shift-D\"\n    comment = \"Interface to the D-810 plugin\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(D810Plugin, self).__init__()",
        "detail": "plugins.D810",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.D810",
        "description": "plugins.D810",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return D810Plugin()",
        "detail": "plugins.D810",
        "documentation": {}
    },
    {
        "label": "D810_VERSION",
        "kind": 5,
        "importPath": "plugins.D810",
        "description": "plugins.D810",
        "peekOfCode": "D810_VERSION = \"0.1\"\nclass D810Plugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"D-810\"\n    wanted_hotkey = \"Ctrl-Shift-D\"\n    comment = \"Interface to the D-810 plugin\"\n    help = \"\"\n    initialized = False\n    def __init__(self):",
        "detail": "plugins.D810",
        "documentation": {}
    },
    {
        "label": "idb_hook_t",
        "kind": 6,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "class idb_hook_t(IDB_Hooks):\n    def __init__(self, hxehook):\n        self.hxehook = hxehook\n        IDB_Hooks.__init__(self)\n    def savebase(self):\n        self.hxehook._reset_all_colors()\n        return 0\n# -----------------------------------------------------------------------\nclass hxe_hook_t(Hexrays_Hooks):\n    def __init__(self):",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "hxe_hook_t",
        "kind": 6,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "class hxe_hook_t(Hexrays_Hooks):\n    def __init__(self):\n        Hexrays_Hooks.__init__(self)\n        self.idbhook = idb_hook_t(self)\n        self.idbhook.hook()\n        self.pseudocode_instances = {}\n        self.n_spaces = 40\n    def close_pseudocode(self, vd):\n        self._reset_colors(vd.view_idx, ignore_vd=True)\n        refresh_idaview_anyway()",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "Dsync",
        "kind": 6,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "class Dsync(ida_idaapi.plugin_t):\n    comment = ''\n    help = ''\n    flags = PLUGIN_MOD\n    wanted_name = 'dsync'\n    wanted_hotkey = 'Ctrl-Shift-S'\n    hxehook = None\n    def init(self):\n        required_ver = 730\n        if not is_ida_version(required_ver) or not init_hexrays_plugin():",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "is_ida_version",
        "kind": 2,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "def is_ida_version(min_ver_required):\n    return IDA_SDK_VERSION >= min_ver_required\n# -----------------------------------------------------------------------\nclass Dsync(ida_idaapi.plugin_t):\n    comment = ''\n    help = ''\n    flags = PLUGIN_MOD\n    wanted_name = 'dsync'\n    wanted_hotkey = 'Ctrl-Shift-S'\n    hxehook = None",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "def PLUGIN_ENTRY():   \n    return Dsync()",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "__author__ = 'https://github.com/patois'\nHL_COLOR = 0xAD8044\n# -----------------------------------------------------------------------\nclass idb_hook_t(IDB_Hooks):\n    def __init__(self, hxehook):\n        self.hxehook = hxehook\n        IDB_Hooks.__init__(self)\n    def savebase(self):\n        self.hxehook._reset_all_colors()\n        return 0",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "HL_COLOR",
        "kind": 5,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "HL_COLOR = 0xAD8044\n# -----------------------------------------------------------------------\nclass idb_hook_t(IDB_Hooks):\n    def __init__(self, hxehook):\n        self.hxehook = hxehook\n        IDB_Hooks.__init__(self)\n    def savebase(self):\n        self.hxehook._reset_all_colors()\n        return 0\n# -----------------------------------------------------------------------",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "YaraSearchResultChooser",
        "kind": 6,
        "importPath": "plugins.findcrypt3",
        "description": "plugins.findcrypt3",
        "peekOfCode": "class YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],\n                [\"String\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.findcrypt3",
        "documentation": {}
    },
    {
        "label": "Findcrypt_Plugin_t",
        "kind": 6,
        "importPath": "plugins.findcrypt3",
        "description": "plugins.findcrypt3",
        "peekOfCode": "class Findcrypt_Plugin_t(idaapi.plugin_t):\n    comment = \"Findcrypt plugin for IDA Pro (using yara framework)\"\n    help = \"todo\"\n    wanted_name = \"Findcrypt\"\n    wanted_hotkey = \"Ctrl-Alt-F\"\n    flags = idaapi.PLUGIN_KEEP\n    def init(self):\n        global p_initialized\n        # register popup menu handlers\n        try:",
        "detail": "plugins.findcrypt3",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.findcrypt3",
        "description": "plugins.findcrypt3",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return Findcrypt_Plugin_t()",
        "detail": "plugins.findcrypt3",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.findcrypt3",
        "description": "plugins.findcrypt3",
        "peekOfCode": "VERSION = \"0.2\"\nYARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod",
        "detail": "plugins.findcrypt3",
        "documentation": {}
    },
    {
        "label": "YARARULES_CFGFILE",
        "kind": 5,
        "importPath": "plugins.findcrypt3",
        "description": "plugins.findcrypt3",
        "peekOfCode": "YARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod\n        def get_label(self):",
        "detail": "plugins.findcrypt3",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.findcrypt3",
        "description": "plugins.findcrypt3",
        "peekOfCode": "p_initialized = False\nclass YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.findcrypt3",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.gepetto",
        "description": "plugins.gepetto",
        "peekOfCode": "def PLUGIN_ENTRY():\n    gepetto.config.load_config()  # Loads configuration data from gepetto/config.ini\n    # Only import the rest of the code after the translations have been loaded, because the _ function (gettext)\n    # needs to have been imported in the namespace first.\n    from gepetto.ida.ui import GepettoPlugin\n    return GepettoPlugin()",
        "detail": "plugins.gepetto",
        "documentation": {}
    },
    {
        "label": "HashDBError",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class HashDBError(Exception):\n    pass\n#--------------------------------------------------------------------------\n# Worker implementation\n#--------------------------------------------------------------------------\n@dataclass(unsafe_hash=True)\nclass Worker(Thread):\n    \"\"\"The worker implementation for multi-threading support.\"\"\"\n    target: Callable\n    args: tuple = field(default_factory=tuple, compare=False)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "Worker",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class Worker(Thread):\n    \"\"\"The worker implementation for multi-threading support.\"\"\"\n    target: Callable\n    args: tuple = field(default_factory=tuple, compare=False)\n    done_callback: Callable = None\n    error_callback: Callable = None\n    def __post_init__(self):\n        \"\"\"Required to initialize the base class (Thread).\"\"\"\n        super().__init__(target=self.__wrapped_target, args=self.args, daemon=True)\n    def __wrapped_target(self, *args, **kwargs):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hashdb_settings_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class hashdb_settings_t(ida_kernwin.Form):\n    \"\"\"Global settings form for hashdb\"\"\"\n    class algorithm_chooser_t(ida_kernwin.Choose):\n        \"\"\"\n        A simple chooser to be used as an embedded chooser\n        \"\"\"\n        def __init__(self, algo_list):\n            ida_kernwin.Choose.__init__(\n                self,\n                \"\",",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "match_select_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class match_select_t(ida_kernwin.Form):\n    \"\"\"Simple form to select string match during hash collision\"\"\"\n    def __init__(self, collision_strings):\n        self.__n = 0\n        F = ida_kernwin.Form\n        F.__init__(self,\nr\"\"\"BUTTON YES* Ok\nHashDB Hash Collision\n{FormChangeCb}\nMore than one string matches this hash!",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_result_form_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class hunt_result_form_t(ida_kernwin.Form):\n    class algorithm_chooser_t(ida_kernwin.Choose):\n        \"\"\"\n        A simple chooser to be used as an embedded chooser\n        \"\"\"\n        def __init__(self, algo_list):\n            ida_kernwin.Choose.__init__(\n                self,\n                \"\",\n                [",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "api_import_select_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class api_import_select_t(ida_kernwin.Form):\n    \"\"\"Simple form to select module to import apis from\"\"\"\n    def __init__(self, string_value, module_list):\n        self.__n = 0\n        F = ida_kernwin.Form\n        F.__init__(self,\nr\"\"\"BUTTON YES* Import\nBUTTON CANCEL No\nHashDB Bulk Import\n{FormChangeCb}",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "unqualified_name_replace_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class unqualified_name_replace_t(ida_kernwin.Form):\n    def __init__(self, unqualified_name: str, invalid_characters: list) -> None:\n        form = \"BUTTON YES* Replace\\n\" \\\n               \"BUTTON CANCEL Skip\\n\" \\\n               \"HashDB: Please replace the invalid characters\\n\\n\" \\\n               \"{form_change_callback}\\n\" \\\n               \"Some of the characters in the hashed string are invalid (highlighted red):\\n\" \\\n               \"{unqualified_name}\\n\" \\\n               \"<##New name\\\\: :{new_name}>\"\n        invalid_characters_html = \"<span style=\\\"font-size: 16px\\\">{}</span>\"",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HashDB_Plugin_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class HashDB_Plugin_t(idaapi.plugin_t):\n    \"\"\"\n    IDA Plugin for HashDB lookup service\n    \"\"\"\n    comment = \"HashDB Lookup Service\"\n    help = \"\"\n    wanted_name = PLUGIN_NAME\n    # We only want a hotkey for the actual hash lookup\n    wanted_hotkey = ''\n    flags = idaapi.PLUGIN_KEEP",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    def finish_populating_widget_popup(self, widget, popup):\n        \"\"\"\n        A right click menu is about to be shown. (IDA 7)\n        \"\"\"\n        inject_actions(widget, popup, idaapi.get_widget_type(widget))\n        return 0\n    def hxe_callback(self, event, *args):\n        \"\"\"\n        HexRays event callback.",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "IDACtxEntry",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class IDACtxEntry(idaapi.action_handler_t):\n    \"\"\"\n    A basic Context Menu class to utilize IDA's action handlers.\n    \"\"\"\n    def __init__(self, action_function):\n        idaapi.action_handler_t.__init__(self)\n        self.action_function = action_function\n    def activate(self, ctx):\n        \"\"\"\n        Execute the embedded action_function when this context menu is invoked.",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_enum",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_enum(enum_name: str):\n    if IDA_9:\n        return idc.get_enum(enum_name)\n    else:\n        return ida_enum.get_enum(enum_name)\ndef import_type(idx: int, enum_name: str):\n    if IDA_9:\n        return idc.import_type(idx, enum_name)\n    else:\n        return ida_typeinf.import_type(ida_typeinf.get_idati(), idx, enum_name, 0)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "import_type",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def import_type(idx: int, enum_name: str):\n    if IDA_9:\n        return idc.import_type(idx, enum_name)\n    else:\n        return ida_typeinf.import_type(ida_typeinf.get_idati(), idx, enum_name, 0)\ndef attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0):\n    if IDA_9:\n        return ida_kernwin.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)\n    else:\n        return idaapi.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "attach_action_to_popup",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0):\n    if IDA_9:\n        return ida_kernwin.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)\n    else:\n        return idaapi.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)\ndef get_enum_member_by_name(enum_value_name: str):\n    if IDA_9:\n        return idc.get_enum_member_by_name(enum_value_name)\n    else:\n        return ida_enum.get_enum_member_by_name(enum_value_name)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_enum_member_by_name",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_enum_member_by_name(enum_value_name: str):\n    if IDA_9:\n        return idc.get_enum_member_by_name(enum_value_name)\n    else:\n        return ida_enum.get_enum_member_by_name(enum_value_name)\n#--------------------------------------------------------------------------\n# Global exception hook to detect plugin exceptions until\n#  we implement a proper test-driven development setup\n# Note: minimum Python version support is 3.5 \n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hashdb_exception_hook",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hashdb_exception_hook(exception_type, value, traceback_object):\n    is_hashdb_exception = False\n    frame_data = {\n        \"user_data\": {\n            \"platform\": sys.platform,\n            \"python_version\": '.'.join([str(sys.version_info.major), str(sys.version_info.minor), str(sys.version_info.micro)]),\n            \"plugin_version\": VERSION,\n            \"ida\": {\n                \"kernel_version\": ida_kernwin.get_kernel_version(),\n                \"bits\": BITS",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_algorithms",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_algorithms(api_url='https://hashdb.openanalysis.net', timeout=None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    algorithms_url = api_url + '/hash'\n    r = requests.get(algorithms_url, timeout=timeout)\n    if not r.ok:\n        raise HashDBError(\"Get algorithms API request failed, status %s\" % r.status_code)\n    results = r.json()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_strings_from_hash",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_strings_from_hash(algorithm, hash_value, xor_value=0, api_url='https://hashdb.openanalysis.net', timeout=None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    hash_value ^= xor_value\n    hash_url = api_url + '/hash/%s/%d' % (algorithm, hash_value)\n    r = requests.get(hash_url, timeout=timeout)\n    if not r.ok:\n        raise HashDBError(\"Get hash API request failed, status %s\" % r.status_code)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_module_hashes",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_module_hashes(module_name, algorithm, permutation, api_url='https://hashdb.openanalysis.net', timeout=None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    module_url = api_url + '/module/%s/%s/%s' % (module_name, algorithm, permutation)\n    r = requests.get(module_url, timeout=timeout)\n    if not r.ok:\n        raise HashDBError(\"Get hash API request failed, status %s\" % r.status_code)\n    results = r.json()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_hash",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_hash(hash_value, api_url='https://hashdb.openanalysis.net', timeout = None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    matches = []\n    hash_list = [hash_value]\n    module_url = api_url + '/hunt'\n    r = requests.post(module_url, json={\"hashes\": hash_list}, timeout=timeout)\n    if not r.ok:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def load_settings():\n    global HASHDB_API_URL \n    global HASHDB_USE_XOR, HASHDB_XOR_VALUE \n    global HASHDB_ALGORITHM, ENUM_PREFIX\n    global NETNODE_NAME\n    node = ida_netnode.netnode(NETNODE_NAME)\n    if ida_netnode.exist(node):\n        if bool(node.hashstr(\"HASHDB_API_URL\")):\n            HASHDB_API_URL = node.hashstr(\"HASHDB_API_URL\")\n        if bool(node.hashstr(\"HASHDB_USE_XOR\")):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "save_settings",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def save_settings():\n    global HASHDB_API_URL \n    global HASHDB_USE_XOR, HASHDB_XOR_VALUE \n    global HASHDB_ALGORITHM, ENUM_PREFIX\n    global NETNODE_NAME\n    # Check if our netnode already exists, otherwise create a new one\n    node = ida_netnode.netnode(NETNODE_NAME)\n    if not ida_netnode.exist(node):\n        node = ida_netnode.netnode()\n        if not node.create(NETNODE_NAME):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_invalid_characters",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_invalid_characters(string: str) -> list:\n    invalid_characters = []\n    # Is the string empty?\n    if not string:\n        return invalid_characters\n    # Is the first character a digit?\n    if string[0].isdigit():\n        invalid_characters.append(0)\n    # Iterate through the characters in the string,\n    #  and check if they are valid using",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "html_format_invalid_characters",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def html_format_invalid_characters(string: str, invalid_characters: list, color: str = \"#F44336\") -> str:\n    # Are there any invalid characters in the string?\n    if not invalid_characters:\n        return string\n    # Format the invalid characters\n    formatted_string = \"\"\n    for index, character in enumerate(string):\n        if index in invalid_characters and color:\n            formatted_string += \"<span style=\\\"color: {}\\\">{}</span>\".format(color, character)\n        else:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_existing_enum_values",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_existing_enum_values(enum_name):\n    # Check if the enum exists\n    if get_enum(enum_name) == idaapi.BADNODE:\n        return {}\n    # Fetch the type definition\n    values = ida_typeinf.get_named_type(ida_typeinf.get_idati(), enum_name, ida_typeinf.NTF_TYPE)\n    if values is None:\n        return {}\n    _, type_str, fields_str, _, _, _, _ = values\n    type_definition = ida_typeinf.idc_print_type(type_str, fields_str, enum_name, 0)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "add_enums",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def add_enums(enum_name, hash_list):\n    \"\"\"\n    Adds a hash list to an enum by name.\n     IMPORTANT: This function should always be executed on the main thread.\n    The hash list should be a list of tuples with three values:\n     name: str, value: int, is_api: bool\n    \"\"\"\n    fixed_hash_values = get_existing_enum_values(enum_name)  # dict[str, int]\n    for enum_value_name, enum_value, is_api in hash_list:\n        # Fixup the name before appending it to the list",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "generate_enum_name",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def generate_enum_name(prefix: str) -> str:\n    \"\"\"\n    Generates an enum name from a prefix\n    \"\"\"\n    global HASHDB_ALGORITHM\n    return prefix + '_' + HASHDB_ALGORITHM\ndef make_const_enum(enum_id, hash_value):\n    # We are in the disassembler we can set the enum directly\n    ea = idc.here()\n    start = idaapi.get_item_head(ea)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "make_const_enum",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def make_const_enum(enum_id, hash_value):\n    # We are in the disassembler we can set the enum directly\n    ea = idc.here()\n    start = idaapi.get_item_head(ea)\n    # Determind if this is code or data/undefined\n    if idc.is_code(idc.get_full_flags(ea)):\n        # Find the operand position\n        if idc.get_operand_value(ea,0) == hash_value:\n            ida_bytes.op_enum(start, 0, enum_id, 0)\n            return True",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "parse_highlighted_value",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def parse_highlighted_value():\n    current_viewer = ida_kernwin.get_current_viewer()\n    is_range_selected, _, _ = ida_kernwin.read_range_selection(current_viewer)\n    if is_range_selected:\n        raise HashDBError(\"Ranged selections are not supported when parsing highlighted values. \"\n                          \"Were multiple lines selected?\")\n    highlight_result = ida_kernwin.get_highlight(current_viewer)\n    if highlight_result is None:\n        raise HashDBError(\"Invalid selection; nothing was selected.\")\n    identifier, flags = highlight_result",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "determine_highlighted_type_size",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def determine_highlighted_type_size(ea: int) -> int:\n    '''Guess the highlighted type and return the size in bytes.'''\n    type = idaapi.idc_guess_type(ea)\n    if type == '__int64':\n        return 8\n    if type == 'int':\n        return 4\n    if type == '__int16':\n        return 2\n    if type == 'char':",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "read_integer_from_db",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def read_integer_from_db(ea: int, default_size: int = 0) -> int:\n    '''\n    Read the highlighted data from the database.\n    Returns: [value, size, was_type_valid]\n    '''\n    type_size = determine_highlighted_type_size(ea)\n    # 64-bit\n    if type_size == 8 or (not type_size and default_size == 8):\n        return [ida_bytes.get_64bit(ea), 8, bool(type_size)]\n    # 32-bit",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "convert_data_to_integer",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def convert_data_to_integer(ea, size: int = 0) -> int:\n    '''\n    Converts the data into a QWORD, DWORD, WORD, or BYTE based on the size provided\n    '''\n    global HASHDB_ALGORITHM_SIZE\n    if not size:\n        size = HASHDB_ALGORITHM_SIZE // 8\n    if size == 8:\n        ida_bytes.create_qword(ea, size, True)\n    elif size == 4:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "global_settings",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def global_settings():\n    global HASHDB_API_URL\n    global HASHDB_USE_XOR\n    global HASHDB_XOR_VALUE\n    global HASHDB_ALGORITHM\n    global ENUM_PREFIX\n    if HASHDB_ALGORITHM != None:\n        algorithms = [[HASHDB_ALGORITHM, str(HASHDB_ALGORITHM_SIZE)]]\n    else:\n        algorithms = []",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "set_algorithm",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def set_algorithm(algorithm: str, size: int) -> bool:\n    global HASHDB_ALGORITHM\n    global HASHDB_ALGORITHM_SIZE\n    # Type checks to prevent accidental errors\n    if not isinstance(algorithm, str):\n        idaapi.msg(\"HashDB encountered an error while trying to set the algorithm: provided algorithm is a string type: %s\\n\", algorithm)\n        return False\n    if isinstance(size, str):\n        size = int(size)\n    if not isinstance(size, int):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "determine_algorithm_size",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def determine_algorithm_size(algorithm_type: str) -> str:\n    size = 'Unknown'\n    if algorithm_type is None:\n        return size\n    if algorithm_type == 'unsigned_int':\n        size = '32'\n    elif algorithm_type == 'unsigned_long':\n        size = '64'\n    return size\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "set_xor_key",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def set_xor_key():\n    \"\"\"\n    Set xor key from selection\n    \"\"\"\n    global HASHDB_USE_XOR\n    global HASHDB_XOR_VALUE\n    try:\n        xor_value = parse_highlighted_value()\n        ida_kernwin.msg(f\"HashDB: Set xor value to {xor_value:#x}\\n\")\n    except HashDBError as exception:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_done_handler",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_done_handler(hash_list: Union[None, list], hash_value: int = None):\n    global ENUM_PREFIX\n    def add_enums_wrapper(enum_name, hash_list):\n        nonlocal enum_id\n        enum_id = add_enums(enum_name, hash_list)\n        return 0 # execute_sync dictates an int return value\n    if hash_list is None or hash_value is None:\n        return\n    # Parse the hash list\n    hash_string = None",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_done",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_done(hash_list: Union[None, list] = None, hash_value: int = None):\n    global HASHDB_REQUEST_LOCK\n    hash_lookup_done_handler(hash_list, hash_value)\n    # Release the lock\n    HASHDB_REQUEST_LOCK.release()\ndef hash_lookup_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hash_lookup_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_error",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hash_lookup_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))\n    HASHDB_REQUEST_LOCK.release()\ndef hash_lookup_request(api_url: str, algorithm: str,\n                        hash_value: int, xor_value: Union[None, int],\n                        timeout: Union[int, float]):\n    # Perform the request",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_request",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_request(api_url: str, algorithm: str,\n                        hash_value: int, xor_value: Union[None, int],\n                        timeout: Union[int, float]):\n    # Perform the request\n    hash_results = None\n    try:\n        hash_results = get_strings_from_hash(algorithm, hash_value, xor_value if xor_value is not None else 0, api_url, timeout)\n    except requests.Timeout:\n        idaapi.msg(\"ERROR: HashDB API lookup hash request timed out.\\n\")\n        logging.exception(\"API request to {} timed out:\".format(HASHDB_API_URL))",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_run",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_run(timeout: Union[int, float] = 0) -> bool:\n    # Check if an algorithm is selected\n    global HASHDB_ALGORITHM, HASHDB_ALGORITHM_SIZE, HASHDB_API_URL, \\\n           ENUM_PREFIX, HASHDB_USE_XOR, HASHDB_XOR_VALUE\n    if HASHDB_ALGORITHM is None:\n        idaapi.warning(\"Please select a hash algorithm before using HashDB.\")\n        settings_results = hashdb_settings_t.show(api_url=HASHDB_API_URL, \n                                                  enum_prefix=ENUM_PREFIX,\n                                                  use_xor=HASHDB_USE_XOR,\n                                                  xor_value=HASHDB_XOR_VALUE)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup():\n    \"\"\"\n    Lookup a hash value from the highlighted text.\n    The function will spawn a new thread with a timeout (`HASHDB_REQUEST_TIMEOUT`).\n     While executing, the request lock is acquired.\n    \"\"\"\n    # Check if we're already running a request\n    global HASHDB_REQUEST_LOCK, HASHDB_REQUEST_TIMEOUT\n    timeout_string = \"{}\".format(HASHDB_REQUEST_TIMEOUT) + \" second{}\".format('s' if HASHDB_REQUEST_TIMEOUT != 1 else \"\")\n    if HASHDB_REQUEST_LOCK.locked():",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_done",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_done(convert_values: bool = False, hash_list: Union[None, list] = None):\n    global HASHDB_REQUEST_LOCK\n    logging.debug(\"hash_scan_done callback invoked, result: {}\".format(\"none\" if hash_list is None else \"{}\".format(hash_list)))\n    global ENUM_PREFIX\n    def add_enums_wrapper(enum_name: str, hash_list):\n        nonlocal enum_id\n        enum_id = add_enums(enum_name, hash_list)\n        return 0 # execute_sync dictates an int return value\n    # Check if the `hash_scan_request` function failed (a caught exception should return `None`)\n    if hash_list is not None:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "rate_limit_hit",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def rate_limit_hit(seconds):\n    spinner_chars = \"|/-\\\\\"\n    for _ in range(seconds):\n        for char in spinner_chars:\n            sys.stdout.write(f'\\r{char} Waiting 65 seconds to respect the HashDB API limit...')\n            sys.stdout.flush()\n            time.sleep(.25)\ndef hash_scan_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_error",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hash_scan_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))\n    HASHDB_REQUEST_LOCK.release()\ndef hash_scan_request(convert_values: bool, hash_list: list,\n                            api_url: str, algorithm: str, xor_value: int,\n                            timeout: Union[int, float]) -> Union[None, list]:\n    api_calls = 0",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_request",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_request(convert_values: bool, hash_list: list,\n                            api_url: str, algorithm: str, xor_value: int,\n                            timeout: Union[int, float]) -> Union[None, list]:\n    api_calls = 0\n    for hash_entry in hash_list:\n        if api_calls == 99:\n            print('\\n')\n            rate_limit_hit(65) # Wait 65 seconds to respect the API limit\n            print('\\n')\n            api_calls = 0",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_run",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_run(convert_values: bool, timeout: Union[int, float] = 0) -> bool:\n    # Only scan for data in the dissassembler\n    if ida_kernwin.get_viewer_place_type(ida_kernwin.get_current_viewer()) != ida_kernwin.TCCPT_IDAPLACE:\n        idaapi.msg(\"ERROR: Scan only available in dissassembler.\\n\")\n        return True # Release the lock\n    # Get the highlighted range\n    start = idc.read_selection_start()\n    end = idc.read_selection_end()\n    if idaapi.BADADDR in (start, end):\n        ea = idc.here()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan(convert_values = True):\n    \"\"\"\n    Scan for a dynamic hash table.\n    The function will spawn a new thread with a timeout (`HASHDB_REQUEST_TIMEOUT`).\n     While executing, the request lock is acquired.\n    \"\"\"\n    # Check if we're already running a request\n    global HASHDB_REQUEST_LOCK, HASHDB_REQUEST_TIMEOUT\n    timeout_string = \"{}\".format(HASHDB_REQUEST_TIMEOUT) + \" second{}\".format('s' if HASHDB_REQUEST_TIMEOUT != 1 else \"\")\n    if HASHDB_REQUEST_LOCK.locked():",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_done",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_done(response: Union[None, list] = None):\n    global HASHDB_REQUEST_LOCK\n    logging.debug(\"hunt_algorithm_done callback invoked, result: {}\".format(\"none\" if response is None else \"{}\".format(response)))\n    # Display the result\n    if response is not None:\n        logging.debug(\"Displaying hash_result_form_t.\")\n        hunt_result_form_callable = functools.partial(hunt_result_form_t.show, response)\n        ida_kernwin.execute_sync(hunt_result_form_callable, ida_kernwin.MFF_FAST)\n    else:\n        logging.debug(\"Couldn't find any algorithms that match the provided hash.\")",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_error",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hunt_algorithm_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))\n    HASHDB_REQUEST_LOCK.release()\ndef hunt_algorithm_request(hash_value: int, timeout=None) -> Union[None, list]:\n    \"\"\"\n    Perform the actual request, and provide the results to the\n     `hunt_algorithm_done` callback.",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_request",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_request(hash_value: int, timeout=None) -> Union[None, list]:\n    \"\"\"\n    Perform the actual request, and provide the results to the\n     `hunt_algorithm_done` callback.\n    This function is required to be a coroutine for seamless timeout handling.\n    \"\"\"\n    global HASHDB_REQUEST_LOCK, HASHDB_API_URL\n    # Attempt to find matches\n    match_results = None\n    try:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_run",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_run(timeout: Union[int, float] = 0) -> bool:\n    global HASHDB_REQUEST_LOCK, HASHDB_USE_XOR, HASHDB_XOR_VALUE\n    # Get the selected hash value\n    try:\n        hash_value = parse_highlighted_value()\n    except HashDBError as exception:\n        ida_kernwin.msg(f\"HashDB ERROR: {exception}\\n\")\n        logging.warning(\"Failed to parse a hash value from the highlighted text.\")\n        return True  # Release the lock\n    # Xor option",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm():\n    \"\"\"\n    Search for an algorithm using a hash value.\n    The function will spawn a new thread with a timeout (`HASHDB_REQUEST_TIMEOUT`).\n     While executing, the request lock is acquired.\n    \"\"\"\n    # Check if we're already running a request\n    global HASHDB_REQUEST_LOCK, HASHDB_REQUEST_TIMEOUT\n    timeout_string = \"{}\".format(HASHDB_REQUEST_TIMEOUT) + \" second{}\".format('s' if HASHDB_REQUEST_TIMEOUT != 1 else \"\")\n    if HASHDB_REQUEST_LOCK.locked():",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "inject_actions",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def inject_actions(form, popup, form_type):\n    \"\"\"\n    Inject actions to popup menu(s) based on context.\n    \"\"\"\n    #\n    # disassembly window\n    #\n    if (form_type == BWN_DISASM) or (form_type == BWN_PSEUDOCODE):\n        # insert the action entry into the menu\n        #",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return HashDB_Plugin_t()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "__AUTHOR__",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "__AUTHOR__ = '@herrcore'\nPLUGIN_NAME = \"HashDB\"\nPLUGIN_HOTKEY = 'Alt+`'\nVERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "PLUGIN_NAME = \"HashDB\"\nPLUGIN_HOTKEY = 'Alt+`'\nVERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------\nmajor, minor = map(int, idaapi.get_kernel_version().split(\".\"))",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HOTKEY",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "PLUGIN_HOTKEY = 'Alt+`'\nVERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------\nmajor, minor = map(int, idaapi.get_kernel_version().split(\".\"))\nassert (major > 6),\"ERROR: HashDB plugin requires IDA v7+\"",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "VERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------\nmajor, minor = map(int, idaapi.get_kernel_version().split(\".\"))\nassert (major > 6),\"ERROR: HashDB plugin requires IDA v7+\"\nassert (sys.version_info >= (3, 5)), \"ERROR: HashDB plugin requires Python 3.5\"",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "IDA_9",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "IDA_9 = major >= 9\nif IDA_9:\n    import ida_ida\nelse:\n    import ida_enum\nimport idc\nimport ida_kernwin\nimport ida_name\nimport ida_bytes\nimport ida_netnode",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_REPORT_BUG_URL",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_REPORT_BUG_URL = \"https://github.com/OALabs/hashdb-ida/issues/new\"\ndef hashdb_exception_hook(exception_type, value, traceback_object):\n    is_hashdb_exception = False\n    frame_data = {\n        \"user_data\": {\n            \"platform\": sys.platform,\n            \"python_version\": '.'.join([str(sys.version_info.major), str(sys.version_info.minor), str(sys.version_info.micro)]),\n            \"plugin_version\": VERSION,\n            \"ida\": {\n                \"kernel_version\": ida_kernwin.get_kernel_version(),",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "sys.excepthook",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "sys.excepthook = hashdb_exception_hook\n# Rest of the imports\nimport re\nimport functools\nimport requests\nfrom typing import Union\n# These imports are specific to the Worker implementation\nimport inspect\nimport logging\nimport threading",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_USE_XOR",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_USE_XOR = False\nHASHDB_XOR_VALUE = 0\nHASHDB_ALGORITHM = None\nHASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_XOR_VALUE",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_XOR_VALUE = 0\nHASHDB_ALGORITHM = None\nHASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_ALGORITHM",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_ALGORITHM = None\nHASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_ALGORITHM_SIZE",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "ENUM_PREFIX",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "ENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "NETNODE_NAME",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "NETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_REQUEST_TIMEOUT",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',\n                          b'\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00',\n                          b'\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_REQUEST_LOCK",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',\n                          b'\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00',\n                          b'\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00',\n                          b'\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x18(\\xba',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASH_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',\n                          b'\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00',\n                          b'\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00',\n                          b'\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x18(\\xba',\n                          b'\\xecz-\\x00\\x00\\x01#IDAT(\\xcfm\\xd1\\xbdJ\\x9ba\\x18\\xc6\\xf1_\\xde<\\xd5d\\x08\\xc1',\n                          b'\\xb46\\x967!\\x1d,\\x88\\xd0\\xa1P\\xe8\\x01\\x14\\x0c\\xb8\\xbbt\\xa9\\xa3\\x07\\xd0\\xb9',\n                          b'\\xab \\x1e\\x83s\\x87R\\xa4]K\\xe8\".*NEpJZL\\x9b\\xa2V\\x90\\xc6\\xa4\\xc6\\xc7%\\x92\\xa0',\n                          b'\\xfe\\xd7\\xeb\\xe6\\xe6\\xfa`\\x9c\\x8c\\x82\\x04\\xe4\\xe4\\xdd\\xc3\\xb4\\x0fV\\x95\\xf0',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASH_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASH_ICON = ida_kernwin.load_custom_icon(data=HASH_ICON_DATA, format=\"png\")\nXOR_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                         b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                         b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00',\n                         b'u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff',\n                         b'\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a',\n                         b'\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x0b\";\\xd6\\xd2\\xa1\\x00\\x00\\x00\\xc3',\n                         b'IDAT(\\xcf\\xa5\\xd01N\\x02\\x01\\x14\\x04\\xd0\\x07B01\\x9a\\x10b\\x89%\\t\\x8dg\\xa0\\xd0f-\\xb8',\n                         b'\\x80x\\x86\\x8d\\r\\xd9#X\\xee\\x05(\\x94\\x0b\\xd0\\xd0@A\\xcb\\t4\\xdb\\x98\\xd8Z\\x90\\xacv\\x82',\n                         b'Z,\\xac\\xab1P0\\xdd\\xfc\\xcc\\x9f\\xcc\\x0c\\xfb\\xa2\\xf4\\x8bU\\x9c \\xb5\\xfcOPu\\xe9F\\x0b',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "XOR_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "XOR_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                         b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                         b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00',\n                         b'u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff',\n                         b'\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a',\n                         b'\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x0b\";\\xd6\\xd2\\xa1\\x00\\x00\\x00\\xc3',\n                         b'IDAT(\\xcf\\xa5\\xd01N\\x02\\x01\\x14\\x04\\xd0\\x07B01\\x9a\\x10b\\x89%\\t\\x8dg\\xa0\\xd0f-\\xb8',\n                         b'\\x80x\\x86\\x8d\\r\\xd9#X\\xee\\x05(\\x94\\x0b\\xd0\\xd0@A\\xcb\\t4\\xdb\\x98\\xd8Z\\x90\\xacv\\x82',\n                         b'Z,\\xac\\xab1P0\\xdd\\xfc\\xcc\\x9f\\xcc\\x0c\\xfb\\xa2\\xf4\\x8bU\\x9c \\xb5\\xfcOPu\\xe9F\\x0b',\n                         b'\\x89{\\x13\\x1f\\xd9\\xf9 \\xff\\xbd\\x15\\x99;\\xf2.\\x11\\xaa\\x99\\xfb,\\x9a_y\\x12 \\x16#X3',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "XOR_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "XOR_ICON = ida_kernwin.load_custom_icon(data=XOR_ICON_DATA, format=\"png\")\nHUNT_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                          b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                          b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0',\n                          b'\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87',\n                          b'\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18',\n                          b'\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x1d\\x10#\"R\\xd1XW\\x00\\x00\\x01.IDAT(\\xcf\\x8d\\xd1;K\\x9b',\n                          b'\\x01\\x18\\xc5\\xf1\\x9fI\\xa8C\\xbd\\xf1\\x0e\\xdd\\xd2\\xc5NJ\\x07;h\\xd5\\xa1\\xf1\\x0bT\\xd4M',\n                          b'\\x14//\\x82\\xad\\x8b\\x83\\x93`\\xf1\\x02~\\x84\\x08-b\\x1c\\xea\\xe6\\xe2 \\x08^\\x9aAQ\\x07\\x87',\n                          b'R\\x9d:\\x99Atx\\x15\\xab`\\xbc\\xd0\\x0eitS\\xcf\\xf2\\xc0\\xe1\\xf0\\x1c\\xf8\\x9f\\x12\\x0f*Q!@',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HUNT_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HUNT_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                          b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                          b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0',\n                          b'\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87',\n                          b'\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18',\n                          b'\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x1d\\x10#\"R\\xd1XW\\x00\\x00\\x01.IDAT(\\xcf\\x8d\\xd1;K\\x9b',\n                          b'\\x01\\x18\\xc5\\xf1\\x9fI\\xa8C\\xbd\\xf1\\x0e\\xdd\\xd2\\xc5NJ\\x07;h\\xd5\\xa1\\xf1\\x0bT\\xd4M',\n                          b'\\x14//\\x82\\xad\\x8b\\x83\\x93`\\xf1\\x02~\\x84\\x08-b\\x1c\\xea\\xe6\\xe2 \\x08^\\x9aAQ\\x07\\x87',\n                          b'R\\x9d:\\x99Atx\\x15\\xab`\\xbc\\xd0\\x0eitS\\xcf\\xf2\\xc0\\xe1\\xf0\\x1c\\xf8\\x9f\\x12\\x0f*Q!@',\n                          b'\\xe4\\xdc\\xdf\\x07\\xb3xkuz\\xe7\\x05\\xae\\xedY\\xb0_\\x08\\x15\\x02\\t=\\x06l\\xdap\\x89\\x97Z4',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HUNT_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HUNT_ICON = ida_kernwin.load_custom_icon(data=HUNT_ICON_DATA, format=\"png\")\nSCAN_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04\\x00\\x00',\n                          b'\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00\\x00\\x00 cHRM',\n                          b'\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00',\n                          b'\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00',\n                          b'\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07',\n                          b'\\xe5\\n\\x08\\x17\\x1c\\x04\\xfd*<n\\x00\\x00\\x01#IDAT(\\xcfe\\xd1\\xb1K\\xe2\\x01\\x18\\xc6\\xf1\\x8f',\n                          b'\\xf6\\xcb\\xeb\\xd0\\x04\\xc7 \\xa8Ii\\x89\\xa2\\xed~\\x16\\xc4m\\xd6\\xbf\\xd0\\x18\\xed\\xd1m\\x07F-ECK',\n                          b'\\xa0K\\xc49_\\rACk\\x10\\xdc\\x12\\x04\\x91qR\\xd2\\xd0PS\\xd7\\xa0h\\x905\\xe8\\x85\\xd9\\xf7\\x1d\\xdfgx',\n                          b'\\xdf\\xe7K\\x9b@\\xa8\\xa8\\xa2aO\\x9f.\\x02\\x90\\xb2l\\xc9\\x80\\xb2s\\'ZzH)i\\xda\\x17\\x8a\\x8b\\x89',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "SCAN_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "SCAN_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04\\x00\\x00',\n                          b'\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00\\x00\\x00 cHRM',\n                          b'\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00',\n                          b'\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00',\n                          b'\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07',\n                          b'\\xe5\\n\\x08\\x17\\x1c\\x04\\xfd*<n\\x00\\x00\\x01#IDAT(\\xcfe\\xd1\\xb1K\\xe2\\x01\\x18\\xc6\\xf1\\x8f',\n                          b'\\xf6\\xcb\\xeb\\xd0\\x04\\xc7 \\xa8Ii\\x89\\xa2\\xed~\\x16\\xc4m\\xd6\\xbf\\xd0\\x18\\xed\\xd1m\\x07F-ECK',\n                          b'\\xa0K\\xc49_\\rACk\\x10\\xdc\\x12\\x04\\x91qR\\xd2\\xd0PS\\xd7\\xa0h\\x905\\xe8\\x85\\xd9\\xf7\\x1d\\xdfgx',\n                          b'\\xdf\\xe7K\\x9b@\\xa8\\xa8\\xa2aO\\x9f.\\x02\\x90\\xb2l\\xc9\\x80\\xb2s\\'ZzH)i\\xda\\x17\\x8a\\x8b\\x89',\n                          b'\\xf6\\xae\\xa3\\xd65m\\x88\\xcbXud\\xa57\\x12z\\xf0[\\xc2\\xbc\\xaa\\xbaK?{\\x03EO\\xa6e\\\\\\xbb\\x94',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "SCAN_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "SCAN_ICON = ida_kernwin.load_custom_icon(data=SCAN_ICON_DATA, format=\"png\")\n#--------------------------------------------------------------------------\n# Error class\n#--------------------------------------------------------------------------\nclass HashDBError(Exception):\n    pass\n#--------------------------------------------------------------------------\n# Worker implementation\n#--------------------------------------------------------------------------\n@dataclass(unsafe_hash=True)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "p_initialized = False\n# Global plugin object\nHASHDB_PLUGIN_OBJECT = None\n# Register IDA plugin\ndef PLUGIN_ENTRY():\n    return HashDB_Plugin_t()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_PLUGIN_OBJECT",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_PLUGIN_OBJECT = None\n# Register IDA plugin\ndef PLUGIN_ENTRY():\n    return HashDB_Plugin_t()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "Hyara_action_handler_t",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class Hyara_action_handler_t(idaapi.action_handler_t):\n    def __init__(self, widget):\n        idaapi.action_handler_t.__init__(self)\n        self.widget = widget\n    def activate(self, ctx):\n        self.widget.setText(hex(idaapi.get_screen_ea()))\n        return 1\n    def update(self, ctx):\n        return idaapi.AST_ENABLE_ALWAYS\nclass Hooks(ida_kernwin.UI_Hooks):",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class Hooks(ida_kernwin.UI_Hooks):\n    def __init__(self):\n        ida_kernwin.UI_Hooks.__init__(self)\n    def finish_populating_widget_popup(self, widget, popup):\n        ida_kernwin.attach_action_to_popup(widget, popup, \"Hyara:select_start_address\", None)\n        ida_kernwin.attach_action_to_popup(widget, popup, \"Hyara:select_end_address\", None)\nclass HyaraWidget(ida_kernwin.PluginForm):\n    def OnCreate(self, form):\n        self.parent = self.FormToPyQtWidget(form)\n        self.HyaraIDA = HyaraIDA()",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "HyaraWidget",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class HyaraWidget(ida_kernwin.PluginForm):\n    def OnCreate(self, form):\n        self.parent = self.FormToPyQtWidget(form)\n        self.HyaraIDA = HyaraIDA()\n        self.parent.setLayout(self.HyaraIDA.layout)\n        idaapi.register_action(\n            ida_kernwin.action_desc_t(\n                \"Hyara:select_start_address\",\n                \"Hyara - Select Start Address\",\n                Hyara_action_handler_t(self.HyaraIDA._start_address),",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "HyaraPlugin",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class HyaraPlugin(idaapi.plugin_t):\n    # https://www.hex-rays.com/products/ida/support/sdkdoc/group___p_l_u_g_i_n__.html\n    flags = idaapi.PLUGIN_UNL\n    comment = \"Hyara\"\n    help = \"help\"\n    wanted_name = \"Hyara\"\n    wanted_hotkey = \"Ctrl+Shift+Y\"\n    def init(self):\n        global hooks\n        idaapi.msg(\"[*] Hyara Plugin\\n\")",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return HyaraPlugin()",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "ActionManager",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ActionManager(object):\n    def __init__(self):\n        self.__actions = []\n    def register(self, action):\n        self.__actions.append(action)\n        idaapi.register_action(\n            idaapi.action_desc_t(action.name, action.description, action, action.hotkey)\n        )\n    def initialize(self):\n        pass",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "Action",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class Action(idaapi.action_handler_t):\n    \"\"\"\n    Convenience wrapper with name property allowing to be registered in IDA using ActionManager\n    \"\"\"\n    description = None\n    hotkey = None\n    def __init__(self):\n        super(Action, self).__init__()\n    @property\n    def name(self):",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "Configuration",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class Configuration:\n    def __init__(self) -> None:\n        self.frida_cmd = \"\"\"frida -U --attach-name=\"com.example.app\" -l gen.js --no-pause\"\"\"\n        self.template = default_template\n        if os.path.exists(\"IDAFrida.json\"):\n            self.load()\n    def set_frida_cmd(self, s):\n        self.frida_cmd = s\n        self.store()\n    def set_template(self, s):",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "ConfigurationUI",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ConfigurationUI(QDialog):\n    def __init__(self, conf: Configuration) -> None:\n        super(ConfigurationUI, self).__init__()\n        self.conf = conf\n        self.edit_template = QTextEdit()\n        self.edit_template.setPlainText(self.conf.template)\n        layout = QHBoxLayout()\n        layout.addWidget(self.edit_template)\n        self.setLayout(layout)\n    def closeEvent(self, a0) -> None:",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "ScriptGenerator",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ScriptGenerator:\n    def __init__(self, configuration: Configuration) -> None:\n        self.conf = configuration\n        self.imagebase = idaapi.get_imagebase()\n    @staticmethod\n    def get_idb_filename():\n        return os.path.basename(idaapi.get_input_file_path())\n    @staticmethod\n    def get_idb_path():\n        return os.path.dirname(idaapi.get_input_file_path())",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "Frida",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class Frida:\n    def __init__(self, conf: Configuration) -> None:\n        self.conf = conf\nclass IDAFridaMenuAction(Action):\n    TopDescription = \"IDAFrida\"\n    def __init__(self):\n        super(IDAFridaMenuAction, self).__init__()\n    def activate(self, ctx) -> None:\n        raise NotImplemented\n    def update(self, ctx) -> None:",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "IDAFridaMenuAction",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class IDAFridaMenuAction(Action):\n    TopDescription = \"IDAFrida\"\n    def __init__(self):\n        super(IDAFridaMenuAction, self).__init__()\n    def activate(self, ctx) -> None:\n        raise NotImplemented\n    def update(self, ctx) -> None:\n        if ctx.widget_type == idaapi.BWN_FUNCS or ctx.widget_type==idaapi.BWN_PSEUDOCODE or ctx.widget_type==idaapi.BWN_DISASM:\n            idaapi.attach_action_to_popup(ctx.widget, None, self.name, self.TopDescription + \"/\")\n            return idaapi.AST_ENABLE_FOR_WIDGET",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "GenerateFridaHookScript",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class GenerateFridaHookScript(IDAFridaMenuAction):\n    description = \"Generate Frida Script\"\n    def __init__(self):\n        super(GenerateFridaHookScript, self).__init__()\n    def activate(self, ctx):\n        gen = ScriptGenerator(global_config)\n        idb_path = os.path.dirname(idaapi.get_input_file_path())\n        out_file = os.path.join(idb_path, \"IDAhook.js\")\n        if ctx.widget_type==idaapi.BWN_FUNCS:\n            selected = [idaapi.getn_func(idx).start_ea for idx in ctx.chooser_selection] #from \"idaapi.getn_func(idx - 1)\" to \"idaapi.getn_func(idx)\"",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "RunGeneratedScript",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class RunGeneratedScript(IDAFridaMenuAction):\n    description = \"Run Generated Script\"\n    def __init__(self):\n        super(RunGeneratedScript, self).__init__()\n    def activate(self, ctx):\n        print(\"template\")\nclass ViewFridaTemplate(IDAFridaMenuAction):\n    description = \"View Frida Template\"\n    def __init__(self):\n        super(ViewFridaTemplate, self).__init__()",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "ViewFridaTemplate",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ViewFridaTemplate(IDAFridaMenuAction):\n    description = \"View Frida Template\"\n    def __init__(self):\n        super(ViewFridaTemplate, self).__init__()\n    def activate(self, ctx):\n        ui = ConfigurationUI(global_config)\n        ui.show()\n        ui.exec_()\nclass SetFridaRunCommand(IDAFridaMenuAction):\n    description = \"Set Frida Command\"",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "SetFridaRunCommand",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class SetFridaRunCommand(IDAFridaMenuAction):\n    description = \"Set Frida Command\"\n    def __init__(self):\n        super(SetFridaRunCommand, self).__init__()\n    def activate(self, ctx):\n        print(\"template\")\naction_manager.register(GenerateFridaHookScript())\n# action_manager.register(RunGeneratedScript())\naction_manager.register(ViewFridaTemplate())\n# action_manager.register(SetFridaRunCommand())",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "action_manager",
        "kind": 5,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "action_manager = ActionManager()\nclass Action(idaapi.action_handler_t):\n    \"\"\"\n    Convenience wrapper with name property allowing to be registered in IDA using ActionManager\n    \"\"\"\n    description = None\n    hotkey = None\n    def __init__(self):\n        super(Action, self).__init__()\n    @property",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "default_template",
        "kind": 5,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "default_template = \"\"\"\nconst MODULE_NAME=\"[filename]\";\nlet isFoudModule = false;\nlet isHooked = false;\n // @ts-ignore\nfunction print_arg(addr) {\n    try {\n        var module = Process.findRangeByAddress(addr);\n        if (module != null) return \"\\\\n\"+hexdump(addr) + \"\\\\n\";\n        return ptr(addr) + \"\\\\n\";",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "global_config",
        "kind": 5,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "global_config = Configuration()\nclass ConfigurationUI(QDialog):\n    def __init__(self, conf: Configuration) -> None:\n        super(ConfigurationUI, self).__init__()\n        self.conf = conf\n        self.edit_template = QTextEdit()\n        self.edit_template.setPlainText(self.conf.template)\n        layout = QHBoxLayout()\n        layout.addWidget(self.edit_template)\n        self.setLayout(layout)",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "CBaseTreeViewer",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CBaseTreeViewer(PluginForm):\n  def populate_tree(self, d):\n    # Clear previous items\n    self.tree.clear()\n    # Build the tree\n    for key in d:\n      src_file_item = QtWidgets.QTreeWidgetItem(self.tree)\n      src_file_item.setText(0, key)\n      src_file_item.ea = BADADDR\n      for ea, name, str_data in d[key]:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "command_handler_t",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class command_handler_t(ida_kernwin.action_handler_t):\n  def __init__(self, obj, cmd_id, num_args = 1):\n    self.obj = obj\n    self.cmd_id = cmd_id\n    self.num_args = num_args\n    ida_kernwin.action_handler_t.__init__(self)\n  def activate(self, ctx):\n    if self.num_args == 1:\n      return self.obj.OnCommand(self.cmd_id)\n    return self.obj.OnCommand(self.obj, self.cmd_id)",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CIDAMagicStringsChooser",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CIDAMagicStringsChooser(Choose):\n  def __init__(self, title, columns, options):\n    Choose.__init__(self, title, columns, options)\n    self.actions = []\n  def AddCommand(self, menu_name, shortcut=None):\n    action_name = \"IDAMagicStrings:%s\" % menu_name.replace(\" \", \"\")\n    self.actions.append([len(self.actions), action_name, menu_name, shortcut])\n    return len(self.actions)-1\n  def OnPopup(self, form, popup_handle):\n    for num, action_name, menu_name, shortcut in self.actions:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CSourceFilesChooser",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CSourceFilesChooser(CIDAMagicStringsChooser):\n  def __init__(self, title):\n    columns = [ [\"Line\", 4], [\"Full path\", 20], [\"Filename\", 15], [\"EA\", 16], [\"Function Name\", 18], [\"String data\", 40], ]\n    CIDAMagicStringsChooser.__init__(self, title, columns, Choose.CH_MULTI)\n    self.n = 0\n    self.icon = -1\n    self.selcount = 0\n    self.modal = False\n    self.items = []\n    self.selected_items = []",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CCandidateFunctionNames",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CCandidateFunctionNames(CIDAMagicStringsChooser):\n  def __init__(self, title, final_list):\n    columns = [ [\"Line\", 4], [\"EA\", 16], [\"Function Name\", 25], [\"Candidate\", 25], [\"FP?\", 2], [\"Strings\", 50], ]\n    CIDAMagicStringsChooser.__init__(self, title, columns, Choose.CH_MULTI)\n    self.n = 0\n    self.icon = -1\n    self.selcount = 0\n    self.modal = False\n    self.items = []\n    self.selected_items = []",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CClassXRefsChooser",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CClassXRefsChooser(idaapi.Choose):\n  def __init__(self, title, items):\n    idaapi.Choose.__init__(self, title, [ [\"Address\", 8], [\"String\", 80] ])\n    self.items = items\n  def OnGetLine(self, n):\n    return self.items[n]\n  def OnGetSize(self):\n    return len(self.items)\n#-------------------------------------------------------------------------------\ndef get_string(ea):",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CClassesTreeViewer",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CClassesTreeViewer(PluginForm):\n  def populate_tree(self):\n    # Clear previous items\n    self.tree.clear()\n    self.nodes = {}\n    self.classes = sorted(self.classes, key=lambda x: x[1][0])\n    for ea, tokens in self.classes:\n      for i, node_name in enumerate(tokens):\n        full_name = \"::\".join(tokens[:tokens.index(node_name)+1])\n        if full_name not in self.nodes:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CClassesGraph",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CClassesGraph(idaapi.GraphViewer):\n  def __init__(self, title, classes, final_list):\n    idaapi.GraphViewer.__init__(self, title)\n    self.selected = None\n    self.classes = classes\n    self.final_list = final_list\n    self.nodes = {}\n    self.nodes_ea = {}\n    self.graph = {}\n    self.last_cmd = 0",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CFakeString",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CFakeString:\n  def __init__(self, ea, s):\n    self.ea = ea\n    self.s = s\n  def __str__(self):\n    return str(self.s)\n  def __repr__(self):\n    return self.__str__()\n#-------------------------------------------------------------------------------\ndef find_function_names(strings_list):",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "magicstrings",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class magicstrings(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"IDA Magic Strings plugin\"\n    help = \"This is magicstrings help\"\n    wanted_name = \"Magic Strings\"\n    wanted_hotkey = \"\"\n    def init(self):\n        return idaapi.PLUGIN_OK\n    def run(self, arg):\n        main()",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "nltk_preprocess",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def nltk_preprocess(strings):\n  if not has_nltk:\n    return\n  strings = \"\\n\".join(map(str, list(strings)))\n  tokens = re.findall(FUNCTION_NAMES_REGEXP, strings)\n  l = []\n  for token in tokens:\n    l.append(token[0])\n  word_tags = nltk.pos_tag(l)\n  for word, tag in word_tags:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_strings",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_strings(strtypes = [0, 1]):\n  strings = Strings()\n  strings.setup(strtypes = strtypes)\n  return strings\n#-------------------------------------------------------------------------------\ndef get_lang(full_path):\n  _, file_ext  = os.path.splitext(full_path.lower())\n  file_ext = file_ext.strip(\".\")\n  for key in LANGS:\n    if file_ext in LANGS[key]:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_lang",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_lang(full_path):\n  _, file_ext  = os.path.splitext(full_path.lower())\n  file_ext = file_ext.strip(\".\")\n  for key in LANGS:\n    if file_ext in LANGS[key]:\n      return key\n  return None\n#-------------------------------------------------------------------------------\ndef add_source_file_to(d, src_langs, refs, full_path, s):\n  if full_path not in d:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "add_source_file_to",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def add_source_file_to(d, src_langs, refs, full_path, s):\n  if full_path not in d:\n    d[full_path] = []\n  lang = get_lang(full_path)\n  if lang is not None:\n    src_langs[lang] += 1\n  for ref in refs:\n    d[full_path].append([ref, get_func_name(ref), str(s)])\n  return d, src_langs\n#-------------------------------------------------------------------------------",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_source_strings",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_source_strings(min_len = 4, strtypes = [0, 1]):\n  strings = get_strings(strtypes)\n  # Search string references to source files\n  src_langs = Counter()\n  total_files = 0\n  d = {}\n  for s in strings:\n    if s and s.length > min_len:\n      ret = re.findall(SOURCE_FILES_REGEXP, str(s), re.IGNORECASE)\n      if ret and len(ret) > 0:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def handler(item, column_no):\n  ea = item.ea\n  if is_mapped(ea):\n    jumpto(ea)\n#-------------------------------------------------------------------------------\nclass CBaseTreeViewer(PluginForm):\n  def populate_tree(self, d):\n    # Clear previous items\n    self.tree.clear()\n    # Build the tree",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "basename",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def basename(path):\n  pos1 = path[::-1].find(\"\\\\\")\n  pos2 = path[::-1].find(\"/\")\n  if pos1 == -1: pos1 = len(path)\n  if pos2 == -1: pos2 = len(path)\n  pos = min(pos1, pos2)\n  return path[len(path)-pos:]\n#-------------------------------------------------------------------------------\nclass command_handler_t(ida_kernwin.action_handler_t):\n  def __init__(self, obj, cmd_id, num_args = 1):",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_string",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_string(ea):\n  tmp = idc.get_strlit_contents(ea, strtype=0)\n  if tmp is None or len(tmp) == 1:\n    unicode_tmp = idc.get_strlit_contents(ea, strtype=1)\n    if unicode_tmp is not None and len(unicode_tmp) > len(tmp):\n      tmp = unicode_tmp\n  if tmp is None:\n    tmp = \"\"\n  elif type(tmp) != str:\n    tmp = tmp.decode(\"utf-8\")",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "classes_handler",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def classes_handler(item, column_no):\n  if item.childCount() == 0:\n    ea = item.ea\n    if is_mapped(ea):\n      jumpto(ea)\n#-------------------------------------------------------------------------------\nclass CClassesTreeViewer(PluginForm):\n  def populate_tree(self):\n    # Clear previous items\n    self.tree.clear()",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "show_tree",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def show_tree(d = None):\n  tree_frm = CBaseTreeViewer()\n  tree_frm.Show(PROGRAM_NAME + \": Source code tree\", d)\n#-------------------------------------------------------------------------------\ndef seems_function_name(candidate):\n  if len(candidate) >= 6 and candidate.lower() not in NOT_FUNCTION_NAMES:\n    if candidate.upper() != candidate:\n      return True\n  return False\n#-------------------------------------------------------------------------------",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "seems_function_name",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def seems_function_name(candidate):\n  if len(candidate) >= 6 and candidate.lower() not in NOT_FUNCTION_NAMES:\n    if candidate.upper() != candidate:\n      return True\n  return False\n#-------------------------------------------------------------------------------\nclass CFakeString:\n  def __init__(self, ea, s):\n    self.ea = ea\n    self.s = s",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "find_function_names",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def find_function_names(strings_list):\n  rarity = {}\n  func_names = {}\n  raw_func_strings = {}\n  class_objects = []\n  class_tmp_names = []\n  for ea, name in Names():\n    func = idaapi.get_func(ea)\n    if func is None:\n      continue",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "show_function_names",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def show_function_names(strings_list):\n  found_func_names = find_function_names(strings_list)\n  func_names, raw_func_strings, rarity, classes = found_func_names\n  final_list = []\n  for key in func_names:\n    candidates = set()\n    for candidate in func_names[key]:\n      if len(rarity[candidate]) == 1:\n        candidates.add(candidate)\n    if len(candidates) == 1:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return magicstrings()\ndef main():\n  ch = CSourceFilesChooser(PROGRAM_NAME + \": Source code files\")\n  if len(ch.items) > 0:\n    ch.show()\n  d = ch.d\n  if len(d) > 0:\n    show_tree(d)\n  show_function_names(ch.s)",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def main():\n  ch = CSourceFilesChooser(PROGRAM_NAME + \": Source code files\")\n  if len(ch.items) > 0:\n    ch.show()\n  d = ch.d\n  if len(d) > 0:\n    show_tree(d)\n  show_function_names(ch.s)\nif __name__ == \"__main__\":\n  main()",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "PROGRAM_NAME",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "PROGRAM_NAME = \"IMS\"\n#-------------------------------------------------------------------------------\nSOURCE_FILES_REGEXP = r\"([a-z_\\/\\\\][a-z0-9_/\\\\:\\-\\.@]+\\.(c|cc|cxx|c\\+\\+|cpp|h|hpp|m|rs|go|ml))($|:| )\"\nLANGS = {}\nLANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "SOURCE_FILES_REGEXP",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "SOURCE_FILES_REGEXP = r\"([a-z_\\/\\\\][a-z0-9_/\\\\:\\-\\.@]+\\.(c|cc|cxx|c\\+\\+|cpp|h|hpp|m|rs|go|ml))($|:| )\"\nLANGS = {}\nLANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS = {}\nLANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"C/C++\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"C\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"C++\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"Obj-C\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"Rust\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"Golang\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"OCaml\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",\n  \"return\", \"libs\", \"home\", \"ambiguous\", \"internal\", \"request\", \"inserting\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "FUNCTION_NAMES_REGEXP",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "FUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",\n  \"return\", \"libs\", \"home\", \"ambiguous\", \"internal\", \"request\", \"inserting\",\n  \"deleting\", \"removing\", \"updating\", \"adding\", \"assertion\", \"flags\",\n  \"overflow\", \"enabled\", \"disabled\", \"enable\", \"disable\", \"virtual\", \"client\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "NOT_FUNCTION_NAMES",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "NOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",\n  \"return\", \"libs\", \"home\", \"ambiguous\", \"internal\", \"request\", \"inserting\",\n  \"deleting\", \"removing\", \"updating\", \"adding\", \"assertion\", \"flags\",\n  \"overflow\", \"enabled\", \"disabled\", \"enable\", \"disable\", \"virtual\", \"client\",\n  \"server\", \"switch\", \"while\", \"offset\", \"abort\", \"panic\", \"static\", \"updated\",\n  \"pointer\", \"reason\", \"month\", \"year\", \"week\", \"hour\", \"minute\", \"second\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "FOUND_TOKENS",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "FOUND_TOKENS = {}\nTOKEN_TYPES = [\"NN\", \"NNS\", \"NNP\", \"JJ\", \"VB\", \"VBD\", \"VBG\", \"VBN\", \"VBP\", \"VBZ\"]\ndef nltk_preprocess(strings):\n  if not has_nltk:\n    return\n  strings = \"\\n\".join(map(str, list(strings)))\n  tokens = re.findall(FUNCTION_NAMES_REGEXP, strings)\n  l = []\n  for token in tokens:\n    l.append(token[0])",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "TOKEN_TYPES",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "TOKEN_TYPES = [\"NN\", \"NNS\", \"NNP\", \"JJ\", \"VB\", \"VBD\", \"VBG\", \"VBN\", \"VBP\", \"VBZ\"]\ndef nltk_preprocess(strings):\n  if not has_nltk:\n    return\n  strings = \"\\n\".join(map(str, list(strings)))\n  tokens = re.findall(FUNCTION_NAMES_REGEXP, strings)\n  l = []\n  for token in tokens:\n    l.append(token[0])\n  word_tags = nltk.pos_tag(l)",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "FunctionDecompilerHandler",
        "kind": 6,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "class FunctionDecompilerHandler(ida_kernwin.action_handler_t):\n    model = ''\n    selection = False\n    def __init__(self,model,selection=False):\n        self.model = model\n        self.selection = selection\n        logging.debug(f'aiDAPal: {model} {selection}')\n        ida_kernwin.action_handler_t.__init__(self)\n    # This method is called when the menu item is clicked\n    def activate(self, ctx):",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "DataAnalysisHandler",
        "kind": 6,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "class DataAnalysisHandler(ida_kernwin.action_handler_t):\n    model = ''\n    selection = False\n    def __init__(self,model,selection=False):\n        self.model = model\n        self.selection = selection\n        logging.debug(f'aiDAPal: data analysis {model} {selection}')\n        ida_kernwin.action_handler_t.__init__(self)\n    # This method is called when the menu item is clicked\n    def activate(self, ctx):",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "MyHooks",
        "kind": 6,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "class MyHooks(ida_kernwin.UI_Hooks):\n    def finish_populating_widget_popup(self, widget, popup_handle):\n        # Check if the widget is the disassembly view\n        if ida_kernwin.get_widget_type(widget) == ida_kernwin.BWN_PSEUDOCODE:\n            for action in code_actions:\n                model_name = action.split('_')[0]\n                ida_kernwin.attach_action_to_popup(widget, popup_handle, action, f'aiDAPal/{model_name}/')\n        # Check if the widget is the disassembly view\n        if ida_kernwin.get_widget_type(widget) == ida_kernwin.BWN_DISASM:\n            for action in data_actions:",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "aidapal_add_context",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")\ndef aidapal_get_context():\n    '''\n    print the current manual context\n    '''\n    outstr = ''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "aidapal_get_context",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def aidapal_get_context():\n    '''\n    print the current manual context\n    '''\n    outstr = ''\n    for x in aidapal_manual_juice:\n        outstr += f'{x}\\n'\n    return outstr\ndef do_analysis(code,model_name):\n    url = ollama_url",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "do_analysis",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def do_analysis(code,model_name):\n    url = ollama_url\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\" : f\"Bearer {api_token}\"\n    }\n    payload = {\"model\": model_name, \"prompt\": code, \"stream\": False,\"format\":\"json\"}\n    res = requests.post(url, headers=headers, json=payload)\n    try:\n        t = res.json()['response']",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "do_show_ui",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def do_show_ui(result,cur_func,data_address):\n    aiDAPalUI(result,cur_func,data_address)\n    return False\n# examples/core/dump_selection.py\ndef get_hexrays_selection():\n    '''\n    get highlighted text from the hexrays view\n    return None if no selection\n    '''\n    # dump current selection",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_hexrays_selection",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_hexrays_selection():\n    '''\n    get highlighted text from the hexrays view\n    return None if no selection\n    '''\n    # dump current selection\n    p0 = ida_kernwin.twinpos_t()\n    p1 = ida_kernwin.twinpos_t()\n    view = ida_kernwin.get_current_viewer()\n    logging.debug(f'aiDAPal: getting hexrays selection')",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_widget_lines",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_widget_lines(widget, tp0, tp1):\n    \"\"\"\n    get lines between places tp0 and tp1 in widget\n    \"\"\"\n    ud = ida_kernwin.get_viewer_user_data(widget)\n    lnar = ida_kernwin.linearray_t(ud)\n    lnar.set_place(tp0.at)\n    lines = []\n    while True:\n        cur_place = lnar.get_place()",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "async_call",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def async_call(cur_func,model_name,extra_context=None,selected_code=None,data_address=None):\n    # if we have a selection, get the selection, otherwise use the whole function\n    logging.debug(f'aiDAPal: async call {model_name}')\n    if selected_code:\n        logging.debug('aiDAPal: selection')\n        code = selected_code\n    else:\n        code = str(cur_func)\n    logging.debug(f'aiDAPal: {code}')\n    if extra_context:",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_data_references_query",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_data_references_query(target_data_ea):\n    results = []\n    query = ''\n    target_data_name = ida_name.get_name(target_data_ea)\n    # Ensure the decompiler is available\n    if not ida_hexrays.init_hexrays_plugin():\n        logging.error(f'aiDAPal: Hex-Rays decompiler is not available.')\n        return results\n    target_xrefs = []\n    xrefs = idautils.XrefsTo(target_data_ea)",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_function_data_ref_comments",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_function_data_ref_comments(current_func_ea):\n    '''\n    extracts string that is a c style comment block of comments for any data refs that\n    have a comment\n    '''\n    if current_func_ea is not None:\n        # Get references from the current function - returns a set of them\n        #references = get_references_from_function(current_func_ea)\n        logging.info(f'aiDAPal: gathering data references for {hex(current_func_ea)}')\n        references = context_juicer.gather_unique_data_references(current_func_ea)",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "unload_plugin",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def unload_plugin():\n    for model in models:\n        ida_kernwin.unregister_action(model)\n    print(\"aiDAPal unloaded\")\n    global hooks\n    if  hooks is not None:\n        hooks.unhook()\n        hooks = None",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "models = ['aidapal:latest']\n# where ollama service is running\nollama_url = \"\"\napi_token = \"\"\n# most important part - zlib compressed ascii art\nload_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "ollama_url",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "ollama_url = \"\"\napi_token = \"\"\n# most important part - zlib compressed ascii art\nload_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "api_token",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "api_token = \"\"\n# most important part - zlib compressed ascii art\nload_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "load_logo",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "load_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")\ndef aidapal_get_context():\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "aidapal_manual_juice",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "aidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")\ndef aidapal_get_context():\n    '''\n    print the current manual context\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "code_actions",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "code_actions = []\ndata_actions = []\nfor model in models:\n    # Register the full function analysis actions\n    action_id = f'{model}_ff'\n    code_actions.append(action_id)\n    action_desc = ida_kernwin.action_desc_t(\n        action_id,   # The unique name of the action\n        f'Full Function', # The label of the menu item\n        FunctionDecompilerHandler(model),    # The action handler class",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "data_actions",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "data_actions = []\nfor model in models:\n    # Register the full function analysis actions\n    action_id = f'{model}_ff'\n    code_actions.append(action_id)\n    action_desc = ida_kernwin.action_desc_t(\n        action_id,   # The unique name of the action\n        f'Full Function', # The label of the menu item\n        FunctionDecompilerHandler(model),    # The action handler class\n        None,                 # Optional shortcut key",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "hooks",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "hooks = MyHooks()\nhooks.hook()\ndef unload_plugin():\n    for model in models:\n        ida_kernwin.unregister_action(model)\n    print(\"aiDAPal unloaded\")\n    global hooks\n    if  hooks is not None:\n        hooks.unhook()\n        hooks = None",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "FunctionNameWidget",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class FunctionNameWidget(QWidget):\n    accepted = True\n    def __init__(self, function_name):\n        super(FunctionNameWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Function Name\")\n        group_layout = QtWidgets.QHBoxLayout()\n        group_layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_layout.setSpacing(10)",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "CommentWidget",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class CommentWidget(QWidget):\n    accepted = True\n    def __init__(self, comment):\n        super(CommentWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Comment\")\n        group_layout = QtWidgets.QHBoxLayout()\n        group_layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_layout.setSpacing(10)",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "VariableWidget",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class VariableWidget(QWidget):\n    accepted = True\n    def __init__(self, variables):\n        super(VariableWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n        # Create the group box for the variables\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Variables\")\n        group_box_layout = QtWidgets.QVBoxLayout()  # Layout to hold the title and the scroll area\n        # Create the inner grid layout",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "aiDAPalUIForm",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class aiDAPalUIForm(ida_kernwin.PluginForm):\n    ida_pal_results = None\n    current_func = None\n    current_data = None\n    def __init__(self,ida_pal_results,current_func,current_data):\n        super(aiDAPalUIForm, self).__init__()\n        self.ida_pal_results = ida_pal_results\n        self.current_func = current_func\n        self.current_data = current_data\n    def OnCreate(self, form):",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "aiDAPalUI",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class aiDAPalUI:\n    def __init__(self, ida_pal_results=None,cur_func=None,cur_data=None):\n        if ida_pal_results is None:\n            self.ida_pal_results = example_input\n        else:\n            self.ida_pal_results = ida_pal_results\n        self.plg = aiDAPalUIForm(self.ida_pal_results,cur_func,cur_data)\n        self.plg.Show(\"aiDAPal Results\")",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "example_input",
        "kind": 5,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "example_input = {'function_name': 'ExampleName', 'comment': \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque orci odio, feugiat nec nisi vel, tempus laoreet nunc. Aliquam libero felis, lacinia non imperdiet sit amet, volutpat vitae odio. Phasellus in ligula sit amet nibh posuere malesuada vel sit amet dui. Donec gravida nec elit vitae mollis. Donec sollicitudin, mauris pellentesque tempus sodales, velit orci tempor sapien, at rutrum urna tellus vel mauris. Donec ac rhoncus nisi, vel consequat libero. In dictum neque ligula, sit amet ultricies eros facilisis eu. Donec justo leo, suscipit quis ligula ut, blandit venenatis neque. Duis euismod viverra tellus, quis dapibus purus facilisis condimentum. Donec massa augue, vestibulum nec ipsum vulputate, feugiat volutpat mi. Sed nec nisl ex. Aliquam dapibus ligula ac orci hendrerit, id sodales leo tempus. Aenean vehicula metus vel pellentesque suscipit. Etiam vel dictum massa. Proin vitae varius sapien. Maecenas accumsan nulla rhoncus ipsum consequat, eget commodo sem finibus. Sed sed metus urna. Praesent vel nulla sed nunc feugiat fermentum a a tortor. Etiam auctor sit amet ligula eu tristique. Suspendisse sollicitudin, sem ut tincidunt volutpat, ipsum risus cursus nisl, non aliquet arcu ipsum eget massa. Fusce venenatis, leo eleifend luctus ultrices, quam odio fringilla augue, vitae tempus purus massa eu nulla. Cras a ullamcorper ligula.\", 'variables': [{'original_name': 'a1', 'new_name': 'example1'}, {'original_name': 'a2', 'new_name': 'example2'}, {'original_name': 'a3', 'new_name': 'example3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}]}\nclass FunctionNameWidget(QWidget):\n    accepted = True\n    def __init__(self, function_name):\n        super(FunctionNameWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Function Name\")\n        group_layout = QtWidgets.QHBoxLayout()\n        group_layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "Keypatch_Asm",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Keypatch_Asm:\n    # supported architectures\n    arch_lists = {\n        \"X86 16-bit\": (KS_ARCH_X86, KS_MODE_16),                # X86 16-bit\n        \"X86 32-bit\": (KS_ARCH_X86, KS_MODE_32),                # X86 32-bit\n        \"X86 64-bit\": (KS_ARCH_X86, KS_MODE_64),                # X86 64-bit\n        \"ARM\": (KS_ARCH_ARM, KS_MODE_ARM),                      # ARM\n        \"ARM Thumb\": (KS_ARCH_ARM, KS_MODE_THUMB),              # ARM Thumb\n        \"ARM64 (ARMV8)\": (KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN),# ARM64\n        \"Hexagon\": (KS_ARCH_HEXAGON, KS_MODE_BIG_ENDIAN),       # Hexagon",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Form",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Keypatch_Form(idaapi.Form):\n    # prepare for form initializing\n    def setup(self, kp_asm, address, assembly=None):\n        self.kp_asm = kp_asm\n        self.address = address\n        # update ordered list of arch and syntax\n        self.syntax_keys = self.kp_asm.dict_to_ordered_list(self.kp_asm.syntax_lists)[0]\n        self.arch_keys = self.kp_asm.dict_to_ordered_list(self.kp_asm.arch_lists)[0]\n        # update current arch & mode\n        self.kp_asm.update_hardware_mode()",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_FillRange",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Keypatch_FillRange(Keypatch_Form):\n    def __init__(self, kp_asm, addr_begin, addr_end, assembly=None, opts=None):\n        self.setup(kp_asm, addr_begin, assembly)\n        self.addr_end = addr_end\n        # create FillRange form\n        super(Keypatch_FillRange, self).__init__(\n            r\"\"\"STARTITEM {id:c_assembly}\nBUTTON YES* Patch\nKEYPATCH:: Fill Range\n            {FormChangeCb}",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Patcher",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Keypatch_Patcher(Keypatch_Form):\n    def __init__(self, kp_asm, address, assembly=None, opts=None):\n        self.setup(kp_asm, address, assembly)\n        # create Patcher form\n        super(Keypatch_Patcher, self).__init__(\n            r\"\"\"STARTITEM {id:c_assembly}\nBUTTON YES* Patch\nKEYPATCH:: Patcher\n            {FormChangeCb}\n            <Endian     :{c_endian}>",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "SearchResultChooser",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class SearchResultChooser(Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        super(SearchResultChooser, self).__init__(\n            title,\n            [[\"Address\", Choose.CHCOL_HEX|40]],\n            flags = flags,\n            width = width,\n            height = height,\n            embedded = embedded)\n        self.n = 0",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Search",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Keypatch_Search(Keypatch_Form):\n    def __init__(self, kp_asm, address, assembly=None):\n        self.setup(kp_asm, address, assembly)\n        # create Search form\n        super(Keypatch_Search, self).__init__(\n            r\"\"\"STARTITEM {id:c_assembly}\nBUTTON YES* Search\nKEYPATCH:: Search\n            {FormChangeCb}\n            <A~r~ch       :{c_arch}>",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "About_Form",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class About_Form(idaapi.Form):\n    def __init__(self, version):\n        # create About form\n        super(About_Form, self).__init__(\n            r\"\"\"STARTITEM 0\nBUTTON YES* Open Keypatch Website\nKEYPATCH:: About\n            {FormChangeCb}\n            Keypatch IDA plugin v%s, using Keystone Engine v%s.\n            (c) Nguyen Anh Quynh + Thanh Nguyen, 2018.",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Update_Form",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Update_Form(idaapi.Form):\n    def __init__(self, version, message):\n        # create Update form\n        super(Update_Form, self).__init__(\n            r\"\"\"STARTITEM 0\nBUTTON YES* Open Keypatch Website\nKEYPATCH:: Check for update\n            {FormChangeCb}\n            Your Keypatch is v%s\n            %s",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        # IDA >= 700 right click widget popup\n        def finish_populating_widget_popup(self, form, popup):\n            if idaapi.get_widget_type(form) == idaapi.BWN_DISASM:\n                try:\n                    idaapi.attach_action_to_popup(form, popup, Kp_MC_Patcher.get_name(), 'Keypatch/')\n                    idaapi.attach_action_to_popup(form, popup, Kp_MC_Fill_Range.get_name(), 'Keypatch/')\n                    idaapi.attach_action_to_popup(form, popup, Kp_MC_Undo.get_name(), 'Keypatch/')\n                    idaapi.attach_action_to_popup(form, popup, \"-\", 'Keypatch/')",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Plugin_t",
        "kind": 6,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "class Keypatch_Plugin_t(idaapi.plugin_t):\n    comment = \"Keypatch plugin for IDA Pro (using Keystone framework)\"\n    help = \"Find more information on Keypatch at http://keystone-engine.org/keypatch\"\n    wanted_name = \"Keypatch Patcher\"\n    wanted_hotkey = \"Ctrl-Alt-K\"\n    flags = idaapi.PLUGIN_KEEP\n    def load_configuration(self):\n        # default\n        self.opts = {}\n        # load configuration from file",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "to_string",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):\n      return s.decode('latin-1')\n  # python2 unicode\n  elif six.PY2 and isinstance(s, six.text_type):\n      return s.encode('utf-8')\n  return str(s)\ndef to_hexstr(buf, sep=' '):\n    # for python3 bytes",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "to_hexstr",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def to_hexstr(buf, sep=' '):\n    # for python3 bytes\n    if six.PY3 and isinstance(buf, bytes):\n        return sep.join(\"{0:02x}\".format(c) for c in buf).upper()\n    return sep.join(\"{0:02x}\".format(ord(c)) for c in buf).upper()\n#########################################################################################################\n################################ IDA 6/7 Compatibility function #########################################\ndef get_dtype(ea, op_idx):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        insn = idaapi.insn_t()",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "get_dtype",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def get_dtype(ea, op_idx):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        insn = idaapi.insn_t()\n        idaapi.decode_insn(insn, ea)\n        dtype = insn.ops[op_idx].dtype\n        dtyp_size = idaapi.get_dtype_size(dtype)\n    else:\n        dtype = idaapi.cmd.Operands[op_idx].dtyp\n        dtyp_size = idaapi.get_dtyp_size(dtype)\n    return dtype, dtyp_size",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "set_comment",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def set_comment(ea, comment):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        idc.set_cmt(ea, comment, 0)\n    else:\n        idc.MakeComm(ea, comment)\ndef get_comment(ea):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idc.get_cmt(ea, 0)\n    return idc.Comment(ea)\ndef read_range_selection():",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "get_comment",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def get_comment(ea):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idc.get_cmt(ea, 0)\n    return idc.Comment(ea)\ndef read_range_selection():\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idaapi.read_range_selection(None)\n    return idaapi.read_selection()\n#########################################################################################################\n# return a normalized code, or None if input is invalid",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "read_range_selection",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def read_range_selection():\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idaapi.read_range_selection(None)\n    return idaapi.read_selection()\n#########################################################################################################\n# return a normalized code, or None if input is invalid\ndef convert_hexstr(code):\n    # normalize code\n    code = code.lower()\n    code = code.replace(' ', '')    # remove space",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "convert_hexstr",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def convert_hexstr(code):\n    # normalize code\n    code = code.lower()\n    code = code.replace(' ', '')    # remove space\n    code = code.replace('h', '')    # remove trailing 'h' in 90h\n    code = code.replace('0x', '')   # remove 0x\n    code = code.replace('\\\\x', '')  # remove \\x\n    code = code.replace(',', '')    # remove ,\n    code = code.replace(';', '')    # remove ;\n    code = code.replace('\"', '')    # remove \"",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "url_download",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def url_download(url):\n    # Import for python2\n    try:\n        from urllib2 import Request, urlopen, URLError, HTTPError\n    except:\n        from urllib.request import Request, urlopen\n        from urllib.error import URLError, HTTPError\n    # create the url and the request\n    req = Request(url)\n    # Open the url",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "get_name_value",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def get_name_value(_from, name):\n    \"\"\"\n    Fixed: the return value truncated(32 bit) of get_name_value function that analyzed 64 bit binary file about ida64 for win.\n    eg:\n    type == idaapi.NT_BYTE\n    (type, value) = idaapi.get_name_value(idc.BADADDR, \"wcschr\") # ida64 for win\n    value = 0x14003d3f0L is correct  ida64 > 7.x for macOS\n    value = 0x4003d3f0L is truncated ida64 >= 6.x for win, ida64 == 6.x for macOS\n    :param _from: ea\n    :param name: name string",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return Keypatch_Plugin_t()",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "is_debug",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "is_debug = False\nif is_debug:\n    ''' \n        Install pydevd:\n        1. sudo pip install pydevd\n        or\n        2. Install pycharm-debug.egg, Ensure to use pycharm pro\n        https://www.jetbrains.com/help/pycharm/remote-debugging-with-product.html\n        # import site\n        # site.addsitedir(\"/usr/local/lib/python2.7/site-packages\")",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "VERSION = \"2.2\"\nMAX_INSTRUCTION_STRLEN = 256\nMAX_ENCODING_LEN = 40\nMAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "MAX_INSTRUCTION_STRLEN",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "MAX_INSTRUCTION_STRLEN = 256\nMAX_ENCODING_LEN = 40\nMAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "MAX_ENCODING_LEN",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "MAX_ENCODING_LEN = 40\nMAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "MAX_ADDRESS_LEN",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "MAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "ENCODING_ERR_OUTPUT",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "ENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "KP_GITHUB_VERSION",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "KP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "KP_HOMEPAGE",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "KP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "X86_NOP",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "X86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "KP_CFGFILE",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "KP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):\n      return s.decode('latin-1')\n  # python2 unicode",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "patch_info",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "patch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):\n      return s.decode('latin-1')\n  # python2 unicode\n  elif six.PY2 and isinstance(s, six.text_type):\n      return s.encode('utf-8')",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "kp_initialized",
        "kind": 5,
        "importPath": "plugins.keypatch",
        "description": "plugins.keypatch",
        "peekOfCode": "kp_initialized = False\n#--------------------------------------------------------------------------\n# Plugin\n#--------------------------------------------------------------------------\nclass Keypatch_Plugin_t(idaapi.plugin_t):\n    comment = \"Keypatch plugin for IDA Pro (using Keystone framework)\"\n    help = \"Find more information on Keypatch at http://keystone-engine.org/keypatch\"\n    wanted_name = \"Keypatch Patcher\"\n    wanted_hotkey = \"Ctrl-Alt-K\"\n    flags = idaapi.PLUGIN_KEEP",
        "detail": "plugins.keypatch",
        "documentation": {}
    },
    {
        "label": "VulnChoose",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class VulnChoose(idaapi.Choose):\n    \"\"\"\n    Chooser class to display result of format string vuln scan\n    \"\"\"\n    def __init__(self, title, items, icon, embedded=False):\n        idaapi.Choose.__init__(self, title, [[\"Address\", 20], [\"Function\", 30], [\"Format\", 30]], embedded=embedded)\n        self.items = items\n        self.icon = 45\n    def GetItems(self):\n        return self.items",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "hotkey_action_handler_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class hotkey_action_handler_t(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for hotkey actions\n    \"\"\"\n    def __init__(self, action):\n        idaapi.action_handler_t.__init__(self)\n        self.action = action\n    def activate(self, ctx):\n        if self.action == ACTION_COPYEA:\n            ea = idc.get_screen_ea()",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "menu_action_handler_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class menu_action_handler_t(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for menu actions\n    \"\"\"\n    def __init__(self, action):\n        idaapi.action_handler_t.__init__(self)\n        self.action = action\n    def activate(self, ctx):\n        if self.action in ACTION_CONVERT:\n            # convert",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "hexrays_action_handler_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class hexrays_action_handler_t(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for hexrays actions\n    \"\"\"\n    def __init__(self, action):\n        idaapi.action_handler_t.__init__(self)\n        self.action = action\n        self.ret_type = {}\n    def activate(self, ctx):\n        if self.action == ACTION_HX_REMOVERETTYPE:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "UI_Hook",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class UI_Hook(idaapi.UI_Hooks):\n    def __init__(self):\n        idaapi.UI_Hooks.__init__(self)\n    def finish_populating_widget_popup(self, form, popup):\n        form_type = idaapi.get_widget_type(form)\n        if idaapi.IDA_SDK_VERSION >= 900:\n            dump_type = idaapi.BWN_HEXVIEW\n        else:\n            dump_type = idaapi.BWN_DUMP\n        if form_type == idaapi.BWN_DISASM or form_type == dump_type:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "HexRays_Hook",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class HexRays_Hook(object):\n    def callback(self, event, *args):\n        if event == idaapi.hxe_populating_popup:\n            form, phandle, vu = args\n            if vu.item.citype == idaapi.VDI_FUNC or (vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr() and vu.item.e.type.is_funcptr()):\n                idaapi.attach_action_to_popup(form, phandle, ACTION_HX_REMOVERETTYPE, None)\n        elif event == idaapi.hxe_double_click:\n            vu, shift_state = args\n            # auto jump to target if clicked item is xxx->func();\n            if vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr():",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "LazyIDA_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class LazyIDA_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_HIDE\n    comment = \"LazyIDA\"\n    help = \"\"\n    wanted_name = \"LazyIDA\"\n    wanted_hotkey = \"\"\n    def init(self):\n        self.hexrays_inited = False\n        self.registered_actions = []\n        self.registered_hx_actions = []",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "copy_to_clip",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:\n            loc = idc.get_name_ea_simple(loc.encode().strip())",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "clip_text",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:\n            loc = idc.get_name_ea_simple(loc.encode().strip())\n        except:\n            return idaapi.BADADDR",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "parse_location",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:\n            loc = idc.get_name_ea_simple(loc.encode().strip())\n        except:\n            return idaapi.BADADDR\n    return loc\nclass VulnChoose(idaapi.Choose):",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return LazyIDA_t()",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_CONVERT",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_CONVERT = [\"lazyida:convert%d\" % i for i in range(10)]\nACTION_SCANVUL = \"lazyida:scanvul\"\nACTION_COPYEA = \"lazyida:copyea\"\nACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_SCANVUL",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_SCANVUL = \"lazyida:scanvul\"\nACTION_COPYEA = \"lazyida:copyea\"\nACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_COPYEA",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_COPYEA = \"lazyida:copyea\"\nACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_GOTOCLIP",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_XORDATA",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_FILLNOP",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_REMOVERETTYPE",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_COPYEA",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_COPYNAME",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_GOTOCLIP",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "u16",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "u16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "u32",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "u32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "u64",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "u64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ARCH",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "BITS",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "BITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "shellcode_search_plugin_t",
        "kind": 6,
        "importPath": "plugins.shellcode_hashes_search_plugin",
        "description": "plugins.shellcode_hashes_search_plugin",
        "peekOfCode": "class shellcode_search_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"This is a comment\"\n    help = \"This is help\"\n    wanted_name = \"Shellcode Hashes\"\n    wanted_hotkey = \"\"\n    def init(self):\n        return idaapi.PLUGIN_OK\n    def run(self, arg):\n        flare.shellcode_hash_search.main()",
        "detail": "plugins.shellcode_hashes_search_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.shellcode_hashes_search_plugin",
        "description": "plugins.shellcode_hashes_search_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return shellcode_search_plugin_t()",
        "detail": "plugins.shellcode_hashes_search_plugin",
        "documentation": {}
    },
    {
        "label": "stackstrings_plugin_t",
        "kind": 6,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "class stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_WANTED_HOTKEY\n    def init(self):\n        try:\n            idaapi.msg(\"StackStrings init() called!\\n\")\n            return idaapi.PLUGIN_OK",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return stackstrings_plugin_t()",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "is_py2 = (sys.version_info[0] == 2)\nif is_py2:\n    # currently depending on vivisect, which will never be ported to py3\n    idaapi.require('flare')\n    idaapi.require('flare.stackstrings')\nPLUGIN_COMMENT = \"This is a comment\"\nPLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_COMMENT",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_COMMENT = \"This is a comment\"\nPLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HELP",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_WANTED_HOTKEY",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_WANTED_HOTKEY\n    def init(self):\n        try:",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "ex_addmenu_item_ctx",
        "kind": 5,
        "importPath": "plugins.stackstrings_plugin",
        "description": "plugins.stackstrings_plugin",
        "peekOfCode": "ex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_WANTED_HOTKEY\n    def init(self):\n        try:\n            idaapi.msg(\"StackStrings init() called!\\n\")",
        "detail": "plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "struct_typer_plugin_t",
        "kind": 6,
        "importPath": "plugins.struct_typer_plugin",
        "description": "plugins.struct_typer_plugin",
        "peekOfCode": "class struct_typer_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"This is a comment\"\n    help = \"This is help\"\n    wanted_name = \"StructTyper\"\n    wanted_hotkey = \"\"\n    def init(self):\n        #idaapi.msg(\"StructTyper init() called!\\n\")\n        return idaapi.PLUGIN_OK\n    def run(self, arg):",
        "detail": "plugins.struct_typer_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.struct_typer_plugin",
        "description": "plugins.struct_typer_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return struct_typer_plugin_t()",
        "detail": "plugins.struct_typer_plugin",
        "documentation": {}
    },
    {
        "label": "traceNatives",
        "kind": 6,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "class traceNatives(plugin_t):\n    flags = PLUGIN_PROC\n    comment = \"traceNatives\"\n    help = \"\"\n    wanted_name = \"traceNatives\"\n    wanted_hotkey = \"\"\n    def init(self):\n        print(\"traceNatives(v0.1) plugin has been loaded.\")\n        return PLUGIN_OK\n    def run(self, arg):",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "getSoPathAndName",
        "kind": 2,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "def getSoPathAndName():\n    fullpath = ida_nalt.get_input_file_path()\n    filepath,filename = os.path.split(fullpath)\n    return filepath,filename\n# \ndef getSegAddr():\n    textStart = []\n    textEnd = []\n    for seg in idautils.Segments():\n        if (idc.get_segm_name(seg)).lower() == '.text' or (",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "getSegAddr",
        "kind": 2,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "def getSegAddr():\n    textStart = []\n    textEnd = []\n    for seg in idautils.Segments():\n        if (idc.get_segm_name(seg)).lower() == '.text' or (\n        idc.get_segm_name(seg)).lower() == 'text':\n            tempStart = idc.get_segm_start(seg)\n            tempEnd = idc.get_segm_end(seg)\n            textStart.append(tempStart)\n            textEnd.append(tempEnd)",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return traceNatives()",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "export_structs",
        "kind": 2,
        "importPath": "scripts.export_struct",
        "description": "scripts.export_struct",
        "peekOfCode": "def export_structs():\n    with open(output_file, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:  #  utf-8 \n        # \n        for idx in range(ida_struct.get_struc_qty()):\n            struct_id = ida_struct.get_struc_by_idx(idx)\n            struct = ida_struct.get_struc(struct_id)\n            if struct:\n                struct_name = ida_struct.get_struc_name(struct_id)\n                f.write(f\"// Structure: {struct_name}\\n\")\n                f.write(f\"struct {struct_name} {{\\n\")",
        "detail": "scripts.export_struct",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "scripts.export_struct",
        "description": "scripts.export_struct",
        "peekOfCode": "output_file = \"C:/Users/jimmy/Projects/flutter-reverse-note/idapro/structures.h\"\ndef export_structs():\n    with open(output_file, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:  #  utf-8 \n        # \n        for idx in range(ida_struct.get_struc_qty()):\n            struct_id = ida_struct.get_struc_by_idx(idx)\n            struct = ida_struct.get_struc(struct_id)\n            if struct:\n                struct_name = ida_struct.get_struc_name(struct_id)\n                f.write(f\"// Structure: {struct_name}\\n\")",
        "detail": "scripts.export_struct",
        "documentation": {}
    },
    {
        "label": "get_member_name_by_index",
        "kind": 2,
        "importPath": "scripts.find_dartObjectPool_index",
        "description": "scripts.find_dartObjectPool_index",
        "peekOfCode": "def get_member_name_by_index(struct_name, index):\n    struct_id = idc.get_struc_id(struct_name)\n    if struct_id == idc.BADADDR:\n        logger.error(f\" '{struct_name}' \")\n        return None\n    offset = 0\n    while True:\n        member_id = idc.get_member_id(struct_id, offset)\n        if member_id == idc.BADADDR:\n            break",
        "detail": "scripts.find_dartObjectPool_index",
        "documentation": {}
    },
    {
        "label": "search_with_mask",
        "kind": 2,
        "importPath": "scripts.find_dartObjectPool_index",
        "description": "scripts.find_dartObjectPool_index",
        "peekOfCode": "def search_with_mask(start_ea, end_ea, pattern, mask):\n    ea = 0x12FEA90  #start_ea\n    pattern_length = len(pattern)\n    total_size = end_ea - start_ea\n    last_percentage = -1\n    while ea != idaapi.BADADDR and ea < end_ea:\n        # Calculate and log progress percentage\n        current_progress = ea - start_ea\n        current_percentage = int((current_progress / total_size) * 100)\n        if current_percentage != last_percentage and current_percentage % 5 == 0:",
        "detail": "scripts.find_dartObjectPool_index",
        "documentation": {}
    },
    {
        "label": "get_member_name_by_index",
        "kind": 2,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "def get_member_name_by_index(struct_name, index):\n    #  ID\n    struct_id = idc.get_struc_id(struct_name)\n    if struct_id == idc.BADADDR:\n        print(f\" '{struct_name}' \")\n        return None\n    # \n    struct_size = idc.get_struc_size(struct_id)\n    if index < 0 or index >= struct_size:\n        print(f\" {index}  '{struct_name}'  {struct_size}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "struct_name",
        "kind": 5,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "struct_name = \"DartObjectPool\"\nindex = 0xD9C8  # \nmember_name = get_member_name_by_index(struct_name, index)\nif member_name:\n    print(f\" '{struct_name}'  {index} : {member_name}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 5,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "index = 0xD9C8  # \nmember_name = get_member_name_by_index(struct_name, index)\nif member_name:\n    print(f\" '{struct_name}'  {index} : {member_name}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "member_name",
        "kind": 5,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "member_name = get_member_name_by_index(struct_name, index)\nif member_name:\n    print(f\" '{struct_name}'  {index} : {member_name}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "WPSearch",
        "kind": 6,
        "importPath": "scripts.wpsearch",
        "description": "scripts.wpsearch",
        "peekOfCode": "class WPSearch(object):\n    '''\n    Searches for immediate values commonly founds in MIPS WPS checksum implementations.\n    May be applicable to other architectures as well.\n    '''\n    IMMEDIATES = {\n                        0x6B5FCA6B : set(),\n                        0x431BDE83 : set(),\n                        0x0A7C5AC5 : set(),\n                        0x10624DD3 : set(),",
        "detail": "scripts.wpsearch",
        "documentation": {}
    },
    {
        "label": "WPSearchFunctionChooser",
        "kind": 6,
        "importPath": "scripts.wpsearch",
        "description": "scripts.wpsearch",
        "peekOfCode": "class WPSearchFunctionChooser(idaapi.Choose2):\n    DELIM_COL_1 = '-' * 50\n    DELIM_COL_2 = '-' * 20\n    DELIM_COL_3 = '-' * 125\n    def __init__(self):\n        idaapi.Choose2.__init__(self,\n                                \"WPS Function Profiles\",\n                                [\n                                    [\"Function\", 15 | idaapi.Choose2.CHCOL_PLAIN],\n                                    [\"Contains checksum algorithm\", 15 | idaapi.Choose2.CHCOL_PLAIN],",
        "detail": "scripts.wpsearch",
        "documentation": {}
    }
]