[
    {
        "label": "struct,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct.",
        "description": "struct.",
        "detail": "struct.",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "ida_funcs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_funcs",
        "description": "ida_funcs",
        "detail": "ida_funcs",
        "documentation": {}
    },
    {
        "label": "idautils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idautils",
        "description": "idautils",
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "Segments",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "XrefsTo",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "FuncItems",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "CodeRefsTo",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idautils",
        "description": "idautils",
        "isExtraImport": true,
        "detail": "idautils",
        "documentation": {}
    },
    {
        "label": "idc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idc",
        "description": "idc",
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "BADADDR",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "XREF_USER",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "dr_I",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "get_func_name",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "get_qword",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "get_segm_end",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "get_segm_name",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "get_strlit_contents",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "get_wide_dword",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "print_insn_mnem",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idc",
        "description": "idc",
        "isExtraImport": true,
        "detail": "idc",
        "documentation": {}
    },
    {
        "label": "ida_bytes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_bytes",
        "description": "ida_bytes",
        "detail": "ida_bytes",
        "documentation": {}
    },
    {
        "label": "get_bytes",
        "importPath": "ida_bytes",
        "description": "ida_bytes",
        "isExtraImport": true,
        "detail": "ida_bytes",
        "documentation": {}
    },
    {
        "label": "patch_dword",
        "importPath": "ida_bytes",
        "description": "ida_bytes",
        "isExtraImport": true,
        "detail": "ida_bytes",
        "documentation": {}
    },
    {
        "label": "ida_name",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_name",
        "description": "ida_name",
        "detail": "ida_name",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPainter",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QMouseEvent",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QKeySequence",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFontDatabase",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QTextDocument",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPainter",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QMouseEvent",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QKeySequence",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFontDatabase",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QTextDocument",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPalette",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "PyQt5.QtCore",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QMimeData",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "pyqtSignal",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QItemSelection",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QItemSelectionModel",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QRectF",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QAbstractTableModel",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QMimeData",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "pyqtSignal",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QItemSelection",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QItemSelectionModel",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QRectF",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QAbstractTableModel",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "PyQt5.QtWidgets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStyle",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAction",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QTableView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHeaderView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QInputDialog",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAbstractItemView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStyle",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAction",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QTableView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHeaderView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QInputDialog",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAbstractItemView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QDialog",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QTextEdit",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QScrollArea",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "idaapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idaapi",
        "description": "idaapi",
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "SEGPERM_READ",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "SEGPERM_WRITE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "xrefblk_t",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "getseg",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "segment_t",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "XREF_DATA",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "dr_W",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "is_loaded",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "getseg",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "get_qword",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "SEGPERM_WRITE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "add_dref",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "get_inf_structure",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_OPENIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_CLOSEIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_TERMIDA",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_REMOVE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_reg",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_imm",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_far",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_near",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_mem",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "o_displ",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_OPENIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_CLOSEIDB",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_TERMIDA",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "NW_REMOVE",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "plugin_t",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "PLUGIN_PROC",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "PLUGIN_OK",
        "importPath": "idaapi",
        "description": "idaapi",
        "isExtraImport": true,
        "detail": "idaapi",
        "documentation": {}
    },
    {
        "label": "ida_segment",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_segment",
        "description": "ida_segment",
        "detail": "ida_segment",
        "documentation": {}
    },
    {
        "label": "ida_kernwin",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_kernwin",
        "description": "ida_kernwin",
        "detail": "ida_kernwin",
        "documentation": {}
    },
    {
        "label": "msg",
        "importPath": "ida_kernwin",
        "description": "ida_kernwin",
        "isExtraImport": true,
        "detail": "ida_kernwin",
        "documentation": {}
    },
    {
        "label": "ida_ida",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_ida",
        "description": "ida_ida",
        "detail": "ida_ida",
        "documentation": {}
    },
    {
        "label": "idabincat.netnode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idabincat.netnode",
        "description": "idabincat.netnode",
        "detail": "idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "importPath": "idabincat.plugin_options",
        "description": "idabincat.plugin_options",
        "isExtraImport": true,
        "detail": "idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "idabincat.npkgen",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idabincat.npkgen",
        "description": "idabincat.npkgen",
        "detail": "idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X64_GPR",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X86_GPR",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X64_GPR",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X86_GPR",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "importPath": "idabincat.analyzer_conf",
        "description": "idabincat.analyzer_conf",
        "isExtraImport": true,
        "detail": "idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "GUI",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GUI",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GUI",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "importPath": "idabincat.gui",
        "description": "idabincat.gui",
        "isExtraImport": true,
        "detail": "idabincat.gui",
        "documentation": {}
    },
    {
        "label": "pybincat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pybincat",
        "description": "pybincat",
        "detail": "pybincat",
        "documentation": {}
    },
    {
        "label": "PyBinCATException",
        "importPath": "pybincat",
        "description": "pybincat",
        "isExtraImport": true,
        "detail": "pybincat",
        "documentation": {}
    },
    {
        "label": "cfa",
        "importPath": "pybincat",
        "description": "pybincat",
        "isExtraImport": true,
        "detail": "pybincat",
        "documentation": {}
    },
    {
        "label": "PyBinCATException",
        "importPath": "pybincat",
        "description": "pybincat",
        "isExtraImport": true,
        "detail": "pybincat",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "pybincat.cfa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pybincat.cfa",
        "description": "pybincat.cfa",
        "detail": "pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "idabincat.hexview",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idabincat.hexview",
        "description": "idabincat.hexview",
        "detail": "idabincat.hexview",
        "documentation": {}
    },
    {
        "label": "dump_binary",
        "importPath": "idabincat.dump_binary",
        "description": "idabincat.dump_binary",
        "isExtraImport": true,
        "detail": "idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "dump_binary",
        "importPath": "idabincat.dump_binary",
        "description": "idabincat.dump_binary",
        "isExtraImport": true,
        "detail": "idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "ida_diskio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_diskio",
        "description": "ida_diskio",
        "detail": "ida_diskio",
        "documentation": {}
    },
    {
        "label": "parsers",
        "importPath": "pybincat.tools",
        "description": "pybincat.tools",
        "isExtraImport": true,
        "detail": "pybincat.tools",
        "documentation": {}
    },
    {
        "label": "parsers",
        "importPath": "pybincat.tools",
        "description": "pybincat.tools",
        "isExtraImport": true,
        "detail": "pybincat.tools",
        "documentation": {}
    },
    {
        "label": "distutils.spawn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "distutils.spawn",
        "description": "distutils.spawn",
        "detail": "distutils.spawn",
        "documentation": {}
    },
    {
        "label": "flask",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flask",
        "description": "flask",
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "ARM",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "Thumb",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "ThumbU",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "AARCH64",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "X86",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "PowerPC64",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "PowerPC",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "RISCV64",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "X64",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "X86",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "X86",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "X86",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "parse_val",
        "importPath": "pybincat.tools.parsers",
        "description": "pybincat.tools.parsers",
        "isExtraImport": true,
        "detail": "pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "conftest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "conftest",
        "description": "conftest",
        "detail": "conftest",
        "documentation": {}
    },
    {
        "label": "ida_idaapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_idaapi",
        "description": "ida_idaapi",
        "detail": "ida_idaapi",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "debug_print",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "debug_print",
        "description": "debug_print",
        "detail": "debug_print",
        "documentation": {}
    },
    {
        "label": "ida_gdl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_gdl",
        "description": "ida_gdl",
        "detail": "ida_gdl",
        "documentation": {}
    },
    {
        "label": "ida_xref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_xref",
        "description": "ida_xref",
        "detail": "ida_xref",
        "documentation": {}
    },
    {
        "label": "ida_graph",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_graph",
        "description": "ida_graph",
        "detail": "ida_graph",
        "documentation": {}
    },
    {
        "label": "ida_lines",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_lines",
        "description": "ida_lines",
        "detail": "ida_lines",
        "documentation": {}
    },
    {
        "label": "ida_moves",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_moves",
        "description": "ida_moves",
        "detail": "ida_moves",
        "documentation": {}
    },
    {
        "label": "ida_auto",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_auto",
        "description": "ida_auto",
        "detail": "ida_auto",
        "documentation": {}
    },
    {
        "label": "ida_ua",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_ua",
        "description": "ida_ua",
        "detail": "ida_ua",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "get_func_relation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "get_func_relation",
        "description": "get_func_relation",
        "detail": "get_func_relation",
        "documentation": {}
    },
    {
        "label": "tinfo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tinfo",
        "description": "tinfo",
        "detail": "tinfo",
        "documentation": {}
    },
    {
        "label": "cto_base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cto_base",
        "description": "cto_base",
        "detail": "cto_base",
        "documentation": {}
    },
    {
        "label": "icon",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "icon",
        "description": "icon",
        "detail": "icon",
        "documentation": {}
    },
    {
        "label": "syncui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "syncui",
        "description": "syncui",
        "detail": "syncui",
        "documentation": {}
    },
    {
        "label": "cto_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cto_utils",
        "description": "cto_utils",
        "detail": "cto_utils",
        "documentation": {}
    },
    {
        "label": "ida_nalt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_nalt",
        "description": "ida_nalt",
        "detail": "ida_nalt",
        "documentation": {}
    },
    {
        "label": "cache_data",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cache_data",
        "description": "cache_data",
        "detail": "cache_data",
        "documentation": {}
    },
    {
        "label": "jump",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jump",
        "description": "jump",
        "detail": "jump",
        "documentation": {}
    },
    {
        "label": "config_base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "config_base",
        "description": "config_base",
        "detail": "config_base",
        "documentation": {}
    },
    {
        "label": "comments",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "comments",
        "description": "comments",
        "detail": "comments",
        "documentation": {}
    },
    {
        "label": "xor_loop_detector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xor_loop_detector",
        "description": "xor_loop_detector",
        "detail": "xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "notable_mnem_finder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "notable_mnem_finder",
        "description": "notable_mnem_finder",
        "detail": "notable_mnem_finder",
        "documentation": {}
    },
    {
        "label": "notable_const_finder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "notable_const_finder",
        "description": "notable_const_finder",
        "detail": "notable_const_finder",
        "documentation": {}
    },
    {
        "label": "notable_inst_finder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "notable_inst_finder",
        "description": "notable_inst_finder",
        "detail": "notable_inst_finder",
        "documentation": {}
    },
    {
        "label": "ida_entry",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_entry",
        "description": "ida_entry",
        "detail": "ida_entry",
        "documentation": {}
    },
    {
        "label": "sip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sip",
        "description": "sip",
        "detail": "sip",
        "documentation": {}
    },
    {
        "label": "qtutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "qtutils",
        "description": "qtutils",
        "detail": "qtutils",
        "documentation": {}
    },
    {
        "label": "ida_strlist",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_strlist",
        "description": "ida_strlist",
        "detail": "ida_strlist",
        "documentation": {}
    },
    {
        "label": "ida_search",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_search",
        "description": "ida_search",
        "detail": "ida_search",
        "documentation": {}
    },
    {
        "label": "ida_typeinf",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_typeinf",
        "description": "ida_typeinf",
        "detail": "ida_typeinf",
        "documentation": {}
    },
    {
        "label": "ida_netnode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_netnode",
        "description": "ida_netnode",
        "detail": "ida_netnode",
        "documentation": {}
    },
    {
        "label": "ida_idp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_idp",
        "description": "ida_idp",
        "detail": "ida_idp",
        "documentation": {}
    },
    {
        "label": "cProfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cProfile",
        "description": "cProfile",
        "detail": "cProfile",
        "documentation": {}
    },
    {
        "label": "pstats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pstats",
        "description": "pstats",
        "detail": "pstats",
        "documentation": {}
    },
    {
        "label": "loop_detector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "loop_detector",
        "description": "loop_detector",
        "detail": "loop_detector",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ida_hexrays",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "minsn_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "vd_printer_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mbl_array_t",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_d",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_n",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_stx",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_ldx",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_xdu",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "m_xds",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_z",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_fn",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_S",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_v",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "EQ_IGNSIZE",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "mop_b",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ida_hexrays",
        "description": "ida_hexrays",
        "isExtraImport": true,
        "detail": "ida_hexrays",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopHistory",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "remove_segment_registers",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_histories",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopHistory",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_histories",
        "importPath": "d810.tracker",
        "description": "d810.tracker",
        "isExtraImport": true,
        "detail": "d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_block",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "make_2way_block_goto",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "update_blk_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "mba_deep_cleaning",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_child_has_an_unconditional_father",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_last_block_is_goto",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "create_block",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "make_2way_block_goto",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "is_conditional_jump",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_2way_block_conditional_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "get_block_serials_by_address",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_2way_block_conditional_successor",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "duplicate_block",
        "importPath": "d810.cfg_utils",
        "description": "d810.cfg_utils",
        "isExtraImport": true,
        "detail": "d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_list",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "maturity_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "string_to_maturity",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "block_printer",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "mop_type_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "maturity_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "mop_type_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "importPath": "d810.hexrays_formatters",
        "description": "d810.hexrays_formatters",
        "isExtraImport": true,
        "detail": "d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "get_all_possibles_values",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotResolvableFatherException",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotDuplicableFatherException",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "get_all_possibles_values",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "configure_mop_tracker_log_verbosity",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "restore_mop_tracker_log_verbosity",
        "importPath": "d810.optimizers.flow.flattening.utils",
        "description": "d810.optimizers.flow.flattening.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "GenericUnflatteningRule",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherCollector",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericUnflatteningRule",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherBlockInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherBlockInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.flow.flattening.generic",
        "description": "d810.optimizers.flow.flattening.generic",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "signed_to_unsigned",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "signed_to_unsigned",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_cf",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_of",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_sub_of",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "ror",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "get_parity_flag",
        "importPath": "d810.utils",
        "description": "d810.utils",
        "isExtraImport": true,
        "detail": "d810.utils",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "FlowOptimizationRule",
        "importPath": "d810.optimizers.flow.handler",
        "description": "d810.optimizers.flow.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "FlowOptimizationRule",
        "importPath": "d810.optimizers.flow.handler",
        "description": "d810.optimizers.flow.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "importPath": "d810.emulator",
        "description": "d810.emulator",
        "isExtraImport": true,
        "detail": "d810.emulator",
        "documentation": {}
    },
    {
        "label": "InstructionDefUseCollector",
        "importPath": "d810.hexrays_hooks",
        "description": "d810.hexrays_hooks",
        "isExtraImport": true,
        "detail": "d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "InstructionDefUseCollector",
        "importPath": "d810.hexrays_hooks",
        "description": "d810.hexrays_hooks",
        "isExtraImport": true,
        "detail": "d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "extract_num_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "extract_num_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_bypass_xdu",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_ignore_msb_cst",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_cst",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "is_check_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_cst",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "OPCODES_INFO",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MBA_RELATED_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "Z3_SPECIAL_OPERANDS",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MINSN_TO_AST_FORBIDDEN_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONDITIONAL_JUMP_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "OPCODES_INFO",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MATURITY_TO_STRING_DICT",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "STRING_TO_MATURITY_DICT",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MOP_TYPE_TO_STRING_DICT",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_ins_mop_size_are_ok",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_blk_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MSB_TABLE",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "importPath": "d810.hexrays_helpers",
        "description": "d810.hexrays_helpers",
        "isExtraImport": true,
        "detail": "d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "importPath": "d810.optimizers.instructions.handler",
        "description": "d810.optimizers.instructions.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "ast_generator",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "importPath": "d810.optimizers.instructions.pattern_matching.handler",
        "description": "d810.optimizers.instructions.pattern_matching.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "mop_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "mop_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "importPath": "d810.ast",
        "description": "d810.ast",
        "isExtraImport": true,
        "detail": "d810.ast",
        "documentation": {}
    },
    {
        "label": "JumpOptimizationRule",
        "importPath": "d810.optimizers.flow.jumps.handler",
        "description": "d810.optimizers.flow.jumps.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "JumpOptimizationRule",
        "importPath": "d810.optimizers.flow.jumps.handler",
        "description": "d810.optimizers.flow.jumps.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "OptimizationRule",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FLOW_MATURITIES",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INSTRUCTION_MATURITIES",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "OptimizationRule",
        "importPath": "d810.optimizers.handler",
        "description": "d810.optimizers.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "InstructionAnalysisRule",
        "importPath": "d810.optimizers.instructions.analysis.handler",
        "description": "d810.optimizers.instructions.analysis.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "get_possible_patterns",
        "importPath": "d810.optimizers.instructions.analysis.utils",
        "description": "d810.optimizers.instructions.analysis.utils",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.analysis.utils",
        "documentation": {}
    },
    {
        "label": "ChainSimplificationRule",
        "importPath": "d810.optimizers.instructions.chain.handler",
        "description": "d810.optimizers.instructions.chain.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.chain.handler",
        "documentation": {}
    },
    {
        "label": "EarlyRule",
        "importPath": "d810.optimizers.instructions.early.handler",
        "description": "d810.optimizers.instructions.early.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.early.handler",
        "documentation": {}
    },
    {
        "label": "Z3Rule",
        "importPath": "d810.optimizers.instructions.z3.handler",
        "description": "d810.optimizers.instructions.z3.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "Z3Rule",
        "importPath": "d810.optimizers.instructions.z3.handler",
        "description": "d810.optimizers.instructions.z3.handler",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "AstEvaluationException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Exception",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "AstEvaluationException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "ControlFlowException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationIndirectJumpException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "UnresolvedMopException",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Exception",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Z3Exception",
        "importPath": "d810.errors",
        "description": "d810.errors",
        "isExtraImport": true,
        "detail": "d810.errors",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_equality",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_equality",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_inequality",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "log_z3_instructions",
        "importPath": "d810.z3_utils",
        "description": "d810.z3_utils",
        "isExtraImport": true,
        "detail": "d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "PatternOptimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "ChainOptimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "Z3Optimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "EarlyOptimizer",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "d810.optimizers.instructions",
        "description": "d810.optimizers.instructions",
        "isExtraImport": true,
        "detail": "d810.optimizers.instructions",
        "documentation": {}
    },
    {
        "label": "ProjectConfiguration",
        "importPath": "d810.conf",
        "description": "d810.conf",
        "isExtraImport": true,
        "detail": "d810.conf",
        "documentation": {}
    },
    {
        "label": "RuleConfiguration",
        "importPath": "d810.conf",
        "description": "d810.conf",
        "isExtraImport": true,
        "detail": "d810.conf",
        "documentation": {}
    },
    {
        "label": "D810Configuration",
        "importPath": "d810.conf",
        "description": "d810.conf",
        "isExtraImport": true,
        "detail": "d810.conf",
        "documentation": {}
    },
    {
        "label": "logging.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.config",
        "description": "logging.config",
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "D810State",
        "importPath": "d810.manager",
        "description": "d810.manager",
        "isExtraImport": true,
        "detail": "d810.manager",
        "documentation": {}
    },
    {
        "label": "D810_LOG_DIR_NAME",
        "importPath": "d810.manager",
        "description": "d810.manager",
        "isExtraImport": true,
        "detail": "d810.manager",
        "documentation": {}
    },
    {
        "label": "configure_loggers",
        "importPath": "d810.log",
        "description": "d810.log",
        "isExtraImport": true,
        "detail": "d810.log",
        "documentation": {}
    },
    {
        "label": "clear_logs",
        "importPath": "d810.log",
        "description": "d810.log",
        "isExtraImport": true,
        "detail": "d810.log",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "yara",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yara",
        "description": "yara",
        "detail": "yara",
        "documentation": {}
    },
    {
        "label": "flare.jayutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flare.jayutils",
        "description": "flare.jayutils",
        "detail": "flare.jayutils",
        "documentation": {}
    },
    {
        "label": "flare.argtracker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flare.argtracker",
        "description": "flare.argtracker",
        "detail": "flare.argtracker",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "array",
        "description": "array",
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "BeautifulSoup",
        "description": "BeautifulSoup",
        "isExtraImport": true,
        "detail": "BeautifulSoup",
        "documentation": {}
    },
    {
        "label": "extract_til_constant_info",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "extract_til_constant_info",
        "description": "extract_til_constant_info",
        "detail": "extract_til_constant_info",
        "documentation": {}
    },
    {
        "label": "xml.sax.handler",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.sax.handler",
        "description": "xml.sax.handler",
        "detail": "xml.sax.handler",
        "documentation": {}
    },
    {
        "label": "unicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicorn",
        "description": "unicorn",
        "detail": "unicorn",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn",
        "description": "unicorn",
        "isExtraImport": true,
        "detail": "unicorn",
        "documentation": {}
    },
    {
        "label": "strings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "strings",
        "description": "strings",
        "detail": "strings",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "jayutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jayutils",
        "description": "jayutils",
        "detail": "jayutils",
        "documentation": {}
    },
    {
        "label": "vivisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "vivisect",
        "description": "vivisect",
        "detail": "vivisect",
        "documentation": {}
    },
    {
        "label": "vivisect.impemu",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "vivisect.impemu",
        "description": "vivisect.impemu",
        "detail": "vivisect.impemu",
        "documentation": {}
    },
    {
        "label": "vivisect.impemu.monitor",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "vivisect.impemu.monitor",
        "description": "vivisect.impemu.monitor",
        "detail": "vivisect.impemu.monitor",
        "documentation": {}
    },
    {
        "label": "pathcore",
        "importPath": "visgraph",
        "description": "visgraph",
        "isExtraImport": true,
        "detail": "visgraph",
        "documentation": {}
    },
    {
        "label": "mykutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mykutils",
        "description": "mykutils",
        "detail": "mykutils",
        "documentation": {}
    },
    {
        "label": "phex",
        "importPath": "mykutils",
        "description": "mykutils",
        "isExtraImport": true,
        "detail": "mykutils",
        "documentation": {}
    },
    {
        "label": "phex",
        "importPath": "mykutils",
        "description": "mykutils",
        "isExtraImport": true,
        "detail": "mykutils",
        "documentation": {}
    },
    {
        "label": "SegPlanner",
        "importPath": "seghelper",
        "description": "seghelper",
        "isExtraImport": true,
        "detail": "seghelper",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "unicorn.x86_const",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicorn.x86_const",
        "description": "unicorn.x86_const",
        "detail": "unicorn.x86_const",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.x86_const",
        "description": "unicorn.x86_const",
        "isExtraImport": true,
        "detail": "unicorn.x86_const",
        "documentation": {}
    },
    {
        "label": "unicorn.arm_const",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicorn.arm_const",
        "description": "unicorn.arm_const",
        "detail": "unicorn.arm_const",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.arm_const",
        "description": "unicorn.arm_const",
        "isExtraImport": true,
        "detail": "unicorn.arm_const",
        "documentation": {}
    },
    {
        "label": "unicorn.arm64_const",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicorn.arm64_const",
        "description": "unicorn.arm64_const",
        "detail": "unicorn.arm64_const",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.arm64_const",
        "description": "unicorn.arm64_const",
        "isExtraImport": true,
        "detail": "unicorn.arm64_const",
        "documentation": {}
    },
    {
        "label": "flare_emu",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flare_emu",
        "description": "flare_emu",
        "detail": "flare_emu",
        "documentation": {}
    },
    {
        "label": "ARC4",
        "importPath": "arc4",
        "description": "arc4",
        "isExtraImport": true,
        "detail": "arc4",
        "documentation": {}
    },
    {
        "label": "idaapi,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idaapi.",
        "description": "idaapi.",
        "detail": "idaapi.",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "frida",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "frida",
        "description": "frida",
        "detail": "frida",
        "documentation": {}
    },
    {
        "label": "do_slowmode_output",
        "importPath": "slow.trace_slow",
        "description": "slow.trace_slow",
        "isExtraImport": true,
        "detail": "slow.trace_slow",
        "documentation": {}
    },
    {
        "label": "ida_frame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_frame",
        "description": "ida_frame",
        "detail": "ida_frame",
        "documentation": {}
    },
    {
        "label": "sark",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sark",
        "description": "sark",
        "detail": "sark",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "parse",
        "description": "parse",
        "detail": "parse",
        "documentation": {}
    },
    {
        "label": "functioninliner",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functioninliner",
        "description": "functioninliner",
        "detail": "functioninliner",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "keypatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keypatch",
        "description": "keypatch",
        "detail": "keypatch",
        "documentation": {}
    },
    {
        "label": "netnode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "netnode",
        "description": "netnode",
        "detail": "netnode",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tqdm",
        "description": "tqdm",
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "wrapt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wrapt",
        "description": "wrapt",
        "detail": "wrapt",
        "documentation": {}
    },
    {
        "label": "messages",
        "importPath": "pyexpat.errors",
        "description": "pyexpat.errors",
        "isExtraImport": true,
        "detail": "pyexpat.errors",
        "documentation": {}
    },
    {
        "label": "messages",
        "importPath": "pyexpat.errors",
        "description": "pyexpat.errors",
        "isExtraImport": true,
        "detail": "pyexpat.errors",
        "documentation": {}
    },
    {
        "label": "gepetto.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gepetto.config",
        "description": "gepetto.config",
        "detail": "gepetto.config",
        "documentation": {}
    },
    {
        "label": "gepetto.ida.handlers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "ExplainHandler",
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "isExtraImport": true,
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "RenameHandler",
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "isExtraImport": true,
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "SwapModelHandler",
        "importPath": "gepetto.ida.handlers",
        "description": "gepetto.ida.handlers",
        "isExtraImport": true,
        "detail": "gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "gepetto.models.model_manager",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "instantiate_model",
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "isExtraImport": true,
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "instantiate_model",
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "isExtraImport": true,
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "load_available_models",
        "importPath": "gepetto.models.model_manager",
        "description": "gepetto.models.model_manager",
        "isExtraImport": true,
        "detail": "gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "register_cli",
        "importPath": "gepetto.ida.cli",
        "description": "gepetto.ida.cli",
        "isExtraImport": true,
        "detail": "gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "groq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "groq",
        "description": "groq",
        "detail": "groq",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "GPT",
        "importPath": "gepetto.models.openai",
        "description": "gepetto.models.openai",
        "isExtraImport": true,
        "detail": "gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT",
        "importPath": "gepetto.models.openai",
        "description": "gepetto.models.openai",
        "isExtraImport": true,
        "detail": "gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "ollama",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ollama",
        "description": "ollama",
        "detail": "ollama",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "importPath": "gepetto.models.base",
        "description": "gepetto.models.base",
        "isExtraImport": true,
        "detail": "gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "importPath": "gepetto.models.base",
        "description": "gepetto.models.base",
        "isExtraImport": true,
        "detail": "gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "importPath": "gepetto.models.base",
        "description": "gepetto.models.base",
        "isExtraImport": true,
        "detail": "gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "together",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "together",
        "description": "together",
        "detail": "together",
        "documentation": {}
    },
    {
        "label": "gettext",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gettext",
        "description": "gettext",
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "pefile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pefile",
        "description": "pefile",
        "detail": "pefile",
        "documentation": {}
    },
    {
        "label": "DockHandler",
        "importPath": "binaryninjaui",
        "description": "binaryninjaui",
        "isExtraImport": true,
        "detail": "binaryninjaui",
        "documentation": {}
    },
    {
        "label": "Transform",
        "importPath": "binaryninja.transform",
        "description": "binaryninja.transform",
        "isExtraImport": true,
        "detail": "binaryninja.transform",
        "documentation": {}
    },
    {
        "label": "cutter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cutter",
        "description": "cutter",
        "detail": "cutter",
        "documentation": {}
    },
    {
        "label": "java.io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "java.io",
        "description": "java.io",
        "detail": "java.io",
        "documentation": {}
    },
    {
        "label": "DefinedDataIterator",
        "importPath": "ghidra.program.util",
        "description": "ghidra.program.util",
        "isExtraImport": true,
        "detail": "ghidra.program.util",
        "documentation": {}
    },
    {
        "label": "MD5Utilities",
        "importPath": "ghidra.util",
        "description": "ghidra.util",
        "isExtraImport": true,
        "detail": "ghidra.util",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageQt",
        "importPath": "PIL.ImageQt",
        "description": "PIL.ImageQt",
        "isExtraImport": true,
        "detail": "PIL.ImageQt",
        "documentation": {}
    },
    {
        "label": "bytes",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCoreApplication",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCursor",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFrame",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QLineEdit",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSpacerItem",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QAbstractItemModel",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCoreApplication",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QAbstractItemView",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QComboBox",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCursor",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QEvent",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFrame",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QHeaderView",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QLabel",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QLineEdit",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPainter",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPoint",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPointF",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QProgressBar",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSortFilterProxyModel",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStandardItem",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTreeView",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QThread",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QAbstractItemView",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QComboBox",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCoreApplication",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCursor",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QEvent",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFrame",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QGroupBox",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QLineEdit",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMetaObject",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QProgressBar",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QRect",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QScrollArea",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSpacerItem",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSplitter",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStandardItem",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QThread",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCoreApplication",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMessageBox",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTranslator",
        "importPath": "idaclu.qt_shims",
        "description": "idaclu.qt_shims",
        "isExtraImport": true,
        "detail": "idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "plg_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "ida_shims",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "plg_utils",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "idaclu_gui",
        "importPath": "idaclu",
        "description": "idaclu",
        "isExtraImport": true,
        "detail": "idaclu",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "i18n",
        "importPath": "idaclu.qt_utils",
        "description": "idaclu.qt_utils",
        "isExtraImport": true,
        "detail": "idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "mmap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap",
        "description": "mmap",
        "detail": "mmap",
        "documentation": {}
    },
    {
        "label": "drcov",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "drcov",
        "description": "drcov",
        "detail": "drcov",
        "documentation": {}
    },
    {
        "label": "ssdeep",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ssdeep",
        "description": "ssdeep",
        "detail": "ssdeep",
        "documentation": {}
    },
    {
        "label": "tlsh",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tlsh",
        "description": "tlsh",
        "detail": "tlsh",
        "documentation": {}
    },
    {
        "label": "ida_dirtree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_dirtree",
        "description": "ida_dirtree",
        "detail": "ida_dirtree",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "determine_ngram_database",
        "importPath": "ngrams",
        "description": "ngrams",
        "isExtraImport": true,
        "detail": "ngrams",
        "documentation": {}
    },
    {
        "label": "helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "helpers",
        "description": "helpers",
        "detail": "helpers",
        "documentation": {}
    },
    {
        "label": "Ui_PluginDialog",
        "importPath": "idaclu.ui_idaclu",
        "description": "idaclu.ui_idaclu",
        "isExtraImport": true,
        "detail": "idaclu.ui_idaclu",
        "documentation": {}
    },
    {
        "label": "FrameLayout",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "CluTreeView",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ConfigTool",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "FilterInputGroup",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "LabelTool",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "PaletteTool",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ProgressIndicator",
        "importPath": "idaclu.qt_widgets",
        "description": "idaclu.qt_widgets",
        "isExtraImport": true,
        "detail": "idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ResultModel",
        "importPath": "idaclu.models",
        "description": "idaclu.models",
        "isExtraImport": true,
        "detail": "idaclu.models",
        "documentation": {}
    },
    {
        "label": "ResultNode",
        "importPath": "idaclu.models",
        "description": "idaclu.models",
        "isExtraImport": true,
        "detail": "idaclu.models",
        "documentation": {}
    },
    {
        "label": "resource",
        "importPath": "idaclu.assets",
        "description": "idaclu.assets",
        "isExtraImport": true,
        "detail": "idaclu.assets",
        "documentation": {}
    },
    {
        "label": "resource",
        "importPath": "idaclu.assets",
        "description": "idaclu.assets",
        "isExtraImport": true,
        "detail": "idaclu.assets",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "keystone",
        "description": "keystone",
        "isExtraImport": true,
        "detail": "keystone",
        "documentation": {}
    },
    {
        "label": "six",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "six",
        "description": "six",
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "uEmu",
        "description": "uEmu",
        "isExtraImport": true,
        "detail": "uEmu",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "unicorn.mips_const",
        "description": "unicorn.mips_const",
        "isExtraImport": true,
        "detail": "unicorn.mips_const",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "ida_enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_enum",
        "description": "ida_enum",
        "detail": "ida_enum",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "HyaraIDA",
        "importPath": "hyara_lib.integration.ida_api",
        "description": "hyara_lib.integration.ida_api",
        "isExtraImport": true,
        "detail": "hyara_lib.integration.ida_api",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "threading,requests,json,zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading.requests.json.zlib",
        "description": "threading.requests.json.zlib",
        "detail": "threading.requests.json.zlib",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "idapal_qt_interface",
        "description": "idapal_qt_interface",
        "isExtraImport": true,
        "detail": "idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "aidapal_context",
        "description": "aidapal_context",
        "isExtraImport": true,
        "detail": "aidapal_context",
        "documentation": {}
    },
    {
        "label": "context_juicer",
        "importPath": "aidapal_helpers",
        "description": "aidapal_helpers",
        "isExtraImport": true,
        "detail": "aidapal_helpers",
        "documentation": {}
    },
    {
        "label": "ida_kernwin,ida_hexrays,ida_funcs,ida_name,ida_bytes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_kernwin.ida_hexrays.ida_funcs.ida_name.ida_bytes",
        "description": "ida_kernwin.ida_hexrays.ida_funcs.ida_name.ida_bytes",
        "detail": "ida_kernwin.ida_hexrays.ida_funcs.ida_name.ida_bytes",
        "documentation": {}
    },
    {
        "label": "ida_struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ida_struct",
        "description": "ida_struct",
        "detail": "ida_struct",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "MD5",
        "kind": 6,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "class MD5:\n    \"An implementation of the MD5 hash function in pure Python.\"\n    def __init__(self):\n        \"Initialisation.\"\n        # Initial 128 bit message digest (4 times 32 bit).\n        self.A = 0L\n        self.B = 0L\n        self.C = 0L\n        self.D = 0L\n        # Initial message length in bits(!).",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def F(x, y, z):\n    return (x & y) | ((~x) & z)\ndef G(x, y, z):\n    return (x & z) | (y & (~z))\ndef H(x, y, z):\n    return x ^ y ^ z\ndef I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def G(x, y, z):\n    return (x & z) | (y & (~z))\ndef H(x, y, z):\n    return x ^ y ^ z\ndef I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def H(x, y, z):\n    return x ^ y ^ z\ndef I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation\n    (now summed-up in one function).\n    \"\"\"",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "I",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def I(x, y, z):\n    return y ^ (x | (~z))\ndef XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation\n    (now summed-up in one function).\n    \"\"\"\n    res = 0L\n    res = res + a + func(b, c, d)",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "XX",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def XX(func, a, b, c, d, x, s, ac):\n    \"\"\"Wrapper for call distribution to functions F, G, H and I.\n    This replaces functions FF, GG, HH and II from \"Appl. Crypto.\n    Rotation is separate from addition to prevent recomputation\n    (now summed-up in one function).\n    \"\"\"\n    res = 0L\n    res = res + a + func(b, c, d)\n    res = res + x\n    res = res + ac",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def new(arg=None):\n    \"\"\"Return a new md5 object.\n    If arg is present, the method call update(arg) is made.\n    \"\"\"\n    md5 = MD5()\n    if arg:\n        md5.update(arg)\n    return md5\ndef md5(arg=None):\n    \"\"\"Same as new().",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "md5",
        "kind": 2,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "def md5(arg=None):\n    \"\"\"Same as new().\n    For backward compatibility reasons, this is an alternative\n    name for the new() function.\n    \"\"\"\n    return new(arg)",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "modules.md5hash.md5hash",
        "description": "modules.md5hash.md5hash",
        "peekOfCode": "__version__ = 0.9\nimport struct, string, copy\n# ======================================================================\n# Bit-Manipulation helpers\n#\n#   _long2bytes() was contributed by Barry Warsaw\n#   and is reused here with tiny modifications.\n# ======================================================================\ndef _long2bytes(n, blocksize=0):\n    \"\"\"Convert a long integer to a byte string.",
        "detail": "modules.md5hash.md5hash",
        "documentation": {}
    },
    {
        "label": "source_path",
        "kind": 5,
        "importPath": "modules.install",
        "description": "modules.install",
        "peekOfCode": "source_path = os.path.dirname(os.path.realpath(__file__))\nif install:\n    print (\"Installing python modules from %s to %s...\" % (source_path, py_module_path))\nelse:\n    print (\"Removing python modules from %s...\" % py_module_path)\nfor py_module in next(os.walk('.'))[1]:\n    src = os.path.join(source_path, py_module, py_module + '.py')\n    dst = os.path.join(py_module_path, py_module + '.py')\n    if install:\n        print (\"Installing %s...\" % py_module)",
        "detail": "modules.install",
        "documentation": {}
    },
    {
        "label": "context",
        "kind": 6,
        "importPath": "plugins.aidapal_context.context",
        "description": "plugins.aidapal_context.context",
        "peekOfCode": "class context:\n    '''\n    This class is a context manager that handles the setting and restoring of the context\n    window for aidapal.\n    The context window is a comment block that is inserted into the c style comment block\n    for each query to the model.\n    '''\n    context = []\n    def __init__(self):\n        self.context = []",
        "detail": "plugins.aidapal_context.context",
        "documentation": {}
    },
    {
        "label": "get_all_comments",
        "kind": 2,
        "importPath": "plugins.aidapal_helpers.context_juicer",
        "description": "plugins.aidapal_helpers.context_juicer",
        "peekOfCode": "def get_all_comments(ea):\n    '''\n    Helper to return both repeatable and non repeatable comments for a given address\n    returns empty string if no comment\n    '''\n    cmt = ida_bytes.get_cmt(ea,False)\n    r_cmt = ida_bytes.get_cmt(ea,True)\n    if cmt is None:\n        if r_cmt is None:\n            return ''",
        "detail": "plugins.aidapal_helpers.context_juicer",
        "documentation": {}
    },
    {
        "label": "gather_unique_data_references",
        "kind": 2,
        "importPath": "plugins.aidapal_helpers.context_juicer",
        "description": "plugins.aidapal_helpers.context_juicer",
        "peekOfCode": "def gather_unique_data_references(function_ea):\n    '''\n    Function to gather unique data references in a given function\n    returns a list of unique data references or empty list if none found\n    '''\n    try:\n        # Get the function object\n        func = ida_funcs.get_func(function_ea)\n        if not func:\n            logging.error(f\"Invalid function address: 0x{function_ea:X}\")",
        "detail": "plugins.aidapal_helpers.context_juicer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.bincat.python.bin.bincat",
        "description": "plugins.bincat.python.bin.bincat",
        "peekOfCode": "def main():\n    from pybincat import mlbincat\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"inputfile\",\n                        help=\"Input state file\")\n    parser.add_argument(\"outputfile\",\n                        help=\"file to output computed states into\")\n    parser.add_argument(\"logfile\",\n                        help=\"log file\")",
        "detail": "plugins.bincat.python.bin.bincat",
        "documentation": {}
    },
    {
        "label": "find_first_tainted_node",
        "kind": 2,
        "importPath": "plugins.bincat.python.bin.bincat",
        "description": "plugins.bincat.python.bin.bincat",
        "peekOfCode": "def find_first_tainted_node(p):\n        node0 = \"0\"\n        nextstates = collections.deque()\n        nextstates.append(node0)\n        tainted = []\n        while nextstates:\n            curstate = p[nextstates.popleft()]\n            nextstates.extend(p.edges[curstate.node_id])\n            for reg, vals in list(curstate.regaddrs.items()):\n                for val in vals:",
        "detail": "plugins.bincat.python.bin.bincat",
        "documentation": {}
    },
    {
        "label": "FakeMlbincat",
        "kind": 6,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "class FakeMlbincat(object):\n    \"\"\"\n    Do not actually load libbincat.so\n    \"\"\"\n    pass\nsys.modules['mlbincat'] = FakeMlbincat()\n# -- General configuration ------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "sys.modules['mlbincat']",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "sys.modules['mlbincat'] = FakeMlbincat()\n# -- General configuration ------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n]",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "extensions = [\n    'sphinx.ext.autodoc',\n]\nautodoc_default_flags = ['members', 'undoc-members', 'inherited-members',\n                         'show-inheritance']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_default_flags",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "autodoc_default_flags = ['members', 'undoc-members', 'inherited-members',\n                         'show-inheritance']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "templates_path = ['_templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "source_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 'BinCAT'\ncopyright = '2016, Airbus Group Innovations'\nauthor = 'Airbus Group Innovations'\n# The version info for the project you're documenting, acts as replacement for",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#source_encoding",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 'BinCAT'\ncopyright = '2016, Airbus Group Innovations'\nauthor = 'Airbus Group Innovations'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = 'BinCAT'\ncopyright = '2016, Airbus Group Innovations'\nauthor = 'Airbus Group Innovations'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "project = 'BinCAT'\ncopyright = '2016, Airbus Group Innovations'\nauthor = 'Airbus Group Innovations'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = 'current'\n# The full version, including alpha/beta/rc tags.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "copyright = '2016, Airbus Group Innovations'\nauthor = 'Airbus Group Innovations'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = 'current'\n# The full version, including alpha/beta/rc tags.\nrelease = 'current'",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "author = 'Airbus Group Innovations'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = 'current'\n# The full version, including alpha/beta/rc tags.\nrelease = 'current'\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "version = 'current'\n# The full version, including alpha/beta/rc tags.\nrelease = 'current'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# There are two options for replacing |today|: either, you set today to some",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "release = 'current'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n# The reST default role (used for this markup: `text`) to use for all",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#today",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#today_fmt",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "exclude_patterns = []\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#default_role",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#add_function_parentheses",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#add_module_names",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#show_authors",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#modindex_common_prefix",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#keep_warnings",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "todo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "html_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_options",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_path",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (relative to this directory) to use as a favicon of",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_title",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_short_title",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_logo",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_logo = None\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# Add any extra paths that contain custom files (such as robots.txt or",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_favicon",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "html_static_path = ['_static']\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_extra_path",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_extra_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_last_updated_fmt",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_smartypants",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_sidebars",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_additional_pages",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_domain_indices",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_index",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_split_index",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sourcelink",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sphinx",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_copyright",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_opensearch",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'\n#html_search_language = 'en'\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_file_suffix",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'\n#html_search_language = 'en'\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n#html_search_options = {'type': 'default'}\n# The name of a javascript file (relative to the configuration directory) that",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_search_language",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_search_language = 'en'\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n#html_search_options = {'type': 'default'}\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = 'scorer.js'\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'BinCATdoc'\n# -- Options for LaTeX output ---------------------------------------------",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_search_options",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_search_options = {'type': 'default'}\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = 'scorer.js'\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'BinCATdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#html_search_scorer",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#html_search_scorer = 'scorer.js'\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'BinCATdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "htmlhelp_basename = 'BinCATdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n# Latex figure (float) alignment",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "latex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n# Latex figure (float) alignment\n#'figure_align': 'htbp',\n}",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "latex_documents = [\n    (master_doc, 'BinCAT.tex', 'BinCAT Documentation',\n     'Airbus Group Innovations', 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#latex_logo",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#latex_use_parts",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_pagerefs",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_urls",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'bincat', 'BinCAT Documentation',",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#latex_appendices",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'bincat', 'BinCAT Documentation',\n     [author], 1)\n]",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#latex_domain_indices",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'bincat', 'BinCAT Documentation',\n     [author], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "man_pages = [\n    (master_doc, 'bincat', 'BinCAT Documentation',\n     [author], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#man_show_urls",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#man_show_urls = False\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'BinCAT', 'BinCAT Documentation',\n     author, 'BinCAT', 'One line description of project.',\n     'Miscellaneous'),\n]",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "texinfo_documents = [\n    (master_doc, 'BinCAT', 'BinCAT Documentation',\n     author, 'BinCAT', 'One line description of project.',\n     'Miscellaneous'),\n]\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_appendices",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_domain_indices",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_show_urls",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#texinfo_show_urls = 'footnote'\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_no_detailmenu",
        "kind": 5,
        "importPath": "plugins.bincat.python.doc.source.conf",
        "description": "plugins.bincat.python.doc.source.conf",
        "peekOfCode": "#texinfo_no_detailmenu = False",
        "detail": "plugins.bincat.python.doc.source.conf",
        "documentation": {}
    },
    {
        "label": "ColorTheme",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.colortheme",
        "description": "plugins.bincat.python.idabincat.hexview.colortheme",
        "peekOfCode": "class ColorTheme(object):\n    \"\"\" interface \"\"\"\n    def get_accent(self, index):\n        \"\"\"\n        :rtype: PyQt5.QtGui.QColor\n        \"\"\"\n        raise NotImplementedError()\nclass LightPastelColorTheme(ColorTheme):\n    \"\"\"\n    #####  Color Palette by Paletton.com",
        "detail": "plugins.bincat.python.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "LightPastelColorTheme",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.colortheme",
        "description": "plugins.bincat.python.idabincat.hexview.colortheme",
        "peekOfCode": "class LightPastelColorTheme(ColorTheme):\n    \"\"\"\n    #####  Color Palette by Paletton.com\n    #####  Palette URL: http://paletton.com/#uid=75a0u0kcglL4Zvw8Eq6eXhmkwen\n    *** Primary color:\n       shade 0 = #8B5674 = rgb(139, 86,116) = rgba(139, 86,116,1) = rgb0(0.545,0.337,0.455)\n       shade 1 = #C9AABC = rgb(201,170,188) = rgba(201,170,188,1) = rgb0(0.788,0.667,0.737)\n       shade 2 = #A77A93 = rgb(167,122,147) = rgba(167,122,147,1) = rgb0(0.655,0.478,0.576)\n       shade 3 = #6F3B58 = rgb(111, 59, 88) = rgba(111, 59, 88,1) = rgb0(0.435,0.231,0.345)\n       shade 4 = #5C2142 = rgb( 92, 33, 66) = rgba( 92, 33, 66,1) = rgb0(0.361,0.129,0.259)",
        "detail": "plugins.bincat.python.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "SolarizedColorTheme",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.colortheme",
        "description": "plugins.bincat.python.idabincat.hexview.colortheme",
        "peekOfCode": "class SolarizedColorTheme(ColorTheme):\n    \"\"\"\n    via http://ethanschoonover.com/solarized\n    solarized accent colors:\n        $yellow:    #b58900;\n        $orange:    #cb4b16;\n        $red:       #dc322f;\n        $magenta:   #d33682;\n        $violet:    #6c71c4;\n        $blue:      #268bd2;",
        "detail": "plugins.bincat.python.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "LoggingObject",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.common",
        "description": "plugins.bincat.python.idabincat.hexview.common",
        "peekOfCode": "class LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):\n        FUNCTION_NAME_INDEX = 3\n        return inspect.stack()[3][FUNCTION_NAME_INDEX]\n    def _formatFormatString(self, args):\n        return [self._getCallerFunction() + \": \" + args[0]] + [a for a in args[1:]]\n    def d(self, *args, **kwargs):",
        "detail": "plugins.bincat.python.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 2,
        "importPath": "plugins.bincat.python.idabincat.hexview.common",
        "description": "plugins.bincat.python.idabincat.hexview.common",
        "peekOfCode": "def h(i):\n    return hex(i).strip(\"L\")\ndef one(s):\n    for c in s:\n        return c\nclass LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):",
        "detail": "plugins.bincat.python.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "one",
        "kind": 2,
        "importPath": "plugins.bincat.python.idabincat.hexview.common",
        "description": "plugins.bincat.python.idabincat.hexview.common",
        "peekOfCode": "def one(s):\n    for c in s:\n        return c\nclass LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):\n        FUNCTION_NAME_INDEX = 3\n        return inspect.stack()[3][FUNCTION_NAME_INDEX]",
        "detail": "plugins.bincat.python.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "HexItemDelegate",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "class HexItemDelegate(QStyledItemDelegate):\n    pixcache = {}\n    def __init__(self, model, parent, *args):\n        super(HexItemDelegate, self).__init__(parent)\n        # compute size hint for hex view\n        dh = QTextDocument()\n        dh.setHtml(\"<font color='green'>DF</font>\")\n        self.hex_hint = QtCore.QSize(int(dh.idealWidth()-dh.documentMargin()), 22)\n        # compute size hint for char view\n        dc = QTextDocument()",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexTableModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "class HexTableModel(QAbstractTableModel):\n    FILTER = ''.join(\n        [(len(repr(chr(x))) == 3 or chr(x) == \"\\\\\") and chr(x) or\n         '.' for x in range(256)])\n    def __init__(self, meminfo, parent=None, *args):\n        super(HexTableModel, self).__init__(parent, *args)\n        self._meminfo = None\n        self._rowcount = None\n        self.setNewMem(meminfo)\n    def setNewMem(self, meminfo):",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexItemSelectionModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "class HexItemSelectionModel(QItemSelectionModel):\n    selectionRangeChanged = pyqtSignal([int])\n    def __init__(self, model, view):\n        \"\"\"\n        :type view: HexTableView\n        \"\"\"\n        super(HexItemSelectionModel, self).__init__(model)\n        self._model = model\n        self._view = view\n        self._start_qindex = None",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexTableView",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "class HexTableView(QTableView):\n    \"\"\" table view that handles click events for better selection handling \"\"\"\n    leftMousePressed = pyqtSignal([QMouseEvent])\n    leftMousePressedIndex = pyqtSignal([QModelIndex])\n    leftMouseMoved = pyqtSignal([QMouseEvent])\n    leftMouseMovedIndex = pyqtSignal([QModelIndex])\n    leftMouseReleased = pyqtSignal([QMouseEvent])\n    leftMouseReleasedIndex = pyqtSignal([QModelIndex])\n    moveKeyPressed = pyqtSignal([QKeySequence])\n    selectKeyPressed = pyqtSignal([QKeySequence])",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexViewWidget",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "class HexViewWidget(QWidget):\n    originsChanged = pyqtSignal()\n    newOverride = pyqtSignal(int, int, bool)\n    def __init__(self, meminfo, parent=None):\n        super(HexViewWidget, self).__init__()\n        self.setupUi(self)\n        self._meminfo = meminfo\n        self._model = HexTableModel(self._meminfo)\n        self._origins = []\n        # ripped from pyuic5 ui/hexview.ui",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "bc_log = logging.getLogger('bincat.hexview')\nbc_log.setLevel(logging.DEBUG)\nclass HexItemDelegate(QStyledItemDelegate):\n    pixcache = {}\n    def __init__(self, model, parent, *args):\n        super(HexItemDelegate, self).__init__(parent)\n        # compute size hint for hex view\n        dh = QTextDocument()\n        dh.setHtml(\"<font color='green'>DF</font>\")\n        self.hex_hint = QtCore.QSize(int(dh.idealWidth()-dh.documentMargin()), 22)",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "Origin",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.hexview.hexview",
        "description": "plugins.bincat.python.idabincat.hexview.hexview",
        "peekOfCode": "Origin = namedtuple(\"Origin\", [\"offset\", \"name\"])\nclass HexViewWidget(QWidget):\n    originsChanged = pyqtSignal()\n    newOverride = pyqtSignal(int, int, bool)\n    def __init__(self, meminfo, parent=None):\n        super(HexViewWidget, self).__init__()\n        self.setupUi(self)\n        self._meminfo = meminfo\n        self._model = HexTableModel(self._meminfo)\n        self._origins = []",
        "detail": "plugins.bincat.python.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "pesection_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "class pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),\n                (\"s_lnnoptr\", ctypes.c_int),\n                (\"s_nreloc\", ctypes.c_ushort),\n                (\"s_nlnno\", ctypes.c_ushort),",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "elf_ph_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "class elf_ph_t(ctypes.Structure):\n    _fields_ = [(\"p_type\", ctypes.c_uint),\n                (\"p_flags\", ctypes.c_uint),\n                (\"p_offset\", ctypes.c_ulonglong),\n                (\"p_vaddr\", ctypes.c_ulonglong),\n                (\"p_paddr\", ctypes.c_ulonglong),\n                (\"p_filesz\", ctypes.c_ulonglong),\n                (\"p_memsz\", ctypes.c_ulonglong),\n                (\"p_align\", ctypes.c_ulonglong)]\nclass ConfigHelpers(object):",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "class ConfigHelpers(object):\n    \"\"\"\n    Holds helpers, that transform data obtained from ida API.\n    Used to generate default configuration.\n    \"\"\"\n    ftypes = {idaapi.f_PE: \"pe\",\n              idaapi.f_ELF: \"elf\",\n              idaapi.f_MACHO: \"macho\"}\n    @staticmethod\n    def get_file_type():",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "InitialState",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "class InitialState(object):\n    \"\"\"\n    Stores the initial state configuration:\n        * registers\n        * memory\n    \"\"\"\n    def __init__(self, entrypoint=None, config=None):\n        if config:\n            arch = config.get('program', 'architecture')\n            self.mem = []",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "class AnalyzerConfig(object):\n    \"\"\"\n    Handles configuration files for the analyzer.\n    \"\"\"\n    def __init__(self, config=None):\n        self.version = \"0.0\"\n        if config:\n            self._config = config\n            self.init_state = InitialState(config=config)\n        else:",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "class AnalyzerConfigurations(object):\n    def __init__(self, state):\n        self._state = state\n        self._netnode = idabincat.netnode.Netnode()\n        #: name -> serialized AnalyzerConfig\n        self._configs = {}\n        #: address (int) -> name\n        self._prefs = {}\n        #: list of functions to be called prior to updating overrides\n        self.pre_callbacks = []",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "bc_log = logging.getLogger('bincat-cfg')\nbc_log.setLevel(logging.INFO)\nX64_GPR = ['rax', 'rcx', 'rdx', 'rbx', 'rbp', 'rsi', 'rdi', 'rsp']+[\"r%d\" % d for d in range(8, 16)]\nX86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X64_GPR",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "X64_GPR = ['rax', 'rcx', 'rdx', 'rbx', 'rbp', 'rsi', 'rdi', 'rsp']+[\"r%d\" % d for d in range(8, 16)]\nX86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X86_GPR",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.analyzer_conf",
        "description": "plugins.bincat.python.idabincat.analyzer_conf",
        "peekOfCode": "X86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),\n                (\"s_lnnoptr\", ctypes.c_int),",
        "detail": "plugins.bincat.python.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerUnavailable",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class AnalyzerUnavailable(Exception):\n    pass\nclass BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "BincatPlugin",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(BincatPlugin, self).__init__()",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class Analyzer(object):\n    def __init__(self, path, finish_cb):\n        self.path = path\n        self.finish_cb = finish_cb\n    def generate_tnpk(self, fname=None, destfname=None):\n        \"\"\"\n        Generates TNPK file for provided fname. If None, generate one for the\n        binary that is currently being analyzed in IDA, using IDA-provided\n        headers.\n        Returns file path to generated tnpk (string), or None if generation was",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzerTimer",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class LocalAnalyzerTimer(object):\n    \"\"\"\n    IDA timer used to kill the BinCAT analyzer if the user\n    cancels the analysis\n    \"\"\"\n    def __init__(self, qprocess):\n        self.interval = 500  # ms\n        self.qprocess = qprocess\n        self.timer = idaapi.register_timer(self.interval, self)\n        if self.timer is None:",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzer",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class LocalAnalyzer(Analyzer):\n    \"\"\"\n    Runs BinCAT locally using QProcess.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        Analyzer.__init__(self, *args, **kwargs)\n    def generate_tnpk(self, fname=None, destfname=None):\n        if fname:\n            imports_data = open(fname, 'r').read()\n        else:",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "WebAnalyzer",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class WebAnalyzer(Analyzer):\n    API_VERSION = \"1.2\"\n    def __init__(self, *args, **kwargs):\n        Analyzer.__init__(self, *args, **kwargs)\n        self.server_url = PluginOptions.get(\"server_url\").rstrip(\"/\")\n        self.reachable_server = False\n        self.check_version()  # raises exception if server is unreachable\n        self.reachable_server = True\n    def check_version(self):\n        try:",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class State(object):\n    \"\"\"\n    Container for (static) plugin state related data & methods.\n    \"\"\"\n    def __init__(self):\n        self.current_ea = None\n        self.cfa = None\n        self.current_node = None\n        #: list of node ids (int)\n        self.current_node_ids = []",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "CallbackWrappedList",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "class CallbackWrappedList(MutableSequence):\n    \"\"\"\n    Acts as a List object, wraps write access with calls to properly invalidate\n    models associated with View GUI objects.\n    Should store only immutable objects.\n    \"\"\"\n    def __init__(self):\n        self._data = []\n        #: list of functions to be called prior to updating list\n        self.pre_callbacks = []",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "dedup_loglines",
        "kind": 2,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "def dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:\n                return True\n        if n == 2:",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return BincatPlugin()",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.bcplugin",
        "description": "plugins.bincat.python.idabincat.bcplugin",
        "peekOfCode": "bc_log = logging.getLogger('bincat.plugin')\nbc_log.setLevel(logging.INFO)\ndef dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:",
        "detail": "plugins.bincat.python.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "dump_binary",
        "kind": 2,
        "importPath": "plugins.bincat.python.idabincat.dump_binary",
        "description": "plugins.bincat.python.idabincat.dump_binary",
        "peekOfCode": "def dump_binary(path):\n    sections = []\n    current_offset = 0\n    with open(path, 'wb+') as f:\n        # over all segments\n        for n in range(ida_segment.get_segm_qty()):\n            seg = ida_segment.getnseg(n)\n            start_ea = seg.start_ea\n            end_ea = seg.end_ea\n            size = end_ea - start_ea",
        "detail": "plugins.bincat.python.idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "dump_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.dump_binary",
        "description": "plugins.bincat.python.idabincat.dump_binary",
        "peekOfCode": "dump_log = logging.getLogger('bincat.plugin.dump_binary')\ndump_log.setLevel(logging.DEBUG)\n# Dumps a remapped binary (as seen in IDA to disk)\n# returns a list of sections\n# [(name, va, vasize, raw_addr, raw_size)]\ndef dump_binary(path):\n    sections = []\n    current_offset = 0\n    with open(path, 'wb+') as f:\n        # over all segments",
        "detail": "plugins.bincat.python.idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "EditConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()\n        self.configtxt.setSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                     QtWidgets.QSizePolicy.Expanding)\n        self.btn_save = QtWidgets.QPushButton('&Save', self)\n        self.btn_save.clicked.connect(self.use_config)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATOptionsForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATOptionsForm_t(QtWidgets.QDialog):\n    def __init__(self, state):\n        super(BinCATOptionsForm_t, self).__init__()\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        lbl_default_bhv = QtWidgets.QLabel(\"Default behaviour\")\n        # Save config in IDB by default\n        self.chk_save = QtWidgets.QCheckBox('Save &configuration to IDB')\n        self.chk_load = QtWidgets.QCheckBox('&Load configuration from IDB')\n        btn_start = QtWidgets.QPushButton('&Save', self)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "Meminfo",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class Meminfo(object):\n    \"\"\"\n    Helper class to access memory as a str\n    \"\"\"\n    def __init__(self, unrel, region, ranges):\n        self.unrel = unrel\n        self.region = region\n        #: list of ranges: [[begin int, end int], ...]\n        self.ranges = ranges\n        self.start = ranges[0][0]",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATMemForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATMemForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT memory display form.\n    \"\"\"\n    def __init__(self, state):\n        super(BinCATMemForm_t, self).__init__()\n        self.s = state\n        self.shown = False\n        self.created = False\n        self.hexwidget = None",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATConfigForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATConfigForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT initial configuration form\n    This form allows the definition and edition of\n    initial registers and memory\n    \"\"\"\n    def __init__(self, state, cfgregmodel, cfgmemmodel):\n        super(BinCATConfigForm_t, self).__init__()\n        self.s = state\n        self.cfgregmodel = cfgregmodel",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATDebugForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATDebugForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Debug form: display IL and instruction bytes, if present in BinCAT\n    output.\n    \"\"\"\n    def __init__(self, state):\n        super(BinCATDebugForm_t, self).__init__()\n        self.s = state\n        self.shown = False\n        self.created = False",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "RegisterItemDelegate",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class RegisterItemDelegate(QtWidgets.QStyledItemDelegate):\n    \"\"\"\n    http://stackoverflow.com/questions/35397943/how-to-make-a-fast-qtableview-with-html-formatted-and-clickable-cells\n    Represents tainted data with colors in the BinCATRegistersForm_t\n    \"\"\"\n    def paint(self, painter, options, index):\n        self.initStyleOption(options, index)\n        painter.save()\n        doc = QtGui.QTextDocument()\n        doc.setHtml(options.text)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATRegistersForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATRegistersForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Register values form\n    This form displays the values of tainted registers\n    \"\"\"\n    def __init__(self, state, regsinfo_model):\n        super(BinCATRegistersForm_t, self).__init__()\n        self.s = state\n        self.regsinfo_model = regsinfo_model\n        self.shown = False",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "InitConfigMemModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class InitConfigMemModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATConfigForm_t TableView memory widget.\n    Contains tainting and values for memory\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(InitConfigMemModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"region\", \"address\", \"value\"]\n        #: list of Value (addresses)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "InitConfigRegModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class InitConfigRegModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATConfigForm_t TableView register's widget.\n    Contains tainting and values for registers\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(InitConfigRegModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"register\", \"value\", \"top\", \"taint\"]\n        #: list of Value (addresses)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "RegistersInfoModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class RegistersInfoModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATRegistersForm TableView widgets.\n    Contains tainting and values for registers\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(RegistersInfoModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"register\", \"value\"]\n        self.colswidths = [90, 90]",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATOverridesForm_t",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATOverridesForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Overrides display form\n    Displays taint overrides defined by the user.\n    An override is defined by:\n    * an address\n    * a register name (memory: not supported yet)\n    * a taint value\n    \"\"\"\n    def __init__(self, state, overrides_model, nops_model, skips_model):",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "OverridesModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class OverridesModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(OverridesModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"eip\", \"addr or reg\", \"[value][!taint]\"]\n    def data(self, index, role):\n        if role not in (Qt.ForegroundRole, Qt.DisplayRole,\n                        Qt.EditRole, Qt.ToolTipRole):\n            return",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATTableView",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class BinCATTableView(QtWidgets.QTableView):\n    def __init__(self, model, parent=None):\n        super(BinCATTableView, self).__init__(parent)\n        self.m = model\n        self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)\n    def contextMenuEvent(self, event):\n        if (self.m.rowCount(None) == 0 or\n                len(self.selectedIndexes()) == 0):\n            return",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "SkipsModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class SkipsModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(SkipsModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"address or function name\", \"arg_nb\", \"ret_val\"]\n    def data(self, index, role):\n        if role not in (Qt.DisplayRole, Qt.EditRole, Qt.ToolTipRole):\n            return\n        col = index.column()",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "NopsModel",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class NopsModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(NopsModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"address or function name\"]\n    def data(self, index, role):\n        if role not in (Qt.DisplayRole, Qt.EditRole, Qt.ToolTipRole):\n            return\n        row = index.row()",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleAnalyzeHere",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleAnalyzeHere(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/ Taint from here\n    base class is not a newstyle class...\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        self.s.gui.BinCATConfigForm.launch_analysis()",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleAddOverride",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleAddOverride(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Add Override\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        v = ida_kernwin.get_current_viewer()\n        thing = ida_kernwin.get_highlight(v)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleNopThisInstruction",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleNopThisInstruction(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Replace this instruction with nop\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        self.s.nops.append([\"0x%x\" % self.s.current_ea])\n        return 1",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleSkipThisFunction",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleSkipThisFunction(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Skip this function...\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        argret, res = QtWidgets.QInputDialog.getText(\n            None,",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleOptions",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleOptions(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Options\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        # display config window\n        bc_conf_form = BinCATOptionsForm_t(self.s)\n        bc_conf_form.exec_()",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleRemap",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleRemap(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Options\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        # display config window\n        fname = ConfigHelpers.askfile(\"*.*\", \"Save to binary\")\n        if fname:",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleShowWindows",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class HandleShowWindows(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Show windows\n    \"\"\"\n    def __init__(self, gui):\n        self.gui = gui\n    def activate(self, ctx):\n        self.gui.show_windows()\n        return 1\n    def update(self, ctx):",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    \"\"\"\n    Class Hooks for BinCAT menu\n    \"\"\"\n    def __init__(self, state, gui):\n        super(Hooks, self).__init__()\n        self.s = state\n        self.gui = gui\n    def ready_to_run(self):\n        self.gui.show_windows()",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GUI",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "class GUI(object):\n    def __init__(self, state):\n        \"\"\"\n        Instanciate BinCAT views\n        \"\"\"\n        self.s = state\n        self.regsinfo_model = RegistersInfoModel(state)\n        self.configregmodel = InitConfigRegModel(state)\n        self.configmemmodel = InitConfigMemModel(state)\n        self.BinCATRegistersForm = BinCATRegistersForm_t(state, self.regsinfo_model)",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "kind": 2,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "def taint_color(n):\n    r, g, b = COLS[n % len(COLS)]\n    return b | g << 8 | r << 16\nclass EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()\n        self.configtxt.setSizePolicy(QtWidgets.QSizePolicy.Expanding,",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "bc_log = logging.getLogger('bincat.gui')\nbc_log.setLevel(logging.DEBUG)\nGREENS = [\n    (169, 241, 100),\n    (207, 207, 154),\n    (192, 195, 188),\n    (158, 199, 191),\n    (195, 238, 153),\n    (179, 179, 135),\n    (118, 155, 148),",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GREENS",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "GREENS = [\n    (169, 241, 100),\n    (207, 207, 154),\n    (192, 195, 188),\n    (158, 199, 191),\n    (195, 238, 153),\n    (179, 179, 135),\n    (118, 155, 148),\n    (195, 207, 184),\n    (241, 242, 184),",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BLUES_AND_YELLOWS",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "BLUES_AND_YELLOWS = [\n    (173, 109,   0),\n    (  2,  28,  66),\n    (173, 170,   0),\n    ( 41,   2,  67),\n    (140,  88,   0),\n    (  4,  68, 162),\n    (246, 241,   0),\n    ( 57,   2,  94),\n    (207, 130,   0),",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "COLS",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.gui",
        "description": "plugins.bincat.python.idabincat.gui",
        "peekOfCode": "COLS = GREENS  # BLUES_AND_YELLOWS\ndef taint_color(n):\n    r, g, b = COLS[n % len(COLS)]\n    return b | g << 8 | r << 16\nclass EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()",
        "detail": "plugins.bincat.python.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "NetnodeCorruptError",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "class NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2\n    Conceptually, this netnode class represents is a key-value store",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "Netnode",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "class Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2\n    Conceptually, this netnode class represents is a key-value store\n      uniquely identified by a namespace.\n    This class abstracts over some of the peculiarities of the low-level",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "BLOB_SIZE",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "BLOB_SIZE = 1024\nOUR_NETNODE = \"$ com.bincat\"\nINT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "OUR_NETNODE",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "OUR_NETNODE = \"$ com.bincat\"\nINT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "INT_KEYS_TAG",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "INT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "STR_KEYS_TAG",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "STR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "STR_TO_INT_MAP_TAG",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "STR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "INT_TO_INT_MAP_TAG",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "INT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.netnode",
        "description": "plugins.bincat.python.idabincat.netnode",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2",
        "detail": "plugins.bincat.python.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "NpkGenException",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.npkgen",
        "description": "plugins.bincat.python.idabincat.npkgen",
        "peekOfCode": "class NpkGenException(Exception):\n    pass\nclass NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later\n        self.structs = set()\n        # add missing #defines",
        "detail": "plugins.bincat.python.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "NpkGen",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.npkgen",
        "description": "plugins.bincat.python.idabincat.npkgen",
        "peekOfCode": "class NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later\n        self.structs = set()\n        # add missing #defines\n        self.imports.append(\"#define __cdecl\")\n        nimps = idaapi.get_import_module_qty()",
        "detail": "plugins.bincat.python.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "npk_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.npkgen",
        "description": "plugins.bincat.python.idabincat.npkgen",
        "peekOfCode": "npk_log = logging.getLogger('bincat.plugin.npkgen')\nnpk_log.setLevel(logging.INFO)\nclass NpkGenException(Exception):\n    pass\nclass NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later",
        "detail": "plugins.bincat.python.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "kind": 6,
        "importPath": "plugins.bincat.python.idabincat.plugin_options",
        "description": "plugins.bincat.python.idabincat.plugin_options",
        "peekOfCode": "class PluginOptions(object):\n    _options = None\n    @classmethod\n    def init(cls):\n        # Configuration files path\n        idausr = ida_diskio.get_user_idadir()\n        cls.config_path = os.path.join(idausr, \"plugins\", \"idabincat\")\n        # Plugin options\n        def_options = {\n            \"save_to_idb\": \"False\",  # config only - results are always saved",
        "detail": "plugins.bincat.python.idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bincat.python.idabincat.plugin_options",
        "description": "plugins.bincat.python.idabincat.plugin_options",
        "peekOfCode": "bc_log = logging.getLogger('bincat.gui.pluginoptions')\nbc_log.setLevel(logging.DEBUG)\nclass PluginOptions(object):\n    _options = None\n    @classmethod\n    def init(cls):\n        # Configuration files path\n        idausr = ida_diskio.get_user_idadir()\n        cls.config_path = os.path.join(idausr, \"plugins\", \"idabincat\")\n        # Plugin options",
        "detail": "plugins.bincat.python.idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "plugins.bincat.python.pybincat.tools.parsers",
        "description": "plugins.bincat.python.pybincat.tools.parsers",
        "peekOfCode": "def memoize(f):\n    \"\"\" Memoization decorator for a function taking a single argument \"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n@memoize\ndef parse_val(s):\n    if s[0] not in '0123456789_?' or '_bincat_tmp' in s:",
        "detail": "plugins.bincat.python.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "parse_val",
        "kind": 2,
        "importPath": "plugins.bincat.python.pybincat.tools.parsers",
        "description": "plugins.bincat.python.pybincat.tools.parsers",
        "peekOfCode": "def parse_val(s):\n    if s[0] not in '0123456789_?' or '_bincat_tmp' in s:\n        # it's a register\n        return s, 0, 0\n    tbvals = dict.fromkeys([\"?\", \"_\"], 0)\n    val = None\n    bdict = {\"0x\": (16, \"f\"),\n             \"0o\": (8, \"7\"),\n             \"0b\": (2, \"1\")}\n    for p in s.split(\",\"):",
        "detail": "plugins.bincat.python.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "val2str",
        "kind": 2,
        "importPath": "plugins.bincat.python.pybincat.tools.parsers",
        "description": "plugins.bincat.python.pybincat.tools.parsers",
        "peekOfCode": "def val2str(val, vtop, vbot, length, base=None, merged=False):\n    if base == 16 or not base:\n        if length == 0 or length is None:\n            fstring = '{0:X}'\n        else:\n            if length % 4 == 0:\n                length = length / 4\n            else:\n                length = (length / 4)+1\n            fstring = ('{0:0>%dX}' % length)",
        "detail": "plugins.bincat.python.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "PyBinCATParseError",
        "kind": 6,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "class PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]\n    _valcache = {}\n    arch = None",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "CFA",
        "kind": 6,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "class CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]\n    _valcache = {}\n    arch = None\n    def __init__(self, addr_nodes, edges, nodes, taintsrcs):\n        #: Value (address) -> [node_id]. Nodes marked \"final\" come first.",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "class Node(object):\n    \"\"\"\n    Stores node data for a given node_id.\n    1 or more Unrel may be stored, each containg regaddrs, regtypes\n    \"\"\"\n    __slots__ = ['address', 'node_id', 'final', 'statements', 'bytes',\n                 'tainted', 'taintsrc', 'unrels']\n    def __init__(self, node_id, address=None, lazy_init=None):\n        self.address = address\n        #: str",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Value",
        "kind": 6,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "class Value(object):\n    __slots__ = ['vtop', 'vbot', 'taint', 'ttop', 'tbot', 'length', 'value', 'region']\n    def __init__(self, region, value, length=None, vtop=0, vbot=0, taint=0,\n                 ttop=0, tbot=0):\n        self.region = region.lower()\n        self.value = value\n        if not length and region == 'reg':\n            self.length = reg_len(value)\n        else:\n            self.length = length",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Unrel",
        "kind": 6,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "class Unrel(object):\n    \"\"\"\n    Contains memory & registers status for a given (Node, unrel_id)\n    bincat output format examples:\n    reg [eax] = 0xfff488!0\n    111  222    33333333333\n    mem[0x1234, 0x1236] = 0x20, 0x0\n    111 2222222222222222  33333 3333 <-- list of 2 valtaint\n    mem[0x24*32] = 0b????1111!0b????0000\n    111 22222222   3333333333333333333333 <-- list of 1 valtaint",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "reg_len",
        "kind": 2,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "def reg_len(regname):\n    \"\"\"\n    Returns register length in bits. CFA.arch must have been set, either\n    manually or by parsing a bincat output file.\n    \"\"\"\n    if CFA.arch == \"armv8\":\n        return {\n            \"x0\": 64, \"x1\": 64, \"x2\": 64, \"x3\": 64, \"x4\": 64, \"x5\": 64,\n            \"x6\": 64, \"x7\": 64, \"x8\": 64, \"x9\": 64, \"x10\": 64, \"x11\": 64,\n            \"x12\": 64, \"x13\": 64, \"x14\": 64, \"x15\": 64, \"x16\": 64, \"x17\": 64,",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "PRETTY_REGIONS",
        "kind": 5,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "PRETTY_REGIONS = {'': 'global', 'h': 'heap',\n                  'b': 'bottom', 't': 'top'}  # used for pointers only\n#: split src region + address (left of '=')\nRE_REGION_ADDR = re.compile(r\"(?P<region>reg|mem|h[0-9]+)\\[(?P<addr>[^]]+)\\]\")\n#: split value\nRE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_REGION_ADDR",
        "kind": 5,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "RE_REGION_ADDR = re.compile(r\"(?P<region>reg|mem|h[0-9]+)\\[(?P<addr>[^]]+)\\]\")\n#: split value\nRE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_VALTAINT",
        "kind": 5,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "RE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_NODE_UNREL",
        "kind": 5,
        "importPath": "plugins.bincat.python.pybincat.cfa",
        "description": "plugins.bincat.python.pybincat.cfa",
        "peekOfCode": "RE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]",
        "detail": "plugins.bincat.python.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def home():\n    return flask.make_response(\n        \"This server runs BinCAT, API version %s\" % API_VERSION, 200)\n@app.route(\"/version\")\ndef version():\n    return API_VERSION\n@app.route(\"/download/<sha256>/<string:compression>\", methods=['HEAD', 'GET'])\n@app.route(\"/download/<sha256>\", methods=['HEAD', 'GET'],\n           defaults={'compression': 'none'})\ndef download(sha256, compression):",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def version():\n    return API_VERSION\n@app.route(\"/download/<sha256>/<string:compression>\", methods=['HEAD', 'GET'])\n@app.route(\"/download/<sha256>\", methods=['HEAD', 'GET'],\n           defaults={'compression': 'none'})\ndef download(sha256, compression):\n    if not SHA256_RE.match(sha256):\n        return flask.make_response(\n            \"SHA256 expected as endpoint parameter.\", 400)\n    sha256 = sha256.lower()",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "download",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def download(sha256, compression):\n    if not SHA256_RE.match(sha256):\n        return flask.make_response(\n            \"SHA256 expected as endpoint parameter.\", 400)\n    sha256 = sha256.lower()\n    filename = os.path.join(app.config['BINARY_STORAGE_FOLDER'], sha256)\n    if os.path.isfile(filename):\n        with open(filename, 'rb') as f:\n            if compression == 'zlib':\n                return zlib.compress(f.read())",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "upload",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def upload():\n    if 'file' not in flask.request.files:\n        return flask.make_response(\n            \"This request was expected to include a file named 'file'.\", 400)\n    f = flask.request.files['file']\n    sha256 = store_string_to_file(f.read())\n    result = {'sha256': sha256}\n    return flask.make_response(flask.jsonify(**result), 200)\ndef store_string_to_file(s, alt_path=None):\n    \"\"\"",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "store_string_to_file",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def store_string_to_file(s, alt_path=None):\n    \"\"\"\n    Write file to storage, with hardlink to alt_path if supplied\n    \"\"\"\n    h = calc_sha256(s)\n    fname = os.path.join(app.config['BINARY_STORAGE_FOLDER'], h)\n    with open(fname, 'wb') as f:\n        f.write(s)\n    if alt_path is not None:\n        try:",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "calc_sha256",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def calc_sha256(s):\n    h = hashlib.new('sha256')\n    h.update(s)\n    return h.hexdigest().lower()\n@app.route(\"/analyze\", methods=['POST'])\ndef analyze():\n    if 'init.ini' not in flask.request.files:\n        return flask.make_response(\n            \"No file named 'init.ini' has been uploaded.\", 400)\n    result = {}",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "analyze",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def analyze():\n    if 'init.ini' not in flask.request.files:\n        return flask.make_response(\n            \"No file named 'init.ini' has been uploaded.\", 400)\n    result = {}\n    init_file = flask.request.files['init.ini']\n    init_file.seek(0)\n    # validation: valid ini file + referenced binary file has already been\n    # uploaded\n    config = configparser.RawConfigParser()",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "convert_to_tnpk",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def convert_to_tnpk(sha256):\n    if not SHA256_RE.match(sha256):\n        return flask.make_response(\n            \"SHA256 expected as endpoint parameter.\", 400)\n    fpath = os.path.join(app.config['BINARY_STORAGE_FOLDER'], sha256)\n    if not os.path.exists(fpath):\n        return flask.make_response(\n            \"Input file %s has not yet been uploaded.\" % sha256, 400)\n    with open(fpath, 'rb') as f:\n        headers_data = f.read()",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "run_bincat",
        "kind": 2,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "def run_bincat(dirname):\n    # do not use chroot: not compatible with grsec\n    cmdline = (\"%s --nosound --caps.drop=all\"\n               \" --quiet\"\n               \" --private\"  # new /root, /home\n               \" --private-dev\"  # new /dev, few devices\n               \" --private-etc=ld.so.cache,ld.so.conf,ld.so.conf.d\"  # new /etc\n               \" --nogroups\"  # no supplementary groups\n               \" --noroot\"  # new user namespace\n               \" --nonewprivs\"  # NO_NEW_PRIVS",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "SHA256_RE",
        "kind": 5,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "SHA256_RE = re.compile('[a-fA-F0-9]{64}')\napp = flask.Flask(__name__)\nAPI_VERSION = \"1.2\"\n# check existence of binary storage folder\nif 'BINARY_STORAGE_FOLDER' not in app.config:\n    app.config['BINARY_STORAGE_FOLDER'] = '/tmp/bincat_web'\nif not os.path.isdir(app.config['BINARY_STORAGE_FOLDER']):\n    app.logger.error(\"Binary storage folder %s does not exist\",\n                     app.config['BINARY_STORAGE_FOLDER'])\n    sys.exit(1)",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "app = flask.Flask(__name__)\nAPI_VERSION = \"1.2\"\n# check existence of binary storage folder\nif 'BINARY_STORAGE_FOLDER' not in app.config:\n    app.config['BINARY_STORAGE_FOLDER'] = '/tmp/bincat_web'\nif not os.path.isdir(app.config['BINARY_STORAGE_FOLDER']):\n    app.logger.error(\"Binary storage folder %s does not exist\",\n                     app.config['BINARY_STORAGE_FOLDER'])\n    sys.exit(1)\n# check whether firejail is installed",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "API_VERSION",
        "kind": 5,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "API_VERSION = \"1.2\"\n# check existence of binary storage folder\nif 'BINARY_STORAGE_FOLDER' not in app.config:\n    app.config['BINARY_STORAGE_FOLDER'] = '/tmp/bincat_web'\nif not os.path.isdir(app.config['BINARY_STORAGE_FOLDER']):\n    app.logger.error(\"Binary storage folder %s does not exist\",\n                     app.config['BINARY_STORAGE_FOLDER'])\n    sys.exit(1)\n# check whether firejail is installed\nfirejail = distutils.spawn.find_executable(\"firejail\")",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "firejail",
        "kind": 5,
        "importPath": "plugins.bincat.python.webbincat.wsgi",
        "description": "plugins.bincat.python.webbincat.wsgi",
        "peekOfCode": "firejail = distutils.spawn.find_executable(\"firejail\")\nif firejail is None:\n    app.logger.error(\"firejail has not been installed\")\n    sys.exit(1)\n@app.route(\"/\")\ndef home():\n    return flask.make_response(\n        \"This server runs BinCAT, API version %s\" % API_VERSION, 200)\n@app.route(\"/version\")\ndef version():",
        "detail": "plugins.bincat.python.webbincat.wsgi",
        "documentation": {}
    },
    {
        "label": "plugin_dir",
        "kind": 5,
        "importPath": "plugins.bincat.python.install_plugin",
        "description": "plugins.bincat.python.install_plugin",
        "peekOfCode": "plugin_dir = os.path.join(idaapi.get_user_idadir(), \"plugins\")\nif not os.path.isdir(plugin_dir):\n    print(\"Creating plugin dir\")\n    os.makedirs(plugin_dir)\nbincat_path = os.path.dirname(os.path.realpath(__file__))\nsrc_idabincat = os.path.join(bincat_path, \"python\", \"idabincat\")\nsrc_pybincat = os.path.join(bincat_path, \"python\", \"pybincat\")\nif os.path.isdir(src_idabincat) and os.path.isdir(src_pybincat):\n    try:\n        print(\"Copying 'idabincat' to \" + plugin_dir)",
        "detail": "plugins.bincat.python.install_plugin",
        "documentation": {}
    },
    {
        "label": "bincat_path",
        "kind": 5,
        "importPath": "plugins.bincat.python.install_plugin",
        "description": "plugins.bincat.python.install_plugin",
        "peekOfCode": "bincat_path = os.path.dirname(os.path.realpath(__file__))\nsrc_idabincat = os.path.join(bincat_path, \"python\", \"idabincat\")\nsrc_pybincat = os.path.join(bincat_path, \"python\", \"pybincat\")\nif os.path.isdir(src_idabincat) and os.path.isdir(src_pybincat):\n    try:\n        print(\"Copying 'idabincat' to \" + plugin_dir)\n        shutil.copytree(src_idabincat, os.path.join(plugin_dir, \"idabincat\"), dirs_exist_ok=True)\n        bin_path = os.path.join(plugin_dir, \"idabincat\", \"bin\")\n        print(\"Copying 'bin' to \" + bin_path)\n        shutil.copytree(os.path.join(bincat_path, 'bin'), bin_path, dirs_exist_ok = True)",
        "detail": "plugins.bincat.python.install_plugin",
        "documentation": {}
    },
    {
        "label": "src_idabincat",
        "kind": 5,
        "importPath": "plugins.bincat.python.install_plugin",
        "description": "plugins.bincat.python.install_plugin",
        "peekOfCode": "src_idabincat = os.path.join(bincat_path, \"python\", \"idabincat\")\nsrc_pybincat = os.path.join(bincat_path, \"python\", \"pybincat\")\nif os.path.isdir(src_idabincat) and os.path.isdir(src_pybincat):\n    try:\n        print(\"Copying 'idabincat' to \" + plugin_dir)\n        shutil.copytree(src_idabincat, os.path.join(plugin_dir, \"idabincat\"), dirs_exist_ok=True)\n        bin_path = os.path.join(plugin_dir, \"idabincat\", \"bin\")\n        print(\"Copying 'bin' to \" + bin_path)\n        shutil.copytree(os.path.join(bincat_path, 'bin'), bin_path, dirs_exist_ok = True)\n        print(\"Copying 'pybincat' to \" + plugin_dir)",
        "detail": "plugins.bincat.python.install_plugin",
        "documentation": {}
    },
    {
        "label": "src_pybincat",
        "kind": 5,
        "importPath": "plugins.bincat.python.install_plugin",
        "description": "plugins.bincat.python.install_plugin",
        "peekOfCode": "src_pybincat = os.path.join(bincat_path, \"python\", \"pybincat\")\nif os.path.isdir(src_idabincat) and os.path.isdir(src_pybincat):\n    try:\n        print(\"Copying 'idabincat' to \" + plugin_dir)\n        shutil.copytree(src_idabincat, os.path.join(plugin_dir, \"idabincat\"), dirs_exist_ok=True)\n        bin_path = os.path.join(plugin_dir, \"idabincat\", \"bin\")\n        print(\"Copying 'bin' to \" + bin_path)\n        shutil.copytree(os.path.join(bincat_path, 'bin'), bin_path, dirs_exist_ok = True)\n        print(\"Copying 'pybincat' to \" + plugin_dir)\n        shutil.copytree(src_pybincat, os.path.join(plugin_dir, \"pybincat\"), dirs_exist_ok=True)",
        "detail": "plugins.bincat.python.install_plugin",
        "documentation": {}
    },
    {
        "label": "PyTest",
        "kind": 6,
        "importPath": "plugins.bincat.python.setup",
        "description": "plugins.bincat.python.setup",
        "peekOfCode": "class PyTest(Command):\n    description = \"run py.test unit tests\"\n    user_options = []\n    def initialize_options(self):\n        pass\n    def finalize_options(self):\n        pass\n    def run(self):\n        import sys,subprocess\n        errno = subprocess.call([sys.executable, 'runtests.py'])",
        "detail": "plugins.bincat.python.setup",
        "documentation": {}
    },
    {
        "label": "package_data_files",
        "kind": 5,
        "importPath": "plugins.bincat.python.setup",
        "description": "plugins.bincat.python.setup",
        "peekOfCode": "package_data_files = ['idabincat/conf/*ini']\nsetup(\n    cmdclass = {'test': PyTest},\n    name             = 'BinCAT',\n    version          = '0.1',\n    author           = 'Sarah Zennou',\n    author_email     = 'sarah.zennou@airbus.com',\n    description      = 'Binary Code Analysis Toolkit',\n    scripts          = ['bin/bincat.py'],\n    packages         = ['pybincat', 'pybincat/tools', 'idabincat', 'idabincat/hexview', 'webbincat'],",
        "detail": "plugins.bincat.python.setup",
        "documentation": {}
    },
    {
        "label": "TestValues_Meta",
        "kind": 6,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "class TestValues_Meta(type):\n    def __repr__(self):\n        return self._name\nclass TestValues(object, metaclass=TestValues_Meta):\n    _name = \"NA\"\n    hash_single = False\n    loop_cnt = [1, 15, 100]\n    op3 = [ 0, 1, 4, 7 ]\n    op5 = [ 0, 1, 8, 30, 31 ]\n    op6 = [ 0, 1, 0x3F ]",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "TestValues",
        "kind": 6,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "class TestValues(object, metaclass=TestValues_Meta):\n    _name = \"NA\"\n    hash_single = False\n    loop_cnt = [1, 15, 100]\n    op3 = [ 0, 1, 4, 7 ]\n    op5 = [ 0, 1, 8, 30, 31 ]\n    op6 = [ 0, 1, 0x3F ]\n    op6_32 = [ 0, 1, 31 ]\n    op8 =  [ 1, 0xff ]\n    op12_s = [-0x800, 0, 1, 0x7ff ]",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "Large",
        "kind": 6,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "class Large(TestValues):\n    _name = \"large\"\n    op8 = [ 0, 1, 2, 7, 8, 0xf, 0x10, 0x7f, 0x80, 0x81, 0xff]\n    op12_s = op8 + [-0x800, -0x100, -0xff, -1,  0x7ff ]\n    op16 = op8 +  [0x1234, 0x7fff, 0x8000, 0x8001, 0xfa72, 0xffff]\n    op16_s = op8 + [ 0x1234, 0x7fff, -0x8000 -0x7fff, -1]\n    op32 = op16 +  [0x12345678, 0x1812fada, 0x12a4b4cd,\n                    0x7fffffff, 0x80000000, 0x80000001, 0xffffffff ]\n    op64 = op32 +  [ 0x123456789, 0x100000000000,  0x65a227c6f24c562a,\n                     0x7fffffffffffffff, 0x8000000000000000, 0x80000000000000001,",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "Medium",
        "kind": 6,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "class Medium(TestValues):\n    _name = \"medium\"\n    op8 =  [ 0, 1, 0x7f, 0x80, 0xff ]\n    op16 = [ 0, 1, 0xff, 0x7fff, 0x8000, 0xffff ]\n    op16_s = [ -0x8000, -0x7fff, -0xff, -1, 0, 1, 0xff, 0x7fff]\n    op32 = [ 0, 1, 0x7fffffff, 0x80000000, 0xffffffff]\n    op64 = op32 + [ 0x7fffffffffffffff, 0x8000000000000000, 0xffffffffffffffff]\n    op32h = [ 0, 0x7fff, 0x8000, 0xffff ]\n    shift = [ 0, 1, 7, 8, 0xf, 0x7f, 0x80, 0x81, 0xff]\n    x86carryop = [ \"stc\", \"clc\" ]",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "Small",
        "kind": 6,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "class Small(TestValues):\n    _name = \"small\"\n    x86carryop = [ \"stc\" ]\n    op3 = [ 0, 7 ]\nclass Smoke(Large):\n    \"\"\"\n    Fast(er?) test set for CI\n    \"\"\"\n    hash_single = True\n    _name = \"smoke\"",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "Smoke",
        "kind": 6,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "class Smoke(Large):\n    \"\"\"\n    Fast(er?) test set for CI\n    \"\"\"\n    hash_single = True\n    _name = \"smoke\"\nCOVERAGES = [Large, Medium, Small, Smoke]\ndef pytest_addoption(parser):\n    parser.addoption(\"--coverage\", choices=[x._name for x in COVERAGES],\n                     default=\"medium\", help=\"test more or less values\")",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "armv8_bitmasks",
        "kind": 2,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "def armv8_bitmasks():\n    res = []\n    size = 2\n    while size <= 64:\n        for length in range(1, size):\n            result = 0xffffffffffffffff >> (64 - length)\n            e = size\n            while e < 64:\n                result |= result << e\n                e *= 2",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "def pytest_addoption(parser):\n    parser.addoption(\"--coverage\", choices=[x._name for x in COVERAGES],\n                     default=\"medium\", help=\"test more or less values\")\ndef pytest_generate_tests(metafunc):\n    func_name = metafunc.function.__name__\n    coverage = {x._name: x for x in COVERAGES}[metafunc.config.option.coverage]\n    for fn in metafunc.fixturenames:\n        fnstr = fn.rstrip(\"_\")  # alias foo_, foo__, etc. to foo\n        if hasattr(coverage, fnstr):\n            params = getattr(coverage, fnstr)",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "def pytest_generate_tests(metafunc):\n    func_name = metafunc.function.__name__\n    coverage = {x._name: x for x in COVERAGES}[metafunc.config.option.coverage]\n    for fn in metafunc.fixturenames:\n        fnstr = fn.rstrip(\"_\")  # alias foo_, foo__, etc. to foo\n        if hasattr(coverage, fnstr):\n            params = getattr(coverage, fnstr)\n            if coverage.hash_single:\n                hashint = int(hashlib.sha1((func_name + fnstr).encode(\"utf8\")).hexdigest(), 16)\n                paramidx = hashint % len(params)",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "COVERAGES",
        "kind": 5,
        "importPath": "plugins.bincat.test.conftest",
        "description": "plugins.bincat.test.conftest",
        "peekOfCode": "COVERAGES = [Large, Medium, Small, Smoke]\ndef pytest_addoption(parser):\n    parser.addoption(\"--coverage\", choices=[x._name for x in COVERAGES],\n                     default=\"medium\", help=\"test more or less values\")\ndef pytest_generate_tests(metafunc):\n    func_name = metafunc.function.__name__\n    coverage = {x._name: x for x in COVERAGES}[metafunc.config.option.coverage]\n    for fn in metafunc.fixturenames:\n        fnstr = fn.rstrip(\"_\")  # alias foo_, foo__, etc. to foo\n        if hasattr(coverage, fnstr):",
        "detail": "plugins.bincat.test.conftest",
        "documentation": {}
    },
    {
        "label": "cmpall",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def cmpall():\n    def cmpall_(*args, **kargs):\n        compare(*args, **kargs)\n        tcompare(*args, **kargs)\n    return cmpall_\ndef test_nop(tmpdir, cmpall):\n    asm = \"\"\"\n        mov r0,r0\n    \"\"\"\n    cmpall(tmpdir, asm, [])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_nop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_nop(tmpdir, cmpall):\n    asm = \"\"\"\n        mov r0,r0\n    \"\"\"\n    cmpall(tmpdir, asm, [])\ndef test_assign(tmpdir, cmpall):\n    asm = \"\"\"\n        mov r0, #0x12\n        mov r1, r0\n        movs r2, r1",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_assign",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_assign(tmpdir, cmpall):\n    asm = \"\"\"\n        mov r0, #0x12\n        mov r1, r0\n        movs r2, r1\n    \"\"\"\n    cmpall(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"n\", \"z\"])\n##  ___   _ _____ _     ___ ___  ___   ___ \n## |   \\ /_\\_   _/_\\   | _ \\ _ \\/ _ \\ / __|\n## | |) / _ \\| |/ _ \\  |  _/   / (_) | (__ ",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_movs_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"\n        movs r0, #{op8}\n    \"\"\".format(**locals())\n    cmpall(tmpdir, asm, [\"r0\", \"n\", \"z\"])\ndef test_mov_reg(tmpdir):\n    asm = \"\"\"\n            mov r0, #0x12\n            movs r1, r0\n            mov r2, r0, lsl #7",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_mov_reg(tmpdir):\n    asm = \"\"\"\n            mov r0, #0x12\n            movs r1, r0\n            mov r2, r0, lsl #7\n            mov r3, r0, lsr #1\n    \"\"\"\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"r3\", \"z\", \"n\"])\ndef test_movt(tmpdir, op16):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_movt",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_movt(tmpdir, op16):\n    asm = \"\"\"\n            mov r8, #0\n            movt r8, #{op16}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r8\"])\ndef test_movw(tmpdir, op16):\n    asm = \"\"\"\n            movw r8, #{op16}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_movw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_movw(tmpdir, op16):\n    asm = \"\"\"\n            movw r8, #{op16}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r8\"])\n@dataop_mov\ndef test_shifted_register_lsl_imm_shift(tmpdir, op, armv7op, armv7shift):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_lsl_imm_shift",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_lsl_imm_shift(tmpdir, op, armv7op, armv7shift):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0\n            adds r0, r0, r0\n            mov r0, #{armv7op}\n            {op}s r1, r0, lsl #{armv7shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"c\", \"n\", \"z\"],\n            top_allowed={\"c\": 1 if armv7shift == 0 else 0})",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_lsl_reg_shift",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_lsl_reg_shift(tmpdir, op, armv7op, armv7shift):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0\n            adds r0, r0, r0\n            mov r0, #{armv7op}\n            mov r1, #{armv7shift}\n            {op}s r2, r0, lsl r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\", \"c\", \"n\", \"z\"],",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_lsr_imm_shift",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_lsr_imm_shift(tmpdir, op, armv7op, armv7shift):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0\n            adds r0, r0, r0\n            mov r0, #{armv7op}\n            {op}s r1, r0, lsr #{armv7shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"c\", \"n\", \"z\"],\n            top_allowed={\"c\": 1 if armv7shift == 0 else 0})",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_lsr_reg_shift",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_lsr_reg_shift(tmpdir, op, armv7op, armv7shift):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0\n            adds r0, r0, r0\n            mov r0, #{armv7op}\n            mov r1, #{armv7shift}\n            {op}s r2, r0, lsr r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\", \"c\", \"n\", \"z\"],",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_lsr_imm_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_lsr_imm_32(tmpdir, op, armv7op):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0\n            adds r0, r0, r0\n            mov r0, #{armv7op}\n            {op}s r1, r0, lsr #32\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"c\", \"n\", \"z\"])\n@dataop_mov",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_lsr_reg_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_lsr_reg_32(tmpdir, op, armv7op):\n    asm = \"\"\"\n            # clear carry\n            mov r0, #0\n            adds r0, r0, r0\n            mov r0, #{armv7op}\n            mov r1, #32\n            {op}s r2, r0, lsr r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\", \"c\", \"n\", \"z\"])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_asr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_asr(tmpdir, armv7shift):\n    asm = \"\"\"\n            mov r0, #0x12\n            mov r1, r0, asr #{armv7shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\"])\ndef test_shifted_register_ror(tmpdir, armv7shift):\n    asm = \"\"\"\n            mov r0, #0x12\n            mov r1, r0, ror #{armv7shift}",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_shifted_register_ror",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_shifted_register_ror(tmpdir, armv7shift):\n    asm = \"\"\"\n            mov r0, #0x12\n            mov r1, r0, ror #{armv7shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\"])\ndef test_mov_set_zflag(tmpdir):\n    asm = \"\"\"\n            mov r1, #0\n            mov r2, #0",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_set_zflag",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_mov_set_zflag(tmpdir):\n    asm = \"\"\"\n            mov r1, #0\n            mov r2, #0\n            mov r3, #0\n            mov r4, #0\n            movs r0, #0x12\n            moveq r1, #1\n            movne r2, #1\n            movs r0, #0",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_set_vflag",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_mov_set_vflag(tmpdir):\n    asm = \"\"\"\n            mov r1, #0\n            mov r2, #0\n            mov r3, #0\n            mov r4, #0\n            movs r0, #0x12\n            movmi r1, #1\n            movpl r2, #1\n            movs r0, #0x80000000",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_mvn",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_mvn(tmpdir):\n    asm = \"\"\"\n            mov r1, #123\n            mvn r2, r1\n            mvn r3, r1, lsl #5\n    \"\"\"\n    compare(tmpdir, asm, [\"r1\",\"r2\",\"r3\"])\n@dataop_comp_logic\ndef test_data_proc_logic(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_logic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_logic(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            {op} r2, r0, r1\n            {op}s r3, r0, r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"r3\", \"n\", \"z\"])\n@dataop_comp_arith\ndef test_data_proc_arith_no_carry(tmpdir, op, armv7op, armv7op_):",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_no_carry",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_arith_no_carry(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            {op} r2, r0, r1\n            {op}s r3, r0, r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"r3\", \"n\", \"z\", \"c\", \"v\"])\n@dataop_comp_arith\n@pytest.mark.xfail # not implemented yet",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_arith_imm(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            {op}.w r1, r0, #{armv7op_}\n    \"\"\".format(**locals())\n    tucompare(tmpdir, asm, [\"r0\",\"r1\"])\n@dataop_comp_arith\ndef test_data_proc_arith_no_carry2(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_no_carry2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_arith_no_carry2(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mvn r0, r0\n            mov r1, #{armv7op_}\n            {op} r2, r0, r1\n            {op}s r3, r0, r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"r3\", \"n\", \"z\", \"c\", \"v\"])\n@dataop_comp_arith_with_carry",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_carry",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_arith_carry(tmpdir, op, armv7op, armv7op_, carry):\n    asm = \"\"\"\n            mrs r0, cpsr\n            bic r0, #0x20000000\n            orr r0, #{carry:#x}\n            msr cpsr, r0\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            {op} r2, r0, r1\n            {op}s r3, r0, r1",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_carry2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_arith_carry2(tmpdir, op, armv7op, armv7op_, carry):\n    asm = \"\"\"\n            mrs r0, cpsr\n            bic r0, #0x20000000\n            orr r0, #{carry:#x}\n            msr cpsr, r0\n            mov r0, #{armv7op}\n            mvn r0, r0\n            mov r1, #{armv7op_}\n            {op} r2, r0, r1",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_test_logic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_test_logic(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            {op} r0, r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"n\", \"z\"])\n@dataop_test_arith\ndef test_data_proc_test_arith(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_test_arith",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_test_arith(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            {op} r0, r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"n\", \"z\", \"c\", \"v\"])\n@pytest.mark.parametrize(\"flags\", list(range(15)))\ndef test_data_proc_msr_cpsr_reg(tmpdir,flags):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_msr_cpsr_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_msr_cpsr_reg(tmpdir,flags):\n    asm = \"\"\"\n            mov r0, #{flags:#x}0000000\n            msr cpsr, r0\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"n\", \"z\", \"v\", \"c\"])\n@pytest.mark.parametrize(\"flags\", list(range(15)))\ndef test_data_proc_msr_cpsr_imm(tmpdir,flags):\n    asm = \"\"\"\n            msr cpsr, #{flags:#x}0000000",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_msr_cpsr_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_msr_cpsr_imm(tmpdir,flags):\n    asm = \"\"\"\n            msr cpsr, #{flags:#x}0000000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"n\", \"z\", \"v\", \"c\"])\n@pytest.mark.parametrize(\"flags\", list(range(15)))\ndef test_data_proc_mrs_cpsr(tmpdir,flags):\n    asm = \"\"\"\n            mov r0, #{flags:#x}0000000\n            msr cpsr, r0",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_mrs_cpsr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_mrs_cpsr(tmpdir,flags):\n    asm = \"\"\"\n            mov r0, #{flags:#x}0000000\n            msr cpsr, r0\n            mrs r1, cpsr\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\",\"n\",\"z\",\"c\",\"v\"])\ndef test_data_proc_read_pc(tmpdir):\n    asm = \"\"\"\n            bl .next",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_read_pc",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_proc_read_pc(tmpdir):\n    asm = \"\"\"\n            bl .next\n         .next:\n            sub r0, pc, lr\n            mov r1, #0\n            sub r2, pc, lr, lsl r1\n    \"\"\"\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\"])\n##  __  __ ___ ___ ___   _     ___ ___ _  _",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_media_ubfx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_media_ubfx(tmpdir, armv7op, op5_couple, request):\n    op5,op5_ = op5_couple\n    asm = \"\"\"\n          mov r2, #{armv7op}\n          ubfx r3, r2, #{op5}, #{op5_}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r2\", \"r3\"])\n@pytest.mark.parametrize(\"opcode\", [\"uxtb\", \"uxth\", \"uxtb16\",\n                                    \"sxtb\", \"sxth\", \"sxtb16\"])\ndef test_media_uxtb_uxth_uxtb16_sxtb_sxth_sxtb16(tmpdir, opcode, armv7op):",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_media_uxtb_uxth_uxtb16_sxtb_sxth_sxtb16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_media_uxtb_uxth_uxtb16_sxtb_sxth_sxtb16(tmpdir, opcode, armv7op):\n    asm = \"\"\"\n            mov r1, #{armv7op}\n            {opcode} r2, r1, ror #0\n            {opcode} r3, r1, ror #8\n            {opcode} r4, r1, ror #16\n            {opcode} r5, r1, ror #24\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r1\", \"r2\", \"r3\", \"r4\", \"r5\",])\n@pytest.mark.parametrize(\"opcode\", [\"uxtab\", \"uxtah\", \"uxtab16\",",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_media_uxtab_uxtah_uxtab16_sxtab_sxtah_sxtab16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_media_uxtab_uxtah_uxtab16_sxtab_sxtah_sxtab16(tmpdir, opcode, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            {opcode} r2, r0, r1, ror #0\n            {opcode} r3, r0, r1, ror #8\n            {opcode} r4, r0, r1, ror #16\n            {opcode} r5, r0, r1, ror #24\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\",])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_media_pkhtb_pkhbt",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_media_pkhtb_pkhbt(tmpdir, armv7op, armv7op_, op5):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            pkhbt r2, r0, r1, lsl #{op5}\n            pkhtb r3, r0, r1, asr #{op5}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\", \"r3\"])\n##  ___   _ _____ _    __  _____ ___ ___ \n## |   \\ /_\\_   _/_\\   \\ \\/ / __| __| _ \\",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_push_pop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_push_pop(tmpdir, cmpall):\n    asm = \"\"\"\n            mov r0, #123\n            push { r0 }\n            pop { r1 }\n    \"\"\"\n    cmpall(tmpdir, asm, [\"r0\",\"r1\"])\ndef test_data_xfer_push1_pop(tmpdir, cmpall):\n    asm = \"\"\"\n            mov r0, #123",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_push1_pop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_push1_pop(tmpdir, cmpall):\n    asm = \"\"\"\n            mov r0, #123\n            mov r1, #13\n            mov r2, #18\n            push { r0 }\n            push { r1 }\n            push { r2 }\n            pop { r3,r4,r5 }\n    \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_push_pop1",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_push_pop1(tmpdir, cmpall):\n    asm = \"\"\"\n            mov r0, #123\n            mov r1, #13\n            mov r2, #18\n            push { r0, r1, r2}\n            pop { r3 }\n            pop { r4 }\n            pop { r5 }\n    \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_offsets",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_offsets(tmpdir):\n    asm = \"\"\"\n            mov r0, #0\n            mov r1, #123\n            mov r2, #101\n            push { r1 }\n            push { r2 }\n            push { r0 }\n            push { r0 }\n            push { r0 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_str_8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_str_8(tmpdir):\n    asm = \"\"\"\n            mov r0, #123\n            str r0, [sp, #-4]!\n            ldrb r1, [sp], #4\n            mov r0, #105\n            strb r0, [sp, #-4]!\n            ldr r2, [sp], #4\n    \"\"\"\n    compare(tmpdir, asm, [\"r0\", \"r1\", \"r2\"])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_ldrh_strh",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_ldrh_strh(tmpdir):\n    asm = \"\"\"\n            mov r0, #123\n            mov r1, #101\n            strh r0, [sp, #-2]!\n            strh r1, [sp, #-2]!\n            ldr  r2, [sp]\n            ldrh r3, [sp], #2\n            ldrsb r4, [sp], #1\n            ldrsb r5, [sp], #1",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_with_lsl",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_with_lsl(tmpdir):\n    asm = \"\"\"\n            mov r0, #123\n            push { r0 }\n            mov r0, #101\n            push { r0 }\n            mov r0, #61\n            push { r0 }\n            mov r0, #42\n            push { r0 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_with_ror_asr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_with_ror_asr(tmpdir):\n    asm = \"\"\"\n            mov r0, #123\n            push { r0 }\n            mov r0, #101\n            push { r0 }\n            mov r0, #61\n            push { r0 }\n            mov r0, #42\n            push { r0 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_unaligned_word",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_unaligned_word(tmpdir):\n    asm = \"\"\"\n            push { r10, r11 }\n            mov r10, #0x12\n            orr r10, r10, #0x3400\n            orr r10, r10, #0x560000\n            orr r10, r10, #0x78000000\n            mvn r11, r10\n            push { r10 }\n            push { r11 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_unaligned_byte",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_data_xfer_unaligned_byte(tmpdir):\n    asm = \"\"\"\n            push { r10, r11 }\n            mov r10, #0xa6\n            orr r10, r10, #0x5200\n            orr r10, r10, #0xf70000\n            orr r10, r10, #0x4e000000\n            mvn r11, r10\n            mov r0, r10, lsl #1\n            mov r1, r10, lsl #2",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_nolink",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_branch_nolink(tmpdir):\n    asm = \"\"\"\n            mov r1, #123\n            b .next\n            mov r1, #101\n       .next:\n            mov r2, #123\n    \"\"\"\n    compare(tmpdir, asm, [\"r1\", \"r2\"])\ndef test_branch_and_link(tmpdir):",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_and_link",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_branch_and_link(tmpdir):\n    asm = \"\"\"\n            mov r1, #123\n            bl .next\n            mov r1, #101\n       .next:\n            mov r2, #123\n            sub r3, pc, lr\n    \"\"\"\n    compare(tmpdir, asm, [\"r1\", \"r2\", \"r3\"])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_and_link2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_branch_and_link2(tmpdir):\n    asm = \"\"\"\n            mov r1, #123\n            bl .next\n            mov r1, #101\n            b .end\n       .next:\n            mov r2, #123\n            mov pc, lr\n       .end:",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_block_xfer_store",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_block_xfer_store(tmpdir):\n    asm = \"\"\"\n            mov r6, sp\n            mov r0, #123\n            mov r2, #101\n            mov r7, #42\n            stmfd sp!, {r0, r2, r7}\n            sub r6, r6, sp\n            ldr r3, [sp]\n            ldr r4, [sp,#4]",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_block_xfer_load_general",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_block_xfer_load_general(tmpdir):\n    asm = \"\"\"\n            mov r0, #123\n            mov r1, #101\n            mov r2, #42\n            mov r3, sp\n            str r1, [sp,#-4]\n            str r2, [sp,#-8]\n            str r2, [sp,#-12]\n            sub sp, sp, #12",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_block_xfer_load_pc",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_block_xfer_load_pc(tmpdir):\n    asm = \"\"\"\n            mov r4, #0\n            mov r0, #123\n            b .after\n        .before:\n            push { lr }\n            push { r0 }\n            push { r0 }\n            push { r0 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_block_xfer_load_self",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_block_xfer_load_self(tmpdir):\n    asm = \"\"\"\n            mov r0, #123\n            mov r1, #101\n            mov r2, #42\n            mov r3, sp\n            str r1, [sp,#-4]\n            str r2, [sp,#-8]\n            str r2, [sp,#-12]\n            sub r3, r3, #12",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_mul_mul",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_mul_mul(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            mul r2, r0, r1\n            muls r3, r0, r1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"r3\", \"n\", \"z\", \"c\"],\n            top_allowed = {\"c\": 1})\ndef test_mul_mla(tmpdir, armv7op, armv7op_, armv7op__):",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_mul_mla",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_mul_mla(tmpdir, armv7op, armv7op_, armv7op__):\n    asm = \"\"\"\n            mov r0, #{armv7op}\n            mov r1, #{armv7op_}\n            mov r2, #{armv7op__}\n            mla r3, r0, r1, r2\n            mlas r4, r0, r1, r2\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\",\"r1\", \"r2\", \"r3\", \"r4\", \"n\", \"z\", \"c\"],\n            top_allowed = {\"c\": 1})",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_swap_swap_word_different_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_swap_swap_word_different_reg(tmpdir):\n    asm = \"\"\"\n            mov r0, #0xaa\n            orr r0, r0, #0x5500\n            orr r0, r0, #0xbb0000\n            orr r0, r0, #0x22000000\n            mvn r1, r0\n            push { r1 }\n            swp r2, r0, [sp]\n            pop { r3 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_swap_swap_word_same_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_swap_swap_word_same_reg(tmpdir):\n    asm = \"\"\"\n            mov r0, #0xaa\n            orr r0, r0, #0x5500\n            orr r0, r0, #0xbb0000\n            orr r0, r0, #0x22000000\n            mvn r1, r0\n            push { r1 }\n            swp r0, r0, [sp]\n            pop { r2 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_swap_swap_byte_different_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_swap_swap_byte_different_reg(tmpdir):\n    asm = \"\"\"\n            mov r0, #0xaa\n            orr r0, r0, #0x5500\n            orr r0, r0, #0xbb0000\n            orr r0, r0, #0x22000000\n            mvn r1, r0\n            push { r1 }\n            swpb r2, r0, [sp]\n            pop { r3 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_swap_swap_byte_same_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_swap_swap_byte_same_reg(tmpdir):\n    asm = \"\"\"\n            mov r0, #0xaa\n            orr r0, r0, #0x5500\n            orr r0, r0, #0xbb0000\n            orr r0, r0, #0x22000000\n            mvn r1, r0\n            push { r1 }\n            swpb r0, r0, [sp]\n            pop { r2 }",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_cond",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "def test_cond(tmpdir, flags, cc):\n    asm = \"\"\"\n            mov r0, #{flags:#x}0000000\n            msr cpsr, r0\n            mov r1, #0\n            mov{cc} r1, #1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"n\", \"z\", \"v\", \"c\", \"r1\"])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "arm",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "arm = ARM(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7.ini.in')\n)\ncompare = arm.compare\nthumb = Thumb(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntcompare = thumb.compare\nthumbu = ThumbU(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "compare = arm.compare\nthumb = Thumb(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntcompare = thumb.compare\nthumbu = ThumbU(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntucompare = thumbu.compare\n@pytest.fixture()",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "thumb",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "thumb = Thumb(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntcompare = thumb.compare\nthumbu = ThumbU(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntucompare = thumbu.compare\n@pytest.fixture()\ndef cmpall():",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "tcompare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "tcompare = thumb.compare\nthumbu = ThumbU(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntucompare = thumbu.compare\n@pytest.fixture()\ndef cmpall():\n    def cmpall_(*args, **kargs):\n        compare(*args, **kargs)\n        tcompare(*args, **kargs)",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "thumbu",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "thumbu = ThumbU(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7thumb.ini.in')\n)\ntucompare = thumbu.compare\n@pytest.fixture()\ndef cmpall():\n    def cmpall_(*args, **kargs):\n        compare(*args, **kargs)\n        tcompare(*args, **kargs)\n    return cmpall_",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "tucompare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "tucompare = thumbu.compare\n@pytest.fixture()\ndef cmpall():\n    def cmpall_(*args, **kargs):\n        compare(*args, **kargs)\n        tcompare(*args, **kargs)\n    return cmpall_\ndef test_nop(tmpdir, cmpall):\n    asm = \"\"\"\n        mov r0,r0",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "dataop_comp_logic",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "dataop_comp_logic = pytest.mark.parametrize(\"op\", [\"and\", \"eor\", \"orr\", \"bic\"])\ndataop_comp_arith = pytest.mark.parametrize(\"op\", [ \"sub\", \"rsb\", \"add\"])\ndataop_comp_arith_with_carry = pytest.mark.parametrize(\"op\", [ \"adc\", \"sbc\", \"rsc\"])\ndataop_test_logic = pytest.mark.parametrize(\"op\", [\"tst\", \"teq\"])\ndataop_test_arith = pytest.mark.parametrize(\"op\", [\"cmp\", \"cmn\"])\ncondition_codes = [ \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\",\n                    \"vs\", \"vc\", \"hi\", \"ls\", \"ge\", \"lt\",\n                    \"gt\", \"le\", \"al\" ]\ndef test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "dataop_comp_arith",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "dataop_comp_arith = pytest.mark.parametrize(\"op\", [ \"sub\", \"rsb\", \"add\"])\ndataop_comp_arith_with_carry = pytest.mark.parametrize(\"op\", [ \"adc\", \"sbc\", \"rsc\"])\ndataop_test_logic = pytest.mark.parametrize(\"op\", [\"tst\", \"teq\"])\ndataop_test_arith = pytest.mark.parametrize(\"op\", [\"cmp\", \"cmn\"])\ncondition_codes = [ \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\",\n                    \"vs\", \"vc\", \"hi\", \"ls\", \"ge\", \"lt\",\n                    \"gt\", \"le\", \"al\" ]\ndef test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"\n        movs r0, #{op8}",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "dataop_comp_arith_with_carry",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "dataop_comp_arith_with_carry = pytest.mark.parametrize(\"op\", [ \"adc\", \"sbc\", \"rsc\"])\ndataop_test_logic = pytest.mark.parametrize(\"op\", [\"tst\", \"teq\"])\ndataop_test_arith = pytest.mark.parametrize(\"op\", [\"cmp\", \"cmn\"])\ncondition_codes = [ \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\",\n                    \"vs\", \"vc\", \"hi\", \"ls\", \"ge\", \"lt\",\n                    \"gt\", \"le\", \"al\" ]\ndef test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"\n        movs r0, #{op8}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "dataop_test_logic",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "dataop_test_logic = pytest.mark.parametrize(\"op\", [\"tst\", \"teq\"])\ndataop_test_arith = pytest.mark.parametrize(\"op\", [\"cmp\", \"cmn\"])\ncondition_codes = [ \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\",\n                    \"vs\", \"vc\", \"hi\", \"ls\", \"ge\", \"lt\",\n                    \"gt\", \"le\", \"al\" ]\ndef test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"\n        movs r0, #{op8}\n    \"\"\".format(**locals())\n    cmpall(tmpdir, asm, [\"r0\", \"n\", \"z\"])",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "dataop_test_arith",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "dataop_test_arith = pytest.mark.parametrize(\"op\", [\"cmp\", \"cmn\"])\ncondition_codes = [ \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\",\n                    \"vs\", \"vc\", \"hi\", \"ls\", \"ge\", \"lt\",\n                    \"gt\", \"le\", \"al\" ]\ndef test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"\n        movs r0, #{op8}\n    \"\"\".format(**locals())\n    cmpall(tmpdir, asm, [\"r0\", \"n\", \"z\"])\ndef test_mov_reg(tmpdir):",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "condition_codes",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv7_isn",
        "description": "plugins.bincat.test.test_armv7_isn",
        "peekOfCode": "condition_codes = [ \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\",\n                    \"vs\", \"vc\", \"hi\", \"ls\", \"ge\", \"lt\",\n                    \"gt\", \"le\", \"al\" ]\ndef test_movs_imm(tmpdir, cmpall, op8):\n    asm = \"\"\"\n        movs r0, #{op8}\n    \"\"\".format(**locals())\n    cmpall(tmpdir, asm, [\"r0\", \"n\", \"z\"])\ndef test_mov_reg(tmpdir):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv7_isn",
        "documentation": {}
    },
    {
        "label": "test_adrp1",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_adrp1(tmpdir, op32):\n    asm = \"\"\"\n    label1:\n        adrp x0, label1\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n    label2:",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_adrp2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_adrp2(tmpdir, op32):\n    asm = \"\"\"\n        adrp x0, label\n        mov x0,x0\n        mov x0,x0\n    label:\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n        adrp x1, label",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_xfer_offsets",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_xfer_offsets(tmpdir, armv8off):\n    asm = \"\"\"\n            mov x0, #0\n            mov x1, #123\n            mov x2, #101\n            stp x1, x2, [sp, #{armv8off}]\n            ldp x3, x4, [sp, #{armv8off}]\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\", \"x1\", \"x2\", \"x3\", \"x4\"])\n@mov_imm",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_mov",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_mov(tmpdir, op, op16, armv8shift):\n    asm = \"\"\"\n        mov x0, 0\n        sub x0, x0, 1\n        {op} x0, #{op16}, LSL #{armv8shift}\n        mov w1, w0\n        mov w2, w1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\",\"x2\"])\n@dataop_comp_logic",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_logic_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_proc_logic_imm(tmpdir, op, armv7op, armv7op_, armv8bitmasks):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            mov x1, #{armv7op_}\n            {op} x2, x0, #{armv8bitmasks}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\"])\n@dataop_comp_logic\ndef test_data_proc_logic(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_logic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_proc_logic(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            mov x1, #{armv7op_}\n            {op} x2, x0, x1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\"])\n@dataop_comp_arith\ndef test_data_proc_arith(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_proc_arith(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            mov x1, #{armv7op_}\n            {op} x2, x0, x1\n    \"\"\".format(**locals())\n    if op[-1] != 's':\n        top_allowed = {\"n\":1, \"c\":1, \"v\":1, \"z\":1}\n    else:\n        top_allowed = {}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_proc_arith_imm(tmpdir, op, armv7op, op12):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            {op} x2, x0, #{op12}\n    \"\"\".format(**locals())\n    if op[-1] != 's':\n        top_allowed = {\"n\":1, \"c\":1, \"v\":1, \"z\":1}\n    else:\n        top_allowed = {}\n    compare(tmpdir, asm, [\"x0\", \"x2\", \"n\", \"c\", \"z\", \"v\"], top_allowed = top_allowed)",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_logic_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_proc_logic_32(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov w0, #{armv7op}\n            mov w1, #{armv7op_}\n            {op} w2, w0, w1\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\"])\n@dataop_comp_arith\ndef test_data_proc_arith_32(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_data_proc_arith_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_data_proc_arith_32(tmpdir, op, armv7op, armv7op_):\n    asm = \"\"\"\n            mov w0, #{armv7op}\n            mov w1, #{armv7op_}\n            {op} w2, w0, w1\n    \"\"\".format(**locals())\n    if op[-1] != 's':\n        top_allowed = {\"n\":1, \"c\":1, \"v\":1, \"z\":1}\n    else:\n        top_allowed = {}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_ubfm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_ubfm(tmpdir, op6, op6_, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            mov x1, #{armv7op_}\n            UBFM x2, x0, #{op6}, #{op6_}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\"])\ndef test_ubfm32(tmpdir, op6_32, op6_32_, armv7op, armv7op_):\n    asm = \"\"\"\n            mov w0, #{armv7op}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_ubfm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_ubfm32(tmpdir, op6_32, op6_32_, armv7op, armv7op_):\n    asm = \"\"\"\n            mov w0, #{armv7op}\n            mov w1, #{armv7op_}\n            UBFM w2, w0, #{op6_32}, #{op6_32_}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\"])\ndef test_madd_sub32(tmpdir, op32, op32_, op32__, op32___):\n    asm = \"\"\"\n            mov w0, #{op32}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_madd_sub32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_madd_sub32(tmpdir, op32, op32_, op32__, op32___):\n    asm = \"\"\"\n            mov w0, #{op32}\n            mov w1, #{op32_}\n            mov w2, #{op32__}\n            mov w3, #{op32___}\n            madd w0, w1, w2, w3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\", \"x3\"])\ndef test_madd_sub64(tmpdir, op64, op64_, op64__, op64___):",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_madd_sub64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_madd_sub64(tmpdir, op64, op64_, op64__, op64___):\n    asm = \"\"\"\n            mov x0, #{op64}\n            mov x1, #{op64_}\n            mov x2, #{op64__}\n            mov x3, #{op64___}\n            madd x0, x1, x2, x3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\",\"x1\", \"x2\", \"x3\"])\ndef test_sxtw(tmpdir, armv7op, armv7op_):",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_sxtw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_sxtw(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov w0, #{armv7op}\n            sxtw x0, w0\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\"])\ndef test_add_sxtw(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            mov x1, #{armv7op_}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_add_sxtw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_add_sxtw(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            mov x1, #{armv7op_}\n            add x2, x1, w0, sxtw\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\", \"x1\", \"x2\"])\ndef test_fp_fmov(tmpdir, armv7op):\n    asm = \"\"\"\n            mov x0, #{armv7op}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_fp_fmov",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_fp_fmov(tmpdir, armv7op):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            fmov s0, w0\n            fmov s10, w0\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"q0\", \"q10\"])\ndef test_simd_eor(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_simd_eor",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_simd_eor(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            fmov s0, w0\n            mov x1, #{armv7op_}\n            fmov s1, w1\n            eor v2.8b, v0.8b, v1.8b\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\", \"x1\", \"q0\", \"q1\", \"q2\"])\ndef test_simd_orr(tmpdir, armv7op, armv7op_):",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_simd_orr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_simd_orr(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            fmov s0, w0\n            mov x1, #{armv7op_}\n            fmov s1, w1\n            orr v2.8b, v0.8b, v1.8b\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\", \"x1\", \"q0\", \"q1\", \"q2\"])\ndef test_simd_and(tmpdir, armv7op, armv7op_):",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_simd_and",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_simd_and(tmpdir, armv7op, armv7op_):\n    asm = \"\"\"\n            mov x0, #{armv7op}\n            fmov s0, w0\n            mov x1, #{armv7op_}\n            fmov s1, w1\n            and v2.8b, v0.8b, v1.8b\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x0\", \"x1\", \"q0\", \"q1\", \"q2\"])\n# This tests does arithmetic between the stack and the global region",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_stack_combine",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "def test_stack_combine(tmpdir):\n    asm = \"\"\"\n            mov x3, 0\n            mov x0, sp\n            mov x1, sp\n            sub x2, x0, x1\n            str x2, [x0]\n            ldr w3, [x0]\n            add x3, x3, 0x100\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "arm",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "arm = AARCH64(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv8.ini.in')\n)\ncompare = arm.compare\nmov_imm = pytest.mark.parametrize(\"op\", [\"movz\", \"movk\", \"movn\"])\ndataop_comp_logic = pytest.mark.parametrize(\"op\", [\"and\", \"eor\", \"orr\", \"bic\"])\ndataop_comp_arith = pytest.mark.parametrize(\"op\", [\"sub\", \"add\", \"adds\", \"subs\"])\ndef test_adrp1(tmpdir, op32):\n    asm = \"\"\"\n    label1:",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "compare = arm.compare\nmov_imm = pytest.mark.parametrize(\"op\", [\"movz\", \"movk\", \"movn\"])\ndataop_comp_logic = pytest.mark.parametrize(\"op\", [\"and\", \"eor\", \"orr\", \"bic\"])\ndataop_comp_arith = pytest.mark.parametrize(\"op\", [\"sub\", \"add\", \"adds\", \"subs\"])\ndef test_adrp1(tmpdir, op32):\n    asm = \"\"\"\n    label1:\n        adrp x0, label1\n        mov x0,x0\n        mov x0,x0",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "mov_imm",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "mov_imm = pytest.mark.parametrize(\"op\", [\"movz\", \"movk\", \"movn\"])\ndataop_comp_logic = pytest.mark.parametrize(\"op\", [\"and\", \"eor\", \"orr\", \"bic\"])\ndataop_comp_arith = pytest.mark.parametrize(\"op\", [\"sub\", \"add\", \"adds\", \"subs\"])\ndef test_adrp1(tmpdir, op32):\n    asm = \"\"\"\n    label1:\n        adrp x0, label1\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "dataop_comp_logic",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "dataop_comp_logic = pytest.mark.parametrize(\"op\", [\"and\", \"eor\", \"orr\", \"bic\"])\ndataop_comp_arith = pytest.mark.parametrize(\"op\", [\"sub\", \"add\", \"adds\", \"subs\"])\ndef test_adrp1(tmpdir, op32):\n    asm = \"\"\"\n    label1:\n        adrp x0, label1\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "dataop_comp_arith",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_armv8_isn",
        "description": "plugins.bincat.test.test_armv8_isn",
        "peekOfCode": "dataop_comp_arith = pytest.mark.parametrize(\"op\", [\"sub\", \"add\", \"adds\", \"subs\"])\ndef test_adrp1(tmpdir, op32):\n    asm = \"\"\"\n    label1:\n        adrp x0, label1\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0\n        mov x0,x0",
        "detail": "plugins.bincat.test.test_armv8_isn",
        "documentation": {}
    },
    {
        "label": "test_coverage",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_coverage",
        "description": "plugins.bincat.test.test_coverage",
        "peekOfCode": "def test_coverage(tmpdir):\n    asm = \"\"\"\n        mov ebx, edi\n        mov ebp, esi\n        cmp edi, 0x9\n        jg end\n        mov edx, 0xA\n        mov esi, 0x0\n        end:\n        mov eax, ebp",
        "detail": "plugins.bincat.test.test_coverage",
        "documentation": {}
    },
    {
        "label": "x86",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_coverage",
        "description": "plugins.bincat.test.test_coverage",
        "peekOfCode": "x86 = X86(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'x86.ini.in')\n)\nxfail = pytest.mark.skip\ndef test_coverage(tmpdir):\n    asm = \"\"\"\n        mov ebx, edi\n        mov ebp, esi\n        cmp edi, 0x9\n        jg end",
        "detail": "plugins.bincat.test.test_coverage",
        "documentation": {}
    },
    {
        "label": "xfail",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_coverage",
        "description": "plugins.bincat.test.test_coverage",
        "peekOfCode": "xfail = pytest.mark.skip\ndef test_coverage(tmpdir):\n    asm = \"\"\"\n        mov ebx, edi\n        mov ebp, esi\n        cmp edi, 0x9\n        jg end\n        mov edx, 0xA\n        mov esi, 0x0\n        end:",
        "detail": "plugins.bincat.test.test_coverage",
        "documentation": {}
    },
    {
        "label": "test_basics_nop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_basics_nop(tmpdir):\n    asm = \"\"\"\n        ori %r0,%r31,0\n        nop\n    \"\"\"\n    compare(tmpdir, asm, [])\ndef test_basics_assign(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_basics_assign(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\"])\ndef test_basics_assign2(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_basics_assign2(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xffff\n        ori %r4, %r4, 0xA5A5\n        lis %r5, 0xA1B2\n        ori %r5, %r5, 0xD4C3\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_op(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op} %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\" ])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_op_dot(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\" ])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_o",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_op_o(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op}o %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"ov\" ])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_o_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_op_o_dot(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op}o. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\", \"ov\", \"ca\" ])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_flags",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_op_flags(tmpdir, op, xer, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {xer}\n        mtspr 1, %r3       # update XER\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        {op}o. %r5, %r3, %r4\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_addi(tmpdir, op, op32, op16_s):\n    asm = \"\"\"\n        lis %r0, {op32}@h\n        ori %r0, %r0, {op32}@l\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {op} %r4, %r3, {op16_s}\n        {op} %r5, %r0, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r3\", \"r4\", \"r5\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_addic(tmpdir, op32, op16_s):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        addic %r4, %r3, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"ca\"])\n@pytest.mark.parametrize(\"op\", [\"addic.\", \"subfic\"])\ndef test_arith_addic_doc_subfic(tmpdir, op, op32, op16_s):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addic_doc_subfic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_addic_doc_subfic(tmpdir, op, op32, op16_s):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        mtspr 1, %r3       # update XER (for XER.so flag)\n        {op} %r4, %r3, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"ca\", \"cr:29-31\"])\n@pytest.mark.parametrize(\"op\", [\"addme\", \"addze\", \"subfme\", \"subfze\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addmeo_addzeo_subfmeo_subfzeo_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_addmeo_addzeo_subfmeo_subfzeo_dot(tmpdir, op, xer, op32):\n    asm = \"\"\"\n        lis %r3, {xer}\n        mtspr 1, %r3       # update XER\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {op}o. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\", \"ov\", \"ca\" ])\ndef test_arith_extsb(tmpdir, op8):",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_extsb",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_extsb(tmpdir, op8):\n    asm = \"\"\"\n        li %r3, {op8}\n        extsb. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\ndef test_arith_extsh(tmpdir, op16_s):\n    asm = \"\"\"\n        li %r3, {op16_s}\n        extsh. %r4, %r3",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_extsh",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_extsh(tmpdir, op16_s):\n    asm = \"\"\"\n        li %r3, {op16_s}\n        extsh. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\n#could do better for cr if modes 32/64 are distinguished\ndef test_arith_divw(tmpdir, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_divw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_divw(tmpdir, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        divwo. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    invalid = (op32_== 0) or (op32 == 0x80000000 and op32_ == 0xffffffff)\n    top = { \"r5\": 0xffffffffffffffff } if invalid else {\"r5\": 0xffffffff00000000}",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_divwu",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_divwu(tmpdir, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        divwuo. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    invalid = op32_== 0\n    top = { \"r5\": 0xffffffffffffffff } if invalid else {\"r5\": 0xffffffff00000000}",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_mul",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_mul(tmpdir, op, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32}@h\n        ori %r4, %r4, {op32}@l\n        {op}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    top = {\"r5\": 0xffffffff00000000}\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\"],",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_mulli",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_arith_mulli(tmpdir, op32, op16_s):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mulli %r4, %r3, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\"])\n##  _              _\n## | |   ___  __ _(_)__\n## | |__/ _ \\/ _` | / _|",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_with_flags",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_with_flags(tmpdir, logic, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        {logic}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\" ])\n@pytest.mark.parametrize(\"logic\", [\"ori\", \"oris\", \"xori\", \"xoris\" ])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_imm(tmpdir, logic, op32, op16):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {logic} %r4, %r3, {op16}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\"])\n@pytest.mark.parametrize(\"logic\", [\"andi.\", \"andis.\" ])\ndef test_logic_imm_dot(tmpdir, logic, op32, op16):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_imm_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_imm_dot(tmpdir, logic, op32, op16):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {logic} %r4, %r3, {op16}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\ndef test_logic_neg(tmpdir, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_neg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_neg(tmpdir, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        nego. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\", \"ov\" ])\n@pytest.mark.parametrize(\"exp\", list(range(33)))\ndef test_cntlzw(tmpdir, exp, op32):\n    op32 |= 2**exp",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_cntlzw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_cntlzw(tmpdir, exp, op32):\n    op32 |= 2**exp\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        cntlzw. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\n@pytest.mark.parametrize(\"op\", [\"rlwimi\", \"rlwinm\"])\ndef test_logic_rlwimi_rlwinm_dot(tmpdir, op, op32, op32_, op5, op5_, op5__):",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_rlwimi_rlwinm_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_rlwimi_rlwinm_dot(tmpdir, op, op32, op32_, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        mr %r5, %r4\n        {op}. %r4, %r3, {op5}, {op5_}, {op5__}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_rlwnm_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_rlwnm_dot(tmpdir, op32, op32_, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        li %r5, {op5}\n        rlwnm. %r4, %r3, %r5, {op5_}, {op5__}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\n@pytest.mark.parametrize(\"op\", [\"slw\", \"srw\", \"sraw\"])\n@pytest.mark.parametrize(\"opshift\", [0, 1, 6, 30, 31, 32, 35, 63, 66, 125])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_shift_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_shift_dot(tmpdir, op, op32, opshift):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtspr 1, %r3       # set ca to a determined value\n        li %r4, {opshift}\n        {op}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\", \"ca\"])\ndef test_logic_srawi(tmpdir, op32, op5):",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_srawi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_logic_srawi(tmpdir, op32, op5):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtspr 1, %r3       # set ca to a determined value\n        srawi. %r4, %r3, {op5}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\", \"ca\"])\n##   ___\n##  / __|___ _ __  _ __  __ _ _ _ ___",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_compare_cmp_cmpl",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_compare_cmp_cmpl(tmpdir, op, l, crfD, op32h, op32h_):\n    so = op32h & 0x8000\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {so}\n        mtspr 1, %r3     # so = 0 or 1\n        lis %r3, {op32h}\n        lis %r4, {op32h_}\n        {op}  cr{crfD}, {l}, %r3, %r4",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_compare_cmpli",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_compare_cmpli(tmpdir, l, crfD, op32h, op32h_):\n    so = op32h & 0x8000\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {so}\n        mtspr 1, %r3     # so = 0 or 1\n        lis %r3, {op32h}\n        cmpli  cr{crfD}, {l}, %r3, {op32h_}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_compare_cmpi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_compare_cmpi(tmpdir, l, crfD, op32h, op16_s):\n    so = op32h & 0x8000\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {so}\n        mtspr 1, %r3     # so = 0 or 1\n        lis %r3, {op32h}\n        cmpi  cr{crfD}, {l}, %r3, {op16_s}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_b",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_b(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        lis %r4, 0x4321\n        b next\n        lis %r3, 0xabcd\n      next:\n        lis %r4, 0xdcba\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\", \"r4\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_b_back",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_b_back(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234\n        b j1\n        lis %r3, 0xabcd\n      j2:\n        lis %r4, 0xabcd",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_and_link",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_and_link(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234\n        bl j1\n        lis %r3, 0xabcd\n        b j2\n      j1:",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_and_link2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_and_link2(tmpdir):\n    asm = \"\"\"\n        bl j1\n        nop\n        nop\n      j1:\n        mflr %r3\n        bl j2\n        nop\n        nop",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_bclr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_bclr(tmpdir, cr7, bit, cond, ctr):\n    asm = \"\"\"\n        li %r7, {cr7}\n        mtcrf 0xff, %r7\n        li %r8, {ctr}\n        mtctr %r8\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_bcctr_bclr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_bcctr_bclr(tmpdir, cr7, bit, cond, ctr):\n    asm = \"\"\"\n        li %r7, {cr7}\n        mtcrf 0xff, %r7\n        li %r8, {ctr}\n        mtctr %r8\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_cond",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_branch_cond(tmpdir, cr7, bit, cond):\n    asm = \"\"\"\n        li %r3, {cr7}\n        mtcrf 0xff, %r3\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234\n        lis %r7, 0x1234\n        lis %r8, 0x1234",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_load",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_load(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}\n        mr %r4, %r1\n        mr %r6, %r1\n        stw %r3, 12(%r1)\n        stw %r3, -16(%r1)",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_load_indexed",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_load_indexed(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}\n        li %r8, 12\n        li %r9, -16\n        mr %r4, %r1\n        mr %r6, %r1",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_load_from_mapping",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_load_from_mapping(tmpdir, op, ofs):\n    asm = \"\"\"\n        b j2\n    j1:\n        mflr %r3\n        {op} %r4, {ofs}(%r3)\n        b end\n    j2:\n        bl j1\n        .string \"the quick brown fox jumps over the lazy dog\"",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_store",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_store(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, 0x5555\n        ori %r3, %r3, 0x5555\n        stw %r3, 12(%r1)\n        stw %r3, -16(%r1)\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_store_indexed",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_store_indexed(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, 0x5555\n        ori %r3, %r3, 0x5555\n        stw %r3, 12(%r1)\n        stw %r3, -16(%r1)\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_load_lmw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_load_lmw(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0xdead\n        stwu %r3, 4(%r1)\n        ori %r3, %r3, 0xbeef\n        stwu %r3, 4(%r1)\n        stw %r3, 4(%r1)\n        stw %r3, 8(%r1)\n        stw %r3, 12(%r1)\n        lmw %r27, -4(%r1)",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_load_stmw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_load_stmw(tmpdir):\n    asm = \"\"\"\n        lis %r31, 0x3131\n        lis %r30, 0x3030\n        lis %r29, 0x2929\n        lis %r28, 0x2828\n        stmw %r28, -4(%r1)\n        lwz %r3, -4(%r1)\n        lwz %r4, 0(%r1)\n        lwz %r5, 4(%r1)",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_load_lswi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_load_lswi(tmpdir, op):\n    asm = \"\"\"\n        xor %r0, %r0, %r0\n        mr %r2, %r0\n        mr %r3, %r0\n        mr %r4, %r0\n        mr %r28, %r0\n        mr %r29, %r0\n        mr %r30, %r0\n        mr %r31, %r0",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_store_stswi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_store_stswi(tmpdir, op):\n    initreg = [\"    lis %r{num}, 0xaa{num:02d}\\n    ori %r{num}, %r{num}, 0x55{num:02d}\".format(num=i)\n               for i in [28, 29, 30, 31, 0, 1, 2, 3, 4]]\n    asm = \"\\n\".join(initreg)+\"\"\"\n        b j2\n    j1:\n        mflr %r10\n        stswi %r28,%r10,{op}\n        b end\n    j2:",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_store_std",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_store_std(tmpdir, op):\n    asm = \"\"\"\n    mflr %r0\n    li %r1, 0xb8\n    li %r4, 24\n    slw %r1, %r1, %r4\n    std{op} %r0, 0x10(%r1)\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\"])\n@pytest.mark.parametrize(\"op\", [\"\", \"u\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_ld",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_ld(tmpdir, op):\n    asm = \"\"\"\n    mflr %r0\n    li %r1, 0x0\n    addi %r1, %r1, 0xb8000000\n    ld{op} %r0, 0x7010(%r1)\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r1\"])\n##   ___                          ___ ___\n##  / _ \\ _ __ ___   ___ _ _     / __| _ \\",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_ops",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_cr_ops(tmpdir, op, op32, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        {op} {op5}, {op5_}, {op5__}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\"])\ndef test_cr_mcrf(tmpdir, op3, op3_, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mcrf",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_cr_mcrf(tmpdir, op3, op3_, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        mcrf {op3}, {op3_}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\"])\n@pytest.mark.parametrize(\"crval\", [x<<12 for x in range(16)])\ndef test_cr_mtcrf(tmpdir, crval):",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mtcrf",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_cr_mtcrf(tmpdir, crval):\n    asm = \"\"\"\n        lis %r3, {crval}\n        mtcrf 0xff, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\" ])\ndef test_cr_mtcrf2(tmpdir, op8, op32):\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mtcrf2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_cr_mtcrf2(tmpdir, op8, op32):\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf {op8:#x}, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\" ])\ndef test_cr_mfcr(tmpdir, op32):",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mfcr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_cr_mfcr(tmpdir, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        mfcr %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr\"])\n##  ___              _      _\n## / __|_ __  ___ __(_)__ _| |",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_special_mtspr_xer",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_special_mtspr_xer(tmpdir, xerval, op8):\n    asm = \"\"\"\n        lis %r3, {xerval}\n        ori %r3, %r3, {op8}\n        mtspr 1, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"so\", \"ov\", \"ca\", \"tbc\"])\ndef test_special_XERso_to_CRso(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x8000",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_special_XERso_to_CRso",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_special_XERso_to_CRso(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x8000\n        mtspr 1, %r3     # so = 1\n        lis %r4, 0\n        mtcrf 0xff,%r4\n        lis %r5, 0\n        add. %r6, %r5, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"r6\", \"cr:60-63\", \"so\", \"ov\", \"ca\" ])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_special_mfspr_processor_version",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "def test_special_mfspr_processor_version(tmpdir):\n    ## PV value comes from powerpc.ini\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3,%r3,0x5678\n        mfspr %r3, 287\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\"])",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "powerpc64",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "powerpc64 = PowerPC64(os.path.join(os.path.dirname(os.path.realpath(__file__)),'powerpc64.ini.in'))\ncompare = powerpc64.compare\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"\n        ori %r0,%r31,0",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "compare = powerpc64.compare\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"\n        ori %r0,%r31,0\n        nop",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "ARITH_OPS",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "ARITH_OPS = [\"add\", \"sub\", \"addc\", \"subfc\", \"adde\", \"subfe\"]\n@pytest.mark.parametrize(\"op\", ARITH_OPS)\ndef test_arith_op(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op} %r5, %r3, %r4",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "VALID_COND_BYTES",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "VALID_COND_BYTES = [ 0x00,       0x02,       0x04,       0x06, 0x07,\n                     0x08,       0x0a,       0x0c,       0x0e, 0x0f,\n                     0x10,       0x12,       0x14,\n                     0x18, 0x19, 0x1a, 0x1b,                         ]\n@pytest.mark.parametrize(\"cr7\", list(range(16)))\n@pytest.mark.parametrize(\"bit\", [\"gt\", \"lt\", \"eq\", \"so\"])\n@pytest.mark.parametrize(\"cond\", VALID_COND_BYTES)\n@pytest.mark.parametrize(\"ctr\", [0, 1])\ndef test_branch_bclr(tmpdir, cr7, bit, cond, ctr):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "CR_OPS",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc64_isn",
        "description": "plugins.bincat.test.test_powerpc64_isn",
        "peekOfCode": "CR_OPS = [\"crand\", \"crandc\", \"creqv\", \"crnand\",\n          \"crnor\", \"cror\", \"crorc\", \"crxor\"]\n@pytest.mark.parametrize(\"op\", CR_OPS)\ndef test_cr_ops(tmpdir, op, op32, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        {op} {op5}, {op5_}, {op5__}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_nop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_basics_nop(tmpdir):\n    asm = \"\"\"\n        ori %r0,%r31,0\n        nop\n    \"\"\"\n    compare(tmpdir, asm, [])\ndef test_basics_assign(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_basics_assign(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\"])\ndef test_basics_assign2(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_basics_assign2(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xffff\n        ori %r4, %r4, 0xA5A5\n        lis %r5, 0xA1B2\n        ori %r5, %r5, 0xD4C3\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\"])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_op(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op} %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\" ])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_op_dot(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\" ])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_o",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_op_o(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op}o %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"ov\" ])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_o_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_op_o_dot(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op}o. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\", \"ov\", \"ca\" ])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_op_flags",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_op_flags(tmpdir, op, xer, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {xer}\n        mtspr 1, %r3       # update XER\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        {op}o. %r5, %r3, %r4\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_addi(tmpdir, op, op32, op16_s):\n    asm = \"\"\"\n        lis %r0, {op32}@h\n        ori %r0, %r0, {op32}@l\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {op} %r4, %r3, {op16_s}\n        {op} %r5, %r0, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r0\", \"r3\", \"r4\", \"r5\"])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_addic(tmpdir, op32, op16_s):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        addic %r4, %r3, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"ca\"])\n@pytest.mark.parametrize(\"op\", [\"addic.\", \"subfic\"])\ndef test_arith_addic_doc_subfic(tmpdir, op, op32, op16_s):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addic_doc_subfic",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_addic_doc_subfic(tmpdir, op, op32, op16_s):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        mtspr 1, %r3       # update XER (for XER.so flag)\n        {op} %r4, %r3, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"ca\", \"cr:29-31\"])\n@pytest.mark.parametrize(\"op\", [\"addme\", \"addze\", \"subfme\", \"subfze\"])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_addmeo_addzeo_subfmeo_subfzeo_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_addmeo_addzeo_subfmeo_subfzeo_dot(tmpdir, op, xer, op32):\n    asm = \"\"\"\n        lis %r3, {xer}\n        mtspr 1, %r3       # update XER\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {op}o. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\", \"ov\", \"ca\" ])\ndef test_arith_extsb(tmpdir, op8):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_extsb",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_extsb(tmpdir, op8):\n    asm = \"\"\"\n        li %r3, {op8}\n        extsb. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\ndef test_arith_extsh(tmpdir, op16_s):\n    asm = \"\"\"\n        li %r3, {op16_s}\n        extsh. %r4, %r3",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_extsh",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_extsh(tmpdir, op16_s):\n    asm = \"\"\"\n        li %r3, {op16_s}\n        extsh. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\ndef test_arith_divw(tmpdir, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_divw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_divw(tmpdir, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        divwo. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    invalid = (op32_== 0) or (op32 == 0x80000000 and op32_ == 0xffffffff)\n    top = { \"r5\": 0xffffffff, \"cr\":0xe0000000 } if invalid else {}",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_divwu",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_divwu(tmpdir, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        divwuo. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    invalid = op32_== 0\n    top = { \"r5\": 0xffffffff, \"cr\":0xe0000000 } if invalid else {}",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_mul",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_mul(tmpdir, op, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32}@h\n        ori %r4, %r4, {op32}@l\n        {op}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\"])\ndef test_arith_mulli(tmpdir, op32, op16_s):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_mulli",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_arith_mulli(tmpdir, op32, op16_s):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mulli %r4, %r3, {op16_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\"])\n##  _              _\n## | |   ___  __ _(_)__\n## | |__/ _ \\/ _` | / _|",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_with_flags",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_with_flags(tmpdir, logic, op32, op32_):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        {logic}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\" ])\n@pytest.mark.parametrize(\"logic\", [\"ori\", \"oris\", \"xori\", \"xoris\" ])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_imm(tmpdir, logic, op32, op16):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {logic} %r4, %r3, {op16}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\"])\n@pytest.mark.parametrize(\"logic\", [\"andi.\", \"andis.\" ])\ndef test_logic_imm_dot(tmpdir, logic, op32, op16):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_imm_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_imm_dot(tmpdir, logic, op32, op16):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        {logic} %r4, %r3, {op16}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\ndef test_logic_neg(tmpdir, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_neg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_neg(tmpdir, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        nego. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\", \"ov\" ])\n@pytest.mark.parametrize(\"exp\", list(range(33)))\ndef test_cntlzw(tmpdir, exp, op32):\n    op32 |= 2**exp",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_cntlzw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_cntlzw(tmpdir, exp, op32):\n    op32 |= 2**exp\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        cntlzw. %r4, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\n@pytest.mark.parametrize(\"op\", [\"rlwimi\", \"rlwinm\"])\ndef test_logic_rlwimi_rlwinm_dot(tmpdir, op, op32, op32_, op5, op5_, op5__):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_rlwimi_rlwinm_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_rlwimi_rlwinm_dot(tmpdir, op, op32, op32_, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        lis %r4, {op32_}@h\n        ori %r4, %r4, {op32_}@l\n        {op}. %r4, %r3, {op5}, {op5_}, {op5__}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\ndef test_logic_rlwnm_dot(tmpdir, op32, op32_, op5, op5_, op5__):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_rlwnm_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_rlwnm_dot(tmpdir, op32, op32_, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        li %r5, {op5}\n        rlwnm. %r4, %r3, %r5, {op5_}, {op5__}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\"])\n@pytest.mark.parametrize(\"op\", [\"slw\", \"srw\", \"sraw\"])\n@pytest.mark.parametrize(\"opshift\", [0, 1, 6, 30, 31, 32, 35, 63, 66, 125])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_shift_dot",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_shift_dot(tmpdir, op, op32, opshift):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtspr 1, %r3       # set ca to a determined value\n        li %r4, {opshift}\n        {op}. %r5, %r3, %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"cr:29-31\", \"ca\"])\ndef test_logic_srawi(tmpdir, op32, op5):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_srawi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_logic_srawi(tmpdir, op32, op5):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtspr 1, %r3       # set ca to a determined value\n        srawi. %r4, %r3, {op5}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr:29-31\", \"ca\"])\n##   ___\n##  / __|___ _ __  _ __  __ _ _ _ ___",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_compare_cmp_cmpl",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_compare_cmp_cmpl(tmpdir, op, crfD, op32h, op32h_):\n    so = op32h & 0x8000\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {so}\n        mtspr 1, %r3     # so = 0 or 1\n        lis %r3, {op32h}\n        lis %r4, {op32h_}\n        {op}  cr{crfD}, %r3, %r4",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_compare_cmpli",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_compare_cmpli(tmpdir, crfD, op32h, op32h_):\n    so = op32h & 0x8000\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {so}\n        mtspr 1, %r3     # so = 0 or 1\n        lis %r3, {op32h}\n        cmpli  cr{crfD}, %r3, {op32h_}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_compare_cmpi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_compare_cmpi(tmpdir, crfD, op32h, op16_s):\n    so = op32h & 0x8000\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {so}\n        mtspr 1, %r3     # so = 0 or 1\n        lis %r3, {op32h}\n        cmpi  cr{crfD}, %r3, {op16_s}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_b",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_b(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        lis %r4, 0x4321\n        b next\n        lis %r3, 0xabcd\n      next:\n        lis %r4, 0xdcba\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\", \"r4\"])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_b_back",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_b_back(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234\n        b j1\n        lis %r3, 0xabcd\n      j2:\n        lis %r4, 0xabcd",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_and_link",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_and_link(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234\n        bl j1\n        lis %r3, 0xabcd\n        b j2\n      j1:",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_and_link2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_and_link2(tmpdir):\n    asm = \"\"\"\n        bl j1\n        nop\n        nop\n      j1:\n        mflr %r3\n        bl j2\n        nop\n        nop",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_bclr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_bclr(tmpdir, cr7, bit, cond, ctr):\n    asm = \"\"\"\n        li %r7, {cr7}\n        mtcrf 0xff, %r7\n        li %r8, {ctr}\n        mtctr %r8\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_bcctr_bclr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_bcctr_bclr(tmpdir, cr7, bit, cond, ctr):\n    asm = \"\"\"\n        li %r7, {cr7}\n        mtcrf 0xff, %r7\n        li %r8, {ctr}\n        mtctr %r8\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_branch_cond",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_branch_cond(tmpdir, cr7, bit, cond):\n    asm = \"\"\"\n        li %r3, {cr7}\n        mtcrf 0xff, %r3\n        lis %r3, 0x1234\n        lis %r4, 0x1234\n        lis %r5, 0x1234\n        lis %r6, 0x1234\n        lis %r7, 0x1234\n        lis %r8, 0x1234",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_load",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_load(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}\n        mr %r4, %r1\n        mr %r6, %r1\n        stw %r3, 12(%r1)\n        stw %r3, -16(%r1)",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_load_indexed",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_load_indexed(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}\n        li %r8, 12\n        li %r9, -16\n        mr %r4, %r1\n        mr %r6, %r1",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_load_from_mapping",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_load_from_mapping(tmpdir, op, ofs):\n    asm = \"\"\"\n        b j2\n    j1:\n        mflr %r3\n        {op} %r4, {ofs}(%r3)\n        b end\n    j2:\n        bl j1\n        .string \"the quick brown fox jumps over the lazy dog\"",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_store",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_store(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, 0x5555\n        ori %r3, %r3, 0x5555\n        stw %r3, 12(%r1)\n        stw %r3, -16(%r1)\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_store_indexed",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_store_indexed(tmpdir, op, val):\n    valh = val >> 16\n    vall = val & 0xffff\n    asm = \"\"\"\n        lis %r3, 0x5555\n        ori %r3, %r3, 0x5555\n        stw %r3, 12(%r1)\n        stw %r3, -16(%r1)\n        lis %r3, {valh}\n        ori %r3, %r3, {vall}",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_load_lmw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_load_lmw(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0xdead\n        stwu %r3, 4(%r1)\n        ori %r3, %r3, 0xbeef\n        stwu %r3, 4(%r1)\n        stw %r3, 4(%r1)\n        stw %r3, 8(%r1)\n        stw %r3, 12(%r1)\n        lmw %r27, -4(%r1)",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_load_stmw",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_load_stmw(tmpdir):\n    asm = \"\"\"\n        lis %r31, 0x3131\n        lis %r30, 0x3030\n        lis %r29, 0x2929\n        lis %r28, 0x2828\n        stmw %r28, -4(%r1)\n        lwz %r3, -4(%r1)\n        lwz %r4, 0(%r1)\n        lwz %r5, 4(%r1)",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_load_lswi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_load_lswi(tmpdir, op):\n    asm = \"\"\"\n        xor %r0, %r0, %r0\n        mr %r1, %r0\n        mr %r2, %r0\n        mr %r3, %r0\n        mr %r4, %r0\n        mr %r28, %r0\n        mr %r29, %r0\n        mr %r30, %r0",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_store_stswi",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_store_stswi(tmpdir, op):\n    initreg = [\"    lis %r{num}, 0xaa{num:02d}\\n    ori %r{num}, %r{num}, 0x55{num:02d}\".format(num=i)\n               for i in [28, 29, 30, 31, 0, 1, 2, 3, 4]]\n    asm = \"\\n\".join(initreg)+\"\"\"\n        b j2\n    j1:\n        mflr %r10\n        stswi %r28,%r10,{op}\n        b end\n    j2:",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_ops",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_cr_ops(tmpdir, op, op32, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        {op} {op5}, {op5_}, {op5__}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\"])\ndef test_cr_mcrf(tmpdir, op3, op3_, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mcrf",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_cr_mcrf(tmpdir, op3, op3_, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        mcrf {op3}, {op3_}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\"])\n@pytest.mark.parametrize(\"crval\", [x<<12 for x in range(16)])\ndef test_cr_mtcrf(tmpdir, crval):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mtcrf",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_cr_mtcrf(tmpdir, crval):\n    asm = \"\"\"\n        lis %r3, {crval}\n        mtcrf 0xff, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\" ])\ndef test_cr_mtcrf2(tmpdir, op8, op32):\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mtcrf2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_cr_mtcrf2(tmpdir, op8, op32):\n    asm = \"\"\"\n        lis %r3, 0\n        mtcrf 0xff, %r3\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf {op8:#x}, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"cr\" ])\ndef test_cr_mfcr(tmpdir, op32):",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_cr_mfcr",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_cr_mfcr(tmpdir, op32):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        mfcr %r4\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"cr\"])\n##  ___              _      _\n## / __|_ __  ___ __(_)__ _| |",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_special_mtspr_xer",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_special_mtspr_xer(tmpdir, xerval, op8):\n    asm = \"\"\"\n        lis %r3, {xerval}\n        ori %r3, %r3, {op8}\n        mtspr 1, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"so\", \"ov\", \"ca\", \"tbc\"])\ndef test_special_XERso_to_CRso(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x8000",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_special_XERso_to_CRso",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_special_XERso_to_CRso(tmpdir):\n    asm = \"\"\"\n        lis %r3, 0x8000\n        mtspr 1, %r3     # so = 1\n        lis %r4, 0\n        mtcrf 0xff,%r4\n        lis %r5, 0\n        add. %r6, %r5, %r3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"r3\", \"r4\", \"r5\", \"r6\", \"cr:28-31\", \"so\", \"ov\", \"ca\" ])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_special_mfspr_processor_version",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "def test_special_mfspr_processor_version(tmpdir):\n    ## PV value comes from powerpc.ini\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3,%r3,0x5678\n        mfspr %r3, 287\n    \"\"\"\n    compare(tmpdir, asm, [\"r3\"])",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "powerpc",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "powerpc = PowerPC(os.path.join(os.path.dirname(os.path.realpath(__file__)),'powerpc.ini.in'))\ncompare = powerpc.compare\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"\n        ori %r0,%r31,0",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "compare = powerpc.compare\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"\n        ori %r0,%r31,0\n        nop",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "ARITH_OPS",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "ARITH_OPS = [\"add\", \"sub\", \"addc\", \"subfc\", \"adde\", \"subfe\"]\n@pytest.mark.parametrize(\"op\", ARITH_OPS)\ndef test_arith_op(tmpdir, op):\n    asm = \"\"\"\n        lis %r3, 0x1234\n        ori %r3, %r3, 0x5678\n        lis %r4, 0xabcd\n        ori %r4, %r4, 0xffff\n        mtspr 1, %r3       # update XER\n        {op} %r5, %r3, %r4",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "VALID_COND_BYTES",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "VALID_COND_BYTES = [ 0x00,       0x02,       0x04,       0x06, 0x07,\n                     0x08,       0x0a,       0x0c,       0x0e, 0x0f,\n                     0x10,       0x12,       0x14,\n                     0x18, 0x19, 0x1a, 0x1b,                         ]\n@pytest.mark.parametrize(\"cr7\", list(range(16)))\n@pytest.mark.parametrize(\"bit\", [\"gt\", \"lt\", \"eq\", \"so\"])\n@pytest.mark.parametrize(\"cond\", VALID_COND_BYTES)\n@pytest.mark.parametrize(\"ctr\", [0, 1])\ndef test_branch_bclr(tmpdir, cr7, bit, cond, ctr):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "CR_OPS",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_powerpc_isn",
        "description": "plugins.bincat.test.test_powerpc_isn",
        "peekOfCode": "CR_OPS = [\"crand\", \"crandc\", \"creqv\", \"crnand\",\n          \"crnor\", \"cror\", \"crorc\", \"crxor\"]\n@pytest.mark.parametrize(\"op\", CR_OPS)\ndef test_cr_ops(tmpdir, op, op32, op5, op5_, op5__):\n    asm = \"\"\"\n        lis %r3, {op32}@h\n        ori %r3, %r3, {op32}@l\n        mtcrf 0xff, %r3\n        {op} {op5}, {op5_}, {op5__}\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_powerpc_isn",
        "documentation": {}
    },
    {
        "label": "test_parse_val",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_pybincat_tools",
        "description": "plugins.bincat.test.test_pybincat_tools",
        "peekOfCode": "def test_parse_val(test, expval, exptop, expbot):\n    val, top, bot = parse_val(test)\n    assert val == expval\n    assert top == exptop\n    assert bot == expbot\n@pytest.mark.parametrize(\"test\", [\n    \"012_45\", \"42?\", \"0x123,?=0xf, 0x45\",\n    \"123,_=0xff,?=0xff0\",\n])\ndef test_parse_val_exc(test):",
        "detail": "plugins.bincat.test.test_pybincat_tools",
        "documentation": {}
    },
    {
        "label": "test_parse_val_exc",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_pybincat_tools",
        "description": "plugins.bincat.test.test_pybincat_tools",
        "peekOfCode": "def test_parse_val_exc(test):\n    with pytest.raises(Exception):\n        parse_val(test)",
        "detail": "plugins.bincat.test.test_pybincat_tools",
        "documentation": {}
    },
    {
        "label": "test_basics_nop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_nop(tmpdir):\n    asm = \"\"\"\n        nop\n    \"\"\"\n    show_cpu(tmpdir, asm, [])\ndef test_basics_assign_lui(tmpdir):\n    asm = \"\"\"\n        lui x20, 0x12345\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign_lui",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_assign_lui(tmpdir):\n    asm = \"\"\"\n        lui x20, 0x12345\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])\ndef test_basics_assign_lui_sext(tmpdir):\n    asm = \"\"\"\n        lui x20, 0x82345\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign_lui_sext",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_assign_lui_sext(tmpdir):\n    asm = \"\"\"\n        lui x20, 0x82345\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])\ndef test_basics_assign_li(tmpdir):\n    asm = \"\"\"\n        li x20, 0x12345678\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign_li",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_assign_li(tmpdir):\n    asm = \"\"\"\n        li x20, 0x12345678\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])\ndef test_basics_assign_li_sext(tmpdir):\n    asm = \"\"\"\n        li x20,0x82345678\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign_li_sext",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_assign_li_sext(tmpdir):\n    asm = \"\"\"\n        li x20,0x82345678\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])\ndef test_basics_assign_auipc(tmpdir):\n    asm = \"\"\"\n        auipc x20,0x12345\n        nop\n        auipc x21,0x12345",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assign_auipc",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_assign_auipc(tmpdir):\n    asm = \"\"\"\n        auipc x20,0x12345\n        nop\n        auipc x21,0x12345\n        sub x20,x21,x20\n    \"\"\"\n    compare(tmpdir, asm, [\"x20\"])\ndef test_basics_assignx2(tmpdir):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_basics_assignx2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_basics_assignx2(tmpdir):\n    asm = \"\"\"\n        li x0,0xff001234\n        li x1,0xff011234\n        li x2,0xff021234\n        li x3,0xff031234\n        li x4,0xff041234\n        li x5,0xff051234\n        li x6,0xff061234\n        li x7,0xff071234",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_log_rtype",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_arith_log_rtype(tmpdir, op, op32, op32_):\n    asm = \"\"\"\n    li x3, {op32}\n    li x4, {op32_}\n    {op} x5, x4, x3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x3\", \"x4\", \"x5\"])\n#I-type arithmetic and logical instructions\n#op can be: ADDI, SLTI, XORI, ORI, ANDI, SLLI, SRLI, SRAI\nop_arithmetic_logical_itype = pytest.mark.parametrize(\"op\", [\"addi\", \"slti\", \"xori\", \"ori\", \"andi\"])",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_log_itype",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_arith_log_itype(tmpdir, op, op32, op12_s):\n    asm = \"\"\"\n    li x3, {op32}\n    {op} x4, x3, {op12_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x3\", \"x4\"])\n#op can be: SLLI, SRLI, SRAI\nop_arithmetic_logical_itype = pytest.mark.parametrize(\"op\", [\"slli\", \"srli\", \"srai\"])\n@op_arithmetic_logical_itype\ndef test_arith_log_shift_itype(tmpdir, op, op32, op5):",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_log_shift_itype",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "def test_arith_log_shift_itype(tmpdir, op, op32, op5):\n    asm = \"\"\"\n    li x3, {op32}\n    {op} x4, x3, {op5}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x3\", \"x4\"])\n##  ___                  _    _\n## | _ )_ _ __ _ _ _  __| |_ (_)_ _  __ _\n## | _ \\ '_/ _` | ' \\/ _| ' \\| | ' \\/ _` |\n## |___/_| \\__,_|_||_\\__|_||_|_|_||_\\__, |",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "riscv64",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "riscv64 = RISCV64(os.path.join(os.path.dirname(os.path.realpath(__file__)),'riscv64.ini.in'))\ncompare = riscv64.compare\nshow_cpu = riscv64.show_cpu\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "compare = riscv64.compare\nshow_cpu = riscv64.show_cpu\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"\n        nop",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "show_cpu",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "show_cpu = riscv64.show_cpu\n##  ___          _\n## | _ ) __ _ __(_)__ ___\n## | _ \\/ _` (_-< / _(_-<\n## |___/\\__,_/__/_\\__/__/\n## Basics\ndef test_basics_nop(tmpdir):\n    asm = \"\"\"\n        nop\n    \"\"\"",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "op_arithmetic_logical_rtype",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "op_arithmetic_logical_rtype = pytest.mark.parametrize(\"op\", [\"add\", \"sub\", \"sll\", \"slt\", \"sltu\", \"xor\", \"srl\", \"sra\", \"or\", \"and\"])\n@op_arithmetic_logical_rtype\ndef test_arith_log_rtype(tmpdir, op, op32, op32_):\n    asm = \"\"\"\n    li x3, {op32}\n    li x4, {op32_}\n    {op} x5, x4, x3\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x3\", \"x4\", \"x5\"])\n#I-type arithmetic and logical instructions",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "op_arithmetic_logical_itype",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "op_arithmetic_logical_itype = pytest.mark.parametrize(\"op\", [\"addi\", \"slti\", \"xori\", \"ori\", \"andi\"])\n@op_arithmetic_logical_itype\ndef test_arith_log_itype(tmpdir, op, op32, op12_s):\n    asm = \"\"\"\n    li x3, {op32}\n    {op} x4, x3, {op12_s}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x3\", \"x4\"])\n#op can be: SLLI, SRLI, SRAI\nop_arithmetic_logical_itype = pytest.mark.parametrize(\"op\", [\"slli\", \"srli\", \"srai\"])",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "op_arithmetic_logical_itype",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_riscv64_isn",
        "description": "plugins.bincat.test.test_riscv64_isn",
        "peekOfCode": "op_arithmetic_logical_itype = pytest.mark.parametrize(\"op\", [\"slli\", \"srli\", \"srai\"])\n@op_arithmetic_logical_itype\ndef test_arith_log_shift_itype(tmpdir, op, op32, op5):\n    asm = \"\"\"\n    li x3, {op32}\n    {op} x4, x3, {op5}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"x3\", \"x4\"])\n##  ___                  _    _\n## | _ )_ _ __ _ _ _  __| |_ (_)_ _  __ _",
        "detail": "plugins.bincat.test.test_riscv64_isn",
        "documentation": {}
    },
    {
        "label": "test_assign",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_assign(tmpdir, op16, op32):\n    asm = \"\"\"\n        mov r12,0xabacadae1212abff\n        mov r13d,{op32:#x}\n        mov rax,0x0abbccdd\n        mov rbx,0xbbccddee11111111\n        mov rcx,0xddeeffaa\n        mov rdx,0xeeffaabb\n        mov eax,0x12341234\n        mov ebx,0xf3124331",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_assign_2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_assign_2(tmpdir):\n    asm = \"\"\"\n        mov rax,0x0\n        mov rbx,0xffffffffffffffff\n        mov ecx,0xffffffff\n        mov r9,0x82345678\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\", \"r9\"])\ndef test_movzx(tmpdir, op64):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_movzx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_movzx(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, 0\n            movzx bx, al\n            movzx ecx, al\n            movzx rdx, ax\n            mov [0x10000c], rax\n            mov r12, 0x100000\n            movzx r11d, byte [r12+0xc]",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_movsx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_movsx(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, 0\n            movsx bx, al\n            movsx ecx, al\n            movsx edx, ax\n            movsxd rdx, eax\n            mov [0x10000C], rax\n            mov r12, 0x100000",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a0",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_a0(tmpdir, op64, op8):\n    asm = \"\"\"\n        xor rax, rax\n        mov rbx, {op64:#x}\n        mov [0x100000], rbx\n        db 0a0h\n        dq 0x100000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"rax\"])\ndef test_mov_a2(tmpdir,  op8):",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_a2(tmpdir,  op8):\n    asm = \"\"\"\n        xor rax, rax\n        mov al, {op8:#x}\n        db 0a2h\n        dq 0x100000\n        xor rbx, rbx\n        mov bl, [0x100000]\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"rax\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a1",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_a1(tmpdir, op64, op8):\n    asm = \"\"\"\n        xor rax, rax\n        mov rbx, {op64:#x}\n        mov [0x100000], rbx\n        db 0a1h\n        dq 0x100000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"rax\"])\ndef test_mov_a3(tmpdir,  op64):",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a3",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_a3(tmpdir,  op64):\n    asm = \"\"\"\n    mov eax, 0x12345678\nmov [0x100004], eax\n        xor rax, rax\n        mov rax, {op64:#x}\n        db 0a3h\n        dq 0x100000\n        xor rbx, rbx\n        mov rbx, [0x100000]",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_66a1",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_66a1(tmpdir, op64, op8):\n    asm = \"\"\"\n        xor rax, rax\n        mov rbx, {op64:#x}\n        mov [0x100000], rbx\n        db 066h\n        db 0a1h\n        dq 0x100000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"rax\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_66a3",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_66a3(tmpdir,  op64):\n    asm = \"\"\"\n    mov rax, 0x12345678abcdef\n    mov [0x100000], rax\n        xor rax, rax\n        mov rax, {op64:#x}\n        db 066\n        db 0a3h\n        dq 0x100000\n        xor rbx, rbx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_mem",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_mem(tmpdir, op64, op8):\n    asm = \"\"\"\n        mov rax, {op64:#x}\n        mov [{op8}+0x100000], al\n        mov [{op8}+0x100004], ax\n        mov [{op8}+0x100008], eax\n        mov [{op8}+0x10000C], rax\n        xor ebx, ebx\n        xor ecx, ecx\n        xor r8, r8",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_mem_to_reg8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_mem_to_reg8(tmpdir, op8):\n    asm = \"\"\"\n        mov eax, 0x12345678\n        mov [{op8}+0x100000], rax\n        ; test bpl\n        push rbp\n        xor ebp, ebp\n        mov bpl, [{op8}+0x100000]\n        mov rbx, rbp\n        pop rbp",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_mem_reg64_off",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_mem_reg64_off(tmpdir, op64, op8, op32):\n    asm = \"\"\"\n        mov rax, {op64}\n        mov rdi, 4\n        mov r12, 0x100400\n        mov [{op8}+r12], al\n        mov [{op8}+r12+rdi], ax\n        mov [{op8}+r12+rdi*2], eax\n        mov [{op8}+r12+rdi*4], rax\n        mov dword [{op8}+r12+rdi*8], {op32}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_mem_prefix_rexw0_off",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_mov_mem_prefix_rexw0_off(tmpdir, op64, op8):\n        asm = \"\"\"\n        mov rax, {op64}\n        mov rdi, 4\n        mov r12, 0x100400\n        mov rcx, 0x12345678abcdef90\n        mov [0x100400], rcx\n        mov [{op8}+r12], al\n        xor rcx, rcx\n        mov rcx,  [r12]",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_lea_complex",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_lea_complex(tmpdir, op32):\n    asm = \"\"\"\n            mov r8, {op32:#x}\n            mov r12, {op32:#x}\n            mov rax, {op32:#x}\n            mov rdx, -1\n            lea r9, [r8+r12*2+0x124000]\n            lea rbx, [rax*8+rax+0x124000]\n            lea edx, [r8+r12+0x124000]\n          \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_imm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_add_imm32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            add eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_add_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            add eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_add_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            add ax, bx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_imm32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_imm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sub_imm32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            sub eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sub_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            sub eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sub_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            sub ax, bx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov rax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_add_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov rax, {op32:#x}\n            add al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_adc_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op32:#x}\n            adc al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov rax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sub_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov rax, {op32:#x}\n            sub al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sbb_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op32:#x}\n            sbb al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_carrytop_adc(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_carrytop_adc",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_carrytop_adc(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            adc eax, ebx\n          \"\"\".format(**locals())\n    topmask = (op32+op32_)^(op32+op32_+1)\n    compare(tmpdir, asm,\n            [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"],\n            top_allowed = {\"rax\":topmask,",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_adc_reg32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            adc eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_adc_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov edx, {op16_:#x}\n            mov ecx, {op16_:#x}\n            adc dx, cx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rdx\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_imm32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_imm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_adc_imm32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            adc eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_reg32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sbb_reg32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            sbb eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sbb_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            sbb ax, bx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_inc_reg32(tmpdir, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_inc_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_inc_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            inc eax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"pf\", \"af\"])\ndef test_arith_add_imm64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            add rax, {op64_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_imm64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_add_imm64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            add rax, {op64_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_add_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}\n            add rax, rbx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_imm64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_imm64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sub_imm64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            sub rax, {op64_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sub_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}\n            sub rax, rbx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_carrytop_adc64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_carrytop_adc64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_carrytop_adc64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}\n            adc rax, rbx\n          \"\"\".format(**locals())\n    topmask = (op64+op64_)^(op64+op64_+1)\n    compare(tmpdir, asm,\n            [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"],\n            top_allowed = {\"rax\":topmask,",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_adc_reg64(tmpdir, op64, op64_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}\n            adc rax, rbx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_imm64(tmpdir, op64, op64_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_imm64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_adc_imm64(tmpdir, op64, op64_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op64:#x}\n            adc rax, {op64_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_reg64(tmpdir, op64, op64_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_sbb_reg64(tmpdir, op64, op64_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}\n            sbb rax, rbx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_inc_reg64(tmpdir, op64):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_inc_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_inc_reg64(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            inc rax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"pf\", \"af\"])\ndef test_arith_inc_reg64_32(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            inc eax",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_inc_reg64_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_inc_reg64_32(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            inc eax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"pf\", \"af\"])\ndef test_arith_xor_reg64_32(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_xor_reg64_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_arith_xor_reg64_32(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64_:#x}\n            xor eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"pf\"])\n##                                      _\n##  ___  ___  __ _ _ __ ___   ___ _ __ | |_ ___\n## / __|/ _ \\/ _` | '_ ` _ \\ / _ \\ '_ \\| __/ __|",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_32bit_switch",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_32bit_switch(tmpdir):\n    asm = \"\"\"\nstart:\n        ;; prepare rsi and rdi for the test\n        mov rsi, 0xffffffffffffffff\n        mov rdi, rsi\n        ;; compute stack width in 64 bits\n        mov rcx, rsp\n        push rax\n        sub rcx, rsp",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_fs_access",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_fs_access(tmpdir):\n    asm = \"\"\"\n        mov rax, 0x12345678abcdef\n        mov [fs:0x8], rax\n        mov rbx, [fs:0x8]\n    \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\"])\n##  _                          _\n## | |__  _ __ __ _ _ __   ___| |__\n## | '_ \\| '__/ _` | '_ \\ / __| '_ \\",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_call",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_call(tmpdir):\n    asm = \"\"\"\n        call target\nalign 0x100\ntarget:\n        pop rax\n        call target2\nalign 0x100\ntarget2:\n        pop rbx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_call_indirect",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_call_indirect(tmpdir):\n    asm = \"\"\"\n        call target\ntarget:\n        pop rax\n        lea rbx, [rax+target2-target]\n        mov [rax+store-target], rbx\n        call [rax+store-target]\nstore:\n        dq 0",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_jmp",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_jmp(tmpdir):\n    asm = \"\"\"\n        jmp target\n        xor rax, rax\n        dec rax\n        jmp end\nalign 0x100\ntarget:\n        mov rax, 1\nend:",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_jmp_reg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_jmp_reg(tmpdir, op8):\n    asm = \"\"\"\n        lea rbx, [rel {op8:#x}]\nalign 0x100\nstart:\n        lea rbx, [rel target]\n        xor rax, rax\n        dec rax\n        jmp rbx\nalign 0x100",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_test_ax16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_test_ax16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            xor rax, rax\n            mov ax, {op16:#x}\n            test ax, {op16_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"sf\", \"zf\", \"pf\"])\ndef test_cond_test_reg8(tmpdir, op8, op8_):\n    asm = \"\"\"\n            xor rcx, rcx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_test_reg8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_test_reg8(tmpdir, op8, op8_):\n    asm = \"\"\"\n            xor rcx, rcx\n            mov cl, {op8:#x}\n            test cl, {op8_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rcx\", \"sf\", \"zf\", \"pf\"])\ndef test_cond_test_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            xor rbx, rbx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_test_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_test_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            xor rbx, rbx\n            mov bx, {op16:#x}\n            test bx, {op16_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"sf\", \"zf\", \"pf\"])\ndef test_cond_test_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_test_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_test_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            test eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"sf\", \"zf\", \"pf\"])\ndef test_cond_cmp_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            cmp eax, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_cmp_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_cmp_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            cmp eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_cond_test_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rbx, {op64:#x}\n            test rbx, {op64_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_test_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_test_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rbx, {op64:#x}\n            test rbx, {op64_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"sf\", \"zf\", \"pf\"])\ndef test_cond_cmp_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rbx, {op64:#x}\n            cmp rbx, {op64_:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_cmp_reg64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_cmp_reg64(tmpdir, op64, op64_):\n    asm = \"\"\"\n            mov rbx, {op64:#x}\n            cmp rbx, {op64_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_cond_jump_jne(tmpdir, loop_cnt):\n    asm = \"\"\"\n            mov rcx, {loop_cnt}\n            mov rax, 0",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_jump_jne",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_cond_jump_jne(tmpdir, loop_cnt):\n    asm = \"\"\"\n            mov rcx, {loop_cnt}\n            mov rax, 0\n         loop:\n            inc rax\n            dec rcx\n            cmp rcx,0\n            jne loop\n          \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_loop_repne_scasb",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_loop_repne_scasb(tmpdir):\n    asm = \"\"\"\n            push 0x00006A69\n            push 0x68676665\n            push 0x64636261\n            mov rdi, rsp\n            xor al,al\n            mov rcx, 0xffffffff\n            cld\n            repne scasb",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_loop_repne_scasb_unknown_memory",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_loop_repne_scasb_unknown_memory(tmpdir):\n    asm = \"\"\"\n            mov rdi, rsp\n            xor al,al\n            mov rcx, 0xff\n            cld\n            repne scasb\n            pushf\n            sub rdi, rsp\n            mov rdx, rcx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_loop_loop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_loop_loop(tmpdir):\n    asm = \"\"\"\n            mov rcx, 0x40\n            mov rax, 0\n         loop:\n            inc rax\n            loop loop\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rcx\", \"zf\", \"of\", \"pf\", \"af\", \"sf\"])\n##                  _          __",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_push16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_push16(tmpdir):\n    asm = \"\"\"\n            xor rbx, rbx\n            mov rax, 0x123456789abcdef0\n            mov rdx, rax\n            push rdx ; push defined data on stack\n            push rdx\n            push ax\n            pop rbx\n            push dx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_push16_mem",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_push16_mem(tmpdir):\n    asm = \"\"\"\n            xor rbx, rbx\n            mov rax, 0x123456789abcdef0\n            mov rdx, rax\n            push ax\n            push rdx\n            push rdx\n            push word [rsp+2]\n            pop rbx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_push64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_push64(tmpdir):\n    asm = \"\"\"\n            xor rbx, rbx\n            mov rax, 0x123456789abcdef0\n            mov rdx, rax\n            push rax\n            pop rbx\n            push rdx\n            pop rcx\n         \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_push_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_push_imm(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            push rax\n            pop rbx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rbx\"])\n##  __  __ ___ ___  ___\n## |  \\/  |_ _/ __|/ __|\n## | |\\/| || |\\__ \\ (__",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_movzx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_movzx(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov esi, {op32:#x}\n            mov rbx, 0\n            movzx bx, al\n            movzx rcx, al\n            movzx rdx, ax\n            movzx rdi, sil\n          \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_movsx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_movsx(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov rbx, 0\n            movsx bx, al\n            movsx rcx, al\n            movsx rdx, ax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\", \"rdx\"])\ndef test_misc_pushf_popf(tmpdir):",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_pushf_popf",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_pushf_popf(tmpdir):\n    asm = \"\"\"\n            stc\n            mov eax, 0x7fffffff\n            mov rbx, 0x7fffffff\n            pushf\n            popf\n            adc ax, bx\n          \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xlat",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xlat(tmpdir, op8):\n    asm = \"\"\"\n            mov rcx, 64\n         loop:\n            mov eax, 0x01020304\n            mul rcx\n            push rax\n            dec rcx\n            jnz loop\n            mov rbx, rsp",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_bswap",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_bswap(tmpdir, op64):\n    asm = \"\"\"\n           mov rax, {op64:#x}\n           mov rbx, {op64:#x}\n           mov rsi, {op64:#x}\n           mov r10, {op64:#x}\n           mov r15, {op64:#x}\n           bswap rax\n           bswap rbx\n           bswap rsi",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_bswap_32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_bswap_32(tmpdir, op64):\n    asm = \"\"\"\n           mov rax, {op64:#x}\n           mov rbx, {op64:#x}\n           mov rsi, {op64:#x}\n           bswap eax\n           bswap ebx\n           bswap esi\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rsi\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xchg_m64_r64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xchg_m64_r64(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov rax, 0x87654641\n           xchg [rsp+4], rax\n           pop rbx\n           pop rcx\n         \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xchg_m8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xchg_m8_r8(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov rax, 0x87654321\n           xchg [rsp+4], al\n           pop rbx\n           pop rcx\n         \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xchg_r64_r64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xchg_r64_r64(tmpdir):\n    asm = \"\"\"\n           mov rax, 0x12345678\n           mov rbx, 0x87654641\n           xchg rax, rbx\n         \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\"])\ndef test_misc_cmpxchg_r64_r64(tmpdir, someval64, someval64_, someval64__):\n    asm = \"\"\"\n           mov rax, {someval64:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_r64_r64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_cmpxchg_r64_r64(tmpdir, someval64, someval64_, someval64__):\n    asm = \"\"\"\n           mov rax, {someval64:#x}\n           mov rbx, {someval64_:#x}\n           mov rcx, {someval64__:#x}\n           cmpxchg rbx, rcx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\", \"zf\"])\ndef test_misc_cmpxchg_r16_r16(tmpdir, someval16, someval16_, someval16__):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_r16_r16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_cmpxchg_r16_r16(tmpdir, someval16, someval16_, someval16__):\n    asm = \"\"\"\n           mov rax, {someval16:#x}\n           mov rbx, {someval16_:#x}\n           mov rcx, {someval16__:#x}\n           cmpxchg bx, cx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\", \"zf\"])\ndef test_misc_cmpxchg_r8_r8(tmpdir, someval8, someval8_, someval8__):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_r8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_cmpxchg_r8_r8(tmpdir, someval8, someval8_, someval8__):\n    asm = \"\"\"\n           mov rax, {someval8:#x}\n           mov rbx, {someval8_:#x}\n           mov rcx, {someval8__:#x}\n           cmpxchg bl, cl\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\", \"zf\"])\ndef test_misc_cmpxchg_m64_r64(tmpdir, someval64, someval64_, someval64__):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_m64_r64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_cmpxchg_m64_r64(tmpdir, someval64, someval64_, someval64__):\n    asm = \"\"\"\n           mov rax, {someval64:#x}\n           push 0\n           push {someval64_:#x}\n           mov rcx, {someval64__:#x}\n           cmpxchg [rsp+4], rcx\n           pop rbx\n           pop rbx\n         \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg8b_posofs",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_cmpxchg8b_posofs(tmpdir, someval64, someval64_, someval64__):\n    # keep order of registers so that rdx:eax <- v1, rcx:rbx <- v2 and [rsp+4] <- v3\n    v1h, v1l = someval64>>32,   someval64&0xffffffff\n    v2h, v2l = someval64_>>32,  someval64_&0xffffffff\n    v3h, v3l = someval64__>>32, someval64__&0xffffffff\n    asm = \"\"\"\n           mov rdx, {v1h:#x}\n           mov rax, {v1l:#x}\n           mov rcx, {v2h:#x}\n           mov rbx, {v2l:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg8b_negofs",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_cmpxchg8b_negofs(tmpdir, someval64, someval64_, someval64__):\n    # keep order of registers so that rdx:eax <- v1, rcx:rbx <- v2 and [rsp+4] <- v3\n    v1h, v1l = someval64>>32,   someval64&0xffffffff\n    v2h, v2l = someval64_>>32,  someval64_&0xffffffff\n    v3h, v3l = someval64__>>32, someval64__&0xffffffff\n    asm = \"\"\"\n           mov rsi, rsp\n           mov rdx, {v1h:#x}\n           mov rax, {v1l:#x}\n           mov rcx, {v2h:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_r64_r64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xadd_r64_r64(tmpdir, op64, op64_):\n    asm = \"\"\"\n           mov eax, {op64:#x}\n           mov rbx, {op64_:#x}\n           xadd rax, rbx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\"])\ndef test_misc_xadd_r16_r16(tmpdir, op16, op16_):\n    asm = \"\"\"\n           mov eax, {op16:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_r16_r16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xadd_r16_r16(tmpdir, op16, op16_):\n    asm = \"\"\"\n           mov eax, {op16:#x}\n           mov rbx, {op16_:#x}\n           xadd ax, bx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\"])\ndef test_misc_xadd_r8_r8(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_r8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xadd_r8_r8(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           mov rbx, {op8_:#x}\n           xadd al, bl\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\", \"rbx\"])\ndef test_misc_xadd_m64_r64(tmpdir, op64, op64_):\n    asm = \"\"\"\n           xor rax, rax",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_m64_r64",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_xadd_m64_r64(tmpdir, op64, op64_):\n    asm = \"\"\"\n           xor rax, rax\n           push rax\n           mov rax, {op64_:#x}\n           push rax\n           mov rbx, {op64_:#x}\n           xadd [rsp+8], rbx\n           pop rax\n           pop rax",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_mov_rm32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_mov_rm32_r32(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov eax, 0x87654321\n           mov [rsp+4], eax\n           pop rbx\n           pop rcx\n         \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_mov_rm8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_mov_rm8_r8(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov eax, 0x87654321\n           mov [rsp+4], al\n           pop rbx\n           pop rcx\n         \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_push_segs_sel",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_push_segs_sel(tmpdir):\n    asm = \"\"\"\n            push 0\n            pop rax\n            push 0\n            pop rbx\n            push 0\n            pop rcx\n            push 0\n            pop rdx",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_lea_complex",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_lea_complex(tmpdir, op64):\n    asm = \"\"\"\n            mov rax, {op64:#x}\n            mov rbx, {op64:#x}\n            lea rax, [rbx+rax*2+0x124000]\n            lea rbx, [rax*4+rbx+0x124000]\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"rax\"])\ndef test_misc_lea_imm(tmpdir):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_lea_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_misc_lea_imm(tmpdir):\n    asm = \"\"\"\n            mov eax, 0\n            mov rbx, 0\n            mov rcx, 0\n            lea eax, [0x124000]\n            lea bx, [0x1240]\n            lea cx, [0x124000]\n          \"\"\"\n    compare(tmpdir, asm, [\"rax\", \"rbx\", \"rcx\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_read_code_as_data",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "def test_read_code_as_data(tmpdir):\n    asm = \"\"\"\n           call lbl\n       lbl:\n           nop\n           nop\n           pop rsi\n           mov eax, [rsi]\n          \"\"\"\n    compare(tmpdir, asm, [\"rax\"])",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "x64",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "x64 = X64(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'x64.ini.in')\n)\ncompare = x64.compare\ncheck = x64.check\n#  _ __ ___   _____   __\n# | '_ ` _ \\ / _ \\ \\ / /\n# | | | | | | (_) \\ V /\n# |_| |_| |_|\\___/ \\_/\ndef test_assign(tmpdir, op16, op32):",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "compare = x64.compare\ncheck = x64.check\n#  _ __ ___   _____   __\n# | '_ ` _ \\ / _ \\ \\ / /\n# | | | | | | (_) \\ V /\n# |_| |_| |_|\\___/ \\_/\ndef test_assign(tmpdir, op16, op32):\n    asm = \"\"\"\n        mov r12,0xabacadae1212abff\n        mov r13d,{op32:#x}",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x64_isn",
        "description": "plugins.bincat.test.test_x64_isn",
        "peekOfCode": "check = x64.check\n#  _ __ ___   _____   __\n# | '_ ` _ \\ / _ \\ \\ / /\n# | | | | | | (_) \\ V /\n# |_| |_| |_|\\___/ \\_/\ndef test_assign(tmpdir, op16, op32):\n    asm = \"\"\"\n        mov r12,0xabacadae1212abff\n        mov r13d,{op32:#x}\n        mov rax,0x0abbccdd",
        "detail": "plugins.bincat.test.test_x64_isn",
        "documentation": {}
    },
    {
        "label": "test_assign",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_assign(tmpdir):\n    asm = \"\"\"\n        mov esi,0xabacadae\n        mov edi,0xacadaeaf\n        mov eax,0xaabbccdd\n        mov ebx,0xbbccddee\n        mov ecx,0xddeeffaa\n        mov edx,0xeeffaabb\n        mov al,0x11\n        mov bh,0x22",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_eax",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_eax(tmpdir):\n    asm = \"\"\"\n        mov al, 0x11\n        xor ebx, ebx\n        mov bl, al\n        mov ax, 0x1234\n        xor ecx, ecx\n        mov cx, ax\n        push 0x12345678\n        mov al, [esp]",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_mem",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_mem(tmpdir, op32, op8):\n    asm = \"\"\"\n        mov eax, {op32}\n        mov [{op8}+0x100000], al\n        mov [{op8}+0x100004], ax\n        mov [{op8}+0x100008], eax\n        xor ebx, ebx\n        xor ecx, ecx\n        mov bl, [{op8}+0x100000]\n        mov cx, [{op8}+0x100004]",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_mem_reg_off",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_mem_reg_off(tmpdir, op32, op8):\n    asm = \"\"\"\n        mov eax, {op32}\n        mov edi, 4\n        mov esi, 0x100400\n        mov [{op8}+esi], al\n        mov [{op8}+esi+edi], ax\n        mov [{op8}+esi+edi*2], eax\n        mov dword [{op8}+esi+edi*4], {op32}\n        xor ebx, ebx",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a0",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_a0(tmpdir, op32, op8):\n    asm = \"\"\"\n        xor eax, eax\n        mov ebx, {op32:#x}\n        mov [0x100000], ebx\n        db 0a0h\n        dd 0x100000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"eax\"])\ndef test_mov_a2(tmpdir,  op8):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a2",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_a2(tmpdir,  op8):\n    asm = \"\"\"\n        xor eax, eax\n        mov al, {op8:#x}\n        db 0a2h\n        dd 0x100000\n        xor ebx, ebx\n        mov bl, [0x100000]\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"eax\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a1",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_a1(tmpdir, op32, op8):\n    asm = \"\"\"\n        xor eax, eax\n        mov ebx, {op32:#x}\n        mov [0x100000], ebx\n        db 0a1h\n        dd 0x100000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"eax\"])\ndef test_mov_a3(tmpdir, op32):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_a3",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_a3(tmpdir, op32):\n    asm = \"\"\"\n        xor eax, eax\n        mov eax, {op32:#x}\n        db 0a3h\n        dd 0x100000\n        xor ebx, ebx\n        mov ebx, [0x100000]\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"eax\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_66a1",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_66a1(tmpdir, op32, op8):\n    asm = \"\"\"\n        xor eax, eax\n        mov ebx, {op32:#x}\n        mov [0x100000], ebx\n        db 066h\n        db 0a1h\n        dd 0x100000\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"eax\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_mov_66a3",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_mov_66a3(tmpdir, op32):\n    asm = \"\"\"\n        xor eax, eax\n        mov eax, {op32:#x}\n        db 066\n        db 0a3h\n        dd 0x100000\n        xor ebx, ebx\n        mov ebx, [0x100000]\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rol_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rol_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            rol eax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_ror_reg32(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_ror_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_ror_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            ror eax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rol_reg16(tmpdir, x86carryop, op16, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rol_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rol_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            rol ax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm.format(**locals()), [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_ror_reg16(tmpdir, x86carryop, op16, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_ror_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_ror_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            ror ax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rol_imm8(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rol_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rol_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            rol eax,{shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_ror_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_ror_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_ror_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            ror eax,{shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\n##  ___  ___ _        __  ___  ___ ___ \n## | _ \\/ __| |      / / | _ \\/ __| _ \\",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rcl_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rcl_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            rcl eax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rcr_reg32(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rcr_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rcr_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            rcr eax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rcl_reg16(tmpdir, x86carryop, op16, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rcl_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rcl_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            rcl ax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rcr_reg16(tmpdir, x86carryop, op16, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rcr_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rcr_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            rcr ax,cl\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rcl_imm8(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rcl_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rcl_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            rcl eax, {shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\ndef test_rotate_rcr_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_rotate_rcr_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_rotate_rcr_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            rcr eax, {shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"of\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0})\n##  ___ _  _ _        __  ___ _  _ ___     __  ___   _   _        __\n## / __| || | |      / / / __| || | _ \\   / / / __| /_\\ | |      / /",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shl_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shl_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            shl eax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shl_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shl_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            shl ax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 16 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shl_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shl_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            shl eax, {shift}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})\ndef test_shift_shr_reg32(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shr_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shr_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            shr eax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shr_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shr_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            shr ax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 16 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shr_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shr_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            shr eax, {shift}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})\ndef test_shift_sal_reg32(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_sal_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_sal_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            sal eax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_sal_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_sal_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            sal ax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 16 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_sal_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_sal_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            sal eax, {shift}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})\ndef test_shift_sar_reg32(tmpdir, x86carryop, op32, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_sar_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_sar_reg32(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op32:#x}\n            sar eax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_sar_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_sar_reg16(tmpdir, x86carryop, op16, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov cl, {shift}\n            mov eax, {op16:#x}\n            sar ax, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 16 else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_sar_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_sar_imm8(tmpdir, x86carryop, op32, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            sar eax, {shift}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"cf\": 1 if shift >= 32 else 0})\ndef test_shift_shld_imm8(tmpdir, x86carryop, op32, op32_, shift):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shld_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shld_imm8(tmpdir, x86carryop, op32, op32_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            shld eax, ebx, {shift}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"eax\":0xffffffff if (shift > 32) else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shld_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shld_reg32(tmpdir, x86carryop, op32, op32_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            mov cl, {shift}\n            shld eax, ebx, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shld_on_mem32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shld_on_mem32(tmpdir, x86carryop, op32, op32_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            push {op32_:#x}\n            push 0\n            mov ebx, {op32:#x}\n            mov cl, {shift}\n            shld [esp+4], ebx, cl\n            pop eax\n            pop eax",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shld_on_mem16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shld_on_mem16(tmpdir, x86carryop, op16, op16_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            push {op16:#x}\n            push 0\n            mov ebx, {op16:#x}\n            mov cl, {shift}\n            shld [esp+4], bx, cl\n            pop eax\n            pop eax",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shld_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shld_reg16(tmpdir, x86carryop, op16, op16_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            mov cl, {shift}\n            shld ax, bx, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shrd_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shrd_imm8(tmpdir, x86carryop, op32, op32_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            shrd eax, ebx, {shift}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,\n                           \"eax\":0xffffffff if (shift > 32) else 0})",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shrd_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shrd_reg32(tmpdir, x86carryop, op32, op32_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            mov cl, {shift}\n            shrd eax, ebx, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_shift_shrd_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_shift_shrd_reg16(tmpdir, x86carryop, op32, op32_, shift):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            mov cl, {shift}\n            shrd ax, bx, cl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"of\", \"cf\"],\n            top_allowed = {\"of\": 1 if (shift&0x1f) != 1 else 0,",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_imm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_add_imm32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            add eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_add_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            add eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_add_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            add ax, bx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_imm32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_imm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sub_imm32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            sub eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov edx, {op32:#x}\n            sub dl, {op8:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sub_reg8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov edx, {op32:#x}\n            sub dl, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"edx\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sub_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            sub eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sub_reg16(tmpdir, op16, op16_):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            sub ax, bx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_reg8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_reg8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sub_reg8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov bl, {op8:#x}\n            sub al, bl\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_add_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_add_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_add_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            add al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_adc_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            adc al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sub_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sub_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sub_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            sub al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sbb_imm8(tmpdir, op32, op8, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            sbb al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_carrytop_adc(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_carrytop_adc",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_carrytop_adc(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            adc eax, ebx\n          \"\"\".format(**locals())\n    topmask = (op32+op32_)^(op32+op32_+1)\n    compare(tmpdir, asm,\n            [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"],\n            top_allowed = {\"eax\":topmask,",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_adc_reg32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            adc eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_adc_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov edx, {op16_:#x}\n            mov ecx, {op16_:#x}\n            adc dx, cx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"edx\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_adc_imm32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_adc_imm32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_adc_imm32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            adc eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_reg32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sbb_reg32(tmpdir, op32, op32_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            sbb eax, ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_sbb_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_sbb_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_sbb_reg16(tmpdir, op16, op16_, x86carryop):\n    asm = \"\"\"\n            {x86carryop}\n            mov eax, {op16:#x}\n            mov ebx, {op16_:#x}\n            sbb ax, bx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_inc_reg32(tmpdir, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_inc_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_inc_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            inc eax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"pf\", \"af\"])\ndef test_arith_dec_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            dec eax",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_dec_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_dec_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            dec eax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"pf\", \"af\"])\ndef test_arith_idiv_reg32(tmpdir, op64, op32):\n    p = op64\n    ph,pl = p>>32, p&0xffffffff\n    q = op32",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_idiv_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_idiv_reg32(tmpdir, op64, op32):\n    p = op64\n    ph,pl = p>>32, p&0xffffffff\n    q = op32\n    asm = \"\"\"\n            mov edx, {ph:#x}\n            mov eax, {pl:#x}\n            mov ebx, {q:#x}\n            idiv ebx\n          \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_idiv_reg8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_idiv_reg8(tmpdir, op16, op8):\n    p = op16\n    q = op8\n    asm = \"\"\"\n            mov eax, {p:#x}\n            mov ebx, {q:#x}\n            idiv bl\n          \"\"\".format(**locals())\n    if q != 0:\n        ps = p if (p >> 15) == 0 else p|((-1)<<15)",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_div_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_div_reg32(tmpdir, op64, op32):\n    p = op64\n    ph,pl = p>>32, p&0xffffffff\n    q = op32\n    asm = \"\"\"\n            mov edx, {ph:#x}\n            mov eax, {pl:#x}\n            mov ebx, {q:#x}\n            div ebx\n          \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_div_reg8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_div_reg8(tmpdir, op16, op8):\n    p = op16\n    q = op8\n    asm = \"\"\"\n            mov eax, {p:#x}\n            mov ebx, {q:#x}\n            div bl\n          \"\"\".format(**locals())\n    if q != 0:\n        if p/q < 2**8:",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_mul_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_mul_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            mul ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"edx\", \"of\", \"cf\"])\ndef test_arith_imul3_reg32_imm(tmpdir, op32, op32_, op32__):\n    asm = \"\"\"\n            mov ecx, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_imul3_reg32_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_imul3_reg32_imm(tmpdir, op32, op32_, op32__):\n    asm = \"\"\"\n            mov ecx, {op32_:#x}\n            mov ebx, {op32__:#x}\n            imul ecx, ebx, {op32:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ecx\", \"ebx\", \"of\", \"cf\"])\ndef test_arith_imul3_reg16_imm(tmpdir, op16, op16_, op16__):\n    asm = \"\"\"\n            mov ecx, {op16_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_imul3_reg16_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_imul3_reg16_imm(tmpdir, op16, op16_, op16__):\n    asm = \"\"\"\n            mov ecx, {op16_:#x}\n            mov ebx, {op16__:#x}\n            imul cx, bx, {op16:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ecx\", \"ebx\", \"of\", \"cf\"])\ndef test_arith_imul_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_imul_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_imul_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32_:#x}\n            imul ebx\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"edx\", \"of\", \"cf\"])\ndef test_arith_neg_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_neg_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_neg_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            neg eax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_arith_neg_reg16(tmpdir, op16):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            neg ax",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_arith_neg_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_arith_neg_reg16(tmpdir, op16):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            neg ax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_logic_and_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            and eax, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_and_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_logic_and_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            and eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\"])\ndef test_logic_or_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            or eax, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_or_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_logic_or_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            or eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\"])\ndef test_logic_xor_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor eax, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_xor_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_logic_xor_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\"])\ndef test_logic_not_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            not eax",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_not_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_logic_not_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            not eax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\"])\ndef test_logic_and_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            and al, {op8:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_and_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_logic_and_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            and al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\"])\ndef test_logic_xor_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor al, {op8:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_logic_xor_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_logic_xor_imm8(tmpdir, op32, op8):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor al, {op8:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\"])\n##  _    ___   ___  ___     __  ___ ___ ___     __   ___ ___  _  _ ___  \n## | |  / _ \\ / _ \\| _ \\   / / | _ \\ __| _ \\   / /  / __/ _ \\| \\| |   \\ \n## | |_| (_) | (_) |  _/  / /  |   / _||  _/  / /  | (_| (_) | .` | |) |\n## |____\\___/ \\___/|_|   /_/   |_|_\\___|_|   /_/    \\___\\___/|_|\\_|___/ ",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_test_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_cond_test_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            test eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"sf\", \"zf\", \"pf\"])\ndef test_cond_cmp_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            cmp eax, {op32_:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_cmp_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_cond_cmp_reg32(tmpdir, op32, op32_):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            cmp eax, {op32_:#x}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])\ndef test_cond_cmovxx_reg32(tmpdir):\n    asm = \"\"\"\n            pushf\n            pop eax",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_cmovxx_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_cond_cmovxx_reg32(tmpdir):\n    asm = \"\"\"\n            pushf\n            pop eax\n            and eax, 0xfffff72a\n            or eax, {flags:#x}\n            push eax\n            popf\n            mov edx, 0xdeadbeef\n            xor ebx,ebx",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_cond_jump_jne",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_cond_jump_jne(tmpdir, loop_cnt):\n    asm = \"\"\"\n            mov ecx, {loop_cnt}\n            mov eax, 0\n         loop:\n            inc eax\n            dec ecx\n            cmp ecx,0\n            jne loop\n          \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_loop_repne_scasb",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_loop_repne_scasb(tmpdir):\n    asm = \"\"\"\n            push 0x00006A69\n            push 0x68676665\n            push 0x64636261\n            mov edi, esp\n            xor al,al\n            mov ecx, 0xffffffff\n            cld\n            repne scasb",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_loop_repne_scasb_unknown_memory",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_loop_repne_scasb_unknown_memory(tmpdir):\n    asm = \"\"\"\n            mov edi, esp\n            xor al,al\n            mov ecx, 0x40\n            cld\n            repne scasb\n            pushf\n            sub edi, esp\n            mov edx, ecx",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_loop_loop",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_loop_loop(tmpdir):\n    asm = \"\"\"\n            mov ecx, 0x40\n            mov eax, 0\n         loop:\n            inc eax\n            loop loop\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ecx\", \"zf\", \"of\", \"pf\", \"af\", \"sf\"])\n##  ___ ___ _____   _____ ___ ___ _____ ___ _  _  ___ ",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bt_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bt_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            bt eax, ebx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_bt_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bt_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bt_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            bt ax, bx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_bt_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bt_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bt_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            bt eax, {shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\"])\ndef test_bittest_bts_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bts_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bts_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            bts eax, ebx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_bts_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bts_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bts_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            bts ax, bx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_bts_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bts_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bts_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            bts eax, {shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\"])\ndef test_bittest_btr_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_btr_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_btr_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            btr eax, ebx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_btr_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_btr_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_btr_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            btr ax, bx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_btr_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_btr_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_btr_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            btr eax, {shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\"])\ndef test_bittest_btc_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_btc_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_btc_reg32(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            btc eax,ebx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_btc_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_btc_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_btc_reg16(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            mov ebx, {shift}\n            btc ax, bx\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"cf\"])\ndef test_bittest_btc_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_btc_imm8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_btc_imm8(tmpdir, shift):\n    asm = \"\"\"\n            mov eax, 0xA35272F4\n            btc eax, {shift}\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\"])\ndef test_bittest_bsr_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor ebx, ebx",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bsr_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bsr_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor ebx, ebx\n            bsr ebx, eax\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"zf\"],\n            top_allowed = {\"ebx\": 0xffffffff if op32 == 0 else 0})\ndef test_bittest_bsr_m32(tmpdir, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bsr_m32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bsr_m32(tmpdir, op32):\n    asm = \"\"\"\n            push {op32:#x}\n            xor ebx, ebx\n            bsr ebx, [esp]\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"zf\"],\n            top_allowed = {\"ebx\": 0xffffffff if op32 == 0 else 0})\ndef test_bittest_bsr_reg16(tmpdir, op16):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bsr_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bsr_reg16(tmpdir, op16):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            xor ebx, ebx\n            bsr bx, ax\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"zf\"],\n            top_allowed = {\"ebx\": 0xffff if op16 == 0 else 0})\ndef test_bittest_bsf_reg32(tmpdir, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bsf_reg32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bsf_reg32(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            xor ebx, ebx\n            bsf ebx, eax\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"zf\"],\n            top_allowed = {\"ebx\": 0xffffffff if op32 == 0 else 0})\ndef test_bittest_bsf_m32(tmpdir, op32):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bsf_m32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bsf_m32(tmpdir, op32):\n    asm = \"\"\"\n            push {op32:#x}\n            xor ebx, ebx\n            bsf ebx, [esp]\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"ebx\", \"zf\"],\n            top_allowed = {\"ebx\": 0xffffffff if op32 == 0 else 0})\ndef test_bittest_bsf_reg16(tmpdir, op16):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bittest_bsf_reg16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bittest_bsf_reg16(tmpdir, op16):\n    asm = \"\"\"\n            mov eax, {op16:#x}\n            xor ebx, ebx\n            bsf bx, ax\n    \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"zf\"],\n            top_allowed = {\"ebx\": 0xffff if op16 == 0 else 0})\n##  __  __ ___ ___  ___ \n## |  \\/  |_ _/ __|/ __|",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_movzx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_movzx(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, 0\n            movzx bx, al\n            movzx ecx, al\n            movzx edx, ax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\", \"edx\"])\ndef test_misc_movsx(tmpdir, op32):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_movsx",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_movsx(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, 0\n            movsx bx, al\n            movsx ecx, al\n            movsx edx, ax\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\", \"edx\"])\ndef test_misc_pushf_popf(tmpdir):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_pushf_popf",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_pushf_popf(tmpdir):\n    asm = \"\"\"\n            stc\n            mov eax, 0x7fffffff\n            mov ebx, 0x7fffffff\n            pushf\n            popf\n            adc ax, bx\n          \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"of\", \"sf\", \"zf\", \"cf\", \"pf\", \"af\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xlat",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xlat(tmpdir, op8):\n    asm = \"\"\"\n            mov ecx, 64\n         loop:\n            mov eax, 0x01020304\n            mul ecx\n            push eax\n            dec ecx\n            jnz loop\n            mov ebx, esp",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xchg_m32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xchg_m32_r32(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov eax, 0x87654321\n           xchg [esp+4], eax\n           pop ebx\n           pop ecx\n         \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bswap",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bswap(tmpdir, op32):\n    asm = \"\"\"\n           mov eax, {op32:#x}\n           mov ebx, {op32:#x}\n           mov esi, {op32:#x}\n           bswap eax\n           bswap ebx\n           bswap esi\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"esi\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xchg_m8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xchg_m8_r8(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov eax, 0x87654321\n           xchg [esp+4], al\n           pop ebx\n           pop ecx\n         \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xchg_r32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xchg_r32_r32(tmpdir):\n    asm = \"\"\"\n           mov eax, 0x12345678\n           mov ebx, 0x87654321\n           xchg eax, ebx\n         \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"ebx\"])\ndef test_misc_cmpxchg_r32_r32(tmpdir, someval32, someval32_, someval32__):\n    asm = \"\"\"\n           mov eax, {someval32:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_r32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_cmpxchg_r32_r32(tmpdir, someval32, someval32_, someval32__):\n    asm = \"\"\"\n           mov eax, {someval32:#x}\n           mov ebx, {someval32_:#x}\n           mov ecx, {someval32__:#x}\n           cmpxchg ebx, ecx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\", \"zf\"])\ndef test_misc_cmpxchg_r16_r16(tmpdir, someval16, someval16_, someval16__):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_r16_r16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_cmpxchg_r16_r16(tmpdir, someval16, someval16_, someval16__):\n    asm = \"\"\"\n           mov eax, {someval16:#x}\n           mov ebx, {someval16_:#x}\n           mov ecx, {someval16__:#x}\n           cmpxchg bx, cx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\", \"zf\"])\ndef test_misc_cmpxchg_r8_r8(tmpdir, someval8, someval8_, someval8__):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_r8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_cmpxchg_r8_r8(tmpdir, someval8, someval8_, someval8__):\n    asm = \"\"\"\n           mov eax, {someval8:#x}\n           mov ebx, {someval8_:#x}\n           mov ecx, {someval8__:#x}\n           cmpxchg bl, cl\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\", \"zf\"])\ndef test_misc_cmpxchg_m32_r32(tmpdir, someval32, someval32_, someval32__):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg_m32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_cmpxchg_m32_r32(tmpdir, someval32, someval32_, someval32__):\n    asm = \"\"\"\n           mov eax, {someval32:#x}\n           push 0\n           push {someval32_:#x}\n           mov ecx, {someval32__:#x}\n           cmpxchg [esp+4], ecx\n           pop ebx\n           pop ebx\n         \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg8b_posofs",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_cmpxchg8b_posofs(tmpdir, someval64, someval64_, someval64__):\n    # keep order of registers so that edx:eax <- v1, ecx:ebx <- v2 and [esp+4] <- v3\n    v1h, v1l = someval64>>32,   someval64&0xffffffff\n    v2h, v2l = someval64_>>32,  someval64_&0xffffffff\n    v3h, v3l = someval64__>>32, someval64__&0xffffffff\n    asm = \"\"\"\n           mov edx, {v1h:#x}\n           mov eax, {v1l:#x}\n           mov ecx, {v2h:#x}\n           mov ebx, {v2l:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_cmpxchg8b_negofs",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_cmpxchg8b_negofs(tmpdir, someval64, someval64_, someval64__):\n    # keep order of registers so that edx:eax <- v1, ecx:ebx <- v2 and [esp+4] <- v3\n    v1h, v1l = someval64>>32,   someval64&0xffffffff\n    v2h, v2l = someval64_>>32,  someval64_&0xffffffff\n    v3h, v3l = someval64__>>32, someval64__&0xffffffff\n    asm = \"\"\"\n           mov esi, esp\n           mov edx, {v1h:#x}\n           mov eax, {v1l:#x}\n           mov ecx, {v2h:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_r32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xadd_r32_r32(tmpdir, op32, op32_):\n    asm = \"\"\"\n           mov eax, {op32:#x}\n           mov ebx, {op32_:#x}\n           xadd eax, ebx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\"])\ndef test_misc_xadd_r16_r16(tmpdir, op16, op16_):\n    asm = \"\"\"\n           mov eax, {op16:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_r16_r16",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xadd_r16_r16(tmpdir, op16, op16_):\n    asm = \"\"\"\n           mov eax, {op16:#x}\n           mov ebx, {op16_:#x}\n           xadd ax, bx\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\"])\ndef test_misc_xadd_r8_r8(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_r8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xadd_r8_r8(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           mov ebx, {op8_:#x}\n           xadd al, bl\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\"])\ndef test_misc_xadd_m32_r32(tmpdir, op32, op32_):\n    asm = \"\"\"\n           push 0",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_xadd_m32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_xadd_m32_r32(tmpdir, op32, op32_):\n    asm = \"\"\"\n           push 0\n           push {op32_:#x}\n           mov ebx, {op32_:#x}\n           xadd [esp+4], ebx\n           pop eax\n           pop eax\n         \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"ebx\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_mov_rm32_r32",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_mov_rm32_r32(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov eax, 0x87654321\n           mov [esp+4], eax\n           pop ebx\n           pop ecx\n         \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_mov_rm8_r8",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_mov_rm8_r8(tmpdir):\n    asm = \"\"\"\n           push 0x12345678\n           push 0xabcdef12\n           mov eax, 0x87654321\n           mov [esp+4], al\n           pop ebx\n           pop ecx\n         \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_push_segs_sel",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_push_segs_sel(tmpdir):\n    asm = \"\"\"\n            push 0\n            pop eax\n            push 0\n            pop ebx\n            push 0\n            pop ecx\n            push 0\n            pop edx",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_lea_complex",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_lea_complex(tmpdir, op32):\n    asm = \"\"\"\n            mov eax, {op32:#x}\n            mov ebx, {op32:#x}\n            lea eax, [ebx+eax*2+0x124000]\n            lea ebx, [eax*4+ebx+0x124000]\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\"])\ndef test_misc_lea_imm(tmpdir):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_lea_imm",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_lea_imm(tmpdir):\n    asm = \"\"\"\n            mov eax, 0\n            mov ebx, 0\n            mov ecx, 0\n            lea eax, [0x124000]\n            lea bx, [0x1240]\n            lea cx, [0x124000]\n          \"\"\"\n    compare(tmpdir, asm, [\"eax\", \"ebx\", \"ecx\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_read_code_as_data",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_read_code_as_data(tmpdir):\n    asm = \"\"\"\n           call lbl\n       lbl:\n           nop\n           nop\n           pop esi\n           mov eax, [esi]\n          \"\"\"\n    compare(tmpdir, asm, [\"eax\"])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_misc_lock",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_misc_lock(tmpdir):\n    asm = \"\"\"\n        push 0x12345678\n        lock inc word [esp]\n        pop eax\n    \"\"\"\n    compare(tmpdir, asm, [\"eax\"])\n##  ___  ___ ___  \n## | _ )/ __|   \\ \n## | _ \\ (__| |) |",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bcd_daa",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bcd_daa(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           add eax, {op8_:#x}\n           daa\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"af\", \"of\"],\n            top_allowed = { \"of\":1 })\ndef test_bcd_das(tmpdir, op8, op8_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bcd_das",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bcd_das(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           sub eax, {op8_:#x}\n           das\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"af\", \"of\"],\n            top_allowed = { \"of\":1 })\ndef test_bcd_aaa(tmpdir, op8, op8_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bcd_aaa",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bcd_aaa(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           add ax, {op8_:#x}\n           aaa\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"af\", \"of\", \"zf\", \"sf\", \"pf\"],\n            top_allowed = {\"of\":1, \"sf\":1, \"zf\":1, \"pf\":1 })\ndef test_bcd_aas(tmpdir, op8, op8_):\n    asm = \"\"\"",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bcd_aas",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bcd_aas(tmpdir, op8, op8_):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           sub ax, {op8_:#x}\n           aas\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"af\", \"of\", \"zf\", \"sf\", \"pf\"],\n            top_allowed = {\"of\":1, \"sf\":1, \"zf\":1, \"pf\":1 })\n@pytest.mark.parametrize(\"base\", [10, 12, 8, 16, 0xff])\ndef test_bcd_aam(tmpdir, op8, op8_, base):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bcd_aam",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bcd_aam(tmpdir, op8, op8_, base):\n    asm = \"\"\"\n           mov eax, {op8:#x}\n           mov ebx, {op8_:#x}\n           mul bx\n           aam {base}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"cf\", \"af\", \"of\", \"zf\", \"sf\", \"pf\"],\n            top_allowed = {\"of\":1, \"af\":1, \"cf\":1 })\n@pytest.mark.parametrize(\"base\", [10, 12, 8, 16, 0xff])",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_bcd_aad",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_bcd_aad(tmpdir, op16, base):\n    asm = \"\"\"\n           mov eax, {op16:#x}\n           aad {base}\n          \"\"\".format(**locals())\n    compare(tmpdir, asm, [\"eax\", \"sf\", \"zf\", \"pf\", \"of\", \"af\", \"cf\"],\n            top_allowed = {\"of\":1, \"af\":1, \"cf\":1 })\n##  ___               _   _\n## | __|  _ _ _    __| |_(_)_ __\n## | _| || | ' \\  (_-< / / | '_ \\",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_isn_nopping",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_isn_nopping(tmpdir):\n    asm = \"\"\"\n           mov eax, 1\n           mov ebx, 1\n           align 0x10\n           mov eax, 2\n           align 0x10\n           mov ebx, 2\n          \"\"\"\n    bc = x86.make_bc_test(tmpdir, asm)",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_fun_skip_noarg",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_fun_skip_noarg(tmpdir):\n    asm = \"\"\"\n           mov eax, 1\n           mov ebx, 4\n           call lbl\n           mov ebx, 5\n           jmp end\n       align 0x100\n       lbl:\n           mov eax, 2",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_fun_skip_arg_cdecl",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_fun_skip_arg_cdecl(tmpdir):\n    asm = \"\"\"\n           mov ebx, 0\n           push 1\n           mov eax, 1\n           push 2\n           push 3\n           call lbl\n           add esp, 8\n           pop ebx",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_fun_skip_arg_stdcall",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_fun_skip_arg_stdcall(tmpdir):\n    asm = \"\"\"\n           mov ebx, 0\n           push 1\n           mov eax, 1\n           push 2\n           push 3\n           call lbl\n           pop ebx\n           jmp end",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_stack_combine",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "def test_stack_combine(tmpdir):\n    asm = \"\"\"\n        mov esp, 0x100100\n        push esp\n        pop eax\n        push 0x12345678\n        pop ebx\n        mov ah, bl\n        add eax, ebx\n    \"\"\".format(**locals())",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "x86",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "x86 = X86(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'x86.ini.in')\n)\ncompare = x86.compare\ncheck = x86.check\n#  _ __ ___   _____   __\n# | '_ ` _ \\ / _ \\ \\ / /\n# | | | | | | (_) \\ V / \n# |_| |_| |_|\\___/ \\_/  \ndef test_assign(tmpdir):",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "compare",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "compare = x86.compare\ncheck = x86.check\n#  _ __ ___   _____   __\n# | '_ ` _ \\ / _ \\ \\ / /\n# | | | | | | (_) \\ V / \n# |_| |_| |_|\\___/ \\_/  \ndef test_assign(tmpdir):\n    asm = \"\"\"\n        mov esi,0xabacadae\n        mov edi,0xacadaeaf",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_isn",
        "description": "plugins.bincat.test.test_x86_isn",
        "peekOfCode": "check = x86.check\n#  _ __ ___   _____   __\n# | '_ ` _ \\ / _ \\ \\ / /\n# | | | | | | (_) \\ V / \n# |_| |_| |_|\\___/ \\_/  \ndef test_assign(tmpdir):\n    asm = \"\"\"\n        mov esi,0xabacadae\n        mov edi,0xacadaeaf\n        mov eax,0xaabbccdd",
        "detail": "plugins.bincat.test.test_x86_isn",
        "documentation": {}
    },
    {
        "label": "test_printf_num",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "def test_printf_num(tmpdir, val, fmt, mod, zeropad, sz):\n    fmtstr = \"TEST[%{mod}{zeropad}{sz}{fmt}]\".format(**locals())\n    asm = \"\"\"\n        push {val:#x}\n        push 0x200      ; {fmt!r}\n        call 0x80000000\n    \"\"\".format(val=val, fmt=fmtstr)\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_mem(0x200, fmtstr+\"\\0\")\n    bc.run()",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "test_printf_string",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "def test_printf_string(tmpdir, val, numl, numr):\n    fmtstr = \"TEST[%{numl}{numr}s]\".format(**locals())\n    asm = \"\"\"\n        push 0x300      ; {val!r}\n        push 0x200      ; {fmt!r}\n        call 0x80000000\n    \"\"\".format(val=val, fmt=fmtstr)\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_mem(0x200, fmtstr+\"\\0\")\n    bc.initfile.set_mem(0x300, val+\"\\0\")",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "test_sprintf_num",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "def test_sprintf_num(tmpdir, val, fmt, mod, zeropad, sz):\n    fmtstr = \"TEST[%{mod}{zeropad}{sz}{fmt}]\".format(**locals())\n    asm = \"\"\"\n        push {val:#x}\n        push 0x200      ; {fmt!r}\n        push 0x100\n        call 0x80000001\n    \"\"\".format(val=val, fmt=fmtstr)\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_mem(0x200, fmtstr+\"\\0\")",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "test_sprintf_string",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "def test_sprintf_string(tmpdir, val, numl, numr):\n    fmtstr = \"TEST[%{numl}{numr}s]\".format(**locals())\n    asm = \"\"\"\n        push 0x300      ; {val!r}\n        push 0x200      ; {fmt!r}\n        push 0x100\n        call 0x80000001\n    \"\"\".format(val=val, fmt=fmtstr)\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_mem(0x200, fmtstr+\"\\0\")",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "test_memcpy_call",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "def test_memcpy_call(tmpdir, src):\n    asm = \"\"\"\n           push {length}\n           push 0x20000\n           push 0x10000\n           call 0x80000002\n    \"\"\".format(length=len(src))\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_mem(0x20000, src+\"\\0\")\n    bc.initfile.set_mem(0x10000, \"\\0\"*100)",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "test_memcpy_push_ret",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "def test_memcpy_push_ret(tmpdir, src):\n    asm = \"\"\"\n           push {length}\n           push 0x20000\n           push 0x10000\n           push 0x80000002\n           ret\n    \"\"\".format(length=len(src))\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_mem(0x20000, src+\"\\0\")",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "x86",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "x86 = X86(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)), 'x86.ini.in')\n)\nxfail = pytest.mark.skip\n@pytest.mark.parametrize(\"val\", [0, 1, 0x1f2, 0x1fa4, 0x45f672, 0x8245fa3d, 0xffffffff])\n@pytest.mark.parametrize(\"fmt\", [pytest.param(\"i\", marks=pytest.mark.xfail),\n                                 \"x\",\n                                 pytest.param(\"d\", marks=pytest.mark.xfail),\n                                 pytest.param(\"lx\", marks=pytest.mark.xfail)])\n@pytest.mark.parametrize(\"mod\", [\"\",",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "xfail",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_stubs",
        "description": "plugins.bincat.test.test_x86_stubs",
        "peekOfCode": "xfail = pytest.mark.skip\n@pytest.mark.parametrize(\"val\", [0, 1, 0x1f2, 0x1fa4, 0x45f672, 0x8245fa3d, 0xffffffff])\n@pytest.mark.parametrize(\"fmt\", [pytest.param(\"i\", marks=pytest.mark.xfail),\n                                 \"x\",\n                                 pytest.param(\"d\", marks=pytest.mark.xfail),\n                                 pytest.param(\"lx\", marks=pytest.mark.xfail)])\n@pytest.mark.parametrize(\"mod\", [\"\",\n                                 pytest.param(\"+\", marks=pytest.mark.xfail),\n                                 pytest.param(\"-\", marks=pytest.mark.xfail)])\n@pytest.mark.parametrize(\"zeropad\", [\"\", \"0\"])",
        "detail": "plugins.bincat.test.test_x86_stubs",
        "documentation": {}
    },
    {
        "label": "test_flag_taint",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_taint",
        "description": "plugins.bincat.test.test_x86_taint",
        "peekOfCode": "def test_flag_taint(tmpdir):\n    asm = \"\"\"\n        test eax, eax\n    \"\"\"\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_reg(\"eax\", \"1!1\")\n    bc.run()\n    assert bc.result.last_reg(\"eax\").taint == 1\n    assert bc.result.last_reg(\"eax\").value == 1\n    assert bc.result.last_reg(\"zf\").value == 0",
        "detail": "plugins.bincat.test.test_x86_taint",
        "documentation": {}
    },
    {
        "label": "test_cmov_taint",
        "kind": 2,
        "importPath": "plugins.bincat.test.test_x86_taint",
        "description": "plugins.bincat.test.test_x86_taint",
        "peekOfCode": "def test_cmov_taint(tmpdir):\n    asm = \"\"\"\n        cmovz ebx, ecx\n    \"\"\"\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_reg(\"ecx\", \"0x12345678\")\n    bc.initfile.set_reg(\"zf\", \"1!1\")\n    bc.run()\n    assert bc.result.last_reg(\"ebx\").value == 0x12345678\n    assert bc.result.last_reg(\"ebx\").taint == 0xFFFFFFFF",
        "detail": "plugins.bincat.test.test_x86_taint",
        "documentation": {}
    },
    {
        "label": "x86",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_taint",
        "description": "plugins.bincat.test.test_x86_taint",
        "peekOfCode": "x86 = X86(\n    os.path.join(os.path.dirname(os.path.realpath(__file__)),'x86.ini.in')\n)\nxfail = pytest.mark.skip\ndef test_flag_taint(tmpdir):\n    asm = \"\"\"\n        test eax, eax\n    \"\"\"\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_reg(\"eax\", \"1!1\")",
        "detail": "plugins.bincat.test.test_x86_taint",
        "documentation": {}
    },
    {
        "label": "xfail",
        "kind": 5,
        "importPath": "plugins.bincat.test.test_x86_taint",
        "description": "plugins.bincat.test.test_x86_taint",
        "peekOfCode": "xfail = pytest.mark.skip\ndef test_flag_taint(tmpdir):\n    asm = \"\"\"\n        test eax, eax\n    \"\"\"\n    bc = x86.make_bc_test(tmpdir, asm)\n    bc.initfile.set_reg(\"eax\", \"1!1\")\n    bc.run()\n    assert bc.result.last_reg(\"eax\").taint == 1\n    assert bc.result.last_reg(\"eax\").value == 1",
        "detail": "plugins.bincat.test.test_x86_taint",
        "documentation": {}
    },
    {
        "label": "Bincat",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class Bincat:\n    def __init__(self, tmpdir, initfile):\n        outf = tmpdir.join('end.ini')\n        logf = tmpdir.join('log.txt')\n        inif = tmpdir.join('init.ini')\n        inif.write(initfile)\n        self.inif = str(inif)\n        self.logf = str(logf)\n        self.outf = str(outf)\n        self.cfa = cfa.CFA.from_filenames(str(inif), str(outf), str(logf))",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "InitFile",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class InitFile:\n    def __init__(self, fname, values={}, directives={}):\n        self.template = open(fname).read()\n        self.values = defaultdict(lambda: \"\")\n        self[\"entrypoint\"] = 0\n        self.values.update(values)\n        self.set_directives(directives)\n        self.program_entries = []\n        self.analyzer_entries = []\n        self.mem = {}",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "BCTest",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class BCTest:\n    def __init__(self, arch, tmpdir, asm):\n        self.arch = arch\n        self.tmpdir = tmpdir\n        self.rawlisting, self.filename, self.opcodes = self.arch.assemble(tmpdir, asm)\n        self.listing = self.arch.prettify_listing(self.rawlisting)\n        directives = self.arch.extract_directives_from_asm(asm)\n        self.initfile = InitFile(self.arch.ini_in_file,\n                                 dict(filepath=self.filename),\n                                 directives)",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "Arch",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class Arch:\n    ALL_REGS = []\n    QEMU = []\n    def __init__(self, ini_in_file=None):\n        self.ini_in_file = ini_in_file\n    def extract_flags(self, regs):\n        pass\n    def prettify_listing(self, asm):\n        return asm\n    def extract_directives_from_asm(self, asm):",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "X86",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class X86(Arch):\n    NASM_TMP_DIR = counter(\"nasm-%i\")\n    ALL_FLAGS = [\"cf\", \"pf\", \"af\", \"zf\", \"sf\", \"df\", \"of\"]\n    ALL_REGS = [\"eax\", \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\", \"esp\", \"ebp\"] + ALL_FLAGS\n    EGGLOADER = 'eggloader_x86'\n    def assemble(self, tmpdir, asm):\n        d = tmpdir.mkdir(next(self.NASM_TMP_DIR))\n        inf = d.join(\"asm.S\")\n        outf = d.join(\"opcodes\")\n        inf.write(\"BITS 32\\n\"+asm)",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "X64",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class X64(Arch):\n    NASM_TMP_DIR = counter(\"nasm-%i\")\n    ALL_FLAGS = [\"cf\", \"pf\", \"af\", \"zf\", \"sf\", \"df\", \"of\"]\n    ALL_REGS = [\"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"rsp\", \"rbp\"] + [ \"r%d\" % i for i in range(8,16) ] + ALL_FLAGS\n    EGGLOADER = 'eggloader_x64'\n    def assemble(self, tmpdir, asm):\n        d = tmpdir.mkdir(next(self.NASM_TMP_DIR))\n        inf = d.join(\"asm.S\")\n        outf = d.join(\"opcodes\")\n        inf.write(\"BITS 64\\n\"+asm)",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "ARM",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class ARM(Arch):\n    ALL_REGS = [\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\",\n                \"r11\", \"r12\", \"sp\", \"lr\", \"pc\", \"n\", \"z\", \"c\", \"v\"]\n    AS_TMP_DIR = counter(\"arm-as-%i\")\n    AS = [\"arm-linux-gnueabi-as\"]\n    OBJCOPY = [\"arm-linux-gnueabi-objcopy\"]\n    OBJDUMP = [\"arm-linux-gnueabi-objdump\", \"-m\", \"arm\"]\n    EGGLOADER = \"eggloader_armv7\"\n    QEMU = [\"qemu-arm\"]\n    def extract_flags(self, regs):",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "Thumb",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class Thumb(ARM):\n    OBJDUMP = [\"arm-linux-gnueabi-objdump\", \"-m\", \"arm\", \"--disassembler-options=force-thumb\"]\n    EGGLOADER = \"eggloader_armv7thumb\"\n    def assemble(self, tmpdir, asm):\n        asm = \"\"\"\n           .code 16\n           .thumb_func\n        \"\"\" + asm\n        return ARM.assemble(self, tmpdir, asm)\nclass ThumbU(Thumb):",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "ThumbU",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class ThumbU(Thumb):\n    def assemble(self, tmpdir, asm):\n        asm = \"\"\"\n           .code 16\n           .syntax unified\n           .thumb_func\n        \"\"\" + asm\n        return ARM.assemble(self, tmpdir, asm)\nclass AARCH64(ARM):\n    ALL_REGS = [\"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", \"x10\",",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "AARCH64",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class AARCH64(ARM):\n    ALL_REGS = [\"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", \"x10\",\n                \"x11\", \"x12\", \"x13\", \"x14\", \"x15\", \"x16\", \"x17\", \"x18\", \"x19\", \"x20\",\n                \"x21\", \"x22\", \"x23\", \"x24\", \"x25\", \"x26\", \"x27\", \"x28\", \"x29\", \"x30\", \"sp\",\n                \"q0\", \"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\", \"q8\", \"q9\", \"q10\",\n                \"q11\", \"q12\", \"q13\", \"q14\", \"q15\", \"q16\", \"q17\", \"q18\", \"q19\", \"q20\",\n                \"q21\", \"q22\", \"q23\", \"q24\", \"q25\", \"q26\", \"q27\", \"q28\", \"q29\", \"q30\", \"q31\",\n                \"pc\", \"n\", \"z\", \"c\", \"v\"]\n    AS = [\"aarch64-linux-gnu-as\"]\n    OBJCOPY = [\"aarch64-linux-gnu-objcopy\"]",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "PowerPC",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class PowerPC(Arch):\n    ALL_REGS = [\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\n                \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\",\n                \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\n                \"r30\", \"r31\", \"lr\", \"ctr\", \"cr\", \"so\", \"ov\", \"ca\", \"tbc\"]\n    AS_TMP_DIR = counter(\"powerpc-as-%i\")\n    AS = [\"powerpc-linux-gnu-as\", \"-many\", \"-mpower9\", \"-mbig\"]\n    OBJCOPY = [\"powerpc-linux-gnu-objcopy\"]\n    OBJDUMP = [\"powerpc-linux-gnu-objdump\", \"-mpowerpc\", \"-EB\"]\n    EGGLOADER = \"eggloader_powerpc\"",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "PowerPC64",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class PowerPC64(Arch):\n    ALL_REGS = [\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\n                \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\",\n                \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\n                \"r30\", \"r31\", \"lr\", \"ctr\", \"cr\", \"so\", \"ov\", \"ca\", \"tbc\"]\n    AS_TMP_DIR = counter(\"powerpc64-as-%i\")\n    AS = [\"powerpc64-linux-gnu-as\", \"-many\", \"-mpower9\", \"-mbig\"]\n    OBJCOPY = [\"powerpc64-linux-gnu-objcopy\"]\n    OBJDUMP = [\"powerpc64-linux-gnu-objdump\", \"-mpowerpc\", \"-M64\", \"-EB\"]\n    EGGLOADER = \"eggloader_powerpc64\"",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "RISCV64",
        "kind": 6,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "class RISCV64(Arch):\n    ALL_REGS = [ \"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\",\n                 \"x10\", \"x11\", \"x12\", \"x13\", \"x14\", \"x15\", \"x16\", \"x17\", \"x18\",\n                 \"x19\", \"x20\", \"x21\", \"x22\", \"x23\", \"x24\", \"x25\", \"x26\", \"x27\",\n                 \"x28\", \"x29\", \"x30\", \"x31\"]\n    AS_TMP_DIR = counter(\"riscv64-as-%i\")\n    AS = [\"riscv64-linux-gnu-as\"]\n    OBJCOPY = [\"riscv64-linux-gnu-objcopy\"]\n    OBJDUMP = [\"riscv64-linux-gnu-objdump\", \"-mriscv:rv64\", \"--disassembler-options=no-aliases,numeric\"]\n    EGGLOADER = \"eggloader_riscv64\"",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "counter",
        "kind": 2,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "def counter(fmt=\"%i\", i=0):\n    while True:\n        yield fmt % i\n        i += 1\nGCC_DIR = counter(\"gcc-%i\")\ndef getReg(my_node, name):\n    v = cfa.Value('reg', name, cfa.reg_len(name))\n    # hardcoded first unrel\n    try:\n        return my_node.unrels[\"0\"][v][0]",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "getReg",
        "kind": 2,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "def getReg(my_node, name):\n    v = cfa.Value('reg', name, cfa.reg_len(name))\n    # hardcoded first unrel\n    try:\n        return my_node.unrels[\"0\"][v][0]\n    except KeyError:\n        return my_node.unrels[list(my_node.unrels.keys())[0]][v][0]\ndef getLastNode(prgm, expect_tree=True):\n    curNode = prgm['0']\n    while True:",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "getLastNode",
        "kind": 2,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "def getLastNode(prgm, expect_tree=True):\n    curNode = prgm['0']\n    while True:\n        nextNodes = prgm.next_nodes(curNode.node_id)\n        if len(nextNodes) == 0:\n            return curNode\n        if not expect_tree:\n            assert len(nextNodes) == 1, \\\n                (\"expected exactly 1 destination node after running this \"\n                 \"instruction (node: %s)\" % curNode.node_id)",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "val2str",
        "kind": 2,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "def val2str(l, val, top=None, taint=None, ttop=None):\n    print(l,val)\n    fmt = \"%%0%ix\" % l\n    s = fmt % val\n    if top:\n        s += (\" ? \"+fmt) % top\n    if taint or ttop:\n        s += (\" ! \"+fmt) % taint\n        if ttop:\n            s += (\"? \"+fmt) % ttop",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "GCC_DIR",
        "kind": 5,
        "importPath": "plugins.bincat.test.util",
        "description": "plugins.bincat.test.util",
        "peekOfCode": "GCC_DIR = counter(\"gcc-%i\")\ndef getReg(my_node, name):\n    v = cfa.Value('reg', name, cfa.reg_len(name))\n    # hardcoded first unrel\n    try:\n        return my_node.unrels[\"0\"][v][0]\n    except KeyError:\n        return my_node.unrels[list(my_node.unrels.keys())[0]][v][0]\ndef getLastNode(prgm, expect_tree=True):\n    curNode = prgm['0']",
        "detail": "plugins.bincat.test.util",
        "documentation": {}
    },
    {
        "label": "cache_data",
        "kind": 6,
        "importPath": "plugins.cto.cache_data",
        "description": "plugins.cto.cache_data",
        "peekOfCode": "class cache_data(debug_print.debug):\n    def __init__(self, data_dict=None, config=None, debug=False):\n        #debug_print.debug.__init__(self, debug)\n        super(cache_data, self).__init__(debug)\n        self.idb_name = idc.get_idb_path()\n        self.dh = self.data_handler(self.idb_name, config, data_dict)\n    class data_handler(object):\n        class data_storage(object):\n            def __init__(self, config=None, data_dict=None):\n                if config is None:",
        "detail": "plugins.cto.cache_data",
        "documentation": {}
    },
    {
        "label": "comment_t",
        "kind": 6,
        "importPath": "plugins.cto.comments",
        "description": "plugins.cto.comments",
        "peekOfCode": "class comment_t(object):\n    def __init__(self, frules=os.path.join(os.path.dirname(__file__),\"cmt_rules.json\")):\n        with open(frules) as f:\n            rules = json.load(f)\n        self.rules = self.create_comment_rules(rules)\n    @staticmethod\n    def create_comment_rules(rules):\n        result = {}\n        for cmt_type in rules:\n            if cmt_type not in result:",
        "detail": "plugins.cto.comments",
        "documentation": {}
    },
    {
        "label": "_config_base",
        "kind": 6,
        "importPath": "plugins.cto.config_base",
        "description": "plugins.cto.config_base",
        "peekOfCode": "class _config_base(object):\n    def __init__(self):\n        self.get_default_config()\n    def __len__(self):\n        return len(self.__dict__)\n    def __repr__(self):\n        return str(self.__dict__)\n    def __str__(self):\n        return str(self.__dict__)\n    def __iter__(self):",
        "detail": "plugins.cto.config_base",
        "documentation": {}
    },
    {
        "label": "CallTreeOverviewer",
        "kind": 6,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "class CallTreeOverviewer(cto_base.cto_base, ida_graph.GraphViewer):\n    orig_title = \"CTO\"\n    DO_NOT_SKIP = 0\n    SKIP_CHILDREN = 1\n    SKIP_PARENTS = 2\n    def __init__(self, start_ea, end_ea=ida_idaapi.BADADDR, max_depth=1, cto_data=None, curr_view=None, close_open=True, title_postfix=\"\", parent=None, skip=DO_NOT_SKIP, debug=False, skip_lib=True, skip_api=True):\n        # generate title\n        self.title = self.orig_title\n        if title_postfix:\n            self.title += title_postfix",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "exec_cto",
        "kind": 2,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "def exec_cto(cto_data=None, curr_view=None, max_depth=1, debug=False):\n    if debug or (\"g_debug\" in globals() and g_debug):\n        debug = True\n    try:\n        r = ida_auto.auto_wait()\n        if r:\n            cto = CallTreeOverviewer(ida_kernwin.get_screen_ea(), cto_data=cto_data, curr_view=curr_view, max_depth=max_depth, debug=debug)\n        else:\n            ida_kernwin.msg(\"IDA is still in automatic analysis and you have canceled the plugin execution. Do it later again if you need.%s\" % (os.linesep))\n    except Exception as e:",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "def main():\n    global g_cto\n    g_cto = exec_cto()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "g_max_recursive",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "g_max_recursive = 10\nFT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_ACT\"):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_ACT\"):\n    setattr(ida_kernwin, \"CVNF_ACT\", 0x4) # 7.5 lacks the definition",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.cto",
        "description": "plugins.cto.cto",
        "peekOfCode": "FT_VTB = get_func_relation.FT_VTB\nif not hasattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\"):\n    setattr(ida_kernwin, \"WOPN_NOT_CLOSED_BY_ESC\", 0x100) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_LAZY\"):\n    setattr(ida_kernwin, \"CVNF_LAZY\", 0x1) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_JUMP\"):\n    setattr(ida_kernwin, \"CVNF_JUMP\", 0x2) # 7.5 lacks the definition\nif not hasattr(ida_kernwin, \"CVNF_ACT\"):\n    setattr(ida_kernwin, \"CVNF_ACT\", 0x4) # 7.5 lacks the definition\nclass CallTreeOverviewer(cto_base.cto_base, ida_graph.GraphViewer):",
        "detail": "plugins.cto.cto",
        "documentation": {}
    },
    {
        "label": "cto_base",
        "kind": 6,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "class cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()\n        self.decomp_avail = False\n        try:\n            import ida_hexrays",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()\n        self.decomp_avail = False",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.cto_base",
        "description": "plugins.cto.cto_base",
        "peekOfCode": "FT_VTB = get_func_relation.FT_VTB\nclass cto_base(debug_print.debug):\n    orig_title = \"CTO\"\n    title = orig_title\n    def __init__(self, cto_data=None, curr_view=None, debug=False):\n        #super(cto_base, self).__init__(debug)\n        debug_print.debug.__init__(self)\n        self.cmt_obj = comments.comment_t()\n        self.decomp_avail = False\n        try:",
        "detail": "plugins.cto.cto_base",
        "documentation": {}
    },
    {
        "label": "MyFilterProxyModel",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:\n            # the option is available only 5.10 and above\n            self.setRecursiveFiltering(True)\n        except AttributeError:",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "limit_keywords_dialog",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class limit_keywords_dialog(QtWidgets.QDialog):\n    state_changed = QtCore.pyqtSignal(str)\n    def __init__(self, parent=None):\n        super().__init__()\n        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n        self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint)\n        self.v = QtWidgets.QVBoxLayout()\n        self.setLayout(self.v)\n        self.key_cboxes = {}\n    @QtCore.pyqtSlot(dict)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "MyWidget",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class MyWidget(QtWidgets.QTreeView):\n    key_pressed = QtCore.pyqtSignal(QtGui.QKeyEvent)\n    current_changed = QtCore.pyqtSignal(QtCore.QModelIndex, QtCore.QModelIndex)\n    state_changed = QtCore.pyqtSignal(str)\n    after_filtered = QtCore.pyqtSignal(str)\n    item_changed = QtCore.pyqtSignal(QtCore.QModelIndex, str, str)\n    builtin_exec = QtCore.pyqtSignal(str)\n    def __init__(self):\n        #super(MyWidget, self).__init__(self)\n        QtWidgets.QTreeView.__init__(self)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "cto_func_lister_t",
        "kind": 6,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "class cto_func_lister_t(cto_base.cto_base, ida_kernwin.PluginForm):\n    imports = {}\n    imports_ids = {}\n    exports = {}\n    exports_ids = {}\n    funcs = {}\n    func_ids = {}\n    callers = {}\n    caller_ids = {}\n    default_bg = None",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "exec_cto_function_lister",
        "kind": 2,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "def exec_cto_function_lister(cto_data=None, debug=False):\n    cto_func_lister = cto_func_lister_t(cto_data=cto_data, debug=debug)\n    r = cto_func_lister.show()\n    if r:\n        return cto_func_lister\n    return None\ndef main():\n    global cto_func_lister\n    try:\n        cto_func_lister.Close(0)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "def main():\n    global cto_func_lister\n    try:\n        cto_func_lister.Close(0)\n        del cto_func_lister\n        cto_func_lister = cto_func_lister_t()\n    except:\n        cto_func_lister = cto_func_lister_t()\n# --------------------------------------------------------------------------\nif __name__ == '__main__':",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_UNK = get_func_relation.FT_UNK\nFT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_GEN = get_func_relation.FT_GEN\nFT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_LIB = get_func_relation.FT_LIB\nFT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_API = get_func_relation.FT_API\nFT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_MEM = get_func_relation.FT_MEM\nFT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_VAR = get_func_relation.FT_VAR\nFT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_STR = get_func_relation.FT_STR\nFT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_STO = get_func_relation.FT_STO\nFT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:\n            # the option is available only 5.10 and above",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.cto_func_lister",
        "description": "plugins.cto.cto_func_lister",
        "peekOfCode": "FT_VTB = get_func_relation.FT_VTB\nclass MyFilterProxyModel(QtCore.QSortFilterProxyModel):\n    itemDataChanged = QtCore.pyqtSignal(QtCore.QModelIndex, str, str, int)\n    def __init__(self, parent=None):\n        super(MyFilterProxyModel, self).__init__(parent)\n        self.idx_set = set([])\n        self.disabled_keyword_set = set([])\n        try:\n            # the option is available only 5.10 and above\n            self.setRecursiveFiltering(True)",
        "detail": "plugins.cto.cto_func_lister",
        "documentation": {}
    },
    {
        "label": "get_strlist_items",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_strlist_items():\n    si = ida_strlist.string_info_t()\n    for i in range(ida_strlist.get_strlist_qty()):\n        if ida_strlist.get_strlist_item(si, i):\n            yield si\ndef get_str_content(si):\n    strbytes = ida_bytes.get_strlit_contents(si.ea, si.length, si.type, ida_bytes.STRCONV_ESCAPE)\n    if sys.version_info.major >= 3:\n         return strbytes.decode(\"UTF-8\", \"replace\")\n    else:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_str_content",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_str_content(si):\n    strbytes = ida_bytes.get_strlit_contents(si.ea, si.length, si.type, ida_bytes.STRCONV_ESCAPE)\n    if sys.version_info.major >= 3:\n         return strbytes.decode(\"UTF-8\", \"replace\")\n    else:\n         return strbytes\n    return strbytes\ndef get_str_content_by_ea(ea):\n    result = None\n    for si in get_strlist_items():",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_str_content_by_ea",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_str_content_by_ea(ea):\n    result = None\n    for si in get_strlist_items():\n        if si.ea == ea:\n            result = get_str_content(si)\n            break\n    return result\ndef deep_update(source, overrides):\n    \"\"\"\n    Update a nested dictionary or similar mapping.",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "deep_update",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def deep_update(source, overrides):\n    \"\"\"\n    Update a nested dictionary or similar mapping.\n    Modify ``source`` in place.\n    \"\"\"\n    for key, value in overrides.items():\n        if key in source and type(source[key]) != type(value):\n            print(\"Error! Couldn't merge because the types of source and dest values are different. Key:\", key, type(source[key]), type(value)) \n        elif isinstance(value, colls.Mapping):\n            if value:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_widget",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_widget(ida_view=g_wname, decomp_view=g_decomp_name, curr_view=None):\n    w = ida_kernwin.get_current_widget()\n    wt = ida_kernwin.BWN_UNKNOWN\n    if w:\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            pass\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:\n            pass\n        else:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "get_xrefs",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def get_xrefs(ea):\n    next_addr = ida_xref.get_first_cref_to(ea)\n    while next_addr != ida_idaapi.BADADDR:\n        yield next_addr\n        next_addr = ida_xref.get_next_cref_to(ea,next_addr)\ndef count_xref(ea):\n    return len(list(get_xrefs(ea)))\ndef count_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "count_xref",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def count_xref(ea):\n    return len(list(get_xrefs(ea)))\ndef count_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        #print(\"%x\" % ea, list(fc))\n        return len(list(fc))\n    return 0\ndef is_64bit(ea):",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "count_bbs",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def count_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        #print(\"%x\" % ea, list(fc))\n        return len(list(fc))\n    return 0\ndef is_64bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "is_64bit",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def is_64bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)\n    if seg and seg.use64():\n        flag = True\n    return flag\ndef is_32bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)\n    if seg:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "is_32bit",
        "kind": 2,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "def is_32bit(ea):\n    flag = False\n    seg = ida_segment.getseg(ea)\n    if seg:\n        if hasattr(seg, \"use32\"):\n            if seg.use32():\n                flag = True\n        else:\n            if not is_64bit(ea):\n                flag = True",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "g_wname",
        "kind": 5,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "g_wname = \"IDA View-A\"\ng_decomp_name = \"Pseudocode-A\"\ndef get_widget(ida_view=g_wname, decomp_view=g_decomp_name, curr_view=None):\n    w = ida_kernwin.get_current_widget()\n    wt = ida_kernwin.BWN_UNKNOWN\n    if w:\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            pass\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "g_decomp_name",
        "kind": 5,
        "importPath": "plugins.cto.cto_utils",
        "description": "plugins.cto.cto_utils",
        "peekOfCode": "g_decomp_name = \"Pseudocode-A\"\ndef get_widget(ida_view=g_wname, decomp_view=g_decomp_name, curr_view=None):\n    w = ida_kernwin.get_current_widget()\n    wt = ida_kernwin.BWN_UNKNOWN\n    if w:\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            pass\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:\n            pass",
        "detail": "plugins.cto.cto_utils",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 6,
        "importPath": "plugins.cto.debug_print",
        "description": "plugins.cto.debug_print",
        "peekOfCode": "class debug(object):\n    def __init__(self, frames=2, lines=20000, outfile=True, file_handle=None):\n        self.outfile = outfile\n        self.f = file_handle\n        self.output_lines = 0\n        self.max_output_lines = lines\n        self.trace_back_frames = frames\n    def _dbg_print(self, *msg):\n        if not self.f and self.outfile:\n            try:",
        "detail": "plugins.cto.debug_print",
        "documentation": {}
    },
    {
        "label": "qprofile",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result\n        finally:\n            s = io.StringIO()",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "l_dbg_print",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def l_dbg_print(*msg):\n    global g_fp\n    global g_lines\n    if True:\n        if not g_fp:\n            try:\n                g_fp = tempfile.NamedTemporaryFile(delete=False, buffering=0)\n            except TypeError:\n                g_fp = tempfile.NamedTemporaryFile(delete=False) # for python 2.7\n            if g_fp:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "funcs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def funcs(ea=0):\n    while ea != ida_idaapi.BADADDR:\n        f = ida_funcs.get_next_func(ea)\n        if f:\n            ea = f.start_ea\n            yield f\n        else:\n            break\ndef get_bbs(f):\n    bbs = {}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_bbs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_bbs(f):\n    bbs = {}\n    for block in f:\n        bbs[block.start_ea] = block\n    return bbs\ndef get_func_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        bbs = get_bbs(fc)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_bbs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_bbs(ea):\n    f = ida_funcs.get_func(ea)\n    if f:\n        fc = ida_gdl.FlowChart(f)\n        bbs = get_bbs(fc)\n        return f, bbs\n    return None, {}\ndef get_imports():\n    def imp_cb(ea, name, ordinal):\n        result.append((modname, ea, str(ordinal) if not name else name, ordinal))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_imports",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_imports():\n    def imp_cb(ea, name, ordinal):\n        result.append((modname, ea, str(ordinal) if not name else name, ordinal))\n        # True -> Continue enumeration\n        # False -> Stop enumeration\n        return True\n    nimps = ida_nalt.get_import_module_qty()\n    result = []\n    for i in range(nimps):\n        modname = ida_nalt.get_import_module_name(i)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_ea_in_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_ea_in_func(target_ea, bbs):\n    for bbea in bbs:\n        bb = bbs[bbea]\n        if bb.start_ea <= target_ea and target_ea < bb.end_ea:\n            return True\n    return False\nFT_UNK = 0    # unknown\nFT_GEN = 1    # for general internal calls\nFT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_type",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type\n    f = ida_funcs.get_func(func_ea)\n    if f is None:\n        return func_type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_info_by_name",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_info_by_name(name):\n    func_type = FT_UNK\n    func_name = \"\"\n    func_ea = ida_idaapi.BADADDR\n    ret = tinfo.get_tinfo_by_name(name)\n    if ret:\n        # for APIs\n        func_name = name\n        func_type = FT_API\n        func_ea = idc.get_name_ea_simple(func_name)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_info_by_cmt",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_info_by_cmt(ea):\n    func_type = FT_UNK\n    func_name = \"\"\n    func_ea = ida_idaapi.BADADDR\n    # get non-repeatable comment\n    cmt = ida_bytes.get_cmt(ea, 0)\n    cmts = []\n    if cmt is not None:\n        cmt = cmt.strip()\n        cmts.append(cmt)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_info_by_opstr",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_info_by_opstr(ea, opn):\n    func_type = FT_UNK\n    func_name = \"\"\n    func_ea = ida_idaapi.BADADDR\n    opstr = idc.print_operand(ea, opn)\n    # api name in structure offset\n    # e.g. call    [edi+BaseStructure.kernel32.GetVersionExA] \n    #           or [eax+struc_1.field_3B4_InternetSetOptionA]\n    if opstr.find('.') >= 0 and opstr.find(')') < 0:\n        member_names = opstr.split('+')[-1].split('.')[:-1]",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_offset_fptr",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_offset_fptr(v):\n    target_ea = ida_idaapi.BADADDR\n    flags = ida_bytes.get_full_flags(v)\n    # call    cs:off_180097558 -> offset free\n    if ida_bytes.is_qword(flags):\n        off_v = ida_bytes.get_qword(v)\n        flags = ida_bytes.get_full_flags(off_v)\n        if ida_bytes.is_code(flags):\n            target_ea = off_v\n        #.data:00007FF9648576A8 ; void __stdcall __noreturn FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_ref_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_ref_func(ea):\n    n = ida_netnode.netnode(\"$ vmm functions\")\n    r = n.altval(ea)\n    if r != ida_idaapi.BADADDR:\n        r -= 1\n    return r & ida_idaapi.BADADDR\ndef get_switch_info(ea):\n    si = ida_nalt.switch_info_t()\n    ida_nalt.get_switch_info(si, ea)\n    if si.startea != ida_idaapi.BADADDR:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_switch_info",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_switch_info(ea):\n    si = ida_nalt.switch_info_t()\n    ida_nalt.get_switch_info(si, ea)\n    if si.startea != ida_idaapi.BADADDR:\n        return si\n    return None\ndef is_indirect_jump_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_indirect_jump_insn(tmp):\n        return True",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_indirect_jump_insn",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_indirect_jump_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_indirect_jump_insn(tmp):\n        return True\n    return False\ndef is_call_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_call_insn(tmp):\n        return True\n    return False",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_call_insn",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_call_insn(ea):\n    tmp = ida_ua.insn_t()\n    if ida_ua.decode_insn(tmp, ea) and ida_idp.is_call_insn(tmp):\n        return True\n    return False\ndef guess_var_size(ea):\n    seg = ida_segment.getseg(ea)\n    if not seg:\n        return 0\n    next_ea = ida_bytes.next_head(ea, ea + seg.abytes()+1)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "guess_var_size",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def guess_var_size(ea):\n    seg = ida_segment.getseg(ea)\n    if not seg:\n        return 0\n    next_ea = ida_bytes.next_head(ea, ea + seg.abytes()+1)\n    sz = seg.abytes()\n    while sz > 0:\n        if ea + sz <= next_ea :\n            break\n        sz = sz // 2",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_var_value_with_guess",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_var_value_with_guess(ea):\n    sz = guess_var_size(ea)\n    if sz == 0:\n        return None\n    value = None\n    if sz == 8:\n        value = ida_bytes.get_qword(ea)\n    elif sz == 4:\n        value = ida_bytes.get_dword(ea)\n    elif sz == 2:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_var_value",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_var_value(ea):\n    value = None\n    flags = ida_bytes.get_full_flags(ea)\n    if ida_bytes.is_qword(flags):\n        value = ida_bytes.get_qword(ea)\n    elif ida_bytes.is_dword(flags):\n        value = ida_bytes.get_dword(ea)\n    elif ida_bytes.is_word(flags):\n        value = ida_bytes.get_word(ea)\n    elif ida_bytes.is_byte(flags):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_str",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_str(ea, v, string_eas):\n    data = ''\n    data_type = FT_VAR\n    vflags = ida_bytes.get_full_flags(v)\n    if ida_bytes.is_strlit(vflags):\n        data_type = FT_STR\n        if ea in string_eas:\n            data = string_eas[ea][1]\n        else:\n            sz = ida_bytes.get_item_size(v)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_funcptr_ea",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_funcptr_ea(ea, import_eas, string_eas):\n    target_ea = ida_idaapi.BADADDR\n    func_type = FT_UNK\n    func_name = \"\"\n    insn = ida_ua.insn_t()\n    inslen = ida_ua.decode_insn(insn, ea)\n    for i in range(inslen):\n        op = insn.ops[i]\n        optype = op.type\n        if ida_ua.o_void == optype:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_stroff_ea",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_stroff_ea(ea, import_eas):\n    target_ea = ida_idaapi.BADADDR\n    func_type = FT_UNK\n    func_name = \"\"\n    insn = ida_ua.insn_t()\n    inslen = ida_ua.decode_insn(insn, ea)\n    i = -1\n    for i in range(inslen):\n        op = insn.ops[i]\n        optype = op.type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_vtbl_methods",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_vtbl_methods(target_ea, vtbl):\n    ea = get_offset_fptr(target_ea)\n    orig_target_ea = target_ea\n    prev_target_ea = target_ea\n    item_diff = 8\n    seg = ida_segment.getseg(target_ea)\n    next_name_ea = idc.get_inf_attr(idc.INF_MAX_EA)\n    if seg:\n        item_diff = 1<<(seg.bitness+1)\n        # get next label that has a xref",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_children",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_children(f, import_eas, string_eas):\n    result = {}\n    apicalls = {}\n    gvars = {}\n    strings = {}\n    stroff = {}\n    vtbl = {}\n    if f is None:\n        return result, apicalls, gvars, strings, stroff, vtbl\n    for ea in f.code_items():",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_xrefs_from",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_xrefs_from(ea):\n    next_addr = ida_xref.get_first_fcref_from(ea)\n    while next_addr != ida_idaapi.BADADDR:\n        yield next_addr\n        next_addr = ida_xref.get_next_fcref_from(ea, next_addr)\ndef get_xrefs(ea):\n    result = {}\n    op = -1\n    next_addr = ida_xref.get_first_fcref_to(ea)\n    while next_addr != ida_idaapi.BADADDR:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_xrefs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_xrefs(ea):\n    result = {}\n    op = -1\n    next_addr = ida_xref.get_first_fcref_to(ea)\n    while next_addr != ida_idaapi.BADADDR:\n        f = ida_funcs.get_func(next_addr)\n        func_ea = ida_idaapi.BADADDR\n        func_type = FT_UNK\n        if f is not None:\n            func_ea = f.start_ea",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_xrefs_in_range",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_xrefs_in_range(ea=idc.get_inf_attr(idc.INF_MIN_EA), max_ea=idc.get_inf_attr(idc.INF_MAX_EA)):\n    flags = ida_bytes.get_flags(ea)\n    if ida_bytes.has_xref(flags):\n        yield ea\n    #print(hex(ea), hex(max_ea))\n    if ea == ida_idaapi.BADADDR:\n        return\n    next_ea = ida_bytes.next_that(ea, max_ea, ida_bytes.has_xref)\n    while next_ea != ida_idaapi.BADADDR:\n        yield next_ea",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_drefs_to",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_drefs_to(ea):\n    ea = ida_bytes.get_item_head(ea)\n    if ea >= idc.get_inf_attr(idc.INF_MAX_EA):\n        return\n    item_sz = ida_bytes.get_item_size(ea)\n    # for getting in the middle of the xrefs of a structure\n    for next_ea in get_xrefs_in_range(ea, ea+item_sz):\n        for next_ea in _get_drefs_to(next_ea):\n            yield next_ea\ndef _get_drefs_from(ea):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_drefs_from",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_drefs_from(ea):\n    ea = ida_bytes.get_item_head(ea)\n    if ea >= idc.get_inf_attr(idc.INF_MAX_EA):\n        return\n    item_sz = ida_bytes.get_item_size(ea)\n    # for getting in the middle of the xrefs of a structure\n    for next_ea in get_xrefs_in_range(ea, ea+item_sz):\n        for next_ea in _get_drefs_from(next_ea):\n            yield next_ea\ndef get_dref_belong_to_func(ea, vtbl_refs, dref_recursive=True, debug=False, dbg_print_func=None):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dref_belong_to_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dref_belong_to_func(ea, vtbl_refs, dref_recursive=True, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    for next_ea in get_drefs_to(ea):\n        if debug: dbg_print(\"dref_to: \", hex(next_ea).rstrip(\"L\"), hex(ea).rstrip(\"L\"))\n        f = ida_funcs.get_func(next_ea)\n        flags = ida_bytes.get_full_flags(next_ea)\n        if f is not None:\n            if debug: dbg_print(\"!!!!!! func\", hex(next_ea).rstrip(\"L\"), hex(f.start_ea).rstrip(\"L\"), hex(ida_idaapi.BADADDR).rstrip(\"L\"))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dref_from_belong_to_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dref_from_belong_to_func(ea, dref_recursive=True, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    ea_flags = ida_bytes.get_flags(ea)\n    for next_ea in get_drefs_from(ea):\n        if debug: dbg_print(\"dref_from: \", hex(next_ea).rstrip(\"L\"), hex(ea).rstrip(\"L\"))\n        #print(hex(next_ea).rstrip(\"L\"), hex(ea).rstrip(\"L\"))\n        f = ida_funcs.get_func(next_ea)\n        flags = ida_bytes.get_full_flags(next_ea)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_refed_strings",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_refed_strings():\n    result = {}\n    s = idautils.Strings()\n    s.setup([ida_nalt.STRTYPE_C, ida_nalt.STRTYPE_C_16], minlen=4)\n    #s.setup()\n    for i in s:\n        r = set(get_drefs_to(i.ea))\n        #print(\"%x: len=%d type=%d -> '%s'\" % (i.ea, i.length, i.strtype, str(i)))\n        if len(r) > 0:\n            for x in r:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dyn_apicalls_partial",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dyn_apicalls_partial(func_relations, ea):\n    if not ea in func_relations:\n        f = ida_funcs.get_func(ea)\n        if f:\n            ea = f.start_ea\n    if ea in func_relations:\n        for caller in func_relations[ea]['children']:\n            func_ea, func_type, op, func_name = func_relations[ea]['children'][caller]\n            if func_ea == ida_idaapi.BADADDR and func_name:\n                yield caller, func_name",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dyn_apicalls",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dyn_apicalls(func_relations):\n    result = {}\n    for callee in func_relations:\n        for caller, func_name in get_dyn_apicalls_partial(func_relations, callee):\n            result[caller] = func_name\n    return result\ndef get_entry_points():\n    n = ida_entry.get_entry_qty()\n    for i in range(n):\n        ordinal = ida_entry.get_entry_ordinal(i)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_entry_points",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_entry_points():\n    n = ida_entry.get_entry_qty()\n    for i in range(n):\n        ordinal = ida_entry.get_entry_ordinal(i)\n        ea = ida_entry.get_entry(ordinal)\n        if ea != ida_idaapi.BADADDR:\n            yield ea\ndef get_opnums(func_relations, keyword='children'):\n    opnums = {}\n    for func_ea in func_relations:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_opnums",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_opnums(func_relations, keyword='children'):\n    opnums = {}\n    for func_ea in func_relations:\n        for caller in func_relations[func_ea][keyword]:\n            callee, func_type, op, func_name = func_relations[func_ea][keyword][caller]\n            opnums[caller] = op\n    return opnums\n# for reverse lookup of vftable\ndef get_vtbl_refs(func_relations):\n    result = {}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_vtbl_refs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_vtbl_refs(func_relations):\n    result = {}\n    for func_ea in func_relations:\n        for vtbl_offset in func_relations[func_ea][\"vftables\"]:\n            for vfptr in func_relations[func_ea][\"vftables\"][vtbl_offset]:\n                result[vfptr] = vtbl_offset\n    return result\ndef get_strings_in_funcs():\n    strings = get_refed_strings()\n    strings_in_func = {}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_strings_in_funcs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_strings_in_funcs():\n    strings = get_refed_strings()\n    strings_in_func = {}\n    for ea in strings:\n        f = ida_funcs.get_func(ea)\n        if f:\n            if f.start_ea in strings_in_func:\n                strings_in_func[f.start_ea][ea] = strings[ea]\n            else:\n                strings_in_func[f.start_ea] = {ea:strings[ea]}",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "is_matched",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def is_matched(text, regexes):\n    matched = False\n    for regex in regexes:\n        if regex.match(text):\n            matched = True\n            break\n    if matched:\n        return True\n    return False\ndef get_cmts_in_func(func_ea, regexes_rpt=None, regexes=None):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_cmts_in_func",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_cmts_in_func(func_ea, regexes_rpt=None, regexes=None):\n    result = {'cmt':{}, 'rcmt':{}}\n    f = ida_funcs.get_func(func_ea)\n    if not f:\n        rcmt = ida_bytes.get_cmt(func_ea, True)\n        cmt = ida_bytes.get_cmt(func_ea, False)\n        if cmt and is_matched(cmt, regexes):\n            result['cmt'][func_ea] = cmt\n        if rcmt and not is_matched(rcmt, regexes_rpt):\n            result['rcmt'][func_ea] = rcmt",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_family_members",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_family_members(ea, f, import_eas=None, string_eas=None):\n    if import_eas is None:\n        import_eas = []\n    if string_eas is None:\n        string_eas = {}\n    target_ea = ea\n    if f is not None:\n        target_ea = f.start_ea\n    parents = get_xrefs(target_ea)\n    children, apicalls, gvars, strings, stroff, vtbl = get_children(f, import_eas, string_eas)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_relation",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_relation(f, import_eas=None, string_eas=None):\n    if import_eas is None:\n        import_eas = []\n    if string_eas is None:\n        string_eas = {}\n    #fc = ida_gdl.FlowChart(f)\n    #bbs = get_bbs(fc)\n    parents, children, apicalls, gvars, strings, stroff, vtbl = get_family_members(f.start_ea, f, import_eas, string_eas)\n    func_type = get_func_type(f.start_ea, import_eas)\n    yield f.start_ea, parents, children, func_type, gvars, strings, stroff, vtbl",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_relation_in_all_funcs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_relation_in_all_funcs(import_eas=None, string_eas=None):\n    for f in funcs():\n        for ea, parents, children, func_type, gvars, strings, stroff, vtbl in get_func_relation(f, import_eas, string_eas):\n            yield ea, parents, children, func_type, gvars, strings, stroff, vtbl\ndef fix_parent(func_relations, vtbl_refs, func_ea):\n    if func_ea not in func_relations:\n        return\n    for parent_caller in func_relations[func_ea][\"parents\"]:\n        if parent_caller in vtbl_refs:\n            parent_callee = vtbl_refs[parent_caller]",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "fix_parent",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def fix_parent(func_relations, vtbl_refs, func_ea):\n    if func_ea not in func_relations:\n        return\n    for parent_caller in func_relations[func_ea][\"parents\"]:\n        if parent_caller in vtbl_refs:\n            parent_callee = vtbl_refs[parent_caller]\n            orig_callee, ft, opn, name = func_relations[func_ea][\"parents\"][parent_caller]\n            func_relations[func_ea][\"parents\"][parent_caller] = (parent_callee, FT_VTB, -1, \"\")\ndef fix_parents(func_relations, vtbl_refs):\n    for func_ea in func_relations:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "fix_parents",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def fix_parents(func_relations, vtbl_refs):\n    for func_ea in func_relations:\n        fix_parent(func_relations, vtbl_refs, func_ea)\n#@qprofile\ndef get_func_relations():\n    t1 = time.time()\n    result = {}\n    imports = get_imports()\n    #import_eas = set([x[1] for x in imports])\n    import_eas = dict.fromkeys([x[1] for x in imports])",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_func_relations",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_func_relations():\n    t1 = time.time()\n    result = {}\n    imports = get_imports()\n    #import_eas = set([x[1] for x in imports])\n    import_eas = dict.fromkeys([x[1] for x in imports])\n    string_eas = get_refed_strings()\n    for func_ea, parents, children, func_type, gvars, strings, stroff, vtbl in get_relation_in_all_funcs(import_eas, string_eas):\n        result[func_ea] = {\"parents\":parents, \"children\":children, \"func_type\":func_type, \"gvars\":gvars, \"strings\":strings, \"struct_offsets\": stroff, \"vftables\": vtbl}\n    vtbl_refs = get_vtbl_refs(result)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_dref_type",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_dref_type(func_ea, func_type, func_relations):\n    if func_type == FT_UNK:\n        if func_ea in func_relations:\n            func_type = func_relations[func_ea][\"func_type\"]\n        if func_type in [FT_UNK]:\n            func_type = FT_VAR\n            flags = ida_bytes.get_flags(func_ea)\n            if ida_bytes.is_strlit(flags):\n                func_type = FT_STR\n    return func_type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "drefs_wrapper",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def drefs_wrapper(drefs, func_relations, direction, vtbl_refs, dref_recursive=True, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    dref_dir = \"parents\"\n    if direction == \"parents\":\n        dref_dir = \"children\"\n    # for drefs\n    for ea, func_ea, dref_off_ea in drefs:\n        if debug: dbg_print(\"ea:\", hex(ea), \"func_ea:\", hex(func_ea), \"dref_off_ea:\", hex(dref_off_ea))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "get_drefs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def get_drefs(func_ea, ea, direction, vtbl_refs, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    drefs = []\n    if direction == \"parents\":\n        if func_ea == ida_idaapi.BADADDR:\n            drefs = list(get_dref_belong_to_func(ea, vtbl_refs, debug=debug, dbg_print_func=dbg_print_func))\n        else:\n            drefs = list(get_dref_belong_to_func(func_ea, vtbl_refs, debug=debug, dbg_print_func=dbg_print_func))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "append_result",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def append_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, func_relations):\n    append_exceeded = False\n    if next_func_ea in func_relations and len(func_relations[next_func_ea][direction]) > 0:\n    #if next_func_ea in func_relations and len([func_relations[next_func_ea][direction][x] for x in func_relations[next_func_ea][direction] if len(func_relations[next_func_ea][direction][x]) > 0 if func_relations[next_func_ea][direction][x][1] not in [FT_STO, FT_VAR, FT_STR]]) > 0:\n        append_exceeded = True\n    _append_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, func_relations, append_exceeded=append_exceeded)\ndef _pop_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, append_exceeded=False):\n    result.pop(-1)\n    if dref_off_ea != ida_idaapi.BADADDR and next_func_ea != ida_idaapi.BADADDR and dref_off_ea != next_func_ea:\n        if not idc.get_struc_name(dref_off_ea):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "pop_result",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def pop_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, func_relations):\n    append_exceeded = False\n    if next_func_ea in func_relations and len(func_relations[next_func_ea][direction]) > 0:\n    #if next_func_ea in func_relations and len([func_relations[next_func_ea][direction][x] for x in func_relations[next_func_ea][direction] if len(func_relations[next_func_ea][direction][x]) > 0 if func_relations[next_func_ea][direction][x][1] not in [FT_STO, FT_VAR, FT_STR]]) > 0:\n        append_exceeded = True\n    _pop_result(result, next_ea, next_func_ea, next_func_type, dref_off_ea, direction, append_exceeded=append_exceeded)\ndef check_next_drefs(drefs, direction, vtbl_refs, func_ea, func_relations, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "check_next_drefs",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def check_next_drefs(drefs, direction, vtbl_refs, func_ea, func_relations, debug=False, dbg_print_func=None):\n    dbg_print = dbg_print_func\n    if dbg_print_func is None:\n        dbg_print = l_dbg_print\n    next_drefs_flag = False\n    next_drefs_code_flag = False\n    if len(drefs) > 0:\n        for next_ea, next_func_ea, dref_off_ea in drefs:\n            if next_func_ea in func_relations:\n                if debug: dbg_print(\"next_dref_flag enabled pattern 0:\", hex(next_ea), hex(next_func_ea), hex(dref_off_ea))",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "trace_func_calls",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def trace_func_calls(func_relations, ea, func_ea=ida_idaapi.BADADDR, target_ea=ida_idaapi.BADADDR, direction=\"parents\", vtbl_refs={}, result=None, force_trace=False, max_recursive=g_max_recursive, nrecursive=0, skip_lib=False, skip_api=False, filtered_nodes=None, finished=None, finished_in_path=None, finished_nodes_in_path=None, debug=False, dbg_print_func=None):\n    local_finished = set([])\n    # initialize default values\n    if result is None:\n        result = []\n    if filtered_nodes is None:\n        filtered_nodes = ()\n    if finished is None:\n        finished = set([])\n    if finished_in_path is None:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "def main():\n    imports = get_imports()\n    import_eas = dict.fromkeys([x[1] for x in imports])\n    string_eas = get_refed_strings()\n    ea = idc.here()\n    #f, bbs = get_func_bbs(ea)\n    if f:\n        ea = f.start_ea\n    parents, children, apicalls, gvars, strings, stroff, vtbl = get_family_members(ea, f, import_eas, string_eas)\n    print(\"Parents  :\", [(hex(x).rstrip(\"L\"), hex(parents[x][0]).rstrip(\"L\")) for x in parents])",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_max_recursive",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_max_recursive = 100\nif \"g_debug\" not in globals():\n    g_debug = False\ng_fp = None\ng_max_lines = 20000\ng_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_fp",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_fp = None\ng_max_lines = 20000\ng_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_max_lines",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_max_lines = 20000\ng_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_lines",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_lines = 0\ng_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "g_dont_record_mnems",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "g_dont_record_mnems = ['nop']\ndef qprofile(func):\n    def profiled_func(*args, **kwargs):\n        try:\n            profile = cProfile.Profile()\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result\n        finally:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_UNK",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_UNK = 0    # unknown\nFT_GEN = 1    # for general internal calls\nFT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_GEN",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_GEN = 1    # for general internal calls\nFT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_LIB",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_LIB = 2    # for static linked libraries\nFT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_API",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_API = 4    # for API call\nFT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_MEM",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_MEM = 8    # for indicrect calls\nFT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_VAR",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_VAR = 16   # for global/static variables. strictly speaking, it's not \"func type\"\nFT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_STR",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_STR = 32   # for string variables. strictly speaking, it's not \"func type\"\nFT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_STO",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_STO = 64   # for structure's offset access. strictly speaking, it's not \"func type\"\nFT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type\n    f = ida_funcs.get_func(func_ea)",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "FT_VTB",
        "kind": 5,
        "importPath": "plugins.cto.get_func_relation",
        "description": "plugins.cto.get_func_relation",
        "peekOfCode": "FT_VTB = 128  # for vftable\ndef get_func_type(func_ea, import_eas=None, func_type=FT_UNK, offset=False):\n    if import_eas is None:\n        import_eas = []\n    #try:\n    #    func_flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)\n    #except TypeError:\n    #    return func_type\n    f = ida_funcs.get_func(func_ea)\n    if f is None:",
        "detail": "plugins.cto.get_func_relation",
        "documentation": {}
    },
    {
        "label": "icon_handler",
        "kind": 6,
        "importPath": "plugins.cto.icon",
        "description": "plugins.cto.icon",
        "peekOfCode": "class icon_handler(object):\n    def __init__(self, icon_data, hexify=False):\n        if hexify:\n            icon_data = self.ascii_to_hex(icon_data)\n        self.icon_data = icon_data\n    @staticmethod\n    def ascii_to_hex(icon_data_ascii):\n        return codecs.decode(b\"\".join(icon_data_ascii), 'hex')\n    @staticmethod\n    def icon_bg_change(icon_data, bg_change=False, bin_transform=False):",
        "detail": "plugins.cto.icon",
        "documentation": {}
    },
    {
        "label": "g_icon_data_ascii",
        "kind": 5,
        "importPath": "plugins.cto.icon",
        "description": "plugins.cto.icon",
        "peekOfCode": "g_icon_data_ascii = (\n    b\"89504E470D0A1A0A0000000D4948445200000020000000200806000000737A7A\",\n    b\"F4000000097048597300000EC300000EC301C76FA8640000001974455874536F\",\n    b\"667477617265007777772E696E6B73636170652E6F72679BEE3C1A0000036249\",\n    b\"4441545885ADD75B8855651407F0DF346383948E4E99A6537445C2ACB1521421\",\n    b\"8C28822E4418965009094120E5180411F6D08588EE3E48D4832464045D686648\",\n    b\"7CA8888AB2FBE5A507C12CA8C0ACD46CB2C6D3C3FA367BCF696F3DFB9C59B0F9\",\n    b\"F6FEBE75F99FF5ADDBE9D23A0D602596E242CC443FFEC66FD8830FF012BEAAA1\",\n    b\"F798342F29FD178D169F2D3871328C2FC1DE1A868BCF9B9D1A9F8BDFDB349E3D\",\n    b\"577402E0E50E8D37C4B53D86EEBAC64FC3F8240028C6442D5A5FA26417BE3C06\",",
        "detail": "plugins.cto.icon",
        "documentation": {}
    },
    {
        "label": "g_icon_data",
        "kind": 5,
        "importPath": "plugins.cto.icon",
        "description": "plugins.cto.icon",
        "peekOfCode": "g_icon_data = codecs.decode(b\"\".join(g_icon_data_ascii), 'hex')\nclass icon_handler(object):\n    def __init__(self, icon_data, hexify=False):\n        if hexify:\n            icon_data = self.ascii_to_hex(icon_data)\n        self.icon_data = icon_data\n    @staticmethod\n    def ascii_to_hex(icon_data_ascii):\n        return codecs.decode(b\"\".join(icon_data_ascii), 'hex')\n    @staticmethod",
        "detail": "plugins.cto.icon",
        "documentation": {}
    },
    {
        "label": "jump_to_func_ptr_line_pos",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jump_to_func_ptr_line_pos(text, func_name, w, tweak=0, add_x=False):\n    flag = False\n    idx = text.find(func_name)\n    #w = find_widget(wname)\n    if w is None:\n        return flag\n    # we are already at a certain point. but ida sometimes does not point to a function in the middle of the instruction.\n    # that's why I use position 0 of x first, and then move to the right position again.\n    if idx == 0:\n        pos, x, y = ida_kernwin.get_custom_viewer_place(w, 0)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_apiname_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_apiname_line(ea, wname=g_wname):\n    fn = idc.get_name(ea)\n    if not fn:\n        return None, None\n    fn, line, idx = get_funcname_line(ea)\n    if not fn:\n        return None, None\n    w = find_widget(wname)\n    if w is None:\n        return None, None",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jump_to_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jump_to_line(ea, i, w):\n    #w = find_widget(wname)\n    if w is None:\n        return False\n    pos, x, y = ida_kernwin.get_custom_viewer_place(w, 0)\n    pos.lnnum = i\n    ida_kernwin.jumpto(w, pos, x, y)\n    return True\n\"\"\"\ndef check_line(ea, i, fn, wname=g_wname):",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "check_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def check_line(ea, i, fn, wname=g_wname):\n    w = find_widget(wname)\n    if w is None:\n        return None, -1\n    pos, x, y = ida_kernwin.get_custom_viewer_place(w, 0)\n    pos.lnnum = i\n    ida_kernwin.jumpto(w, pos, x, y)\n    l = ida_kernwin.get_curline()\n    l_removed = ida_lines.tag_remove(l)\n    l_removed_content = l_removed.split(\";\")[0]",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_line_no_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_line_no_decomp(text, vu, max_trial=200):\n    line = \"\"\n    lineno = -1\n    x = -1\n    lnnum = 0\n    y = 0\n    for i, l in enumerate(vu.cfunc.get_pseudocode()):\n        if ida_lines.tag_remove(l.line).startswith(\"//\"):\n            y += 1\n            continue",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_funcname_line_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_funcname_line_decomp(ea, vu, max_trial=200):\n    func_decl_str = ida_lines.tag_remove(vu.cfunc.print_dcl())\n    f = ida_funcs.get_func(ea)\n    func_name = ida_funcs.get_func_name(f.start_ea)\n    func_name = ida_name.validate_name(func_name, ida_name.VNT_VISIBLE)\n    # for API thunk call (e.g. __WSADisSet -> _WSADisSet)\n    if func_decl_str.find(func_name) < 0 and func_name.startswith(\"_\"):\n        func_name = func_name[1:]\n    line, lineno, lnnum, x, y = get_line_no_decomp(func_name, vu)\n    return line, lineno, lnnum, x, y",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_line_no",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_line_no(ea, text, max_trial=200, chk_cmt=False):\n    _, disass = ida_lines.generate_disassembly(\n        ea,\n        max_trial,  # maximum number of lines\n        False,      # as_stack=False\n        True)       # notags\n    for i, l in enumerate(disass):\n        if chk_cmt:\n            l_content = ''\n            if l.find(\";\") >= 0:",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_funcname_line",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_funcname_line(ea, w, max_trial=200):\n    f = ida_funcs.get_func(ea)\n    if f:\n        func_ea = f.start_ea\n        fn = idc.get_func_name(func_ea)\n    else:\n        fn = ida_name.get_name(ea)\n    if fn:\n        fn = ida_name.validate_name(fn, ida_name.VNT_VISIBLE)\n        #print(fn)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "push_lochist_jump",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def push_lochist_jump(w):\n    r = False\n    if w is None:\n        return False\n    loc = ida_moves.lochist_entry_t()\n    r = ida_kernwin.get_custom_viewer_location(loc, w)\n    if r:\n        loc.renderer_info().pos.cx = 0\n        r = ida_kernwin.custom_viewer_jump(w, loc, ida_kernwin.CVNF_JUMP)\n    return False",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_name_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_name_decomp(ea, w):\n    try:\n        import ida_hexrays\n        ida_hexrays.init_hexrays_plugin()\n    except ImportError:\n        return\n    vu = ida_hexrays.get_widget_vdui(w)\n    #print(vu.cfunc)\n    if vu is None:\n        return",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_name",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_name(ea, w):\n    wt = ida_kernwin.get_widget_type(w)\n    if wt == ida_kernwin.BWN_DISASM:\n        jumpto_name_ida(ea, w)\n    elif wt == ida_kernwin.BWN_PSEUDOCODE:\n        jumpto_name_decomp(ea, w)\ndef jumpto_name_ida(ea, w):\n    flag = False\n    ida_kernwin.jumpto(ea)\n    func = ida_funcs.get_func(ea)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_name_ida",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_name_ida(ea, w):\n    flag = False\n    ida_kernwin.jumpto(ea)\n    func = ida_funcs.get_func(ea)\n    # for callee\n    if func:\n        #print(\"%x\" % func.start_ea)\n        fn, line, idx = get_funcname_line(func.start_ea, w)\n        if idx >= 0:\n            if w is None:",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_offset",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_offset(ea, w):\n    flag = False\n    wt = ida_kernwin.get_widget_type(w)\n    if wt == ida_kernwin.BWN_DISASM:\n        flag = jumpto_offset_ida(ea, w)\n    elif wt == ida_kernwin.BWN_PSEUDOCODE:\n        pass\n    return flag\ndef jumpto_offset_ida(ea, w):\n    curr_line = ida_lines.tag_remove(ida_kernwin.get_curline())",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_offset_ida",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_offset_ida(ea, w):\n    curr_line = ida_lines.tag_remove(ida_kernwin.get_curline())\n    search_key = \" offset \"\n    x = curr_line.find(search_key)\n    if x > 0:\n        x += len(search_key)\n        func_name = ida_name.extract_name(curr_line.split(search_key)[1], 0)\n        # sometimes mismatch actual function name and and validate name.\n        # to fix it, get name and compare its name with it.\n        off_v = ida_xref.get_first_dref_from(ea)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_opn",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_opn(ea, opn, w):\n    flag = False\n    if opn >= 0:\n        tweak = 0\n        #ida_kernwin.jumpto(ea, opn, ida_kernwin.UIJMP_DONTPUSH)\n        ida_kernwin.jumpto(ea, opn)\n        wt = ida_kernwin.get_widget_type(w)\n        if wt == ida_kernwin.BWN_DISASM:\n            jumpto_opn_ida(ea, opn, w)\n        elif wt == ida_kernwin.BWN_PSEUDOCODE:",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_highlight_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_highlight_decomp(w):\n    vu = None\n    highlight = None\n    try:\n        import ida_hexrays\n        ida_hexrays.init_hexrays_plugin()\n    except ImportError:\n        return None, None\n    vu = ida_hexrays.get_widget_vdui(w)\n    #print(vu.cfunc)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_current_line_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_current_line_decomp(highlight, vu):\n    x, y = vu.cfunc.find_item_coords(highlight)\n    return ida_lines.tag_remove(list(vu.cfunc.get_pseudocode())[y].line)\ndef get_highlight_name_decomp(w):\n    highlight, vu = get_highlight_decomp(w)\n    if highlight and highlight.is_expr():\n        hl_str = highlight.print1(None)\n        return hl_str\n    return None\ndef jumpto_opn_decomp(ea, opn, w):",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "get_highlight_name_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def get_highlight_name_decomp(w):\n    highlight, vu = get_highlight_decomp(w)\n    if highlight and highlight.is_expr():\n        hl_str = highlight.print1(None)\n        return hl_str\n    return None\ndef jumpto_opn_decomp(ea, opn, w):\n    flag = False\n    try:\n        import ida_hexrays",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_opn_decomp",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_opn_decomp(ea, opn, w):\n    flag = False\n    try:\n        import ida_hexrays\n        ida_hexrays.init_hexrays_plugin()\n    except ImportError:\n        return False\n    highlight, vu = get_highlight_decomp(w)\n    if highlight and highlight.is_expr():\n        hl_str = highlight.print1(None)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "jumpto_opn_ida",
        "kind": 2,
        "importPath": "plugins.cto.jump",
        "description": "plugins.cto.jump",
        "peekOfCode": "def jumpto_opn_ida(ea, opn, w):\n    flag = False\n    if True:\n        tweak = 0\n        op = idc.print_operand(ea, opn)\n        optype = idc.get_operand_type(ea, opn)\n        v = idc.get_operand_value(ea, opn)\n        f = ida_funcs.get_func(ea)\n        func_flags = idc.get_func_attr(ea, idc.FUNCATTR_FLAGS)\n        func_name = ida_funcs.get_func_name(ea)",
        "detail": "plugins.cto.jump",
        "documentation": {}
    },
    {
        "label": "loop_detector",
        "kind": 6,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "class loop_detector(object):\n    def __init__(self, ea, quantity_limit=True, chunk_quantity=1000):\n        self.ea = ea\n        self.f = ida_gdl.FlowChart(ida_funcs.get_func(ea))\n        self.chunk_quantity = chunk_quantity\n        self.quantity_limit = quantity_limit\n        self.finished = set([])\n        self.recognized_loop = []\n    def get_bb(self, ea):\n        block = None",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "print_loops",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def print_loops(loops):\n    i = 0\n    for loop in loops:\n        if len(loop) > 0:\n            print(\"  found loop starting at %08x:\" % loop[0][0])\n            for lbb in loop:\n                print(\"    bb_start_ea: %08x\" % lbb[0])\n            i += 1\n    print(\"found %d loops!\" % i)\n\"\"\"",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "recognized_loop",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def recognized_loop(func_ea, chunk_quantity=1000, quantity_limit=True):\n    ld = loop_detector(func_ea, quantity_limit, chunk_quantity)\n    loops = ld.find_loops()\n    print(\"func addr: %08x\" % func_ea)\n    print_loops(loops)\n\"\"\"\ndef get_all_loops_in_all_funcs():\n    for func_ea in idautils.Functions():\n        ld = loop_detector(func_ea)\n        loops = ld.get_all_loops_in_func()",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "get_all_loops_in_all_funcs",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def get_all_loops_in_all_funcs():\n    for func_ea in idautils.Functions():\n        ld = loop_detector(func_ea)\n        loops = ld.get_all_loops_in_func()\n        yield func_ea, loops\ndef main():\n    for func_ea, loops in get_all_loops_in_all_funcs():\n        print(\"----------------- %x -------------------\" % func_ea)\n        print_loops(loops)\n\"\"\"",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def main():\n    for func_ea, loops in get_all_loops_in_all_funcs():\n        print(\"----------------- %x -------------------\" % func_ea)\n        print_loops(loops)\n\"\"\"\ndef main():\n    ea = ida_kernwin.get_screen_ea()\n    print(\"-----------------all loops in func -------------------\")\n    ld = loop_detector(ea)\n    loops = ld.get_all_loops_in_func()",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.loop_detector",
        "description": "plugins.cto.loop_detector",
        "peekOfCode": "def main():\n    ea = ida_kernwin.get_screen_ea()\n    print(\"-----------------all loops in func -------------------\")\n    ld = loop_detector(ea)\n    loops = ld.get_all_loops_in_func()\n    print_loops(loops)\n\"\"\"\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto.loop_detector",
        "documentation": {}
    },
    {
        "label": "notable_const_t",
        "kind": 6,
        "importPath": "plugins.cto.notable_const_finder",
        "description": "plugins.cto.notable_const_finder",
        "peekOfCode": "class notable_const_t(object):\n    def __init__(self, frules=os.path.join(os.path.dirname(__file__),\"notable_consts.json\"), show_high_ent=False, cmt_prefix=\"NT_CON: \"):\n        with open(frules) as f:\n            consts = json.load(f)\n        self.consts = {}\n        for rule_name in consts:\n            if rule_name not in self.consts:\n                self.consts[rule_name] = {}\n            if rule_name == \"single\":\n                for val in consts[rule_name]:",
        "detail": "plugins.cto.notable_const_finder",
        "documentation": {}
    },
    {
        "label": "get_op_size",
        "kind": 2,
        "importPath": "plugins.cto.notable_const_finder",
        "description": "plugins.cto.notable_const_finder",
        "peekOfCode": "def get_op_size(dtyp):\n    if dtyp == ida_ua.dt_dword:\n        size = 4\n    elif dtyp == ida_ua.dt_word:\n        size = 2\n    elif dtyp == ida_ua.dt_byte:\n        size = 1\n    elif dtyp == ida_ua.dt_qword:\n        size = 8\n    else:",
        "detail": "plugins.cto.notable_const_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.notable_const_finder",
        "description": "plugins.cto.notable_const_finder",
        "peekOfCode": "def main():\n    c = notable_const_t()\n    for func_ea, const_ea, val, rule_name in c.collect_notable_consts():\n        print(\"%x %s: %x, %x, %s\" % (func_ea, idc.get_name(func_ea), const_ea, val, rule_name))\nif __name__ == \"__main__\":\n    main()",
        "detail": "plugins.cto.notable_const_finder",
        "documentation": {}
    },
    {
        "label": "notable_inst_t",
        "kind": 6,
        "importPath": "plugins.cto.notable_inst_finder",
        "description": "plugins.cto.notable_inst_finder",
        "peekOfCode": "class notable_inst_t(object):\n    def __init__(self, frules=os.path.join(os.path.dirname(__file__),\"notable_insts.json\"), show_high_ent=False, cmt_prefix=\"NT_INST: \"):\n        with open(frules) as f:\n            insts = json.load(f)\n        self.insts = {}\n        for rule_type in insts:\n            if rule_type not in self.insts:\n                self.insts[rule_type] = {}\n            if rule_type == \"single\":\n                for rule_name in insts[rule_type]:",
        "detail": "plugins.cto.notable_inst_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.notable_inst_finder",
        "description": "plugins.cto.notable_inst_finder",
        "peekOfCode": "def main():\n    i = notable_inst_t()\n    for func_ea, inst_ea, rule_name, disasm in i.collect_notable_insts():\n        print(\"%x %s: %x: %s: %s\" % (func_ea, idc.get_name(func_ea), inst_ea, rule_name, disasm))\nif __name__ == \"__main__\":\n    main()",
        "detail": "plugins.cto.notable_inst_finder",
        "documentation": {}
    },
    {
        "label": "notable_mnem_t",
        "kind": 6,
        "importPath": "plugins.cto.notable_mnem_finder",
        "description": "plugins.cto.notable_mnem_finder",
        "peekOfCode": "class notable_mnem_t(object):\n    def __init__(self, cmt_prefix=\"NT_MNEM: \"):\n        self.cmt_prefix = cmt_prefix\n    @staticmethod\n    def get_code_eas(ea=idc.get_inf_attr(idc.INF_MIN_EA), max_ea=idc.get_inf_attr(idc.INF_MAX_EA)):\n        flags = ida_bytes.get_flags(ea)\n        if ida_bytes.is_code(flags):\n            yield ea\n        ea = ida_bytes.next_that(ea, max_ea, ida_bytes.is_code)\n        while ea != ida_idaapi.BADADDR:",
        "detail": "plugins.cto.notable_mnem_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.notable_mnem_finder",
        "description": "plugins.cto.notable_mnem_finder",
        "peekOfCode": "def main():\n    c = notable_mnem_t()\n    for func_ea, ea, mnem_type, dst_ea in c.mnem_handlers():\n        print(\"%x %s: %x: %s, %x\" % (func_ea, idc.get_name(func_ea), ea, mnem_type, dst_ea))\nif __name__ == \"__main__\":\n    main()",
        "detail": "plugins.cto.notable_mnem_finder",
        "documentation": {}
    },
    {
        "label": "enable_toolbar_t",
        "kind": 6,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "class enable_toolbar_t(ida_kernwin.UI_Hooks):\n    def __init__(self, toolbar_name):\n        self.toolbar_name = toolbar_name\n        ida_kernwin.UI_Hooks.__init__(self)\n        self.hook()\n    def ready_to_run(self):\n        self.enable_toolbar()\n    def enable_toolbar(self):\n        widget = ida_kernwin.open_navband_window(ida_kernwin.get_screen_ea(),1)\n        set_toobar_visible(widget, self.toolbar_name)",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "can_use_qt",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def can_use_qt():\n    try:\n        import sip\n        from PyQt5 import QtCore\n        from PyQt5 import QtWidgets\n        from PyQt5 import QtGui\n    except ImportError:\n        return False\n    return True\ndef get_qver():",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "get_qver",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def get_qver():\n    from PyQt5 import QtCore\n    v = QtCore.qVersion()\n    maj, mnr, _ =[int(x) for x in v.split(\".\")]\n    return maj, mnr\ndef get_widget(w, widget_types=None, title=None, max_try=100):\n    import sip\n    from PyQt5 import QtWidgets\n    if widget_types is None:\n        widget_types = set([QtWidgets.QWidget,QtWidgets.QSplitter])",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "get_widget",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def get_widget(w, widget_types=None, title=None, max_try=100):\n    import sip\n    from PyQt5 import QtWidgets\n    if widget_types is None:\n        widget_types = set([QtWidgets.QWidget,QtWidgets.QSplitter])\n    widget = sip.wrapinstance(int(w), QtWidgets.QWidget)\n    i = 0\n    while i < max_try and widget and type(widget) != QtWidgets.QMainWindow:\n        if type(widget) in widget_types:\n            #print(widget.windowTitle(), type(widget))",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "get_qmain_window",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def get_qmain_window(w, max_try = 100):\n    if not can_use_qt():\n        return None\n    import sip\n    from PyQt5 import QtWidgets\n    if w is None:\n        return None\n    widget = sip.wrapinstance(int(w), QtWidgets.QWidget)\n    find_flag = False\n    i = 0",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "find_toolbar",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def find_toolbar(widget, toolbar_name):\n    if not can_use_qt():\n        return None\n    from PyQt5 import QtWidgets\n    for cwidget in widget.children():\n        if type(cwidget) == QtWidgets.QToolBar:\n            #print(cwidget.objectName())\n            #print(cwidget.accessibleName())\n            if cwidget.objectName() == toolbar_name:\n                return cwidget",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "set_toobar_visible",
        "kind": 2,
        "importPath": "plugins.cto.qtutils",
        "description": "plugins.cto.qtutils",
        "peekOfCode": "def set_toobar_visible(w, toolbar_name):\n    if not can_use_qt():\n        return False\n    from PyQt5 import QtCore\n    widget = get_qmain_window(w)\n    if widget:\n        tb_widget = find_toolbar(widget, toolbar_name)\n        if tb_widget and not tb_widget.isVisible():\n            tb_widget.setEnabled(True)\n            tb_widget.setVisible(True)",
        "detail": "plugins.cto.qtutils",
        "documentation": {}
    },
    {
        "label": "sync_data",
        "kind": 6,
        "importPath": "plugins.cto.syncdata",
        "description": "plugins.cto.syncdata",
        "peekOfCode": "class sync_data(object):\n    g_data_name = \"g_cto_data\"\n    def get(self):\n        # this process should be the first instance of CTO related object\n        if not hasattr(sys.modules[\"__main__\"], self.g_data_name):\n            print(\"data is unavailable. extract data from idb or pickle\")\n            return None\n        else:\n            print(\"get data from global variable\")\n            # Read the global dict",
        "detail": "plugins.cto.syncdata",
        "documentation": {}
    },
    {
        "label": "my_ui_hooks_t",
        "kind": 6,
        "importPath": "plugins.cto.syncui",
        "description": "plugins.cto.syncui",
        "peekOfCode": "class my_ui_hooks_t(ida_kernwin.UI_Hooks):\n    def __init__(self, g):\n        ida_kernwin.UI_Hooks.__init__(self)\n        self.hook()\n        # let's use weakrefs, so as soon as the last ref to\n        # the 'CallTreeOverviewer' instance is dropped, the 'my_ui_hooks_t'\n        # instance hooks can be automatically un-hooked, and deleted.\n        # (in other words: avoid circular reference.)\n        import weakref\n        self.v = weakref.ref(g)",
        "detail": "plugins.cto.syncui",
        "documentation": {}
    },
    {
        "label": "my_view_hooks_t",
        "kind": 6,
        "importPath": "plugins.cto.syncui",
        "description": "plugins.cto.syncui",
        "peekOfCode": "class my_view_hooks_t(ida_kernwin.View_Hooks):\n    def __init__(self, g):\n        ida_kernwin.View_Hooks.__init__(self)\n        self.hook()\n        # let's use weakrefs, so as soon as the last ref to\n        # the 'CallTreeOverviewer' instance is dropped, the 'my_view_hooks_t'\n        # instance hooks can be automatically un-hooked, and deleted.\n        # (in other words: avoid circular reference.)\n        import weakref\n        self.v = weakref.ref(g)",
        "detail": "plugins.cto.syncui",
        "documentation": {}
    },
    {
        "label": "get_tinfo",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_tinfo(ea):\n    tif = ida_typeinf.tinfo_t()\n    result = ida_nalt.get_tinfo(tif, ea)\n    #if result and func_flag:\n    #    result = ida_typeinf.is_type_func(tif.get_realtype())\n    return tif if result else None\n#def get_tinfo_by_name(name, func_flag=True):\ndef get_tinfo_by_name(name):\n    tinfo = None\n    result = ida_typeinf.get_named_type(ida_typeinf.get_idati(), name, 0)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_tinfo_by_name",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_tinfo_by_name(name):\n    tinfo = None\n    result = ida_typeinf.get_named_type(ida_typeinf.get_idati(), name, 0)\n    if result:\n        tinfo = ida_typeinf.tinfo_t()\n        ret = tinfo.deserialize(ida_typeinf.get_idati(), result[1], result[2])\n        if not ret:\n            return None\n        #if ret and func_flag:\n        #    ret = ida_typeinf.is_type_func(tinfo.get_realtype())",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_local_tinfo_by_name",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_local_tinfo_by_name(name, func_flag=True):\n    ea = ida_name.get_name_ea(ida_idaapi.BADADDR, name)\n    if ea == ida_idaapi.BADADDR:\n        return None\n    tinfo = ida_typeinf.tinfo_t()\n    ret = ida_nalt.get_tinfo(tinfo, ea)\n    if not ret:\n        tinfo = None\n    if ret and func_flag:\n        #ret = ida_typeinf.is_type_func(tinfo.get_realtype())",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "apply_tinfo_to_ea",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def apply_tinfo_to_ea(tinfo, ea, opn=0):\n    if not tinfo:\n        return False\n    if not tinfo.is_funcptr():\n        tinfo.create_ptr(tinfo)\n    # why do we apply both apply_callee_tinfo & set_op_tinfo?\n    # it is because set_op_tinfo() causes change in hexrays decompilation\n    # apply_callee_tinfo() updates ida's stack analysis\n    ida_typeinf.apply_callee_tinfo(ea, tinfo)\n    # apply_callee_tinfo doesn't have return value, so we have to return the result of set_op_tinfo2.",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_op_tif",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_op_tif(ea, opn=0):\n    tif = ida_typeinf.tinfo_t()\n    result = ida_nalt.get_op_tinfo(tif, ea, opn)\n    return tif  if result else None\ndef comp_tifs(name, ea, opn=0):\n    tif = get_op_tif(ea, opn)\n    tif2 = get_tinfo_by_name(name)\n    if _comp_tifs(tif, tif2):\n        return True\n    return False",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "comp_tifs",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def comp_tifs(name, ea, opn=0):\n    tif = get_op_tif(ea, opn)\n    tif2 = get_tinfo_by_name(name)\n    if _comp_tifs(tif, tif2):\n        return True\n    return False\ndef _comp_tifs(tif, tif2):\n    tif2 = get_op_tif(ea, opn)\n    if not tif2.is_funcptr():\n        tif2.create_ptr(tif2)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "del_tinfo_from_ea",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def del_tinfo_from_ea(ea, opn=0):\n    ida_nalt.del_op_tinfo(ea, opn)\n    # remove comments and reset var names for the result of appy_callee_tinfo()?\n    #for ea in ida_typeinf.get_arg_addrs(caller):\n    #    print(hex(ea))\ng_api_name_postfix_regex = re.compile(r'(.*)_[0-9]+$')\ndef get_true_name(name):\n    r = g_api_name_postfix_regex.search(name)\n    if r:\n        grps = r.groups()",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_true_name",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_true_name(name):\n    r = g_api_name_postfix_regex.search(name)\n    if r:\n        grps = r.groups()\n        if len(grps) > 0:\n            return grps[0]\n    return name\ndef guess_true_names(name):\n    names = [name]\n    removed_postfix = get_true_name(name)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "guess_true_names",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def guess_true_names(name):\n    names = [name]\n    removed_postfix = get_true_name(name)\n    result = [name]\n    if name != removed_postfix:\n        names.append(removed_postfix)\n        result.append(removed_postfix)\n    for n in names:\n        for prefix in [\"_\", \"__\", \"Rtl\"]:\n            result.append(prefix+n)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_func_detail",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_func_detail(tif):\n    fi = ida_typeinf.func_type_data_t()\n    tif.get_func_details(fi)\n    return fi\ndef get_func_args(fi):\n    if not fi.empty():\n        #print fi\n        for i in fi:\n            yield i\ndef is_thiscall(cc):",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_func_args",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_func_args(fi):\n    if not fi.empty():\n        #print fi\n        for i in fi:\n            yield i\ndef is_thiscall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_THISCALL:\n        return True\n    return False\ndef is_fastcall(cc):",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "is_thiscall",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def is_thiscall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_THISCALL:\n        return True\n    return False\ndef is_fastcall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_FASTCALL:\n        return True\n    return False\n\"\"\"\ndef del_op_tinfo(func_relations, func_ea, ea):",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "is_fastcall",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def is_fastcall(cc):\n    if cc & ida_typeinf.CM_CC_MASK == ida_typeinf.CM_CC_FASTCALL:\n        return True\n    return False\n\"\"\"\ndef del_op_tinfo(func_relations, func_ea, ea):\n    if func_ea in func_relations:\n        if ea in func_relations[func_ea]['children']:\n            callee, func_type, opn, func_name = func_relations[func_ea]['children'][ea]\n            if callee == ida_idaapi.BADADDR and func_name:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "del_op_tinfo",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def del_op_tinfo(func_relations, func_ea, ea):\n    if func_ea in func_relations:\n        if ea in func_relations[func_ea]['children']:\n            callee, func_type, opn, func_name = func_relations[func_ea]['children'][ea]\n            if callee == ida_idaapi.BADADDR and func_name:\n                ida_nalt.del_op_tinfo(ea, opn)\ndef get_callee_info(func_relations, caller_ea):\n    f = ida_funcs.get_func(caller_ea)\n    if f and f.start_ea in func_relations:\n        if caller_ea in func_relations[f.start_ea]['children']:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "get_callee_info",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def get_callee_info(func_relations, caller_ea):\n    f = ida_funcs.get_func(caller_ea)\n    if f and f.start_ea in func_relations:\n        if caller_ea in func_relations[f.start_ea]['children']:\n            callee, func_type, op, func_name =  func_relations[f.start_ea]['children'][caller_ea]\n            return callee, func_type, op, func_name\n    return None, None, None, None\ndef apply_tif(caller, func_name):\n    callee, func_type, opn, _func_name = get_callee_info(caller)\n    if callee is not None:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "apply_tif",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def apply_tif(caller, func_name):\n    callee, func_type, opn, _func_name = get_callee_info(caller)\n    if callee is not None:\n        tif = get_tinfo_by_name(func_name)\n        if tif:\n            apply_tinfo_to_ea(tif, caller, opn)\ndef update_caller_tif(ea, func_name=None):\n    callee_ea, func_type, opn, _func_name = get_callee_info(ea)\n    if callee_ea is not None:\n        if func_name is None:",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "update_caller_tif",
        "kind": 2,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "def update_caller_tif(ea, func_name=None):\n    callee_ea, func_type, opn, _func_name = get_callee_info(ea)\n    if callee_ea is not None:\n        if func_name is None:\n            #if callee_ea == ida_idaapi.BADADDR and _func_name:\n            if _func_name:\n                func_name = _func_name\n            else:\n                func_name, func_type, v = get_func_relation.get_func_info_by_opstr(ea, opn)\n        ida_nalt.del_op_tinfo(ea, opn)",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "g_api_name_postfix_regex",
        "kind": 5,
        "importPath": "plugins.cto.tinfo",
        "description": "plugins.cto.tinfo",
        "peekOfCode": "g_api_name_postfix_regex = re.compile(r'(.*)_[0-9]+$')\ndef get_true_name(name):\n    r = g_api_name_postfix_regex.search(name)\n    if r:\n        grps = r.groups()\n        if len(grps) > 0:\n            return grps[0]\n    return name\ndef guess_true_names(name):\n    names = [name]",
        "detail": "plugins.cto.tinfo",
        "documentation": {}
    },
    {
        "label": "rename_func",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def rename_func(ea, xref_cnt, prefix='xorloop_', rename_prefix=g_rename_prefix, force=False):\n    name = idc.get_name(ea)\n    if name.find(prefix) >= 0:\n        return\n    rename_flag = False\n    for n in g_rename_prefix:\n        if name.startswith(n):\n            rename_flag = True\n    if force:\n        rename_flag = True",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "get_xor_insns_all_funcs",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def get_xor_insns_all_funcs():\n    for func_ea in idautils.Functions():\n        for ea in get_xor_insns(func_ea):\n            yield func_ea, ea\ndef get_xor_insns(func_ea):\n    for ea in idautils.FuncItems(func_ea):\n        mnem = idc.print_insn_mnem(ea)\n        if mnem == 'xor':\n            op1 = idc.print_operand(ea, 0)\n            op2 = idc.print_operand(ea, 1)",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "get_xor_insns",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def get_xor_insns(func_ea):\n    for ea in idautils.FuncItems(func_ea):\n        mnem = idc.print_insn_mnem(ea)\n        if mnem == 'xor':\n            op1 = idc.print_operand(ea, 0)\n            op2 = idc.print_operand(ea, 1)\n            if op1 != op2:\n                yield ea\ndef find_xor_loop(xor=False, comment=True, rename=False, cmt_prefix=\"CTO-\"):\n    to_rename_funcs = {}",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "find_xor_loop",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def find_xor_loop(xor=False, comment=True, rename=False, cmt_prefix=\"CTO-\"):\n    to_rename_funcs = {}\n    for func_ea, ea in get_xor_insns_all_funcs():\n        ld = loop_detector.loop_detector(func_ea)\n        bb = ld.get_bb(ea)\n        annotation_type = \"\"\n        # skip the candidate for xor loop if the basic block is function start or function end because it is not in a loop.\n        if len(tuple(bb.preds())) == 0 or len(tuple(bb.succs())) == 0:\n            if xor:\n                annotation_type = \"xor\"",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "def main():\n    for func_ea, ea, annotation_type in find_xor_loop():\n        print(\"%x %s: %s, %x: %s\" % (func_ea, idc.get_name(func_ea), annotation_type, ea, idc.generate_disasm_line(ea, 0)))\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "g_rename_prefix",
        "kind": 5,
        "importPath": "plugins.cto.xor_loop_detector",
        "description": "plugins.cto.xor_loop_detector",
        "peekOfCode": "g_rename_prefix = ('sub_',)\ndef rename_func(ea, xref_cnt, prefix='xorloop_', rename_prefix=g_rename_prefix, force=False):\n    name = idc.get_name(ea)\n    if name.find(prefix) >= 0:\n        return\n    rename_flag = False\n    for n in g_rename_prefix:\n        if name.startswith(n):\n            rename_flag = True\n    if force:",
        "detail": "plugins.cto.xor_loop_detector",
        "documentation": {}
    },
    {
        "label": "FixPredecessorOfConditionalJumpBlock",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "description": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "peekOfCode": "class FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):\n    DESCRIPTION = \"Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_PASSES = 100\n    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:\n        if len(pred_comparison_values) == 0:\n            return False, False\n        jmp_ins = jmp_blk.tail\n        compared_value = jmp_ins.r.nnn.value\n        compared_value_size = jmp_ins.r.size",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "description": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nJMP_OPCODE_HANDLED = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jge, m_jg, m_jl, m_jle]\nclass FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):\n    DESCRIPTION = \"Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_PASSES = 100\n    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:\n        if len(pred_comparison_values) == 0:\n            return False, False\n        jmp_ins = jmp_blk.tail",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "documentation": {}
    },
    {
        "label": "JMP_OPCODE_HANDLED",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "description": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "peekOfCode": "JMP_OPCODE_HANDLED = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jge, m_jg, m_jl, m_jle]\nclass FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):\n    DESCRIPTION = \"Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_PASSES = 100\n    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:\n        if len(pred_comparison_values) == 0:\n            return False, False\n        jmp_ins = jmp_blk.tail\n        compared_value = jmp_ins.r.nnn.value",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherBlockInfo(object):\n    def __init__(self, blk, father=None):\n        self.blk = blk\n        self.ins = []\n        self.use_list = []\n        self.use_before_def_list = []\n        self.def_list = []\n        self.assume_def_list = []\n        self.comparison_value = None\n        self.compared_mop = None",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherInfo(object):\n    def __init__(self, mba: mbl_array_t):\n        self.mba = mba\n        self.mop_compared = None\n        self.entry_block = None\n        self.comparison_values = []\n        self.dispatcher_internal_blocks = []\n        self.dispatcher_exit_blocks = []\n    def reset(self):\n        self.mop_compared = None",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherCollector(minsn_visitor_t):\n    DISPATCHER_CLASS = GenericDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 2\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 2\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 2\n    def __init__(self):\n        super().__init__()\n        self.dispatcher_list = []\n        self.explored_blk_serials = []\n        self.dispatcher_min_internal_block = self.DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericUnflatteningRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericUnflatteningRule(FlowOptimizationRule):\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    def __init__(self):\n        super().__init__()\n        self.mba = None\n        self.cur_maturity = MMAT_ZERO\n        self.cur_maturity_pass = 0\n        self.last_pass_nb_patch_done = 0\n        self.maturities = self.DEFAULT_UNFLATTENING_MATURITIES\n    def check_if_rule_should_be_used(self, blk: mblock_t) -> bool:",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "GenericDispatcherUnflatteningRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "class GenericDispatcherUnflatteningRule(GenericUnflatteningRule):\n    DISPATCHER_COLLECTOR_CLASS = GenericDispatcherCollector\n    MOP_TRACKER_MAX_NB_BLOCK = 100\n    MOP_TRACKER_MAX_NB_PATH = 100\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 5\n    def __init__(self):\n        super().__init__()\n        self.dispatcher_collector = self.DISPATCHER_COLLECTOR_CLASS()\n        self.dispatcher_list = []",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "description": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nclass GenericDispatcherBlockInfo(object):\n    def __init__(self, blk, father=None):\n        self.blk = blk\n        self.ins = []\n        self.use_list = []\n        self.use_before_def_list = []\n        self.def_list = []\n        self.assume_def_list = []\n        self.comparison_value = None",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.generic",
        "documentation": {}
    },
    {
        "label": "OllvmDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "OllvmDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:\n            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)\n        self.dispatcher_internal_blocks.append(self.entry_block)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "OllvmDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class OllvmDispatcherCollector(GenericDispatcherCollector):\n    DISPATCHER_CLASS = OllvmDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 2\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 3\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 2\nclass Unflattener(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by OLLVM\"\n    DISPATCHER_COLLECTOR_CLASS = OllvmDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "Unflattener",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "class Unflattener(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by OLLVM\"\n    DISPATCHER_COLLECTOR_CLASS = OllvmDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 5",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFLATTENING_JUMP_OPCODES = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jg, m_jge, m_jl, m_jle]\nclass OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "FLATTENING_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "peekOfCode": "FLATTENING_JUMP_OPCODES = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jg, m_jge, m_jl, m_jle]\nclass OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass OllvmDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t) -> bool:\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.entry_block = OllvmDispatcherBlockInfo(blk)\n        self.entry_block.parse()",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener",
        "documentation": {}
    },
    {
        "label": "UnflattenerFakeJump",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "peekOfCode": "class UnflattenerFakeJump(GenericUnflatteningRule):\n    DESCRIPTION = \"Check if a jump is always taken for each father blocks and remove them\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\n    DEFAULT_MAX_PASSES = None\n    def analyze_blk(self, blk: mblock_t) -> int:\n        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:\n            return 0\n        if blk.get_reginsn_qty() != 1:\n            return 0\n        if blk.tail.r.t != mop_n:",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFAKE_LOOP_OPCODES = [m_jz, m_jnz]\nclass UnflattenerFakeJump(GenericUnflatteningRule):\n    DESCRIPTION = \"Check if a jump is always taken for each father blocks and remove them\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\n    DEFAULT_MAX_PASSES = None\n    def analyze_blk(self, blk: mblock_t) -> int:\n        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:\n            return 0\n        if blk.get_reginsn_qty() != 1:",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "documentation": {}
    },
    {
        "label": "FAKE_LOOP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "peekOfCode": "FAKE_LOOP_OPCODES = [m_jz, m_jnz]\nclass UnflattenerFakeJump(GenericUnflatteningRule):\n    DESCRIPTION = \"Check if a jump is always taken for each father blocks and remove them\"\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\n    DEFAULT_MAX_PASSES = None\n    def analyze_blk(self, blk: mblock_t) -> int:\n        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:\n            return 0\n        if blk.get_reginsn_qty() != 1:\n            return 0",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_fake_jump",
        "documentation": {}
    },
    {
        "label": "TigressIndirectDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)\n        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)\n        self.entry_block.parse()",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "TigressIndirectDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)\n        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:\n            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "TigressIndirectDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class TigressIndirectDispatcherCollector(GenericDispatcherCollector):\n    DISPATCHER_CLASS = TigressIndirectDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 0\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 0\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 0\nclass LabelTableInfo(object):\n    def __init__(self, sp_offset, mem_offset, nb_elt, ptr_size=8):\n        self.sp_offset = sp_offset\n        self.mem_offset = mem_offset\n        self.nb_elt = nb_elt",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "LabelTableInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class LabelTableInfo(object):\n    def __init__(self, sp_offset, mem_offset, nb_elt, ptr_size=8):\n        self.sp_offset = sp_offset\n        self.mem_offset = mem_offset\n        self.nb_elt = nb_elt\n        self.ptr_size = ptr_size\n    def update_mop_tracker(self, mba: mbl_array_t, mop_tracker: MopTracker):\n        stack_array_base_address = mba.stkoff_ida2vd(self.sp_offset)\n        for i in range(self.nb_elt):\n            tmp_mop = mop_t()",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "UnflattenerTigressIndirect",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "class UnflattenerTigressIndirect(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"\"\n    DISPATCHER_COLLECTOR_CLASS = TigressIndirectDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_LOCOPT]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 1\n    def __init__(self):\n        super().__init__()\n        self.label_info = None\n        self.goto_table_info = {}",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "FLATTENING_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "peekOfCode": "FLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressIndirectDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared = self._get_comparison_info(blk)\n        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_indirect",
        "documentation": {}
    },
    {
        "label": "TigressSwitchDispatcherBlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)\n        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)\n        self.entry_block.parse()",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "TigressSwitchDispatcherInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)\n        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)\n        self.entry_block.parse()\n        for used_mop in self.entry_block.use_list:\n            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "TigressSwitchDispatcherCollector",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class TigressSwitchDispatcherCollector(GenericDispatcherCollector):\n    DISPATCHER_CLASS = TigressSwitchDispatcherInfo\n    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 0\n    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 4\n    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 4\nclass UnflattenerSwitchCase(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by Tigress with Switch case dispatcher\"\n    DISPATCHER_COLLECTOR_CLASS = TigressSwitchDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_GLBOPT1]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "UnflattenerSwitchCase",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "class UnflattenerSwitchCase(GenericDispatcherUnflatteningRule):\n    DESCRIPTION = \"Remove control flow flattening generated by Tigress with Switch case dispatcher\"\n    DISPATCHER_COLLECTOR_CLASS = TigressSwitchDispatcherCollector\n    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_GLBOPT1]\n    DEFAULT_MAX_DUPLICATION_PASSES = 20\n    DEFAULT_MAX_PASSES = 5",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "unflat_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "unflat_logger = logging.getLogger('D810.unflat')\nFLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "FLATTENING_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "description": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "peekOfCode": "FLATTENING_JUMP_OPCODES = [m_jtbl]\nclass TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):\n    pass\nclass TigressSwitchDispatcherInfo(GenericDispatcherInfo):\n    def explore(self, blk: mblock_t):\n        self.reset()\n        if not self._is_candidate_for_dispatcher_entry_block(blk):\n            return False\n        self.mop_compared, mcases = self._get_comparison_info(blk)\n        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.unflattener_switch_case",
        "documentation": {}
    },
    {
        "label": "UnflatteningException",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class UnflatteningException(Exception):\n    pass\nclass DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "DispatcherUnflatteningException",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotDuplicableFatherException",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:\n        tracker_logger.setLevel(logging.ERROR)\n        emulator_logger.setLevel(logging.ERROR)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "NotResolvableFatherException",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "class NotResolvableFatherException(UnflatteningException):\n    pass\ndef configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:\n        tracker_logger.setLevel(logging.ERROR)\n        emulator_logger.setLevel(logging.ERROR)\n    return [tracker_log_level, emulator_log_level]\ndef restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "configure_mop_tracker_log_verbosity",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def configure_mop_tracker_log_verbosity(verbose=False):\n    tracker_log_level = tracker_logger.getEffectiveLevel()\n    emulator_log_level = emulator_logger.getEffectiveLevel()\n    if not verbose:\n        tracker_logger.setLevel(logging.ERROR)\n        emulator_logger.setLevel(logging.ERROR)\n    return [tracker_log_level, emulator_log_level]\ndef restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):\n    tracker_logger.setLevel(tracker_log_level)\n    emulator_logger.setLevel(emulator_log_level)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "restore_mop_tracker_log_verbosity",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):\n    tracker_logger.setLevel(tracker_log_level)\n    emulator_logger.setLevel(emulator_log_level)\ndef get_all_possibles_values(mop_histories, searched_mop_list, verbose=False):\n    log_levels = configure_mop_tracker_log_verbosity(verbose)\n    mop_cst_values_list = []\n    for mop_history in mop_histories:\n        mop_cst_values_list.append([mop_history.get_mop_constant_value(searched_mop)\n                                    for searched_mop in searched_mop_list])\n    restore_mop_tracker_log_verbosity(*log_levels)",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "get_all_possibles_values",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def get_all_possibles_values(mop_histories, searched_mop_list, verbose=False):\n    log_levels = configure_mop_tracker_log_verbosity(verbose)\n    mop_cst_values_list = []\n    for mop_history in mop_histories:\n        mop_cst_values_list.append([mop_history.get_mop_constant_value(searched_mop)\n                                    for searched_mop in searched_mop_list])\n    restore_mop_tracker_log_verbosity(*log_levels)\n    return mop_cst_values_list\ndef check_if_all_values_are_found(mop_cst_values_list):\n    all_values_are_found = True",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "check_if_all_values_are_found",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "def check_if_all_values_are_found(mop_cst_values_list):\n    all_values_are_found = True\n    for cst_list in mop_cst_values_list:\n        if None in cst_list:\n            all_values_are_found = False\n            break\n    return all_values_are_found",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "tracker_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "tracker_logger = logging.getLogger('D810.tracker')\nemulator_logger = logging.getLogger('D810.emulator')\nclass UnflatteningException(Exception):\n    pass\nclass DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "emulator_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "description": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "peekOfCode": "emulator_logger = logging.getLogger('D810.emulator')\nclass UnflatteningException(Exception):\n    pass\nclass DispatcherUnflatteningException(UnflatteningException):\n    pass\nclass NotDuplicableFatherException(UnflatteningException):\n    pass\nclass NotResolvableFatherException(UnflatteningException):\n    pass",
        "detail": "plugins.d810.d810.optimizers.flow.flattening.utils",
        "documentation": {}
    },
    {
        "label": "JumpOptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "class JumpOptimizationRule(InstructionOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = []\n    LEFT_PATTERN = None\n    RIGHT_PATTERN = None\n    REPLACEMENT_OPCODE = None\n    REPLACEMENT_LEFT_PATTERN = None\n    REPLACEMENT_RIGHT_PATTERN = None\n    FUZZ_PATTERNS = True\n    def __init__(self):\n        super().__init__()",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "JumpFixer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "class JumpFixer(FlowOptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.known_rules = []\n        self.rules = []\n    def register_rule(self, rule: JumpOptimizationRule):\n        self.known_rules.append(rule)\n    def configure(self, kwargs):\n        super().configure(kwargs)\n        self.rules.clear()",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "logger = logging.getLogger(\"D810.branch_fixer\")\noptimizer_logger = logging.getLogger('D810.optimizer')\nclass JumpOptimizationRule(InstructionOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = []\n    LEFT_PATTERN = None\n    RIGHT_PATTERN = None\n    REPLACEMENT_OPCODE = None\n    REPLACEMENT_LEFT_PATTERN = None\n    REPLACEMENT_RIGHT_PATTERN = None\n    FUZZ_PATTERNS = True",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "description": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nclass JumpOptimizationRule(InstructionOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = []\n    LEFT_PATTERN = None\n    RIGHT_PATTERN = None\n    REPLACEMENT_OPCODE = None\n    REPLACEMENT_LEFT_PATTERN = None\n    REPLACEMENT_RIGHT_PATTERN = None\n    FUZZ_PATTERNS = True\n    def __init__(self):",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.handler",
        "documentation": {}
    },
    {
        "label": "JnzRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_neg,\n                           AstNode(m_and,\n                                   AstNode(m_bnot,\n                                           AstLeaf(\"x_0\")),\n                                   AstConstant(\"1\", 1)))\n    RIGHT_PATTERN = AstLeaf(\"x_0\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule2(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_or,\n                           AstNode(m_bnot,\n                                   AstLeaf(\"x_0\")),\n                           AstConstant(\"1\", 1))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        if opcode == m_jnz:",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule3(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_xor,\n                           AstNode(m_xor,\n                                   AstLeaf(\"x_0\"),\n                                   AstConstant(\"c_1\")),\n                           AstNode(m_and,\n                                   AstLeaf(\"x_0\"),\n                                   AstConstant(\"c_2\")))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule4(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_sub,\n                           AstConstant(\"3\", 3),\n                           AstLeaf(\"x_0\"))\n    RIGHT_PATTERN = AstLeaf(\"x_0\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        if opcode == m_jnz:\n            self.jump_replacement_block_serial = self.jump_original_block_serial",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule5(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_xor,\n                           AstNode(m_sub,\n                                   AstConstant(\"3\", 3),\n                                   AstLeaf(\"x_0\")),\n                           AstLeaf(\"x_0\"))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule6",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule6(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_xor,\n                           AstNode(m_bnot,\n                                   AstNode(m_sub,\n                                           AstConstant(\"3\", 3),\n                                           AstLeaf(\"x_0\"))),\n                           AstNode(m_bnot,\n                                   AstLeaf(\"x_0\")))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule7",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule7(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstLeaf(\"x_0\"),\n                           AstConstant(\"c_1\"))\n    RIGHT_PATTERN = AstConstant(\"c_2\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        tmp = left_candidate[\"c_1\"].value & right_candidate[\"c_2\"].value\n        if tmp == right_candidate[\"c_2\"].value:",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JnzRule8",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JnzRule8(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"x_0\"),\n                      AstConstant(\"c_1\"))\n    RIGHT_PATTERN = AstConstant(\"c_2\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        tmp = left_candidate[\"c_1\"].value & right_candidate[\"c_2\"].value\n        if tmp == left_candidate[\"c_1\"].value:",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JbRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JbRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jb]\n    PATTERN = AstNode(m_xdu,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)))\n    RIGHT_PATTERN = AstConstant(\"2\", 2)\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        self.jump_replacement_block_serial = self.jump_original_block_serial",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "JaeRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "description": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "peekOfCode": "class JaeRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jae]\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstConstant(\"c_1\"))\n    RIGHT_PATTERN = AstConstant(\"c_2\")\n    REPLACEMENT_OPCODE = m_goto\n    def check_candidate(self, opcode, left_candidate, right_candidate):\n        if left_candidate[\"c_1\"].value >= right_candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.opaque",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule1(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jge]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstNode(m_or, AstLeaf(\"xdu_x_0\"), AstConstant(\"c_2\")),\n                           AstNode(m_or,\n                                   AstNode(m_xor, AstLeaf(\"x_0\"), AstConstant(\"c_1\")),\n                                   AstNode(m_bnot, AstNode(m_sub, AstLeaf(\"x_0\"), AstConstant(\"c_1\")))))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_jl\n    REPLACEMENT_LEFT_PATTERN = AstLeaf(\"x_0\")",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule2(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jge]\n    LEFT_PATTERN = AstNode(m_or,\n                           AstNode(m_xdu,\n                                   AstNode(m_and,\n                                           AstNode(m_bnot, AstLeaf(\"x_0\")), AstConstant(\"c_1\"))),\n                           AstNode(m_and,\n                                   AstNode(m_sub, AstLeaf('xdu_x_0'), AstConstant('xdu_c_1')),\n                                   AstNode(m_bnot, AstNode(m_xdu, AstNode(m_xor, AstLeaf('xdu1_x_0'), AstConstant('xdu_c_1'))))))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule3(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jge]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstNode(m_sub, AstLeaf('x_0'), AstConstant('c_1')),\n                           AstNode(m_bnot, AstLeaf(\"x_0\")))\n    RIGHT_PATTERN = AstConstant(\"0\", 0)\n    REPLACEMENT_OPCODE = m_jg\n    REPLACEMENT_LEFT_PATTERN = AstLeaf(\"x_0\")\n    REPLACEMENT_RIGHT_PATTERN = AstLeaf(\"c_1\")\n    def check_candidate(self, opcode, left_candidate, right_candidate):",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "CompareConstantRule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "description": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "peekOfCode": "class CompareConstantRule4(JumpOptimizationRule):\n    ORIGINAL_JUMP_OPCODES = [m_jl, m_jge]\n    LEFT_PATTERN = AstNode(m_and,\n                           AstNode(m_or,\n                                   AstNode(m_bnot,\n                                           AstNode(m_sub,\n                                                   AstLeaf('x_0'),\n                                                   AstConstant('c_1'))),\n                                   AstNode(m_xor,\n                                           AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.flow.jumps.tricks",
        "documentation": {}
    },
    {
        "label": "FlowOptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.flow.handler",
        "description": "plugins.d810.d810.optimizers.flow.handler",
        "peekOfCode": "class FlowOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = DEFAULT_FLOW_MATURITIES\n        self.use_whitelist = False\n        self.whitelisted_function_ea_list = []\n        self.use_blacklist = False\n        self.blacklisted_function_ea_list = []\n    def configure(self, kwargs):\n        super().configure(kwargs)",
        "detail": "plugins.d810.d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.flow.handler",
        "description": "plugins.d810.d810.optimizers.flow.handler",
        "peekOfCode": "logger = logging.getLogger('D810.optimizer')\nclass FlowOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = DEFAULT_FLOW_MATURITIES\n        self.use_whitelist = False\n        self.whitelisted_function_ea_list = []\n        self.use_blacklist = False\n        self.blacklisted_function_ea_list = []\n    def configure(self, kwargs):",
        "detail": "plugins.d810.d810.optimizers.flow.handler",
        "documentation": {}
    },
    {
        "label": "InstructionAnalysisRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "description": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "peekOfCode": "class InstructionAnalysisRule(InstructionOptimizationRule):\n    def analyze_instruction(self, blk, ins):\n        raise NotImplementedError\nclass InstructionAnalyzer(InstructionOptimizer):\n    RULE_CLASSES = [InstructionAnalysisRule]\n    def set_maturity(self, maturity: int):\n        self.cur_maturity = maturity\n        for rule in self.rules:\n            rule.set_maturity(self.cur_maturity)\n    def analyze(self, blk: mblock_t, ins: minsn_t):",
        "detail": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "InstructionAnalyzer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "description": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "peekOfCode": "class InstructionAnalyzer(InstructionOptimizer):\n    RULE_CLASSES = [InstructionAnalysisRule]\n    def set_maturity(self, maturity: int):\n        self.cur_maturity = maturity\n        for rule in self.rules:\n            rule.set_maturity(self.cur_maturity)\n    def analyze(self, blk: mblock_t, ins: minsn_t):\n        if blk is not None:\n            self.cur_maturity = blk.mba.maturity\n        if self.cur_maturity not in self.maturities:",
        "detail": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "description": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nclass InstructionAnalysisRule(InstructionOptimizationRule):\n    def analyze_instruction(self, blk, ins):\n        raise NotImplementedError\nclass InstructionAnalyzer(InstructionOptimizer):\n    RULE_CLASSES = [InstructionAnalysisRule]\n    def set_maturity(self, maturity: int):\n        self.cur_maturity = maturity\n        for rule in self.rules:\n            rule.set_maturity(self.cur_maturity)",
        "detail": "plugins.d810.d810.optimizers.instructions.analysis.handler",
        "documentation": {}
    },
    {
        "label": "ExampleGuessingRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.analysis.pattern_guess",
        "description": "plugins.d810.d810.optimizers.instructions.analysis.pattern_guess",
        "peekOfCode": "class ExampleGuessingRule(InstructionAnalysisRule):\n    DESCRIPTION = \"Detect pattern with variable used multiple times and with multiple different opcodes\"\n    def __init__(self):\n        super().__init__()\n        self.maturities = DEFAULT_INSTRUCTION_MATURITIES\n        self.cur_maturity = None\n        self.min_nb_var = 1\n        self.max_nb_var = 3\n        self.min_nb_diff_opcodes = 3\n        self.max_nb_diff_opcodes = -1",
        "detail": "plugins.d810.d810.optimizers.instructions.analysis.pattern_guess",
        "documentation": {}
    },
    {
        "label": "get_possible_patterns",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.analysis.utils",
        "description": "plugins.d810.d810.optimizers.instructions.analysis.utils",
        "peekOfCode": "def get_possible_patterns(ast, min_nb_use=2, ref_ast_info_by_index=None, max_nb_pattern=64):\n    # max_nb_pattern is used to prevent memory explosion when very large patterns are parsed\n    if ast.is_leaf():\n        return [ast]\n    if ref_ast_info_by_index is None:\n        if ast.ast_index not in ast.sub_ast_info_by_index.keys():\n            ast.compute_sub_ast()\n        ref_ast_info_by_index = ast.sub_ast_info_by_index\n    possible_patterns = []\n    if ref_ast_info_by_index[ast.ast_index].number_of_use >= min_nb_use:",
        "detail": "plugins.d810.d810.optimizers.instructions.analysis.utils",
        "documentation": {}
    },
    {
        "label": "ChainSimplification",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class ChainSimplification(object):\n    def __init__(self, opcode):\n        self.opcode = opcode\n        self.formatted_ins = \"\"\n        self.non_cst_mop_list = []\n        self.cst_mop_list = []\n        self._is_instruction_simplified = False\n    def add_mop(self, mop):\n        if (mop.t == mop_d) and (mop.d.opcode == self.opcode):\n            self.add_mop(mop.d.l)",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "ArithmeticChainSimplification",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class ArithmeticChainSimplification(object):\n    def __init__(self):\n        self.formatted_ins = \"\"\n        self.add_non_cst_mop_list = []\n        self.add_cst_mop_list = []\n        self.sub_non_cst_mop_list = []\n        self.sub_cst_mop_list = []\n        self.add_other_cst_list = []\n        self.sub_other_cst_list = []\n        self._is_instruction_simplified = False",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "XorChain",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class XorChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove XOR chains with common terms. E.g. x ^ 4 ^ y ^ 6 ^ 5 ^ x ==> y ^ 7\"\n    def check_and_replace(self, blk, ins):\n        xor_simplifier = ChainSimplification(m_xor)\n        new_ins = xor_simplifier.simplify(ins)\n        return new_ins\nclass AndChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove AND chains with common terms. E.g. x & 4 & y & 6 & 5 & x ==> x & y & 4\"\n    def check_and_replace(self, blk, ins):\n        and_simplifier = ChainSimplification(m_and)",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "AndChain",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class AndChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove AND chains with common terms. E.g. x & 4 & y & 6 & 5 & x ==> x & y & 4\"\n    def check_and_replace(self, blk, ins):\n        and_simplifier = ChainSimplification(m_and)\n        new_ins = and_simplifier.simplify(ins)\n        return new_ins\nclass OrChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove OR chains with common terms. E.g. x | 4 | y | 6 | 5 | x ==> x | y | 7\"\n    def check_and_replace(self, blk, ins):\n        or_simplifier = ChainSimplification(m_or)",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "OrChain",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class OrChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove OR chains with common terms. E.g. x | 4 | y | 6 | 5 | x ==> x | y | 7\"\n    def check_and_replace(self, blk, ins):\n        or_simplifier = ChainSimplification(m_or)\n        new_ins = or_simplifier.simplify(ins)\n        return new_ins\nclass ArithmeticChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove arithmetic chains with common terms. E.g. x + 4 + y - (6 + x - 5) ==>  y + 3\"\n    def check_and_replace(self, blk, ins):\n        arithmetic_simplifier = ArithmeticChainSimplification()",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "ArithmeticChain",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "class ArithmeticChain(ChainSimplificationRule):\n    DESCRIPTION = \"Remove arithmetic chains with common terms. E.g. x + 4 + y - (6 + x - 5) ==>  y + 3\"\n    def check_and_replace(self, blk, ins):\n        arithmetic_simplifier = ArithmeticChainSimplification()\n        new_ins = arithmetic_simplifier.simplify(ins)\n        return new_ins",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "rules_chain_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "description": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "peekOfCode": "rules_chain_logger = logging.getLogger('D810.rules.chain')\nclass ChainSimplification(object):\n    def __init__(self, opcode):\n        self.opcode = opcode\n        self.formatted_ins = \"\"\n        self.non_cst_mop_list = []\n        self.cst_mop_list = []\n        self._is_instruction_simplified = False\n    def add_mop(self, mop):\n        if (mop.t == mop_d) and (mop.d.opcode == self.opcode):",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.chain_rules",
        "documentation": {}
    },
    {
        "label": "ChainSimplificationRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.handler",
        "description": "plugins.d810.d810.optimizers.instructions.chain.handler",
        "peekOfCode": "class ChainSimplificationRule(InstructionOptimizationRule):\n    pass\nclass ChainOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [ChainSimplificationRule]",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.handler",
        "documentation": {}
    },
    {
        "label": "ChainOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.chain.handler",
        "description": "plugins.d810.d810.optimizers.instructions.chain.handler",
        "peekOfCode": "class ChainOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [ChainSimplificationRule]",
        "detail": "plugins.d810.d810.optimizers.instructions.chain.handler",
        "documentation": {}
    },
    {
        "label": "EarlyRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.early.handler",
        "description": "plugins.d810.d810.optimizers.instructions.early.handler",
        "peekOfCode": "class EarlyRule(GenericPatternRule):\n    pass\nclass EarlyOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [EarlyRule]",
        "detail": "plugins.d810.d810.optimizers.instructions.early.handler",
        "documentation": {}
    },
    {
        "label": "EarlyOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.early.handler",
        "description": "plugins.d810.d810.optimizers.instructions.early.handler",
        "peekOfCode": "class EarlyOptimizer(InstructionOptimizer):\n    RULE_CLASSES = [EarlyRule]",
        "detail": "plugins.d810.d810.optimizers.instructions.early.handler",
        "documentation": {}
    },
    {
        "label": "SetGlobalVariablesToZero",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.early.mem_read",
        "description": "plugins.d810.d810.optimizers.instructions.early.mem_read",
        "peekOfCode": "class SetGlobalVariablesToZero(EarlyRule):\n    DESCRIPTION = \"This rule can be used to patch memory read\"\n    PATTERN = AstNode(m_mov, AstLeaf(\"ro_dword\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def __init__(self):\n        super().__init__()\n        self.ro_dword_min_ea = None\n        self.ro_dword_max_ea = None\n    def configure(self, kwargs):\n        super().configure(kwargs)",
        "detail": "plugins.d810.d810.optimizers.instructions.early.mem_read",
        "documentation": {}
    },
    {
        "label": "SetGlobalVariablesToZeroIfDetectedReadOnly",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.early.mem_read",
        "description": "plugins.d810.d810.optimizers.instructions.early.mem_read",
        "peekOfCode": "class SetGlobalVariablesToZeroIfDetectedReadOnly(EarlyRule):\n    DESCRIPTION = \"WARNING: Use it only if you know what you are doing as it may patch data not related to obfuscation\"\n    PATTERN = AstNode(m_mov, AstLeaf(\"ro_dword\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def __init__(self):\n        super().__init__()\n        # If we optimized too early (in MMAT_GENERATED), we may replace something like\n        # 'mov     &($dword_10020CC8).4, eoff.4' by 'mov     #0.4, eoff.4'\n        # and this will lead to incorrect decompilation where MEMORY[0] is used\n        # Thus, we explicitly specify the MMAT_PREOPTIMIZED maturity.",
        "detail": "plugins.d810.d810.optimizers.instructions.early.mem_read",
        "documentation": {}
    },
    {
        "label": "ReplaceMovHigh",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.experimental",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.experimental",
        "peekOfCode": "class ReplaceMovHigh(PatternMatchingRule):\n    PATTERN = AstNode(m_mov,\n                      AstConstant('c_0'))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstConstant(\"new_c_0\"), AstNode(m_and, AstLeaf(\"new_reg\"), AstConstant(\"mask\")))\n    def check_candidate(self, candidate):\n        # IDA does not do constant propagation for pattern such as:\n        # mov     #0x65A4.2, r6.2\n        # mov     #0x210F.2, r6^2.2\n        # jz      r0.4, r6.4\n        # Thus, we try to detect mov to r6^2 and replace by (or #0x210F0000.4, r6.4 & 0x0000ffff.4, r6.4",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.experimental",
        "documentation": {}
    },
    {
        "label": "PatternMatchingRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class PatternMatchingRule(GenericPatternRule):\n    PATTERN = None\n    PATTERNS = None\n    FUZZ_PATTERN = True\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.fuzz_pattern = self.FUZZ_PATTERN\n    def configure(self, fuzz_pattern=None, **kwargs):\n        super().configure(kwargs)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "RulePatternInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class RulePatternInfo(object):\n    def __init__(self, rule, pattern):\n        self.rule = rule\n        self.pattern = pattern\ndef signature_generator(ref_sig):\n    for i, x in enumerate(ref_sig):\n        if x not in [\"N\", \"L\"]:\n            for sig_suffix in signature_generator(ref_sig[i + 1:]):\n                yield ref_sig[:i] + [\"L\"] + sig_suffix\n    yield ref_sig",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternStorage",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class PatternStorage(object):\n    # The PatternStorage object is used to store patterns associated to rules\n    # A PatternStorage contains a dictionary (next_layer_patterns) where:\n    #  - keys are the signature of a pattern at a specific depth (i.e. the opcodes, the variable and constant)\n    #  - values are PatternStorage object for the next depth\n    # Additionally, it stores the rule objects which are resolved for the PatternStorage depth\n    def __init__(self, depth=1):\n        self.depth = depth\n        self.next_layer_patterns = {}\n        self.rule_resolved = []",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "PatternOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "class PatternOptimizer(InstructionOptimizer):\n    # The main idea of PatternOptimizer is to generate/store all possible patterns associated to all known rules in a $\n    # dictionary-like object (PatternStorage) when the plugin is loaded.\n    # => it means that we generate a very large number of patterns\n    #\n    # At runtime, we transform the microcode instruction in a list of keys that we search in the PatternStorage object\n    # to speed up the checks\n    # => we don't want to test all patterns, so we use the PatternStorage object to (quickly) get the patterns\n    # which have the same shape as the microcode instruction\n    RULE_CLASSES = [PatternMatchingRule]",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "signature_generator",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def signature_generator(ref_sig):\n    for i, x in enumerate(ref_sig):\n        if x not in [\"N\", \"L\"]:\n            for sig_suffix in signature_generator(ref_sig[i + 1:]):\n                yield ref_sig[:i] + [\"L\"] + sig_suffix\n    yield ref_sig\nclass PatternStorage(object):\n    # The PatternStorage object is used to store patterns associated to rules\n    # A PatternStorage contains a dictionary (next_layer_patterns) where:\n    #  - keys are the signature of a pattern at a specific depth (i.e. the opcodes, the variable and constant)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "rec_get_all_binary_subtree_representation",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def rec_get_all_binary_subtree_representation(elt_list):\n    if len(elt_list) == 1:\n        return elt_list\n    if len(elt_list) == 2:\n        return [elt_list]\n    tmp_res = []\n    for i in range(1, len(elt_list)):\n        left_list = rec_get_all_binary_subtree_representation(elt_list[:i])\n        right_list = rec_get_all_binary_subtree_representation(elt_list[i:])\n        for l in left_list:",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "rec_get_all_binary_tree_representation",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def rec_get_all_binary_tree_representation(elt_list):\n    if len(elt_list) <= 1:\n        return elt_list\n    tmp = list(itertools.permutations(elt_list))\n    tmp2 = []\n    for perm_tmp in tmp:\n        tmp2 += rec_get_all_binary_subtree_representation(perm_tmp)\n    return tmp2\ndef get_all_binary_tree_representation(all_elt):\n    tmp = rec_get_all_binary_tree_representation(all_elt)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_all_binary_tree_representation",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_all_binary_tree_representation(all_elt):\n    tmp = rec_get_all_binary_tree_representation(all_elt)\n    return tmp\ndef generate_ast(opcode, leafs):\n    if isinstance(leafs, AstLeaf):\n        return leafs\n    if isinstance(leafs, AstNode):\n        return leafs\n    if len(leafs) == 1:\n        return leafs[0]",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "generate_ast",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def generate_ast(opcode, leafs):\n    if isinstance(leafs, AstLeaf):\n        return leafs\n    if isinstance(leafs, AstNode):\n        return leafs\n    if len(leafs) == 1:\n        return leafs[0]\n    if len(leafs) == 2:\n        return AstNode(opcode, generate_ast(opcode, leafs[0]), generate_ast(opcode, leafs[1]))\ndef get_addition_operands(ast_node):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_addition_operands",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_addition_operands(ast_node):\n    if not isinstance(ast_node, AstNode):\n        return [ast_node]\n    if ast_node.opcode == m_add:\n        return get_addition_operands(ast_node.left) + get_addition_operands(ast_node.right)\n    elif ast_node.opcode == m_sub:\n        tmp = get_addition_operands(ast_node.left)\n        for aaa in get_addition_operands(ast_node.right):\n            tmp.append(AstNode(m_neg, aaa))\n        return tmp",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_opcode_operands",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_opcode_operands(ref_opcode, ast_node):\n    if not isinstance(ast_node, AstNode):\n        return [ast_node]\n    if ast_node.opcode == ref_opcode:\n        return get_opcode_operands(ref_opcode, ast_node.left) + get_opcode_operands(ref_opcode, ast_node.right)\n    else:\n        return [ast_node]\ndef get_similar_opcode_operands(ast_node):\n    if ast_node.opcode in [m_add, m_sub]:\n        add_elts = get_addition_operands(ast_node)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_similar_opcode_operands",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_similar_opcode_operands(ast_node):\n    if ast_node.opcode in [m_add, m_sub]:\n        add_elts = get_addition_operands(ast_node)\n        all_add_ordering = get_all_binary_tree_representation(add_elts)\n        ast_res = []\n        for leaf_ordering in all_add_ordering:\n            ast_res.append(generate_ast(m_add, leaf_ordering))\n        return ast_res\n    elif ast_node.opcode in [m_xor, m_or, m_and, m_mul]:\n        same_elts = get_opcode_operands(ast_node.opcode, ast_node)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "get_ast_variations_with_add_sub",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def get_ast_variations_with_add_sub(opcode, left, right):\n    possible_ast = [AstNode(opcode, left, right)]\n    if opcode == m_add:\n        if isinstance(left, AstNode) and isinstance(right, AstNode):\n            if (left.opcode == m_neg) and (right.opcode == m_neg):\n                possible_ast.append(AstNode(m_neg, AstNode(m_add, left.left, right.left)))\n        if isinstance(right, AstNode) and (right.opcode == m_neg):\n            possible_ast.append(AstNode(m_sub, left, right.left))\n    return possible_ast\ndef ast_generator(ast_node, excluded_opcodes=None):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "ast_generator",
        "kind": 2,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "def ast_generator(ast_node, excluded_opcodes=None):\n    if not isinstance(ast_node, AstNode):\n        return [ast_node]\n    res_ast = []\n    excluded_opcodes = excluded_opcodes if excluded_opcodes is not None else []\n    if ast_node.opcode not in excluded_opcodes:\n        if ast_node.opcode in [m_add, m_sub]:\n            similar_ast_list = get_similar_opcode_operands(ast_node)\n            for similar_ast in similar_ast_list:\n                sub_ast_left_list = ast_generator(similar_ast.left, excluded_opcodes=[m_add, m_sub])",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\npattern_search_logger = logging.getLogger('D810.pattern_search')\nclass PatternMatchingRule(GenericPatternRule):\n    PATTERN = None\n    PATTERNS = None\n    FUZZ_PATTERN = True\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.fuzz_pattern = self.FUZZ_PATTERN",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "pattern_search_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "peekOfCode": "pattern_search_logger = logging.getLogger('D810.pattern_search')\nclass PatternMatchingRule(GenericPatternRule):\n    PATTERN = None\n    PATTERNS = None\n    FUZZ_PATTERN = True\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.fuzz_pattern = self.FUZZ_PATTERN\n    def configure(self, fuzz_pattern=None, **kwargs):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.handler",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_sub,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_1\")),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Add_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Add_HackersDelightRule_4(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_HackersDelightRule_5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_HackersDelightRule_5(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstNode(m_or,\n                                              AstLeaf(\"x_0\"),\n                                              AstLeaf(\"x_1\")),\n                                      AstLeaf(\"x_2\"))),\n                      AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_SpecialConstantRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_SpecialConstantRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_2\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_SpecialConstantRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_SpecialConstantRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"val_ff\", 0xff)),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_SpecialConstantRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_SpecialConstantRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_2\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf('x_1'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_mul,\n                              AstConstant(\"val_fe\"),\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "Add_OllvmRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class Add_OllvmRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_mul,\n                              AstConstant(\"val_fe\"),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "AddXor_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class AddXor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"bnot_x_1\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "AddXor_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "peekOfCode": "class AddXor_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_bnot,\n                                      AstNode(m_and,\n                                              AstLeaf(\"bnot_x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_add",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot, AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass And_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass And_HackersDelightRule_4(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))\nclass And_OllvmRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_OllvmRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_OllvmRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_OllvmRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_OllvmRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_OllvmRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_OllvmRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):\n        return equal_bnot_mop(candidate[\"x_1\"].mop, candidate[\"bnot_x_1\"].mop)\nclass And_FactorRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf('x_0'),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))\nclass AndBnot_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_HackersDelightRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_3(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_bnot, AstLeaf(\"x_1\")))\nclass AndBnot_FactorRule_4(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndBnot_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndBnot_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_xor,\n                              AstLeaf('x_1'),\n                              AstLeaf('x_0')),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('bnot_x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndOr_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndOr_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_2\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_1\"),\n                              AstLeaf(\"x_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_or,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndXor_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndXor_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_2\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_1\"),\n                              AstLeaf(\"x_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "And1_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class And1_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_mul, AstLeaf(\"x_0\"), AstLeaf(\"x_0\")),\n                      AstConstant(\"3\", 3))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstLeaf(\"x_0\"),\n                                  AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_1\", 1, candidate.size)\n        return True",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "AndGetUpperBits_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "peekOfCode": "class AndGetUpperBits_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_mul,\n                      AstConstant(\"c_1\"),\n                      AstNode(m_and,\n                              AstNode(m_shr,\n                                      AstLeaf('x_0'),\n                                      AstConstant(\"c_2\")),\n                              AstConstant(\"c_3\")))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstConstant(\"c_res\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_and",
        "documentation": {}
    },
    {
        "label": "Bnot_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_neg,\n                              AstLeaf(\"x_0\")),\n                      AstConstant(\"1\", 1))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\nclass Bnot_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstNode(m_or,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_1\"))\nclass Bnot_MbaRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\nclass Bnot_FactorRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\nclass Bnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstConstant(\"minus_1\"),\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_0\"))\n    def check_candidate(self, candidate):\n        if candidate[\"minus_1\"].value != SUB_TABLE[candidate[\"minus_1\"].size] - 1:\n            return False\n        return True\nclass Bnot_FactorRule_3(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_bnot, AstLeaf('x_0')),\n                      AstNode(m_bnot, AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstLeaf(\"x_1\"))\nclass BnotXor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"bnot_x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('bnot_x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_Rule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')),\n                      AstNode(m_or,\n                              AstLeaf('bnot_x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotXor_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotXor_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\nclass BnotAnd_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\nclass BnotAnd_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_or,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAnd_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAnd_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"bnot_x_0\"),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_and, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\n    def check_candidate(self, candidate):\n        if not equal_bnot_mop(candidate[\"x_0\"].mop, candidate[\"bnot_x_0\"].mop):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotOr_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotOr_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_bnot,\n                                  AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))\nclass BnotAdd_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "BnotAdd_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class BnotAdd_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"bnot_x_1\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "Bnot_XorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "peekOfCode": "class Bnot_XorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_bnot, AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_bnot",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_xor,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_1_1\")),\n                              AstConstant(\"c_2_1\")),\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_0\")),\n                      AstNode(m_mul,\n                              AstConstant(\"c_1\"),\n                              AstNode(m_sub,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_2\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_sub,\n                              AstConstant(\"c_1\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstLeaf(\"x_0\"),\n                                  AstNode(m_add,\n                                          AstLeaf(\"x_1\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule5(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_1\"),\n                              AstConstant(\"c_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule6",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule6(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_2\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule7",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule7(PatternMatchingRule):\n    PATTERN = AstNode(m_shr,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_shr,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_2\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule8",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule8(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_res\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule9",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule9(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstConstant(\"c_and\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule10",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule10(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule11",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule11(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstConstant(\"c_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_2\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule12",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule12(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstConstant(\"c_1\"),\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule13",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule13(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstConstant(\"cst_1\"),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule14",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule14(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstNode(m_or,\n                                          AstLeaf(\"x_0\"),\n                                          AstLeaf(\"lnot_c_1\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule15",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule15(PatternMatchingRule):\n    PATTERN = AstNode(m_shr,\n                      AstNode(m_shr,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_shr, AstLeaf(\"x_0\"), AstConstant(\"c_res\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"c_res\", candidate[\"c_1\"].value + candidate[\"c_2\"].value, candidate[\"c_1\"].size)\n        return True",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule16",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule16(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstLeaf(\"x_0\"),\n                                  AstLeaf(\"bnot_c_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"bnot_c_1\", candidate[\"c_1\"].value ^ AND_TABLE[candidate[\"c_1\"].size],",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule17",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule17(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_and,\n                                  AstNode(m_bnot, AstLeaf(\"x_0\")),\n                                  AstLeaf(\"bnot_c_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"bnot_c_1\", candidate[\"c_1\"].value ^ AND_TABLE[candidate[\"c_1\"].size],",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule18",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule18(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_bnot, AstLeaf(\"x_0\")),\n                                  AstLeaf(\"bnot_c_1\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"bnot_c_1\", candidate[\"c_1\"].value ^ AND_TABLE[candidate[\"c_1\"].size],",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule19",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule19(PatternMatchingRule):\n    PATTERN = AstNode(m_sar,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_and, AstNode(m_shr, AstLeaf(\"x_0\"), AstConstant(\"c_2\")), AstConstant(\"c_res\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"c_res\", candidate[\"c_1\"].value >> candidate[\"c_2\"].value,\n                                    candidate[\"c_1\"].size)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule20",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule20(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf('bnot_x_0'),\n                              AstConstant('c_and_1')),\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_and_2')),\n                              AstConstant('c_xor')))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule21",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule21(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_and')),\n                              AstConstant('c_xor_1')),\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "CstSimplificationRule22",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "peekOfCode": "class CstSimplificationRule22(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_and')),\n                              AstConstant('c_xor_1')),\n                      AstNode(m_xor,\n                              AstNode(m_and,\n                                      AstLeaf('bnot_x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_cst",
        "documentation": {}
    },
    {
        "label": "GetIdentRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "peekOfCode": "class GetIdentRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"x_0\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "documentation": {}
    },
    {
        "label": "GetIdentRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "peekOfCode": "class GetIdentRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"x_0\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "documentation": {}
    },
    {
        "label": "GetIdentRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "peekOfCode": "class GetIdentRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"x_0\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mov",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1')),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_mul,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_1')),\n                              AstLeaf('x_0')),\n                      AstNode(m_mul,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_1')),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('c_1'))),\n                      AstNode(m_mul,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_MbaRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_MbaRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\")),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_mul,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstConstant(\"2\", 2),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_add,\n                                      AstLeaf(\"x_1\"),\n                                      AstNode(m_or,\n                                              AstLeaf(\"x_0\"),\n                                              AstLeaf(\"bnot_x_1\")))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Mul_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "peekOfCode": "class Mul_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_neg,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_mul,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_mul",
        "documentation": {}
    },
    {
        "label": "Neg_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class Neg_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstConstant(\"1\", 1))\n    REPLACEMENT_PATTERN = AstNode(m_neg, AstLeaf(\"x_0\"))\nclass Neg_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "Neg_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class Neg_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_bnot,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_neg, AstLeaf(\"x_0\"))\nclass NegAdd_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegAdd_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegAdd_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegAdd_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegAdd_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_1\"),\n                                      AstLeaf(\"x_2\"))),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegAdd_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegAdd_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstConstant('val_fe'),\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegOr_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegOr_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_or,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegXor_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegXor_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "NegXor_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "peekOfCode": "class NegXor_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_mul,\n                              AstConstant('2', 2),\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_neg",
        "documentation": {}
    },
    {
        "label": "Or_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):\n        if not equal_bnot_mop(candidate[\"x_1\"].mop, candidate[\"bnot_x_1\"].mop):\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_HackersDelightRule_2_variant_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_HackersDelightRule_2_variant_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_HackersDelightRule_2_variant_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_neg, AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_MbaRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_MbaRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_MbaRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_add,\n                              AstNode(m_add,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1')),\n                              AstConstant('1', 1)),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf('x_1'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_MbaRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_MbaRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf('x_0'),\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstNode(m_bnot,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_FactorRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_1\"),\n                                      AstLeaf(\"x_2\"))),\n                      AstNode(m_xor,\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"bnot_x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_OllvmRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_OllvmRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_xor,\n                                      AstLeaf(\"bnot_x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):\n        if not equal_bnot_mop(candidate[\"x_0\"].mop,  candidate[\"bnot_x_0\"].mop):\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Or_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf('bnot_x_0'),\n                                      AstLeaf('bnot_x_1'))),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "Or_Rule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class Or_Rule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass OrBnot_FactorRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_bnot,\n                                          AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_and,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\")),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass OrBnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstNode(m_bnot, AstLeaf(\"x_1\")))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "OrBnot_FactorRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "peekOfCode": "class OrBnot_FactorRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf(\"x_0\"), AstNode(m_bnot, AstLeaf(\"x_1\")))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_or",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value | candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value & candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_add,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2)),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2))),\n                      AstConstant(\"0\", 0))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule4(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_xor,\n                              AstNode(m_sub,\n                                      AstConstant(\"cst_1\"),\n                                      AstLeaf(\"x_0\")),\n                              AstLeaf(\"x_0\")),\n                      AstConstant(\"0\", 0))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule5(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_neg,\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),\n                                      AstConstant(\"1\", 1))),\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule6",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule6(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_add,\n                              AstNode(m_add,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_1\")),\n                              AstNode(m_and,\n                                      AstNode(m_add,\n                                              AstLeaf(\"x_0\"),\n                                              AstConstant(\"c_2\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetnzRule8",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetnzRule8(PatternMatchingRule):\n    PATTERN = AstNode(m_setnz,\n                      AstNode(m_xor,\n                              AstNode(m_bnot,\n                                      AstNode(m_sub,\n                                              AstConstant(\"3\", 3),\n                                              AstLeaf(\"x_0\"))),\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_0\"))),\n                      AstConstant(\"0\", 0))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetzRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetzRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value | candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetzRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetzRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        if (candidate[\"c_1\"].value & candidate[\"c_2\"].value) == candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetzRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetzRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_add,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2)),\n                              AstNode(m_xor,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"2\", 2))),\n                      AstConstant(\"0\", 0))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredSetbRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredSetbRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_setb,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"c_1\")),\n                      AstConstant(\"c_2\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        if candidate[\"c_1\"].value >= candidate[\"c_2\"].value:\n            return False",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOdd1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOdd1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_mul,\n                              AstLeaf('x_0'),\n                              AstNode(m_sub,\n                                      AstLeaf('x_0'),\n                                      AstConstant('1', 1))),\n                      AstConstant('1', 1))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant('val_0'))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOdd2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOdd2(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_mul,\n                              AstLeaf('x_0'),\n                              AstNode(m_add,\n                                      AstLeaf('x_0'),\n                                      AstConstant('1', 1))),\n                      AstConstant('1', 1))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant('val_0'))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_0\", 0, candidate.size)\n        return True\n# Pred0Rule2: (xdu(x_0 & 1) == 2) ==> 0",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule2(PatternMatchingRule):\n    PATTERN = AstNode(m_setz,\n                      AstNode(m_xdu,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstConstant(\"c_1\", 1))),\n                      AstConstant(\"c_2\", 2))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_0\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_0\", 0, candidate.size)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule3(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_0\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_0\", 0, candidate.size)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule4(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_0\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Pred0Rule5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class Pred0Rule5(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_xor,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_0\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_ff\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_ff\", AND_TABLE[candidate.size], candidate.size)\n        return True\n# Pred1Rule2: (x_0 ^ x_1) | (~x_0 | x_1) ==> 0xff",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_or,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_ff\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf(\"val_ff\"))\n    def check_candidate(self, candidate):\n        candidate.add_constant_leaf(\"val_ff\", AND_TABLE[candidate.size], candidate.size)",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredFFRule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredFFRule4(PatternMatchingRule):\n    DESCRIPTION = \"(x_0 | x_1) | (~(x_0 & x_1))  ==>  0xff\"\n    PATTERN = AstNode(m_or,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOr2_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOr2_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_and,\n                      AstNode(m_bnot,\n                              AstNode(m_mul,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_0'))),\n                      AstConstant('3', 3))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_and,\n                                          AstNode(m_bnot, AstLeaf('x_0')),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "PredOr1_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "peekOfCode": "class PredOr1_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstLeaf('x_0'),\n                      AstNode(m_add,\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstConstant('1', 1)),\n                              AstConstant('1', 1)))\n    REPLACEMENT_PATTERN = AstNode(m_or,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_predicates",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_add,\n                              AstNode(m_bnot,\n                                      AstLeaf(\"x_1\")),\n                              AstConstant(\"1\", 1)))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Sub_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"bnot_x_1\"))),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstNode(m_neg,\n                                      AstLeaf('x_0')),\n                              AstConstant('1', 1)),\n                      AstNode(m_mul,\n                              AstConstant('c_minus_2'),\n                              AstLeaf('x_0')))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstConstant(\"val_1\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_bnot,\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf(\"x_0\"), AstConstant(\"1\", 1))\nclass Sub1Add_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1Add_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1Add_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_xor,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1And_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1And_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_and,\n                                          AstLeaf(\"x_0\"),\n                                          AstLeaf(\"x_1\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1Or_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1Or_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_sub,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Sub1And1_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "peekOfCode": "class Sub1And1_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstNode(m_bnot,\n                                      AstLeaf('x_0')),\n                              AstConstant(\"1\", 1)),\n                      AstLeaf('x_0'))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_and,\n                                          AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_sub",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Xor_HackersDelightRule_2(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))),\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_sub,\n                              AstNode(m_sub,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1')),\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_or,\n                                              AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_HackersDelightRule_5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_HackersDelightRule_5(PatternMatchingRule):\n    FUZZ_PATTERN = False\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_sub,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_and,\n                                              AstLeaf(\"x_0\"),\n                                              AstLeaf(\"x_1\"))),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf('x_0'),\n                      AstNode(m_sub,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_and,\n                                              AstLeaf('x_1'),\n                                              AstNode(m_bnot,\n                                                      AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_MbaRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_MbaRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf('x_0'),\n                      AstNode(m_sub,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstNode(m_and,\n                                              AstLeaf('x_0'),\n                                              AstLeaf('x_1'))),\n                              AstLeaf('x_1')))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_MbaRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_MbaRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf('x_0'),\n                      AstNode(m_mul,\n                              AstConstant('2', 2),\n                              AstNode(m_and,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_FactorRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_FactorRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_FactorRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_FactorRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('bnot_x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('bnot_x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\n    def check_candidate(self, candidate):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_FactorRule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_FactorRule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_xor,\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf(\"x_0\"), AstLeaf(\"x_1\"))\nclass Xor_SpecialConstantRule_1(PatternMatchingRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_SpecialConstantRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_SpecialConstantRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_sub,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_and,\n                                      AstNode(m_bnot,\n                                              AstLeaf(\"x_0\")),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_SpecialConstantRule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_SpecialConstantRule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstLeaf('x_0'),\n                      AstNode(m_add,\n                              AstNode(m_mul,\n                                      AstConstant('0xfe'),\n                                      AstNode(m_and,\n                                              AstLeaf('x_0'),\n                                              AstLeaf('x_1'))),\n                              AstLeaf('x_1')))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor1_MbaRule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor1_MbaRule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_bnot,\n                              AstLeaf('x_0')),\n                      AstNode(m_or,\n                              AstNode(m_mul,\n                                      AstConstant('2', 2),\n                                      AstLeaf('x_0')),\n                              AstConstant('2', 2)))\n    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstConstant(\"val_1\"))",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_bnot,\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_2(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_2')),\n                              AstNode(m_xor,\n                                      AstLeaf('x_1'),\n                                      AstLeaf('bnot_x2'))),\n                      AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_3(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstNode(m_xor,\n                                      AstLeaf('x_0'),\n                                      AstLeaf('x_2')),\n                              AstNode(m_xor,\n                                      AstLeaf('x_1'),\n                                      AstLeaf('x_2'))),\n                      AstNode(m_and,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_4(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"bnot_x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstLeaf('x_0'),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_Rule_4_WithXdu",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_Rule_4_WithXdu(PatternMatchingRule):\n    PATTERN = AstNode(m_or,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstConstant(\"bnot_c_1\")),\n                      AstNode(m_and,\n                              AstNode(m_bnot, AstLeaf(\"x_0\")),\n                              AstConstant(\"c_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_xor,\n                                  AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "XorAlmost_Rule_1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class XorAlmost_Rule_1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstNode(m_or,\n                                      AstLeaf(\"x_0\"),\n                                      AstNode(m_sub,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "Xor_NestedStuff",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "peekOfCode": "class Xor_NestedStuff(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstNode(m_add,\n                                      AstLeaf('x_9'),\n                                      AstLeaf('x_10')),\n                              AstLeaf(\"x_11\")),\n                      AstNode(m_add,\n                              AstLeaf(\"x_14\"),\n                              AstNode(m_mul,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.rewrite_xor",
        "documentation": {}
    },
    {
        "label": "WeirdRule1",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule1(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstLeaf(\"x_0\"),\n                      AstNode(m_or,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstNode(m_or,\n                                          AstLeaf(\"x_0\"),\n                                          AstNode(m_bnot, AstLeaf(\"x_1\"))),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule2",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule2(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_bnot, AstLeaf(\"x_1\"))))\n    REPLACEMENT_PATTERN = AstNode(m_add,\n                                  AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule3",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule3(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstNode(m_bnot, AstLeaf(\"x_1\"))),\n                      AstNode(m_mul,\n                              AstConstant(\"2\", 2),\n                              AstLeaf(\"x_0\")))\n    REPLACEMENT_PATTERN = AstNode(m_neg,\n                                  AstNode(m_add,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule4",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule4(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"bnot_x_1\")),\n                      AstNode(m_and,\n                              AstLeaf(\"x_0\"),\n                              AstLeaf(\"x_1\")))\n    REPLACEMENT_PATTERN = AstNode(m_sub,\n                                  AstNode(m_xor,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule5",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule5(PatternMatchingRule):\n    PATTERN = AstNode(m_sub,\n                      AstNode(m_add,\n                              AstNode(m_or,\n                                      AstLeaf(\"bnot_x_0\"),\n                                      AstNode(m_and,\n                                              AstLeaf(\"bnot_x_1\"),\n                                              AstLeaf(\"x_2\"))),\n                              AstNode(m_add,\n                                      AstLeaf(\"x_0\"),",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "WeirdRule6",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "description": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "peekOfCode": "class WeirdRule6(PatternMatchingRule):\n    PATTERN = AstNode(m_add,\n                      AstNode(m_or,\n                              AstLeaf('x_0'),\n                              AstLeaf('x_1')),\n                      AstNode(m_and,\n                              AstLeaf('x_0'),\n                              AstNode(m_bnot,\n                                      AstLeaf('x_1'))))\n    REPLACEMENT_PATTERN = AstNode(m_add,",
        "detail": "plugins.d810.d810.optimizers.instructions.pattern_matching.weird",
        "documentation": {}
    },
    {
        "label": "Z3ConstantOptimization",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.cst",
        "description": "plugins.d810.d810.optimizers.instructions.z3.cst",
        "peekOfCode": "class Z3ConstantOptimization(Z3Rule):\n    DESCRIPTION = \"Detect and replace obfuscated constants\"\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"c_res\"))\n    def __init__(self):\n        super().__init__()\n        self.min_nb_opcode = 3\n        self.min_nb_constant = 3\n    def configure(self, kwargs):\n        super().configure(kwargs)\n        if \"min_nb_opcode\" in kwargs.keys():",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.cst",
        "documentation": {}
    },
    {
        "label": "Z3Rule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.handler",
        "description": "plugins.d810.d810.optimizers.instructions.z3.handler",
        "peekOfCode": "class Z3Rule(GenericPatternRule):\n    pass\nclass Z3Optimizer(InstructionOptimizer):\n    RULE_CLASSES = [Z3Rule]",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "Z3Optimizer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.handler",
        "description": "plugins.d810.d810.optimizers.instructions.z3.handler",
        "peekOfCode": "class Z3Optimizer(InstructionOptimizer):\n    RULE_CLASSES = [Z3Rule]",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.handler",
        "documentation": {}
    },
    {
        "label": "Z3setzRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3setzRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_setz check is always True or False\"\n    PATTERN = AstNode(m_setz,\n                      AstLeaf(\"x_0\"),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        if z3_check_mop_equality(candidate[\"x_0\"].mop, candidate[\"x_1\"].mop):\n            candidate.add_constant_leaf(\"val_res\", 1, candidate.size)\n            return True",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "Z3setnzRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3setnzRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_setnz check is always True or False\"\n    PATTERN = AstNode(m_setnz,\n                      AstLeaf(\"x_0\"),\n                      AstLeaf(\"x_1\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        if z3_check_mop_equality(candidate[\"x_0\"].mop, candidate[\"x_1\"].mop):\n            candidate.add_constant_leaf(\"val_res\", 0, candidate.size)\n            return True",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "Z3lnotRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3lnotRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_lnot check is always True or False\"\n    PATTERN = AstNode(m_lnot,\n                      AstLeaf(\"x_0\"))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        val_0_mop = mop_t()\n        val_0_mop.make_number(0, candidate[\"x_0\"].size)\n        if z3_check_mop_equality(candidate[\"x_0\"].mop, val_0_mop):\n            candidate.add_constant_leaf(\"val_res\", 1, candidate.size)",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "Z3SmodRuleGeneric",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "description": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "peekOfCode": "class Z3SmodRuleGeneric(Z3Rule):\n    DESCRIPTION = \"Check with Z3 if a m_setz check is always True or False\"\n    PATTERN = AstNode(m_smod,\n                      AstLeaf(\"x_0\"),\n                      AstConstant(\"2\", 2))\n    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant(\"val_res\"))\n    def check_candidate(self, candidate):\n        cst_0_mop = mop_t()\n        cst_0_mop.make_number(0, candidate.size)\n        if z3_check_mop_equality(candidate.mop, cst_0_mop):",
        "detail": "plugins.d810.d810.optimizers.instructions.z3.predicates",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.handler",
        "description": "plugins.d810.d810.optimizers.instructions.handler",
        "peekOfCode": "class InstructionOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = []\n    def check_and_replace(self, blk, ins):\n        return None\nclass GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None\n    PATTERNS = None\n    REPLACEMENT_PATTERN = None",
        "detail": "plugins.d810.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "GenericPatternRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.handler",
        "description": "plugins.d810.d810.optimizers.instructions.handler",
        "peekOfCode": "class GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None\n    PATTERNS = None\n    REPLACEMENT_PATTERN = None\n    def __init__(self):\n        super().__init__()\n        self.pattern_candidates = [self.PATTERN]\n        if self.PATTERNS is not None:\n            self.pattern_candidates += self.PATTERNS\n    def check_candidate(self, candidate: AstNode):",
        "detail": "plugins.d810.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizer",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.instructions.handler",
        "description": "plugins.d810.d810.optimizers.instructions.handler",
        "peekOfCode": "class InstructionOptimizer(object):\n    RULE_CLASSES = []\n    NAME = None\n    def __init__(self, maturities: List[int], log_dir=None):\n        self.rules = set()\n        self.rules_usage_info = {}\n        self.maturities = maturities\n        self.log_dir = log_dir\n        self.cur_maturity = MMAT_PREOPTIMIZED\n    def add_rule(self, rule: InstructionOptimizationRule):",
        "detail": "plugins.d810.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "d810_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.instructions.handler",
        "description": "plugins.d810.d810.optimizers.instructions.handler",
        "peekOfCode": "d810_logger = logging.getLogger('D810')\noptimizer_logger = logging.getLogger('D810.optimizer')\nclass InstructionOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = []\n    def check_and_replace(self, blk, ins):\n        return None\nclass GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None",
        "detail": "plugins.d810.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.instructions.handler",
        "description": "plugins.d810.d810.optimizers.instructions.handler",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nclass InstructionOptimizationRule(OptimizationRule):\n    def __init__(self):\n        super().__init__()\n        self.maturities = []\n    def check_and_replace(self, blk, ins):\n        return None\nclass GenericPatternRule(InstructionOptimizationRule):\n    PATTERN = None\n    PATTERNS = None",
        "detail": "plugins.d810.d810.optimizers.instructions.handler",
        "documentation": {}
    },
    {
        "label": "OptimizationRule",
        "kind": 6,
        "importPath": "plugins.d810.d810.optimizers.handler",
        "description": "plugins.d810.d810.optimizers.handler",
        "peekOfCode": "class OptimizationRule(object):\n    NAME = None\n    DESCRIPTION = None\n    def __init__(self):\n        self.maturities = []\n        self.config = {}\n        self.log_dir = None\n    def set_log_dir(self, log_dir):\n        self.log_dir = log_dir\n    def configure(self, kwargs):",
        "detail": "plugins.d810.d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INSTRUCTION_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.handler",
        "description": "plugins.d810.d810.optimizers.handler",
        "peekOfCode": "DEFAULT_INSTRUCTION_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_FLOW_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\nclass OptimizationRule(object):\n    NAME = None\n    DESCRIPTION = None\n    def __init__(self):\n        self.maturities = []\n        self.config = {}\n        self.log_dir = None\n    def set_log_dir(self, log_dir):",
        "detail": "plugins.d810.d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FLOW_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.optimizers.handler",
        "description": "plugins.d810.d810.optimizers.handler",
        "peekOfCode": "DEFAULT_FLOW_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]\nclass OptimizationRule(object):\n    NAME = None\n    DESCRIPTION = None\n    def __init__(self):\n        self.maturities = []\n        self.config = {}\n        self.log_dir = None\n    def set_log_dir(self, log_dir):\n        self.log_dir = log_dir",
        "detail": "plugins.d810.d810.optimizers.handler",
        "documentation": {}
    },
    {
        "label": "AstInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "class AstInfo(object):\n    def __init__(self, ast: Union[AstNode, AstLeaf], number_of_use: int):\n        self.ast = ast\n        self.number_of_use = number_of_use\n    def __str__(self):\n        return \"{0} used {1} times: {2}\".format(self.ast, self.number_of_use, format_mop_t(self.ast.mop))\nclass AstNode(dict):\n    def __init__(self, opcode, left=None, right=None, dst=None):\n        super(dict, self).__init__()\n        self.opcode = opcode",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "AstNode",
        "kind": 6,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "class AstNode(dict):\n    def __init__(self, opcode, left=None, right=None, dst=None):\n        super(dict, self).__init__()\n        self.opcode = opcode\n        self.left = left\n        self.right = right\n        self.dst = dst\n        self.dst_mop = None\n        self.opcodes = []\n        self.mop = None",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "AstLeaf",
        "kind": 6,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "class AstLeaf(object):\n    def __init__(self, name):\n        self.name = name\n        self.ast_index = None\n        self.mop = None\n        self.z3_var = None\n        self.z3_var_name = None\n        self.dest_size = None\n        self.ea = None\n        self.sub_ast_info_by_index = {}",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "AstConstant",
        "kind": 6,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "class AstConstant(AstLeaf):\n    def __init__(self, name, expected_value=None, expected_size=None):\n        super().__init__(name)\n        self.expected_value = expected_value\n        self.expected_size = expected_size\n    @property\n    def value(self):\n        return self.mop.nnn.value\n    def is_constant(self):\n        # An AstConstant is always constant, so return True",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "check_and_add_to_list",
        "kind": 2,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "def check_and_add_to_list(new_ast: Union[AstNode, AstLeaf], known_ast_list: List[Union[AstNode, AstLeaf]]):\n    is_new_ast_known = False\n    for existing_elt in known_ast_list:\n        if equal_mops_ignore_size(new_ast.mop, existing_elt.mop):\n            new_ast.ast_index = existing_elt.ast_index\n            is_new_ast_known = True\n            break\n    if not is_new_ast_known:\n        ast_index = len(known_ast_list)\n        new_ast.ast_index = ast_index",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "mop_to_ast_internal",
        "kind": 2,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "def mop_to_ast_internal(mop: mop_t, ast_list: List[Union[AstNode, AstLeaf]]) -> Union[None, AstNode, AstLeaf]:\n    if mop is None:\n        return None\n    if mop.t != mop_d or (mop.d.opcode not in MBA_RELATED_OPCODES):\n        tree = AstLeaf(format_mop_t(mop))\n        tree.mop = mop\n        dest_size = mop.size if mop.t != mop_d else mop.d.d.size\n        tree.dest_size = dest_size\n    else:\n        left_ast = mop_to_ast_internal(mop.d.l, ast_list)",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "mop_to_ast",
        "kind": 2,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "def mop_to_ast(mop: mop_t) -> Union[None, AstNode, AstLeaf]:\n    mop_ast = mop_to_ast_internal(mop, [])\n    mop_ast.compute_sub_ast()\n    return mop_ast\ndef minsn_to_ast(instruction: minsn_t) -> Union[None, AstNode, AstLeaf]:\n    try:\n        if instruction.opcode in MINSN_TO_AST_FORBIDDEN_OPCODES:\n            # To avoid error 50278\n            return None\n        ins_mop = mop_t()",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "minsn_to_ast",
        "kind": 2,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "def minsn_to_ast(instruction: minsn_t) -> Union[None, AstNode, AstLeaf]:\n    try:\n        if instruction.opcode in MINSN_TO_AST_FORBIDDEN_OPCODES:\n            # To avoid error 50278\n            return None\n        ins_mop = mop_t()\n        ins_mop.create_from_insn(instruction)\n        if instruction.opcode == m_mov:\n            tmp = AstNode(m_mov, mop_to_ast(ins_mop))\n            tmp.mop = ins_mop",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.ast",
        "description": "plugins.d810.d810.ast",
        "peekOfCode": "logger = logging.getLogger('D810')\ndef check_and_add_to_list(new_ast: Union[AstNode, AstLeaf], known_ast_list: List[Union[AstNode, AstLeaf]]):\n    is_new_ast_known = False\n    for existing_elt in known_ast_list:\n        if equal_mops_ignore_size(new_ast.mop, existing_elt.mop):\n            new_ast.ast_index = existing_elt.ast_index\n            is_new_ast_known = True\n            break\n    if not is_new_ast_known:\n        ast_index = len(known_ast_list)",
        "detail": "plugins.d810.d810.ast",
        "documentation": {}
    },
    {
        "label": "log_block_info",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def log_block_info(blk: mblock_t, logger_func=helper_logger.info):\n    if blk is None:\n        logger_func(\"Block is None\")\n        return\n    vp = block_printer()\n    blk._print(vp)\n    logger_func(\"Block {0} with successors {1} and predecessors {2}:\\n{3}\"\n                .format(blk.serial, [x for x in blk.succset], [x for x in blk.predset], vp.get_block_mc()))\ndef insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):\n    if blk.tail is not None:",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "insert_goto_instruction",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):\n    if blk.tail is not None:\n        goto_ins = minsn_t(blk.tail)\n    else:\n        goto_ins = minsn_t(blk.start)\n    if nop_previous_instruction:\n        blk.make_nop(blk.tail)\n    blk.insert_into_block(goto_ins, blk.tail)\n    # We nop instruction before setting it to goto to avoid error 52123\n    blk.make_nop(blk.tail)",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_call_block_successor",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def change_1way_call_block_successor(call_blk: mblock_t, call_blk_successor_serial: int) -> bool:\n    if call_blk.nsucc() != 1:\n        return False\n    mba = call_blk.mba\n    previous_call_blk_successor_serial = call_blk.succset[0]\n    previous_call_blk_successor = mba.get_mblock(previous_call_blk_successor_serial)\n    nop_blk = insert_nop_blk(call_blk)\n    insert_goto_instruction(nop_blk, call_blk_successor_serial, nop_previous_instruction=True)\n    is_ok = change_1way_block_successor(nop_blk, call_blk_successor_serial)\n    if not is_ok:",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_1way_block_successor",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def change_1way_block_successor(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 1:\n        return False\n    mba: mbl_array_t = blk.mba\n    previous_blk_successor_serial = blk.succset[0]\n    previous_blk_successor = mba.get_mblock(previous_blk_successor_serial)\n    if blk.tail is None:\n        # We add a goto instruction\n        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)\n    elif blk.tail.opcode == m_goto:",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_0way_block_successor",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def change_0way_block_successor(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 0:\n        return False\n    mba = blk.mba\n    if blk.tail.opcode == m_ijmp:\n        # We replace ijmp instruction with goto instruction\n        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)\n    else:\n        # We add a goto instruction\n        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_2way_block_conditional_successor",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def change_2way_block_conditional_successor(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 2:\n        return False\n    mba = blk.mba\n    previous_blk_conditional_successor_serial = blk.tail.d.b\n    previous_blk_conditional_successor = mba.get_mblock(previous_blk_conditional_successor_serial)\n    blk.tail.d = mop_t()\n    blk.tail.d.make_blkref(blk_successor_serial)\n    # Bookkeeping\n    blk.succset._del(previous_blk_conditional_successor_serial)",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "update_blk_successor",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def update_blk_successor(blk: mblock_t, old_successor_serial: int, new_successor_serial: int) -> int:\n    if blk.nsucc() == 1:\n        change_1way_block_successor(blk, new_successor_serial)\n    elif blk.nsucc() == 2:\n        if old_successor_serial == blk.serial + 1:\n            helper_logger.info(\"Can't update direct block successor: {0} - {1} - {2}\"\n                               .format(blk.serial, old_successor_serial, new_successor_serial))\n            return 0\n        else:\n            change_2way_block_conditional_successor(blk, new_successor_serial)",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "make_2way_block_goto",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def make_2way_block_goto(blk: mblock_t, blk_successor_serial: int) -> bool:\n    if blk.nsucc() != 2:\n        return False\n    mba = blk.mba\n    previous_blk_successor_serials = [x for x in blk.succset]\n    previous_blk_successors = [mba.get_mblock(x) for x in previous_blk_successor_serials]\n    insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)\n    # Update block properties\n    blk.type = BLT_1WAY\n    blk.flags |= MBL_GOTO",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "create_block",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def create_block(blk: mblock_t, blk_ins: List[minsn_t], is_0_way: bool = False) -> mblock_t:\n    mba = blk.mba\n    new_blk = insert_nop_blk(blk)\n    for ins in blk_ins:\n        tmp_ins = minsn_t(ins)\n        tmp_ins.setaddr(new_blk.tail.ea)\n        new_blk.insert_into_block(tmp_ins, new_blk.tail)\n    if is_0_way:\n        new_blk.type = BLT_0WAY\n        # Bookkeeping",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "update_block_successors",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def update_block_successors(blk: mblock_t, blk_succ_serial_list: List[int]):\n    mba = blk.mba\n    if len(blk_succ_serial_list) == 0:\n        blk.type = BLT_0WAY\n    elif len(blk_succ_serial_list) == 1:\n        blk.type = BLT_1WAY\n    elif len(blk_succ_serial_list) == 2:\n        blk.type = BLT_2WAY\n    else:\n        raise",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "insert_nop_blk",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def insert_nop_blk(blk: mblock_t) -> mblock_t:\n    mba = blk.mba\n    nop_block = mba.copy_block(blk, blk.serial + 1)\n    cur_ins = nop_block.head\n    while cur_ins is not None:\n        nop_block.make_nop(cur_ins)\n        cur_ins = cur_ins.next\n    nop_block.type = BLT_1WAY\n    # We might have clone a block with multiple or no successor, thus we need to clean all\n    prev_successor_serials = [x for x in nop_block.succset]",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_last_block_is_goto",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def ensure_last_block_is_goto(mba: mbl_array_t) -> int:\n    last_blk = mba.get_mblock(mba.qty - 2)\n    if last_blk.nsucc() == 1:\n        change_1way_block_successor(last_blk, last_blk.succset[0])\n        return 1\n    elif last_blk.nsucc() == 0:\n        return 0\n    else:\n        raise ControlFlowException(\"Last block {0} is not one way (not supported yet)\".format(last_blk.serial))\ndef duplicate_block(block_to_duplicate: mblock_t) -> Tuple[mblock_t, mblock_t]:",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "duplicate_block",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def duplicate_block(block_to_duplicate: mblock_t) -> Tuple[mblock_t, mblock_t]:\n    mba = block_to_duplicate.mba\n    duplicated_blk = mba.copy_block(block_to_duplicate, mba.qty - 1)\n    helper_logger.debug(\"  Duplicated {0} -> {1}\".format(block_to_duplicate.serial, duplicated_blk.serial))\n    duplicated_blk_default = None\n    if (block_to_duplicate.tail is not None) and is_mcode_jcond(block_to_duplicate.tail.opcode):\n        block_to_duplicate_default_successor = mba.get_mblock(block_to_duplicate.serial + 1)\n        duplicated_blk_default = insert_nop_blk(duplicated_blk)\n        change_1way_block_successor(duplicated_blk_default, block_to_duplicate.serial + 1)\n        helper_logger.debug(\"  {0} is conditional, so created a default child {1} for {2} which goto {3}\"",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "change_block_address",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def change_block_address(block: mblock_t, new_ea: int):\n    # Can be used to fix error 50357\n    mb_curr = block.head\n    while mb_curr:\n        mb_curr.ea = new_ea\n        mb_curr = mb_curr.next\ndef is_conditional_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode in CONDITIONAL_JUMP_OPCODES\n    return False",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "is_conditional_jump",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def is_conditional_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode in CONDITIONAL_JUMP_OPCODES\n    return False\ndef is_indirect_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode == m_ijmp\n    return False\ndef get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "is_indirect_jump",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def is_indirect_jump(blk: mblock_t) -> bool:\n    if (blk is not None) and (blk.tail is not None):\n        return blk.tail.opcode == m_ijmp\n    return False\ndef get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):\n        blk = mba.get_mblock(i)\n        if blk.start == address:\n            blk_serial_list.append(i)",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "get_block_serials_by_address",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):\n        blk = mba.get_mblock(i)\n        if blk.start == address:\n            blk_serial_list.append(i)\n    return blk_serial_list\ndef get_block_serials_by_address_range(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "get_block_serials_by_address_range",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def get_block_serials_by_address_range(mba: mbl_array_t, address: int) -> List[int]:\n    blk_serial_list = []\n    for i in range(mba.qty):\n        blk = mba.get_mblock(i)\n        if blk.start <= address <= blk.end:\n            blk_serial_list.append(i)\n    return blk_serial_list\ndef mba_remove_simple_goto_blocks(mba: mbl_array_t) -> int:\n    last_block_index = mba.qty - 1\n    nb_change = 0",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "mba_remove_simple_goto_blocks",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def mba_remove_simple_goto_blocks(mba: mbl_array_t) -> int:\n    last_block_index = mba.qty - 1\n    nb_change = 0\n    for goto_blk_serial in range(last_block_index):\n        goto_blk: mblock_t = mba.get_mblock(goto_blk_serial)\n        if goto_blk.is_simple_goto_block():\n            goto_blk_dst_serial = goto_blk.tail.l.b\n            goto_blk_preset = [x for x in goto_blk.predset]\n            for father_serial in goto_blk_preset:\n                father_blk: mblock_t = mba.get_mblock(father_serial)",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "mba_deep_cleaning",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def mba_deep_cleaning(mba: mbl_array_t, call_mba_combine_block=True) -> int:\n    if mba.maturity < MMAT_CALLS:\n        # Doing this optimization before MMAT_CALLS may create blocks with call instruction (not last instruction)\n        # IDA does like that and will raise a 50864 error\n        return 0\n    if call_mba_combine_block:\n        # Ideally we want IDA to simplify the graph for us with combine_blocks\n        # However, We observe several crashes when this option is activated\n        # (especially when it is used during  O-LLVM unflattening)\n        # TODO: investigate the root cause of this issue",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "ensure_child_has_an_unconditional_father",
        "kind": 2,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "def ensure_child_has_an_unconditional_father(father_block: mblock_t, child_block: mblock_t) -> int:\n    if father_block is None:\n        return 0\n    mba = father_block.mba\n    if father_block.nsucc() == 1:\n        return 0\n    if father_block.tail.d.b == child_block.serial:\n        helper_logger.debug(\"Father {0} is a conditional jump to child {1}, creating a new father\"\n                            .format(father_block.serial, child_block.serial))\n        new_father_block = insert_nop_blk(mba.get_mblock(mba.qty - 2))",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "helper_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.cfg_utils",
        "description": "plugins.d810.d810.cfg_utils",
        "peekOfCode": "helper_logger = logging.getLogger('D810.helper')\ndef log_block_info(blk: mblock_t, logger_func=helper_logger.info):\n    if blk is None:\n        logger_func(\"Block is None\")\n        return\n    vp = block_printer()\n    blk._print(vp)\n    logger_func(\"Block {0} with successors {1} and predecessors {2}:\\n{3}\"\n                .format(blk.serial, [x for x in blk.succset], [x for x in blk.predset], vp.get_block_mc()))\ndef insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):",
        "detail": "plugins.d810.d810.cfg_utils",
        "documentation": {}
    },
    {
        "label": "MicroCodeInterpreter",
        "kind": 6,
        "importPath": "plugins.d810.d810.emulator",
        "description": "plugins.d810.d810.emulator",
        "peekOfCode": "class MicroCodeInterpreter(object):\n    def __init__(self, global_environment=None):\n        self.global_environment = MicroCodeEnvironment() if global_environment is None else global_environment\n    def _eval_instruction_and_update_environment(self, blk: mblock_t, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:\n        environment.set_cur_flow(blk, ins)\n        res = self._eval_instruction(ins, environment)\n        if res is not None:\n            if (ins.d is not None) and ins.d.t != mop_z:\n                environment.assign(ins.d, res, auto_define=True)\n        return res",
        "detail": "plugins.d810.d810.emulator",
        "documentation": {}
    },
    {
        "label": "MopMapping",
        "kind": 6,
        "importPath": "plugins.d810.d810.emulator",
        "description": "plugins.d810.d810.emulator",
        "peekOfCode": "class MopMapping(object):\n    def __init__(self):\n        self.mops = []\n        self.mops_values = []\n    def __setitem__(self, mop: mop_t, mop_value: int):\n        mop_index = get_mop_index(mop, self.mops)\n        mop_value &= AND_TABLE[mop.size]\n        if mop_index != -1:\n            self.mops_values[mop_index] = mop_value\n            return",
        "detail": "plugins.d810.d810.emulator",
        "documentation": {}
    },
    {
        "label": "MicroCodeEnvironment",
        "kind": 6,
        "importPath": "plugins.d810.d810.emulator",
        "description": "plugins.d810.d810.emulator",
        "peekOfCode": "class MicroCodeEnvironment(object):\n    def __init__(self, parent: Union[None, MicroCodeEnvironment] = None):\n        self.parent = parent\n        self.mop_r_record = MopMapping()\n        self.mop_S_record = MopMapping()\n        self.cur_blk = None\n        self.cur_ins = None\n        self.next_blk = None\n        self.next_ins = None\n    def items(self):",
        "detail": "plugins.d810.d810.emulator",
        "documentation": {}
    },
    {
        "label": "emulator_log",
        "kind": 5,
        "importPath": "plugins.d810.d810.emulator",
        "description": "plugins.d810.d810.emulator",
        "peekOfCode": "emulator_log = logging.getLogger('D810.emulator')\nclass MicroCodeInterpreter(object):\n    def __init__(self, global_environment=None):\n        self.global_environment = MicroCodeEnvironment() if global_environment is None else global_environment\n    def _eval_instruction_and_update_environment(self, blk: mblock_t, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:\n        environment.set_cur_flow(blk, ins)\n        res = self._eval_instruction(ins, environment)\n        if res is not None:\n            if (ins.d is not None) and ins.d.t != mop_z:\n                environment.assign(ins.d, res, auto_define=True)",
        "detail": "plugins.d810.d810.emulator",
        "documentation": {}
    },
    {
        "label": "D810Exception",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class D810Exception(Exception):\n    pass\nclass AstException(D810Exception):\n    pass\nclass AstEvaluationException(AstException):\n    pass\nclass D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "AstException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class AstException(D810Exception):\n    pass\nclass AstEvaluationException(AstException):\n    pass\nclass D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "AstEvaluationException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class AstEvaluationException(AstException):\n    pass\nclass D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "D810Z3Exception",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class D810Z3Exception(D810Exception):\n    pass\nclass ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "ControlFlowException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class ControlFlowException(D810Exception):\n    pass\nclass EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea\n        self.dest_serial_list = dest_serial_list\nclass UnresolvedMopException(EmulationException):",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class EmulationException(D810Exception):\n    pass\nclass EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea\n        self.dest_serial_list = dest_serial_list\nclass UnresolvedMopException(EmulationException):\n    pass\nclass WritableMemoryReadException(EmulationException):",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "EmulationIndirectJumpException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class EmulationIndirectJumpException(EmulationException):\n    def __init__(self, message, dest_ea, dest_serial_list):\n        super().__init__(message)\n        self.dest_ea = dest_ea\n        self.dest_serial_list = dest_serial_list\nclass UnresolvedMopException(EmulationException):\n    pass\nclass WritableMemoryReadException(EmulationException):\n    pass\nclass UnsupportedInstructionException(EmulationException):",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "UnresolvedMopException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class UnresolvedMopException(EmulationException):\n    pass\nclass WritableMemoryReadException(EmulationException):\n    pass\nclass UnsupportedInstructionException(EmulationException):\n    pass",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "WritableMemoryReadException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class WritableMemoryReadException(EmulationException):\n    pass\nclass UnsupportedInstructionException(EmulationException):\n    pass",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "UnsupportedInstructionException",
        "kind": 6,
        "importPath": "plugins.d810.d810.errors",
        "description": "plugins.d810.d810.errors",
        "peekOfCode": "class UnsupportedInstructionException(EmulationException):\n    pass",
        "detail": "plugins.d810.d810.errors",
        "documentation": {}
    },
    {
        "label": "mba_printer",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "class mba_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)\n        self.mc = []\n    def get_mc(self):\n        return self.mc\n    def _print(self, indent, line):\n        self.mc.append(\"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in line])+\"\\n\")\n        return 1\nclass block_printer(vd_printer_t):",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "block_printer",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "class block_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)\n        self.block_ins = []\n    def get_block_mc(self):\n        return \"\\n\".join(self.block_ins)\n    def _print(self, indent, line):\n        self.block_ins.append(\"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in line]))\n        return 1\ndef write_mc_to_file(mba: mbl_array_t, filename: str, mba_flags: int = 0) -> bool:",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_minsn_t",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def format_minsn_t(ins: minsn_t) -> str:\n    if ins is None:\n        return \"minsn_t is None\"\n    tmp = ins._print()\n    pp_ins = \"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in tmp])\n    return pp_ins\ndef format_mop_t(mop_in: mop_t) -> str:\n    if mop_in is None:\n        return \"mop_t is None\"\n    if mop_in.t > 15:",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_t",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def format_mop_t(mop_in: mop_t) -> str:\n    if mop_in is None:\n        return \"mop_t is None\"\n    if mop_in.t > 15:\n        # To avoid error 50581\n        return \"Unknown mop type {0}\".format(mop_in.t)\n    return mop_in.dstr()\ndef format_mop_list(mop_list: List[mop_t]) -> str:\n    return \", \".join([format_mop_t(x) for x in mop_list])\ndef maturity_to_string(maturity_level: int) -> str:",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "format_mop_list",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def format_mop_list(mop_list: List[mop_t]) -> str:\n    return \", \".join([format_mop_t(x) for x in mop_list])\ndef maturity_to_string(maturity_level: int) -> str:\n    return MATURITY_TO_STRING_DICT.get(maturity_level, \"Unknown maturity: {0}\".format(maturity_level))\ndef string_to_maturity(maturity_string: str) -> int:\n    return STRING_TO_MATURITY_DICT.get(maturity_string)\ndef mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "maturity_to_string",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def maturity_to_string(maturity_level: int) -> str:\n    return MATURITY_TO_STRING_DICT.get(maturity_level, \"Unknown maturity: {0}\".format(maturity_level))\ndef string_to_maturity(maturity_string: str) -> int:\n    return STRING_TO_MATURITY_DICT.get(maturity_string)\ndef mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "string_to_maturity",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def string_to_maturity(maturity_string: str) -> int:\n    return STRING_TO_MATURITY_DICT.get(maturity_string)\ndef mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:\n        return \"Unknown opcode: {0}\".format(opcode)\nclass mba_printer(vd_printer_t):",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "mop_type_to_string",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def mop_type_to_string(mop_type: int) -> str:\n    return MOP_TYPE_TO_STRING_DICT.get(mop_type, \"Unknown mop type: {0}\".format(mop_type))\ndef opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:\n        return \"Unknown opcode: {0}\".format(opcode)\nclass mba_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "opcode_to_string",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def opcode_to_string(opcode) -> str:\n    try:\n        return OPCODES_INFO[opcode][\"name\"]\n    except KeyError:\n        return \"Unknown opcode: {0}\".format(opcode)\nclass mba_printer(vd_printer_t):\n    def __init__(self):\n        vd_printer_t.__init__(self)\n        self.mc = []\n    def get_mc(self):",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "write_mc_to_file",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def write_mc_to_file(mba: mbl_array_t, filename: str, mba_flags: int = 0) -> bool:\n    if not mba:\n        return False\n    vp = mba_printer()\n    mba.set_mba_flags(mba_flags)\n    mba._print(vp)\n    with open(filename, \"w\") as f:\n        f.writelines(vp.get_mc())\n    return True\ndef dump_microcode_for_debug(mba: mbl_array_t, log_dir_path: str, name: str = \"\"):",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "dump_microcode_for_debug",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "def dump_microcode_for_debug(mba: mbl_array_t, log_dir_path: str, name: str = \"\"):\n    mc_filename = os.path.join(log_dir_path, \"{0:x}_maturity_{1}_{2}.log\".format(mba.entry_ea, mba.maturity, name))\n    logger.info(\"Dumping microcode in file {0}...\".format(mc_filename))\n    write_mc_to_file(mba, mc_filename)",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_formatters",
        "description": "plugins.d810.d810.hexrays_formatters",
        "peekOfCode": "logger = logging.getLogger('D810.helper')\ndef format_minsn_t(ins: minsn_t) -> str:\n    if ins is None:\n        return \"minsn_t is None\"\n    tmp = ins._print()\n    pp_ins = \"\".join([c if 0x20 <= ord(c) <= 0x7e else \"\" for c in tmp])\n    return pp_ins\ndef format_mop_t(mop_in: mop_t) -> str:\n    if mop_in is None:\n        return \"mop_t is None\"",
        "detail": "plugins.d810.d810.hexrays_formatters",
        "documentation": {}
    },
    {
        "label": "equal_bnot_cst",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:\n        mop_size = lo.size\n    return lo.nnn.value ^ ro.nnn.value == AND_TABLE[mop_size]\ndef equal_bnot_mop(lo: mop_t, ro: mop_t, test_two_sides=True) -> bool:\n    if lo.t == mop_n:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_bnot_mop",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def equal_bnot_mop(lo: mop_t, ro: mop_t, test_two_sides=True) -> bool:\n    if lo.t == mop_n:\n        return equal_bnot_cst(lo, ro)\n    # We first check for a bnot operand\n    if (lo.t == mop_d) and lo.d.opcode == m_bnot:\n        if equal_mops_ignore_size(lo.d.l, ro):\n            return True\n    # Otherwise Hexrays may have optimized using ~(-x) = x - 1\n    if (lo.t == mop_d) and lo.d.opcode == m_neg:\n        if (ro.t == mop_d) and ro.d.opcode == m_sub:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_ignore_msb_cst",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def equal_ignore_msb_cst(lo: mop_t, ro: mop_t) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    mask = AND_TABLE[lo.size] ^ MSB_TABLE[lo.size]\n    return lo.nnn.value & mask == ro.nnn.value & mask\ndef equal_mops_bypass_xdu(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):\n        return False",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_bypass_xdu",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def equal_mops_bypass_xdu(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):\n        return False\n    if (lo.t == mop_d) and (lo.d.opcode == m_xdu):\n        return equal_mops_bypass_xdu(lo.d.l, ro)\n    if (ro.t == mop_d) and (ro.d.opcode == m_xdu):\n        return equal_mops_bypass_xdu(lo, ro.d.l)\n    return equal_mops_ignore_size(lo, ro)\ndef equal_mops_ignore_size(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "equal_mops_ignore_size",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def equal_mops_ignore_size(lo: mop_t, ro: mop_t) -> bool:\n    if (lo is None) or (ro is None):\n        return False\n    if lo.t != ro.t:\n        return False\n    if lo.t == mop_z:\n        return True\n    elif lo.t == mop_fn:\n        return lo.fpc == ro.fpc\n    elif lo.t == mop_n:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "is_check_mop",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def is_check_mop(lo: mop_t) -> bool:\n    if lo.t != mop_d:\n        return False\n    if lo.d.opcode in CHECK_OPCODES:\n        return True\n    if lo.d.opcode in [m_xds, m_xdu]:\n        return is_check_mop(lo.d.l)\n    return False\ndef extract_num_mop(ins: minsn_t) -> Tuple[mop_t, mop_t]:\n    num_mop = None",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "extract_num_mop",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def extract_num_mop(ins: minsn_t) -> Tuple[mop_t, mop_t]:\n    num_mop = None\n    other_mop = None\n    if ins.l.t == mop_n:\n        num_mop = ins.l\n        other_mop = ins.r\n    if ins.r.t == mop_n:\n        num_mop = ins.r\n        other_mop = ins.l\n    return [num_mop, other_mop]",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_ins_mop_size_are_ok",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def check_ins_mop_size_are_ok(ins: minsn_t) -> bool:\n    \"\"\"\n    This function can be used to check if a created instruction has consistent mop size\n    Use it to avoid Hex-Rays decompilation errors when replacing instructions\n    :param ins:\n    :return:\n    \"\"\"\n    ins_dest_size = ins.d.size\n    if ins.opcode in [m_stx, m_ldx]:\n        if ins.r.t == mop_d:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_mop_is_result_of",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def check_mop_is_result_of(lo: mop_t, mc) -> bool:\n    if lo.t != mop_d:\n        return False\n    return lo.d.opcode == mc\ndef extract_by_opcode_type(ins: minsn_t, mc) -> Tuple[mop_t, mop_t]:\n    if check_mop_is_result_of(ins.l, mc):\n        return [ins.l, ins.r]\n    if check_mop_is_result_of(ins.r, mc):\n        return [ins.r, ins.l]\n    return [None, None]",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "extract_by_opcode_type",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def extract_by_opcode_type(ins: minsn_t, mc) -> Tuple[mop_t, mop_t]:\n    if check_mop_is_result_of(ins.l, mc):\n        return [ins.l, ins.r]\n    if check_mop_is_result_of(ins.r, mc):\n        return [ins.r, ins.l]\n    return [None, None]\ndef check_ins_have_same_operands(ins1: minsn_t, ins2: minsn_t, ignore_order=False) -> bool:\n    if equal_mops_ignore_size(ins1.l, ins2.l) and equal_mops_ignore_size(ins1.r, ins2.r):\n        return True\n    if not ignore_order:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "check_ins_have_same_operands",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def check_ins_have_same_operands(ins1: minsn_t, ins2: minsn_t, ignore_order=False) -> bool:\n    if equal_mops_ignore_size(ins1.l, ins2.l) and equal_mops_ignore_size(ins1.r, ins2.r):\n        return True\n    if not ignore_order:\n        return False\n    return equal_mops_ignore_size(ins1.l, ins2.r) and equal_mops_ignore_size(ins1.r, ins2.l)\ndef get_mop_index(searched_mop: mop_t, mop_list) -> int:\n    for i, test_mop in enumerate(mop_list):\n        if equal_mops_ignore_size(searched_mop, test_mop):\n            return i",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_mop_index",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def get_mop_index(searched_mop: mop_t, mop_list) -> int:\n    for i, test_mop in enumerate(mop_list):\n        if equal_mops_ignore_size(searched_mop, test_mop):\n            return i\n    return -1\ndef append_mop_if_not_in_list(mop: mop_t, mop_list) -> bool:\n    mop_index = get_mop_index(mop, mop_list)\n    if mop_index == -1:\n        mop_list.append(mop)\n        return True",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "append_mop_if_not_in_list",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def append_mop_if_not_in_list(mop: mop_t, mop_list) -> bool:\n    mop_index = get_mop_index(mop, mop_list)\n    if mop_index == -1:\n        mop_list.append(mop)\n        return True\n    return False\ndef get_blk_index(searched_blk: mblock_t, blk_list: List[mblock_t]) -> int:\n    blk_serial_list = [blk.serial for blk in blk_list]\n    try:\n        return blk_serial_list.index(searched_blk.serial)",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "get_blk_index",
        "kind": 2,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "def get_blk_index(searched_blk: mblock_t, blk_list: List[mblock_t]) -> int:\n    blk_serial_list = [blk.serial for blk in blk_list]\n    try:\n        return blk_serial_list.index(searched_blk.serial)\n    except ValueError:\n        return -1",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "OPCODES_INFO",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "OPCODES_INFO = {\n    m_nop: {\"name\": \"nop\", \"nb_operands\": 0, \"is_commutative\": True},\n    m_stx: {\"name\": \"stx\", \"nb_operands\": 2, \"is_commutative\": False},\n    m_ldx: {\"name\": \"ldx\", \"nb_operands\": 2, \"is_commutative\": False},\n    m_ldc: {\"name\": \"ldc\", \"nb_operands\": 1, \"is_commutative\": False},\n    m_mov: {\"name\": \"mov\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"\"},\n    m_neg: {\"name\": \"neg\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"-\"},\n    m_lnot: {\"name\": \"lnot\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"!\"},\n    m_bnot: {\"name\": \"bnot\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"~\"},\n    m_xds: {\"name\": \"xds\", \"nb_operands\": 1, \"is_commutative\": False, \"symbol\": \"xds\"},",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MATURITY_TO_STRING_DICT",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "MATURITY_TO_STRING_DICT = {\n    MMAT_ZERO: \"MMAT_ZERO\",\n    MMAT_GENERATED: \"MMAT_GENERATED\",\n    MMAT_PREOPTIMIZED: \"MMAT_PREOPTIMIZED\",\n    MMAT_LOCOPT: \"MMAT_LOCOPT\",\n    MMAT_CALLS: \"MMAT_CALLS\",\n    MMAT_GLBOPT1: \"MMAT_GLBOPT1\",\n    MMAT_GLBOPT2: \"MMAT_GLBOPT2\",\n    MMAT_GLBOPT3: \"MMAT_GLBOPT3\",\n    MMAT_LVARS: \"MMAT_LVARS\",",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "STRING_TO_MATURITY_DICT",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "STRING_TO_MATURITY_DICT = {v: k for k, v in MATURITY_TO_STRING_DICT.items()}\nMOP_TYPE_TO_STRING_DICT = {\n    mop_z: \"mop_z\",\n    mop_r: \"mop_r\",\n    mop_n: \"mop_n\",\n    mop_str: \"mop_str\",\n    mop_d: \"mop_d\",\n    mop_S: \"mop_S\",\n    mop_v: \"mop_v\",\n    mop_b: \"mop_b\",",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MOP_TYPE_TO_STRING_DICT",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "MOP_TYPE_TO_STRING_DICT = {\n    mop_z: \"mop_z\",\n    mop_r: \"mop_r\",\n    mop_n: \"mop_n\",\n    mop_str: \"mop_str\",\n    mop_d: \"mop_d\",\n    mop_S: \"mop_S\",\n    mop_v: \"mop_v\",\n    mop_b: \"mop_b\",\n    mop_f: \"mop_f\",",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "Z3_SPECIAL_OPERANDS",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "Z3_SPECIAL_OPERANDS = [\"UDiv\", \"URem\", \"LShR\", \"UGT\", \"UGE\", \"ULT\", \"ULE\"]\nBOOLEAN_OPCODES = [m_lnot, m_bnot, m_or, m_and, m_xor]\nARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]\nBIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "BOOLEAN_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "BOOLEAN_OPCODES = [m_lnot, m_bnot, m_or, m_and, m_xor]\nARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]\nBIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "ARITHMETICAL_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "ARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]\nBIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "BIT_OPERATIONS_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "BIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]\nCHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CHECK_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "CHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,\n                 m_setbe, m_setg, m_setge, m_setl, m_setle]\nMBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MBA_RELATED_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "MBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES\nCONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONDITIONAL_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "CONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]\nUNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "UNCONDITIONAL_JUMP_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "UNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]\nCONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "CONTROL_FLOW_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "CONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES\nMINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MINSN_TO_AST_FORBIDDEN_OPCODES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "MINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]\nSUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "SUB_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "SUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}\nAND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "AND_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "AND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}\nMSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:\n        mop_size = lo.size",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "MSB_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_helpers",
        "description": "plugins.d810.d810.hexrays_helpers",
        "peekOfCode": "MSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}\n# Hex-Rays mop equality checking\ndef equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:\n    if (lo.t != mop_n) or (ro.t != mop_n):\n        return False\n    if lo.size != ro.size:\n        return False\n    if mop_size is None:\n        mop_size = lo.size\n    return lo.nnn.value ^ ro.nnn.value == AND_TABLE[mop_size]",
        "detail": "plugins.d810.d810.hexrays_helpers",
        "documentation": {}
    },
    {
        "label": "InstructionDefUseCollector",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "class InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):\n        if is_target:\n            append_mop_if_not_in_list(op, self.target_mops)\n        else:",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "InstructionOptimizerManager",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "class InstructionOptimizerManager(optinsn_t):\n    def __init__(self, manager: D810Manager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))\n        super().__init__()\n        self.manager = manager\n        self.instruction_visitor = InstructionVisitorManager(self)\n        self._last_optimizer_tried = None\n        self.current_maturity = None\n        self.current_blk_serial = None\n        self.generate_z3_code = False",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "InstructionVisitorManager",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "class InstructionVisitorManager(minsn_visitor_t):\n    def __init__(self, optimizer: InstructionOptimizerManager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))\n        super().__init__()\n        self.instruction_optimizer = optimizer\n    def visit_minsn(self) -> bool:\n        return self.instruction_optimizer.optimize(self.blk, self.curins)\nclass BlockOptimizerManager(optblock_t):\n    def __init__(self, manager: D810Manager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "BlockOptimizerManager",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "class BlockOptimizerManager(optblock_t):\n    def __init__(self, manager: D810Manager):\n        optimizer_logger.debug(\"Initializing {0}...\".format(self.__class__.__name__))\n        super().__init__()\n        self.manager = manager\n        self.cfg_rules = set()\n        self.current_maturity = None\n        self.cfg_rules_usage_info = {}\n    def func(self, blk: mblock_t):\n        self.log_info_on_input(blk)",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "HexraysDecompilationHook",
        "kind": 6,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "class HexraysDecompilationHook(Hexrays_Hooks):\n    def __init__(self, manager):\n        super().__init__()\n        self.manager = manager\n    def prolog(self, mba: mbl_array_t, fc, reachable_blocks, decomp_flags) -> \"int\":\n        main_logger.info(\"Starting decompilation of function at 0x{0:x}\".format(mba.entry_ea))\n        self.manager.instruction_optimizer.reset_rule_usage_statistic()\n        self.manager.block_optimizer.reset_rule_usage_statistic()\n        return 0\n    def glbopt(self, mba: mbl_array_t) -> \"int\":",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "main_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "main_logger = logging.getLogger('D810')\noptimizer_logger = logging.getLogger('D810.optimizer')\nhelper_logger = logging.getLogger('D810.helper')\nDEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "optimizer_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "optimizer_logger = logging.getLogger('D810.optimizer')\nhelper_logger = logging.getLogger('D810.helper')\nDEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "helper_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "helper_logger = logging.getLogger('D810.helper')\nDEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_PATTERN_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_CHAIN_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_Z3_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nDEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OPTIMIZATION_EARLY_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]\nDEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):\n        if is_target:",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ANALYZER_MATURITIES",
        "kind": 5,
        "importPath": "plugins.d810.d810.hexrays_hooks",
        "description": "plugins.d810.d810.hexrays_hooks",
        "peekOfCode": "DEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]\nclass InstructionDefUseCollector(mop_visitor_t):\n    def __init__(self):\n        super().__init__()\n        self.unresolved_ins_mops = []\n        self.memory_unresolved_ins_mops = []\n        self.target_mops = []\n    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):\n        if is_target:\n            append_mop_if_not_in_list(op, self.target_mops)",
        "detail": "plugins.d810.d810.hexrays_hooks",
        "documentation": {}
    },
    {
        "label": "PluginConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.d810.d810.ida_ui",
        "description": "plugins.d810.d810.ida_ui",
        "peekOfCode": "class PluginConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        logger.debug(\"Initializing PluginConfigurationFileForm_t\")\n        super().__init__(parent)\n        self.state = state\n        self.log_dir_changed = False\n        self.log_dir = self.state.d810_config.get(\"log_dir\")\n        self.erase_logs_on_reload = self.state.d810_config.get(\"erase_logs_on_reload\")\n        self.generate_z3_code = self.state.d810_config.get(\"generate_z3_code\")\n        self.dump_intermediate_microcode = self.state.d810_config.get(\"dump_intermediate_microcode\")",
        "detail": "plugins.d810.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "EditConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.d810.d810.ida_ui",
        "description": "plugins.d810.d810.ida_ui",
        "peekOfCode": "class EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        logger.debug(\"Initializing EditConfigurationFileForm_t\")\n        super().__init__(parent)\n        self.state = state\n        self.resize(1000, 500)\n        self.setWindowTitle(\"Rule Configuration Editor\")\n        # Main layout\n        self.config_layout = QtWidgets.QVBoxLayout(self)\n        # Configuration Name Selection Layout",
        "detail": "plugins.d810.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "D810ConfigForm_t",
        "kind": 6,
        "importPath": "plugins.d810.d810.ida_ui",
        "description": "plugins.d810.d810.ida_ui",
        "peekOfCode": "class D810ConfigForm_t(ida_kernwin.PluginForm):\n    def __init__(self, state):\n        super().__init__()\n        self.state = state\n        self.shown = False\n        self.created = False\n        self.parent = None\n    def OnClose(self, form):\n        logger.debug(\"Calling OnClose\")\n        self.shown = False",
        "detail": "plugins.d810.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "D810GUI",
        "kind": 6,
        "importPath": "plugins.d810.d810.ida_ui",
        "description": "plugins.d810.d810.ida_ui",
        "peekOfCode": "class D810GUI(object):\n    def __init__(self, state):\n        \"\"\"\n        Instanciate D-810 views\n        \"\"\"\n        logger.debug(\"Initializing D810GUI\")\n        self.state = state\n        self.d810_config_form = D810ConfigForm_t(self.state)\n        # XXX fix\n        idaapi.set_dock_pos(\"D-810\", \"IDA View-A\", idaapi.DP_TAB)",
        "detail": "plugins.d810.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.ida_ui",
        "description": "plugins.d810.d810.ida_ui",
        "peekOfCode": "logger = logging.getLogger('D810.ui')\nclass PluginConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        logger.debug(\"Initializing PluginConfigurationFileForm_t\")\n        super().__init__(parent)\n        self.state = state\n        self.log_dir_changed = False\n        self.log_dir = self.state.d810_config.get(\"log_dir\")\n        self.erase_logs_on_reload = self.state.d810_config.get(\"erase_logs_on_reload\")\n        self.generate_z3_code = self.state.d810_config.get(\"generate_z3_code\")",
        "detail": "plugins.d810.d810.ida_ui",
        "documentation": {}
    },
    {
        "label": "clear_logs",
        "kind": 2,
        "importPath": "plugins.d810.d810.log",
        "description": "plugins.d810.d810.log",
        "peekOfCode": "def clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),\n                                                                  \"z3_log_filename\": z3_test_file.as_posix()})\n    z3_file_logger = logging.getLogger('D810.z3_test')",
        "detail": "plugins.d810.d810.log",
        "documentation": {}
    },
    {
        "label": "configure_loggers",
        "kind": 2,
        "importPath": "plugins.d810.d810.log",
        "description": "plugins.d810.d810.log",
        "peekOfCode": "def configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),\n                                                                  \"z3_log_filename\": z3_test_file.as_posix()})\n    z3_file_logger = logging.getLogger('D810.z3_test')\n    z3_file_logger.info(\"from z3 import BitVec, BitVecVal, UDiv, URem, LShR, UGT, UGE, ULT, ULE, prove\\n\\n\")",
        "detail": "plugins.d810.d810.log",
        "documentation": {}
    },
    {
        "label": "LOG_CONFIG_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.d810.log",
        "description": "plugins.d810.d810.log",
        "peekOfCode": "LOG_CONFIG_FILENAME = \"log.ini\"\nLOG_FILENAME = \"d810.log\"\nZ3_TEST_FILENAME = \"z3_check_instructions_substitution.py\"\ndef clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME",
        "detail": "plugins.d810.d810.log",
        "documentation": {}
    },
    {
        "label": "LOG_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.d810.log",
        "description": "plugins.d810.d810.log",
        "peekOfCode": "LOG_FILENAME = \"d810.log\"\nZ3_TEST_FILENAME = \"z3_check_instructions_substitution.py\"\ndef clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),",
        "detail": "plugins.d810.d810.log",
        "documentation": {}
    },
    {
        "label": "Z3_TEST_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.d810.log",
        "description": "plugins.d810.d810.log",
        "peekOfCode": "Z3_TEST_FILENAME = \"z3_check_instructions_substitution.py\"\ndef clear_logs(log_dir):\n    shutil.rmtree(log_dir, ignore_errors=True)\ndef configure_loggers(log_dir):\n    os.makedirs(log_dir, exist_ok=True)\n    log_main_file = Path(log_dir) / LOG_FILENAME\n    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME\n    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME\n    logging.config.fileConfig(log_conf_file.as_posix(), defaults={\"default_log_filename\": log_main_file.as_posix(),\n                                                                  \"z3_log_filename\": z3_test_file.as_posix()})",
        "detail": "plugins.d810.d810.log",
        "documentation": {}
    },
    {
        "label": "D810Manager",
        "kind": 6,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "class D810Manager(object):\n    def __init__(self, log_dir):\n        self.instruction_optimizer_rules = []\n        self.instruction_optimizer_config = {}\n        self.block_optimizer_rules = []\n        self.block_optimizer_config = {}\n        self.instruction_optimizer = None\n        self.block_optimizer = None\n        self.hx_decompiler_hook = None\n        self.log_dir = log_dir",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "D810State",
        "kind": 6,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "class D810State(object):\n    def __init__(self, d810_config: D810Configuration):\n        # For debugging purposes, to interact with this object from the console\n        # Type in IDA Python shell 'from d810.manager import d810_state' to access it\n        global d810_state\n        d810_state = self\n        reload_all_modules()\n        self.d810_config = d810_config\n        self.log_dir = os.path.join(self.d810_config.get(\"log_dir\"), D810_LOG_DIR_NAME)\n        self.manager = D810Manager(self.log_dir)",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "reload_all_modules",
        "kind": 2,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "def reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):\n    def __init__(self, log_dir):\n        self.instruction_optimizer_rules = []\n        self.instruction_optimizer_config = {}",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "d810_state",
        "kind": 5,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "d810_state = None\nD810_LOG_DIR_NAME = \"d810_logs\"\nMANAGER_INFO_FILENAME = \"manager_info.json\"\nlogger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "D810_LOG_DIR_NAME",
        "kind": 5,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "D810_LOG_DIR_NAME = \"d810_logs\"\nMANAGER_INFO_FILENAME = \"manager_info.json\"\nlogger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "MANAGER_INFO_FILENAME",
        "kind": 5,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "MANAGER_INFO_FILENAME = \"manager_info.json\"\nlogger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):\n    def __init__(self, log_dir):",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.manager",
        "description": "plugins.d810.d810.manager",
        "peekOfCode": "logger = logging.getLogger('D810')\ndef reload_all_modules():\n    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)\n    with open(manager_info_path, \"r\") as f:\n        manager_info = json.load(f)\n    for module_name in manager_info[\"module_list\"]:\n        idaapi.require(module_name)\nclass D810Manager(object):\n    def __init__(self, log_dir):\n        self.instruction_optimizer_rules = []",
        "detail": "plugins.d810.d810.manager",
        "documentation": {}
    },
    {
        "label": "BlockInfo",
        "kind": 6,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "class BlockInfo(object):\n    def __init__(self, blk: mblock_t, ins=None):\n        self.blk = blk\n        self.ins_list = []\n        if ins is not None:\n            self.ins_list.append(ins)\n    def get_copy(self) -> BlockInfo:\n        new_block_info = BlockInfo(self.blk)\n        new_block_info.ins_list = [x for x in self.ins_list]\n        return new_block_info",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopHistory",
        "kind": 6,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "class MopHistory(object):\n    def __init__(self, searched_mop_list: List[mop_t]):\n        self.searched_mop_list = [mop_t(x) for x in searched_mop_list]\n        self.history = []\n        self.unresolved_mop_list = []\n        self._mc_interpreter = MicroCodeInterpreter()\n        self._mc_initial_environment = MicroCodeEnvironment()\n        self._mc_current_environment = self._mc_initial_environment.get_copy()\n        self._is_dirty = True\n    def add_mop_initial_value(self, mop: mop_t, value: int):",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "MopTracker",
        "kind": 6,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "class MopTracker(object):\n    def __init__(self, searched_mop_list: List[mop_t], max_nb_block=-1, max_path=-1):\n        self.mba = None\n        self._unresolved_mops = []\n        self._memory_unresolved_mops = []\n        for searched_mop in searched_mop_list:\n            a, b = get_standard_and_memory_mop_lists(searched_mop)\n            self._unresolved_mops += a\n            self._memory_unresolved_mops += b\n        self.history = MopHistory(searched_mop_list)",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_standard_and_memory_mop_lists",
        "kind": 2,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "def get_standard_and_memory_mop_lists(mop_in: mop_t) -> Tuple[List[mop_t], List[mop_t]]:\n    if mop_in.t in [mop_r, mop_S]:\n        return [mop_in], []\n    elif mop_in.t == mop_v:\n        return [], [mop_in]\n    elif mop_in.t == mop_d:\n        ins_mop_info = InstructionDefUseCollector()\n        mop_in.d.for_all_ops(ins_mop_info)\n        return remove_segment_registers(ins_mop_info.unresolved_ins_mops), ins_mop_info.memory_unresolved_ins_mops\n    else:",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_block_with_multiple_predecessors",
        "kind": 2,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "def get_block_with_multiple_predecessors(var_histories: List[MopHistory]) -> Tuple[Union[None, mblock_t],\n                                                                                   Union[None, Dict[int, List[MopHistory]]]]:\n    for i, var_history in enumerate(var_histories):\n        pred_blk = var_history.block_path[0]\n        for block in var_history.block_path[1:]:\n            tmp_dict = {pred_blk.serial: [var_history]}\n            for j in range(i + 1, len(var_histories)):\n                blk_index = get_blk_index(block, var_histories[j].block_path)\n                if (blk_index - 1) >= 0:\n                    other_pred = var_histories[j].block_path[blk_index - 1]",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "try_to_duplicate_one_block",
        "kind": 2,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "def try_to_duplicate_one_block(var_histories: List[MopHistory]) -> Tuple[int, int]:\n    nb_duplication = 0\n    nb_change = 0\n    if (len(var_histories) == 0) or (len(var_histories[0].block_path) == 0):\n        return nb_duplication, nb_change\n    mba = var_histories[0].block_path[0].mba\n    block_to_duplicate, pred_dict = get_block_with_multiple_predecessors(var_histories)\n    if block_to_duplicate is None:\n        return nb_duplication, nb_change\n    logger.debug(\"Block to duplicate found: {0} with {1} successors\"",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "duplicate_histories",
        "kind": 2,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "def duplicate_histories(var_histories: List[MopHistory], max_nb_pass: int = 10) -> Tuple[int, int]:\n    cur_pass = 0\n    total_nb_duplication = 0\n    total_nb_change = 0\n    logger.info(\"Trying to fix new var_history...\")\n    for i, var_history in enumerate(var_histories):\n        logger.info(\" start.{0}: {1}\".format(i, var_history.block_serial_path))\n    while cur_pass < max_nb_pass:\n        logger.debug(\"Current path {0}\".format(cur_pass))\n        nb_duplication, nb_change = try_to_duplicate_one_block(var_histories)",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_segment_register_indexes",
        "kind": 2,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "def get_segment_register_indexes(mop_list: List[mop_t]) -> List[int]:\n    # This is a very dirty and probably buggy\n    segment_register_indexes = []\n    for i, mop in enumerate(mop_list):\n        if mop.t == mop_r:\n            formatted_mop = format_mop_t(mop)\n            if formatted_mop in [\"ds.2\", \"cs.2\", \"es.2\", \"ss.2\"]:\n                segment_register_indexes.append(i)\n    return segment_register_indexes\ndef remove_segment_registers(mop_list: List[mop_t]) -> List[mop_t]:",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "remove_segment_registers",
        "kind": 2,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "def remove_segment_registers(mop_list: List[mop_t]) -> List[mop_t]:\n    # TODO: instead of doing that, we should add the segment registers to the (global?) emulation environment\n    segment_register_indexes = get_segment_register_indexes(mop_list)\n    if len(segment_register_indexes) == 0:\n        return mop_list\n    new_mop_list = []\n    for i, mop in enumerate(mop_list):\n        if i in segment_register_indexes:\n            pass\n        else:",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "logger = logging.getLogger('D810.tracker')\nclass BlockInfo(object):\n    def __init__(self, blk: mblock_t, ins=None):\n        self.blk = blk\n        self.ins_list = []\n        if ins is not None:\n            self.ins_list.append(ins)\n    def get_copy(self) -> BlockInfo:\n        new_block_info = BlockInfo(self.blk)\n        new_block_info.ins_list = [x for x in self.ins_list]",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "cur_mop_tracker_nb_path",
        "kind": 5,
        "importPath": "plugins.d810.d810.tracker",
        "description": "plugins.d810.d810.tracker",
        "peekOfCode": "cur_mop_tracker_nb_path = 0\nclass MopTracker(object):\n    def __init__(self, searched_mop_list: List[mop_t], max_nb_block=-1, max_path=-1):\n        self.mba = None\n        self._unresolved_mops = []\n        self._memory_unresolved_mops = []\n        for searched_mop in searched_mop_list:\n            a, b = get_standard_and_memory_mop_lists(searched_mop)\n            self._unresolved_mops += a\n            self._memory_unresolved_mops += b",
        "detail": "plugins.d810.d810.tracker",
        "documentation": {}
    },
    {
        "label": "get_all_subclasses",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_all_subclasses(python_class):\n    python_class.__subclasses__()\n    subclasses = set()\n    check_these = [python_class]\n    while check_these:\n        parent = check_these.pop()\n        for child in parent.__subclasses__():\n            if child not in subclasses:\n                subclasses.add(child)\n                check_these.append(child)",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "unsigned_to_signed",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def unsigned_to_signed(unsigned_value, nb_bytes):\n    return CTYPE_SIGNED_TABLE[nb_bytes](unsigned_value).value\ndef signed_to_unsigned(signed_value, nb_bytes):\n    return CTYPE_UNSIGNED_TABLE[nb_bytes](signed_value).value\ndef get_msb(value, nb_bytes):\n    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)\ndef get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "signed_to_unsigned",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def signed_to_unsigned(signed_value, nb_bytes):\n    return CTYPE_UNSIGNED_TABLE[nb_bytes](signed_value).value\ndef get_msb(value, nb_bytes):\n    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)\ndef get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_msb",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_msb(value, nb_bytes):\n    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)\ndef get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)\ndef get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_cf",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_add_cf(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)\ndef get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)\ndef get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)\ndef get_sub_of(op1, op2, nb_bytes):",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_add_of",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_add_of(op1, op2, nb_bytes):\n    res = op1 + op2\n    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)\ndef get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)\ndef get_sub_of(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)\ndef get_parity_flag(op1, op2, nb_bytes):",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_sub_cf",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_sub_cf(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)\ndef get_sub_of(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)\ndef get_parity_flag(op1, op2, nb_bytes):\n    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value\n    return (bin(tmp).count(\"1\") + 1) % 2\ndef ror(x, n, nb_bits=32):",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_sub_of",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_sub_of(op1, op2, nb_bytes):\n    res = op1 - op2\n    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)\ndef get_parity_flag(op1, op2, nb_bytes):\n    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value\n    return (bin(tmp).count(\"1\") + 1) % 2\ndef ror(x, n, nb_bits=32):\n    mask = (2 ** n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (nb_bits - n))",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "get_parity_flag",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def get_parity_flag(op1, op2, nb_bytes):\n    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value\n    return (bin(tmp).count(\"1\") + 1) % 2\ndef ror(x, n, nb_bits=32):\n    mask = (2 ** n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (nb_bits - n))\ndef rol(x, n, nb_bits=32):\n    return ror(x, nb_bits - n, nb_bits)",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "ror",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def ror(x, n, nb_bits=32):\n    mask = (2 ** n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (nb_bits - n))\ndef rol(x, n, nb_bits=32):\n    return ror(x, nb_bits - n, nb_bits)",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "rol",
        "kind": 2,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "def rol(x, n, nb_bits=32):\n    return ror(x, nb_bits - n, nb_bits)",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "CTYPE_SIGNED_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "CTYPE_SIGNED_TABLE = {1: ctypes.c_int8, 2: ctypes.c_int16, 4: ctypes.c_int32, 8: ctypes.c_int64}\nCTYPE_UNSIGNED_TABLE = {1: ctypes.c_uint8, 2: ctypes.c_uint16, 4: ctypes.c_uint32, 8: ctypes.c_uint64}\ndef get_all_subclasses(python_class):\n    python_class.__subclasses__()\n    subclasses = set()\n    check_these = [python_class]\n    while check_these:\n        parent = check_these.pop()\n        for child in parent.__subclasses__():\n            if child not in subclasses:",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "CTYPE_UNSIGNED_TABLE",
        "kind": 5,
        "importPath": "plugins.d810.d810.utils",
        "description": "plugins.d810.d810.utils",
        "peekOfCode": "CTYPE_UNSIGNED_TABLE = {1: ctypes.c_uint8, 2: ctypes.c_uint16, 4: ctypes.c_uint32, 8: ctypes.c_uint64}\ndef get_all_subclasses(python_class):\n    python_class.__subclasses__()\n    subclasses = set()\n    check_these = [python_class]\n    while check_these:\n        parent = check_these.pop()\n        for child in parent.__subclasses__():\n            if child not in subclasses:\n                subclasses.add(child)",
        "detail": "plugins.d810.d810.utils",
        "documentation": {}
    },
    {
        "label": "create_z3_vars",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def create_z3_vars(leaf_list: List[AstLeaf]):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    known_leaf_list = []\n    known_leaf_z3_var_list = []\n    for leaf in leaf_list:\n        if not leaf.is_constant():\n            leaf_index = get_mop_index(leaf.mop, known_leaf_list)\n            if leaf_index == -1:\n                known_leaf_list.append(leaf.mop)",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "ast_to_z3_expression",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def ast_to_z3_expression(ast: Union[AstNode, AstLeaf], use_bitvecval=False):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    if isinstance(ast, AstLeaf):\n        if ast.is_constant():\n            return z3.BitVecVal(ast.value, 32)\n        return ast.z3_var\n    if ast.opcode == m_neg:\n        return -(ast_to_z3_expression(ast.left, use_bitvecval))\n    elif ast.opcode == m_lnot:",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "mop_list_to_z3_expression_list",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def mop_list_to_z3_expression_list(mop_list: List[mop_t]):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    ast_list = [mop_to_ast(mop) for mop in mop_list]\n    ast_leaf_list = []\n    for ast in ast_list:\n        ast_leaf_list += ast.get_leaf_list()\n    _ = create_z3_vars(ast_leaf_list)\n    return [ast_to_z3_expression(ast) for ast in ast_list]\ndef z3_check_mop_equality(mop1: mop_t, mop2: mop_t) -> bool:",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_equality",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def z3_check_mop_equality(mop1: mop_t, mop2: mop_t) -> bool:\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    z3_mop1, z3_mop2 = mop_list_to_z3_expression_list([mop1, mop2])\n    s = z3.Solver()\n    s.add(z3.Not(z3_mop1 == z3_mop2))\n    if s.check().r == -1:\n        return True\n    return False\ndef z3_check_mop_inequality(mop1: mop_t, mop2: mop_t) -> bool:",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_check_mop_inequality",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def z3_check_mop_inequality(mop1: mop_t, mop2: mop_t) -> bool:\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    z3_mop1, z3_mop2 = mop_list_to_z3_expression_list([mop1, mop2])\n    s = z3.Solver()\n    s.add(z3_mop1 == z3_mop2)\n    if s.check().r == -1:\n        return True\n    return False\ndef rename_leafs(leaf_list: List[AstLeaf]) -> List[str]:",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "rename_leafs",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def rename_leafs(leaf_list: List[AstLeaf]) -> List[str]:\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    known_leaf_list = []\n    for leaf in leaf_list:\n        if not leaf.is_constant() and leaf.mop.t != mop_z:\n            leaf_index = get_mop_index(leaf.mop, known_leaf_list)\n            if leaf_index == -1:\n                known_leaf_list.append(leaf.mop)\n                leaf_index = len(known_leaf_list) - 1",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "log_z3_instructions",
        "kind": 2,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "def log_z3_instructions(original_ins: minsn_t, new_ins: minsn_t):\n    if not Z3_INSTALLED:\n        raise D810Z3Exception(\"Z3 is not installed\")\n    orig_mba_tree = minsn_to_ast(original_ins)\n    new_mba_tree = minsn_to_ast(new_ins)\n    if orig_mba_tree is None or new_mba_tree is None:\n        return None\n    orig_leaf_list = orig_mba_tree.get_leaf_list()\n    new_leaf_list = new_mba_tree.get_leaf_list()\n    var_def_list = rename_leafs(orig_leaf_list + new_leaf_list)",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "logger = logging.getLogger('D810.plugin')\nz3_file_logger = logging.getLogger('D810.z3_test')\ntry:\n    import z3\n    Z3_INSTALLED = True\n    # Since version 4.8.2, when Z3 is creating a BitVec, it relies on _str_to_bytes which uses sys.stdout.encoding\n    # However, in IDA Pro (7.6sp1) sys.stdout is an object of type IDAPythonStdOut\n    # which doesn't have a 'encoding' attribute, thus we set it to something, so that Z3 works\n    import sys\n    try:",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "z3_file_logger",
        "kind": 5,
        "importPath": "plugins.d810.d810.z3_utils",
        "description": "plugins.d810.d810.z3_utils",
        "peekOfCode": "z3_file_logger = logging.getLogger('D810.z3_test')\ntry:\n    import z3\n    Z3_INSTALLED = True\n    # Since version 4.8.2, when Z3 is creating a BitVec, it relies on _str_to_bytes which uses sys.stdout.encoding\n    # However, in IDA Pro (7.6sp1) sys.stdout is an object of type IDAPythonStdOut\n    # which doesn't have a 'encoding' attribute, thus we set it to something, so that Z3 works\n    import sys\n    try:\n        x = sys.stdout.encoding",
        "detail": "plugins.d810.d810.z3_utils",
        "documentation": {}
    },
    {
        "label": "D810Plugin",
        "kind": 6,
        "importPath": "plugins.d810.D810",
        "description": "plugins.d810.D810",
        "peekOfCode": "class D810Plugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"D-810\"\n    wanted_hotkey = \"Ctrl-Shift-D\"\n    comment = \"Interface to the D-810 plugin\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(D810Plugin, self).__init__()",
        "detail": "plugins.d810.D810",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.d810.D810",
        "description": "plugins.d810.D810",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return D810Plugin()",
        "detail": "plugins.d810.D810",
        "documentation": {}
    },
    {
        "label": "D810_VERSION",
        "kind": 5,
        "importPath": "plugins.d810.D810",
        "description": "plugins.d810.D810",
        "peekOfCode": "D810_VERSION = \"0.1\"\nclass D810Plugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"D-810\"\n    wanted_hotkey = \"Ctrl-Shift-D\"\n    comment = \"Interface to the D-810 plugin\"\n    help = \"\"\n    initialized = False\n    def __init__(self):",
        "detail": "plugins.d810.D810",
        "documentation": {}
    },
    {
        "label": "YaraSearchResultChooser",
        "kind": 6,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "class YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],\n                [\"String\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "Findcrypt_Plugin_t",
        "kind": 6,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "class Findcrypt_Plugin_t(idaapi.plugin_t):\n    comment = \"Findcrypt plugin for IDA Pro (using yara framework)\"\n    help = \"todo\"\n    wanted_name = \"Findcrypt\"\n    wanted_hotkey = \"Ctrl-Alt-F\"\n    flags = idaapi.PLUGIN_KEEP\n    def init(self):\n        global p_initialized\n        # register popup menu handlers\n        try:",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return Findcrypt_Plugin_t()",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "VERSION = \"0.2\"\nYARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "YARARULES_CFGFILE",
        "kind": 5,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "YARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod\n        def get_label(self):",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.findcrypt-yara.findcrypt3",
        "description": "plugins.findcrypt-yara.findcrypt3",
        "peekOfCode": "p_initialized = False\nclass YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.findcrypt-yara.findcrypt3",
        "documentation": {}
    },
    {
        "label": "YaraSearchResultChooser",
        "kind": 6,
        "importPath": "plugins.fix.findcrypt3",
        "description": "plugins.fix.findcrypt3",
        "peekOfCode": "class YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],\n                [\"String\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.fix.findcrypt3",
        "documentation": {}
    },
    {
        "label": "Findcrypt_Plugin_t",
        "kind": 6,
        "importPath": "plugins.fix.findcrypt3",
        "description": "plugins.fix.findcrypt3",
        "peekOfCode": "class Findcrypt_Plugin_t(idaapi.plugin_t):\n    comment = \"Findcrypt plugin for IDA Pro (using yara framework)\"\n    help = \"todo\"\n    wanted_name = \"Findcrypt\"\n    wanted_hotkey = \"Ctrl-Alt-F\"\n    flags = idaapi.PLUGIN_KEEP\n    def init(self):\n        global p_initialized\n        # register popup menu handlers\n        try:",
        "detail": "plugins.fix.findcrypt3",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.fix.findcrypt3",
        "description": "plugins.fix.findcrypt3",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return Findcrypt_Plugin_t()",
        "detail": "plugins.fix.findcrypt3",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.fix.findcrypt3",
        "description": "plugins.fix.findcrypt3",
        "peekOfCode": "VERSION = \"0.2\"\nYARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod",
        "detail": "plugins.fix.findcrypt3",
        "documentation": {}
    },
    {
        "label": "YARARULES_CFGFILE",
        "kind": 5,
        "importPath": "plugins.fix.findcrypt3",
        "description": "plugins.fix.findcrypt3",
        "peekOfCode": "YARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"findcrypt3.rules\")\ntry:\n    class Kp_Menu_Context(idaapi.action_handler_t):\n        def __init__(self):\n            idaapi.action_handler_t.__init__(self)\n        @classmethod\n        def get_name(self):\n            return self.__name__\n        @classmethod\n        def get_label(self):",
        "detail": "plugins.fix.findcrypt3",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.fix.findcrypt3",
        "description": "plugins.fix.findcrypt3",
        "peekOfCode": "p_initialized = False\nclass YaraSearchResultChooser(idaapi.Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [\n                [\"Address\", idaapi.Choose.CHCOL_HEX|10],\n                [\"Rules file\", idaapi.Choose.CHCOL_PLAIN|12],\n                [\"Name\", idaapi.Choose.CHCOL_PLAIN|25],",
        "detail": "plugins.fix.findcrypt3",
        "documentation": {}
    },
    {
        "label": "findGetProcAddress",
        "kind": 2,
        "importPath": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "description": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "peekOfCode": "def findGetProcAddress(cfunc):\n    class visitor(idaapi.ctree_visitor_t):\n        def __init__(self, cfunc):\n            idaapi.ctree_visitor_t.__init__(self, idaapi.CV_FAST)\n            self.cfunc = cfunc\n        def visit_expr(self, i):\n            if i.op == idaapi.cot_call:\n                # look for calls to GetProcAddress\n                if idc.Name(i.x.obj_ea) == \"GetProcAddress\":\n                    # ASCSTR_C == 0",
        "detail": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "documentation": {}
    },
    {
        "label": "event_callback",
        "kind": 2,
        "importPath": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "description": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "peekOfCode": "def event_callback(event, *args):\n        if event == idaapi.hxe_maturity:\n            cfunc, maturity = args\n            if maturity == idaapi.CMAT_FINAL:\n                findGetProcAddress(cfunc)\n        return 0\ndef main():\n    if not idaapi.init_hexrays_plugin():\n        return False\n    print \"Hex-rays version %s has been detected\" % idaapi.get_hexrays_version()",
        "detail": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "description": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "peekOfCode": "def main():\n    if not idaapi.init_hexrays_plugin():\n        return False\n    print \"Hex-rays version %s has been detected\" % idaapi.get_hexrays_version()\n    idaapi.install_hexrays_callback(event_callback)\nif main():\n    idaapi.term_hexrays_plugin();",
        "detail": "plugins.flare-ida.decompiler_scripts.find_get_proc_address",
        "documentation": {}
    },
    {
        "label": "char_converter_visitor_t",
        "kind": 6,
        "importPath": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "description": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "peekOfCode": "class char_converter_visitor_t(idaapi.ctree_visitor_t):\n    def __init__(self):\n        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_FAST)\n    def visit_expr(self, expr):\n        \"\"\"\n        Search for simple assignents to stack vars\n        \"\"\"\n        if expr.op != ida_hexrays.cot_asg:\n            return 0\n        _x = expr.x",
        "detail": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "documentation": {}
    },
    {
        "label": "stack_strings_ah_t",
        "kind": 6,
        "importPath": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "description": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "peekOfCode": "class stack_strings_ah_t(ida_kernwin.action_handler_t):\n    def __init__(self):\n        ida_kernwin.action_handler_t.__init__(self)\n    def activate(self, ctx):\n        vu = ida_hexrays.get_widget_vdui(ctx.widget)\n        # ----------------------------------------------\n        # Do something with the vdui (vu)\n        print \"Analyzing decompiled code...\"\n        cv = char_converter_visitor_t()\n        cv.apply_to(vu.cfunc.body, None)",
        "detail": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "documentation": {}
    },
    {
        "label": "cb",
        "kind": 2,
        "importPath": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "description": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "peekOfCode": "def cb(event, *args):\n    if event == ida_hexrays.hxe_populating_popup:\n        widget, phandle, vu = args\n        res = idaapi.attach_action_to_popup(vu.ct, None, ACTION_NAME)\n    return 0\ndef show_banner():\n    print \"-\" * 60\n    print \"CHAR CONVERTER\"\n    print \"Converts stack string assignments to char representation\"\n    print",
        "detail": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "documentation": {}
    },
    {
        "label": "show_banner",
        "kind": 2,
        "importPath": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "description": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "peekOfCode": "def show_banner():\n    print \"-\" * 60\n    print \"CHAR CONVERTER\"\n    print \"Converts stack string assignments to char representation\"\n    print\n    print \"Example:\"\n    print \"v1 = 65 -> v1 = 'A'\"\n    print \"v2 = 66 -> v1 = 'B'\"\n    print \"...\"\n    print \"-\" * 60",
        "detail": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "description": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "peekOfCode": "def main():\n    show_banner()\n    print \"Unregistering old action...\"\n    ida_kernwin.unregister_action(ACTION_NAME)\n    if ida_hexrays.init_hexrays_plugin():\n        ida_kernwin.register_action(\n            ida_kernwin.action_desc_t(\n                ACTION_NAME,\n                \"Keep sanity (stack strings)\",\n                stack_strings_ah_t(),",
        "detail": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "documentation": {}
    },
    {
        "label": "ACTION_NAME",
        "kind": 5,
        "importPath": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "description": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "peekOfCode": "ACTION_NAME = \"Stack strings\"\n# --------------------------------------------------------------------------\nclass char_converter_visitor_t(idaapi.ctree_visitor_t):\n    def __init__(self):\n        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_FAST)\n    def visit_expr(self, expr):\n        \"\"\"\n        Search for simple assignents to stack vars\n        \"\"\"\n        if expr.op != ida_hexrays.cot_asg:",
        "detail": "plugins.flare-ida.decompiler_scripts.stack_strings_helper",
        "documentation": {}
    },
    {
        "label": "getFunctionArgumentCount",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example1",
        "description": "plugins.flare-ida.examples.argtracker_example1",
        "peekOfCode": "def getFunctionArgumentCount(ea):\n    '''\n    Bit of a hack, since IDA doesn't seem to have a good way to get this information.\n    Gets the frame for a given function, and counts named members following the 'r'\n    member.\n    Note: IDA won't create a frame member for an unreferenced function arg... so you've\n    been warned.\n    '''\n    rFound = False\n    argCount = 0",
        "detail": "plugins.flare-ida.examples.argtracker_example1",
        "documentation": {}
    },
    {
        "label": "handleCreateThread",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example1",
        "description": "plugins.flare-ida.examples.argtracker_example1",
        "peekOfCode": "def handleCreateThread(ea):\n    logger.debug('handleCreateThread: starting up 0x%08x', ea)\n    vw = c_jayutils.loadWorkspace(c_jayutils.getInputFilepath())\n    logger.info('Loaded workspace')\n    tracker = c_argtracker.ArgTracker(vw)\n    interestingXrefs = idautils.CodeRefsTo(ea, 1)\n    for xref in interestingXrefs:\n        argsList = tracker.getPushArgs(xref, 7)\n        if len(argsList) == 0:\n            logger.error('Unable to get push args at: 0x%08x', xref)",
        "detail": "plugins.flare-ida.examples.argtracker_example1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example1",
        "description": "plugins.flare-ida.examples.argtracker_example1",
        "peekOfCode": "def main():\n    beginThreadExLoc = idc.LocByName('_beginthreadex')\n    if beginThreadExLoc == idc.BADADDR:\n        print 'Function \"_beginthreadex\" not found. Returning'\n        return\n    for xref in idautils.CodeRefsTo(beginThreadExLoc, 1):\n        if getFunctionArgumentCount(xref) == 7:\n            print 'Found likely MyCreateThread: 0x%08x' % xref\n            handleCreateThread(idc.GetFunctionAttr(xref, idc.FUNCATTR_START))\nmain()",
        "detail": "plugins.flare-ida.examples.argtracker_example1",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.examples.argtracker_example1",
        "description": "plugins.flare-ida.examples.argtracker_example1",
        "peekOfCode": "logger = c_jayutils.getLogger('')\ndef getFunctionArgumentCount(ea):\n    '''\n    Bit of a hack, since IDA doesn't seem to have a good way to get this information.\n    Gets the frame for a given function, and counts named members following the 'r'\n    member.\n    Note: IDA won't create a frame member for an unreferenced function arg... so you've\n    been warned.\n    '''\n    rFound = False",
        "detail": "plugins.flare-ida.examples.argtracker_example1",
        "documentation": {}
    },
    {
        "label": "decodeString",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example2",
        "description": "plugins.flare-ida.examples.argtracker_example2",
        "peekOfCode": "def decodeString(strLoc, count, const1):\n    buff = idc.GetManyBytes(strLoc, count)\n    decString = decodeSoguBytes20100921_strings(buff, 0, count, const1)\n    return decString\ndef decodeSoguBytes20100921_strings(inBytes, offset, count, const1):\n    v9 = const1\n    v7 = const1\n    v8 = const1\n    t1 = const1\n    xBytes = array.array('B', inBytes[offset:offset+count])",
        "detail": "plugins.flare-ida.examples.argtracker_example2",
        "documentation": {}
    },
    {
        "label": "decodeSoguBytes20100921_strings",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example2",
        "description": "plugins.flare-ida.examples.argtracker_example2",
        "peekOfCode": "def decodeSoguBytes20100921_strings(inBytes, offset, count, const1):\n    v9 = const1\n    v7 = const1\n    v8 = const1\n    t1 = const1\n    xBytes = array.array('B', inBytes[offset:offset+count])\n    result = array.array('B', inBytes[offset:offset+count])\n    for idx in xrange(len(xBytes)):\n        v9 = 0xffffffff & (v9 + (-3 - 8*v9))\n        t1 = 0xffffffff & (t1 + (-5 + -32 * t1))",
        "detail": "plugins.flare-ida.examples.argtracker_example2",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example2",
        "description": "plugins.flare-ida.examples.argtracker_example2",
        "peekOfCode": "def getArgs():\n    '''\n    Phase 1:\n    For each xref to the string decoder, use argracker to grab the interesting\n    arguments. Print them out as a list of tuples that will be used in phase 2.\n    '''\n    decStringFunc = 0x10002F6C\n    vw = c_jayutils.loadWorkspace(c_jayutils.getInputFilepath())\n    logger.info('Loaded workspace')\n    tracker = c_argtracker.ArgTracker(vw)",
        "detail": "plugins.flare-ida.examples.argtracker_example2",
        "documentation": {}
    },
    {
        "label": "processStuff",
        "kind": 2,
        "importPath": "plugins.flare-ida.examples.argtracker_example2",
        "description": "plugins.flare-ida.examples.argtracker_example2",
        "peekOfCode": "def processStuff(results):\n    '''\n    Phase 2:\n    For each argument tuple, decode the string and apply \n    '''\n    for cVa, strLoc, locVa, strLen, lenVa, constVa, const1 in results:\n        #logger.info('Trying to process 0x%08x: 0x%08x (0x%08x) 0x%04x (0x%08x) 0x%08x (0x%08x)', cVa, strLoc, locVa, strLen, lenVa, const1, constVa)\n        try:\n            decString = decodeString(strLoc, strLen, const1)\n            #logger.infoHex(decString, '0x%08x: %s', strLoc, decString)",
        "detail": "plugins.flare-ida.examples.argtracker_example2",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.examples.argtracker_example2",
        "description": "plugins.flare-ida.examples.argtracker_example2",
        "peekOfCode": "logger = c_jayutils.getLogger('')\ndef decodeString(strLoc, count, const1):\n    buff = idc.GetManyBytes(strLoc, count)\n    decString = decodeSoguBytes20100921_strings(buff, 0, count, const1)\n    return decString\ndef decodeSoguBytes20100921_strings(inBytes, offset, count, const1):\n    v9 = const1\n    v7 = const1\n    v8 = const1\n    t1 = const1",
        "detail": "plugins.flare-ida.examples.argtracker_example2",
        "documentation": {}
    },
    {
        "label": "stuff1",
        "kind": 5,
        "importPath": "plugins.flare-ida.examples.argtracker_example2",
        "description": "plugins.flare-ida.examples.argtracker_example2",
        "peekOfCode": "stuff1 =  [\n(0x10001024, 0x10019060, 0x10001014, 0x0000000a, 0x10001019, 0x1000101b, 0x91735667),\n(0x10001076, 0x1001906c, 0x10001066, 0x00000010, 0x1000106b, 0x1000106d, 0x4539aadc),\n(0x100010c3, 0x10019080, 0x100010b3, 0x00000012, 0x100010b8, 0x100010ba, 0xa65979a0),\n(0x10001110, 0x10019094, 0x10001100, 0x00000006, 0x10001105, 0x10001107, 0xfc65f1b4),\n(0x10001162, 0x1001909c, 0x10001152, 0x0000000c, 0x10001157, 0x10001159, 0x1af06eb2),\n(0x100011b4, 0x100190ac, 0x100011a4, 0x00000011, 0x100011a9, 0x100011ab, 0xe8d146ee),\n(0x10001209, 0x100190c0, 0x100011f9, 0x0000000a, 0x100011fe, 0x10001200, 0xb62e2c25),\n(0x1000125e, 0x100190cc, 0x1000124e, 0x00000017, 0x10001253, 0x10001255, 0xcdf6a00c),\n(0x100012b9, 0x100190f4, 0x100012a9, 0x00000009, 0x100012ae, 0x100012b0, 0x0da8e1b7),",
        "detail": "plugins.flare-ida.examples.argtracker_example2",
        "documentation": {}
    },
    {
        "label": "show_usage",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "description": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "peekOfCode": "def show_usage():\n    print 'Usage:',\n    print sys.argv[0] + ' <path to tilib> <til directory>'\ndef main(tilib_exe, til_dir):\n    logging.basicConfig(level=logging.WARN)\n    if not os.path.isfile(tilib_exe):\n        g_logger.warn(tilib_exe + ' is not a file')\n        return False\n    if not os.path.isdir(til_dir):\n        g_logger.warn(til_dir + ' is not a directory')",
        "detail": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "description": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "peekOfCode": "def main(tilib_exe, til_dir):\n    logging.basicConfig(level=logging.WARN)\n    if not os.path.isfile(tilib_exe):\n        g_logger.warn(tilib_exe + ' is not a file')\n        return False\n    if not os.path.isdir(til_dir):\n        g_logger.warn(til_dir + ' is not a directory')\n        return False\n    const_pattern = re.compile(\"([0-9A-Fa-f]{8}) ([0-9A-Fa-f]{8}) +([A-Za-z0-9_]+) ([A-Za-z0-9_]+)\")\n    ignored_enum_names = set([\"int\", \"unsigned\", \"const\", \"UINT\", \"void\", \"struct\", \"__int16\", \"char\"])",
        "detail": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "documentation": {}
    },
    {
        "label": "g_logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "description": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "peekOfCode": "g_logger = logging.getLogger(\"til_extractor\")\ndef show_usage():\n    print 'Usage:',\n    print sys.argv[0] + ' <path to tilib> <til directory>'\ndef main(tilib_exe, til_dir):\n    logging.basicConfig(level=logging.WARN)\n    if not os.path.isfile(tilib_exe):\n        g_logger.warn(tilib_exe + ' is not a file')\n        return False\n    if not os.path.isdir(til_dir):",
        "detail": "plugins.flare-ida.MSDN_crawler.extract_til_constant_info",
        "documentation": {}
    },
    {
        "label": "strip_html",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def strip_html(string):\n    r1 = re.compile(\"<.*?>\")\n    r2 = re.compile(\" +\")\n    return r2.sub(\" \", r1.sub(\"\", string).replace(\"&nbsp;\", \" \")\n                  .replace(\"\\t\", \" \").replace(\"&)\", \")\")\n                  .replace(\"&#8211;\", \"-\").replace(\"&#8212;\", \"-\")\n                  .replace(\"&#160;\", \" \"))\ndef parse_old_style(file, content):\n    m = re.search(\n        \"<ph:apidata><api>(.*)</api><name>(.*)</name></ph:apidata>\", content)",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "parse_old_style",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def parse_old_style(file, content):\n    m = re.search(\n        \"<ph:apidata><api>(.*)</api><name>(.*)</name></ph:apidata>\", content)\n    if m:\n        dll = m.group(1).lower()\n        function_name = m.group(2)\n        m = re.search(\"<span></span><P>(.*?)</P>\", content)\n        if m:\n            description = strip_html(m.group(1))\n        else:",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "parse_new_style",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def parse_new_style(file, content, const_enum):\n    # Check for > not for /> because some docs are broken\n    api_types = re.findall(\n        \"<MSHelp:Attr Name=\\\"APIType\\\" Value=\\\"(.*?)\\\"[ /]*>\", content)\n    if api_types in ([], [\"Schema\"], [\"UserDefined\"], [\"HeaderDef\"],\n                     [\"MOFDef\"], [\"NA\"], [\"LibDef\"]):\n        return None\n    if api_types not in ([], [\"COM\"], [\"DllExport\"]):\n        g_logger.debug(\"API Type: \", ' '.join(api_types))\n    # Check for > not for /> because some docs are broken",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "get_enum_for_constant",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def get_enum_for_constant(constant_name, const_enum):\n    if constant_name in const_enum:\n        return const_enum[constant_name]\n    else:\n        return False\ndef parse_file(file, const_enum):\n    g_logger.debug(\"Parsing %s\" % file)\n    try:\n        text_file = open(file, \"r\")\n    except IOError as e:",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "parse_file",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def parse_file(file, const_enum):\n    g_logger.debug(\"Parsing %s\" % file)\n    try:\n        text_file = open(file, \"r\")\n    except IOError as e:\n        g_logger.warn(\"Could not read file \" + file + e.message)\n        return None\n    content = text_file.read().translate(None, \"\\r\\n\")\n    text_file.close()\n    if content.find(\"ph:apidata\") != -1:",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "to_xml",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def to_xml(results):\n    xml_string = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?>\"\n    xml_string = xml_string + \"<msdn>\\n\"\n    xml_string = xml_string + \"<functions>\\n\"\n    #for (dll, fct, _, args, cd, _, _) in results:\n    #    print '\\t', dll, fct\n    #    print '\\t\\t', args\n    #    print '\\t\\t\\t', cd\n    for (dll_name, function_name, description, arguments, constant_data,\n         constant_enum, return_value) in results:",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "exclude_dir",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def exclude_dir(directory):\n    exclude_dirs = [\"\\\\1033\\\\html\", \"\\\\1033\\\\workshop\"]\n    for exclude_dir in exclude_dirs:\n        if directory.find(exclude_dir) != -1:\n            return True\n    return False\ndef parse_files(msdn_directory, tilib_exe, til_dir):\n    \"\"\"\n    Return parsed information from MSDN documentation\n    \"\"\"",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "parse_files",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def parse_files(msdn_directory, tilib_exe, til_dir):\n    \"\"\"\n    Return parsed information from MSDN documentation\n    \"\"\"\n    file_counter = 0\n    results = []\n    const_enum = {}\n    const_enum = extract_til_constant_info.main(tilib_exe, til_dir)\n    if not const_enum:\n        g_logger.warn('Could not extract information from TIL files')",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "show_usage",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def show_usage():\n    print 'Usage:',\n    print sys.argv[0] + ' <path to msdn> <path to tilib> <til directory>'\ndef main():\n    print \"MSDN crawler based on zynamics msdn-crawler - Copyright 2010\"\n    if len(sys.argv) < 4:\n        show_usage()\n        sys.exit(1)\n    if \"-v\" in sys.argv:\n        logging.basicConfig(level=logging.DEBUG)",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "def main():\n    print \"MSDN crawler based on zynamics msdn-crawler - Copyright 2010\"\n    if len(sys.argv) < 4:\n        show_usage()\n        sys.exit(1)\n    if \"-v\" in sys.argv:\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        logging.basicConfig(level=logging.WARN)\n    msdn_directory = sys.argv[1]",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "MSDN_INFO_FILE",
        "kind": 5,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "MSDN_INFO_FILE = 'msdn_data.xml'\ng_logger = logging.getLogger(__name__)\ndef strip_html(string):\n    r1 = re.compile(\"<.*?>\")\n    r2 = re.compile(\" +\")\n    return r2.sub(\" \", r1.sub(\"\", string).replace(\"&nbsp;\", \" \")\n                  .replace(\"\\t\", \" \").replace(\"&)\", \")\")\n                  .replace(\"&#8211;\", \"-\").replace(\"&#8212;\", \"-\")\n                  .replace(\"&#160;\", \" \"))\ndef parse_old_style(file, content):",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "g_logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "description": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "peekOfCode": "g_logger = logging.getLogger(__name__)\ndef strip_html(string):\n    r1 = re.compile(\"<.*?>\")\n    r2 = re.compile(\" +\")\n    return r2.sub(\" \", r1.sub(\"\", string).replace(\"&nbsp;\", \" \")\n                  .replace(\"\\t\", \" \").replace(\"&)\", \")\")\n                  .replace(\"&#8211;\", \"-\").replace(\"&#8212;\", \"-\")\n                  .replace(\"&#160;\", \" \"))\ndef parse_old_style(file, content):\n    m = re.search(",
        "detail": "plugins.flare-ida.MSDN_crawler.msdn_crawler",
        "documentation": {}
    },
    {
        "label": "apply_callee_type_plugin_t",
        "kind": 6,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "class apply_callee_type_plugin_t(idaapi.plugin_t):\n    flags = 0\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = \"\"\n    def init(self):\n        idaapi.msg('apply_callee_type_plugin:init\\n')\n        installMenu()\n        return idaapi.PLUGIN_OK",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "installMenuIda7",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "def installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1\n        def update(self, ctx):\n            return idaapi.AST_ENABLE_FOR_WIDGET if ctx.widget_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_WIDGET\n    ret = idaapi.register_action(idaapi.action_desc_t(\n            ACTION_NAME,            # Name. Acts as an ID. Must be unique.\n            PLUGIN_NAME,            # Label. That's what users see.",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "installMenu",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "def installMenu():\n    #hack -> stashing a flag under idaapi to prevent multiple menu items from appearing\n    if hasattr(sys.modules['idaapi'], '_apply_callee_type_plugin_installFlag'):\n        #print('Skipping menu install: already present')\n        return\n    if using_ida7api:\n        return installMenuIda7()\n    global ex_addmenu_item_ctx\n    ex_addmenu_item_ctx = idaapi.add_menu_item(\n        MENU_PATH, ",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    try:\n        return apply_callee_type_plugin_t()\n    except Exception as err:\n        import traceback\n        msg(\"Error: %s\\n%s\" % (str(err), traceback.format_exc()))\n        raise\ndef doApplyCallee(*args):\n    #idaapi.msg('doApplyCallee:Calling now\\n')\n    flare.apply_callee_type.main()",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "doApplyCallee",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "def doApplyCallee(*args):\n    #idaapi.msg('doApplyCallee:Calling now\\n')\n    flare.apply_callee_type.main()",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HELP",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "PLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"ApplyCalleeType\"\nPREFERRED_SHORTCUT = \"Alt-J\"\nPLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None ",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "PLUGIN_NAME = \"ApplyCalleeType\"\nPREFERRED_SHORTCUT = \"Alt-J\"\nPLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PREFERRED_SHORTCUT",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "PREFERRED_SHORTCUT = \"Alt-J\"\nPLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_COMMENT",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "PLUGIN_COMMENT = \"Apply callee type to indirect call location\"\nACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "ACTION_NAME",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "ACTION_NAME = 'flare:apply_callee_type'\nMENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "MENU_PATH",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "MENU_PATH = \"Edit/Operand type/Manual\"\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1\n        def update(self, ctx):\n            return idaapi.AST_ENABLE_FOR_WIDGET if ctx.widget_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_WIDGET\n    ret = idaapi.register_action(idaapi.action_desc_t(",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "ex_addmenu_item_ctx",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "description": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "peekOfCode": "ex_addmenu_item_ctx = None \ndef installMenuIda7():\n    class ApplyCalleeHandler(idaapi.action_handler_t):\n        def activate(self, ctx):\n            doApplyCallee()\n            return 1\n        def update(self, ctx):\n            return idaapi.AST_ENABLE_FOR_WIDGET if ctx.widget_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_WIDGET\n    ret = idaapi.register_action(idaapi.action_desc_t(\n            ACTION_NAME,            # Name. Acts as an ID. Must be unique.",
        "detail": "plugins.flare-ida.plugins.apply_callee_type_plugin",
        "documentation": {}
    },
    {
        "label": "shellcode_search_plugin_t",
        "kind": 6,
        "importPath": "plugins.flare-ida.plugins.shellcode_hashes_search_plugin",
        "description": "plugins.flare-ida.plugins.shellcode_hashes_search_plugin",
        "peekOfCode": "class shellcode_search_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"This is a comment\"\n    help = \"This is help\"\n    wanted_name = \"Shellcode Hashes\"\n    wanted_hotkey = \"\"\n    def init(self):\n        return idaapi.PLUGIN_OK\n    def run(self, arg):\n        flare.shellcode_hash_search.main()",
        "detail": "plugins.flare-ida.plugins.shellcode_hashes_search_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.shellcode_hashes_search_plugin",
        "description": "plugins.flare-ida.plugins.shellcode_hashes_search_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return shellcode_search_plugin_t()",
        "detail": "plugins.flare-ida.plugins.shellcode_hashes_search_plugin",
        "documentation": {}
    },
    {
        "label": "stackstrings_plugin_t",
        "kind": 6,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "class stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_WANTED_HOTKEY\n    def init(self):\n        try:\n            idaapi.msg(\"StackStrings init() called!\\n\")\n            return idaapi.PLUGIN_OK",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return stackstrings_plugin_t()",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "is_py2 = (sys.version_info[0] == 2)\nif is_py2:\n    # currently depending on vivisect, which will never be ported to py3\n    idaapi.require('flare')\n    idaapi.require('flare.stackstrings')\nPLUGIN_COMMENT = \"This is a comment\"\nPLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_COMMENT",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_COMMENT = \"This is a comment\"\nPLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HELP",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_HELP = \"This is help\"\nPLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_NAME = \"StackStrings\"\nPLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_WANTED_HOTKEY",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "PLUGIN_WANTED_HOTKEY = \"Alt-0\"\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))\nusing_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_WANTED_HOTKEY\n    def init(self):\n        try:",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "ex_addmenu_item_ctx",
        "kind": 5,
        "importPath": "plugins.flare-ida.plugins.stackstrings_plugin",
        "description": "plugins.flare-ida.plugins.stackstrings_plugin",
        "peekOfCode": "ex_addmenu_item_ctx = None \nclass stackstrings_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_KEEP\n    comment = PLUGIN_COMMENT\n    help = PLUGIN_HELP\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_WANTED_HOTKEY\n    def init(self):\n        try:\n            idaapi.msg(\"StackStrings init() called!\\n\")",
        "detail": "plugins.flare-ida.plugins.stackstrings_plugin",
        "documentation": {}
    },
    {
        "label": "struct_typer_plugin_t",
        "kind": 6,
        "importPath": "plugins.flare-ida.plugins.struct_typer_plugin",
        "description": "plugins.flare-ida.plugins.struct_typer_plugin",
        "peekOfCode": "class struct_typer_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"This is a comment\"\n    help = \"This is help\"\n    wanted_name = \"StructTyper\"\n    wanted_hotkey = \"\"\n    def init(self):\n        #idaapi.msg(\"StructTyper init() called!\\n\")\n        return idaapi.PLUGIN_OK\n    def run(self, arg):",
        "detail": "plugins.flare-ida.plugins.struct_typer_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.flare-ida.plugins.struct_typer_plugin",
        "description": "plugins.flare-ida.plugins.struct_typer_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return struct_typer_plugin_t()",
        "detail": "plugins.flare-ida.plugins.struct_typer_plugin",
        "documentation": {}
    },
    {
        "label": "ParsingException",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "class ParsingException(Exception):\n    def __init__(self, message):\n        super(ParsingException, self).__init__(message)\n        self.message = message\nclass Argument:\n    def __init__(self):\n        self.name = \"\"\n        self.description = \"\"\n        self.constants = []\n        self.enums = []",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "Argument",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "class Argument:\n    def __init__(self):\n        self.name = \"\"\n        self.description = \"\"\n        self.constants = []\n        self.enums = []\n        self._logger = logging.getLogger(\n            __name__ + '.' + self.__class__.__name__)\n    def __str__(self):\n        return (\"(%s, %s): %s\" % (self.name, self.enums, self.description)).encode(\"ISO-8859-1\")",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "Constant",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "class Constant:\n    def __init__(self):\n        self.name = \"\"\n        self.value = \"\"\n        self.description = \"\"\n        self._logger = logging.getLogger(\n            __name__ + '.' + self.__class__.__name__)\n    def __str__(self):\n        return (\"(%s, %s)\" % (self.name, self.value)).encode(\"ISO-8859-1\")\n    def __repr__(self):",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "class Function:\n    def __init__(self):\n        self.name = \"\"\n        self.dll = \"\"\n        self.description = \"\"\n        self.arguments = []\n        self.returns = \"\"\n        self._logger = logging.getLogger(\n            __name__ + '.' + self.__class__.__name__)\n    def __str__(self):",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "FunctionHandler",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "class FunctionHandler(xml.sax.handler.ContentHandler):\n    c = itertools.count()\n    IN_FUNCTION = next(c)\n    IN_FUNCTION_NAME = next(c)\n    IN_DLL = next(c)\n    IN_FUNCTION_DESCRIPTION = next(c)\n    IN_ARGUMENTS = next(c)\n    IN_ARGUMENT = next(c)\n    IN_ARGUMENT_NAME = next(c)\n    IN_ARGUMENT_DESCRIPTION = next(c)",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "def parse(xmlfile):\n    \"\"\"\n    Return parsed MSDN information.\n    Argument:\n    xmlfile -- xml data file storing the MSDN information\n    \"\"\"\n    g_logger.info('Starting parsing ' + xmlfile)\n    parser = xml.sax.make_parser()\n    try:\n        handler = FunctionHandler()",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "g_logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "description": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "peekOfCode": "g_logger = logging.getLogger(__name__)\ndef parse(xmlfile):\n    \"\"\"\n    Return parsed MSDN information.\n    Argument:\n    xmlfile -- xml data file storing the MSDN information\n    \"\"\"\n    g_logger.info('Starting parsing ' + xmlfile)\n    parser = xml.sax.make_parser()\n    try:",
        "detail": "plugins.flare-ida.python.flare.IDB_MSDN_Annotator.xml_parser",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def main():\n    eh = flare_emu.EmuHelper()\n    # hacky way to increase stack size (default is 0x2000 and it's really only half, because the stack pointer begins\n    # in the middle of the allocated stack size); for functions with larger stacks this caused issues, see e.g.,\n    # https://github.com/mandiant/flare-ida/issues/127\n    eh.stackSize = 0x8000\n    eh.resetEmulatorHeapAndStack()\n    # dictionary that stores data used across emulation runs, function emulation specific data is set below\n    userData = {\n        # found stackstrings in stack memory",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "instr_hook",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def instr_hook(uc, address, size, userData):\n    \"\"\"\n    Hook that runs before every instruction. Performs emulation sanity checks.\n    Extract stackstrings at end of a basic block (bb) if bb contains enough memory writes.\n    No success with UC_HOOK_BLOCK as bbs may differ between IDA and Unicorn\n    :param uc: Unicorn object\n    :param address: current instruction address\n    :param size: current instruction size\n    :param userData: user-provided data\n    :return: None",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "call_hook",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def call_hook(address, argv, funcName, userData):\n    \"\"\"\n    Hook all function calls. Extract stackstrings.\n    :param address: address of call\n    :param argv: call arguments\n    :param funcName: name of called function\n    :param userData: user-provided data\n    :return: None\n    \"\"\"\n    # IMPROVEMENT record funcName",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "hook_mem_write",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def hook_mem_write(uc, access, address, size, value, userData):\n    \"\"\"\n    Hook all memory read and write events. Count memory writes and record written address locations.\n    :param uc: Unicorn object\n    :param access: memory access type\n    :param address: memory address\n    :param size: memory address size\n    :param value: memory value\n    :param userData: user-provided data\n    :return: None",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "noop",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def noop(*args):\n    \"\"\"\n    No operation callback\n    :param args:\n    :return: None\n    \"\"\"\ndef get_bb_ends(address):\n    \"\"\"\n    Get end addresses of all bbs in function containing address.\n    :param address: address in function",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "get_bb_ends",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def get_bb_ends(address):\n    \"\"\"\n    Get end addresses of all bbs in function containing address.\n    :param address: address in function\n    :return: list of bb end addresses\n    \"\"\"\n    function = idaapi.get_func(address)\n    flowchart = idaapi.FlowChart(function)\n    return [idc.prev_head(bb.end_ea) for bb in flowchart]\ndef update_init_sp(address, userData):",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "update_init_sp",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def update_init_sp(address, userData):\n    \"\"\"\n    Hack to get stack pointer at beginning of emulation.\n    :param address: current instruction address\n    :param userData: user-provided data\n    :return: None\n    \"\"\"\n    eh = userData[\"EmuHelper\"]\n    if address == userData[\"funcStart\"]:\n        userData[\"init_sp\"] = eh.getRegVal(\"sp\")",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "update_stackstrings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def update_stackstrings(address, userData):\n    \"\"\"\n    Extract stackstrings and update userData value.\n    :param address: current instruction address\n    :param userData: user-provided data\n    :return: None\n    \"\"\"\n    eh = userData[\"EmuHelper\"]\n    stack_top = eh.getRegVal(\"sp\")\n    stack_start, stack_end = eh.getEmuMemRegion(eh.stack)",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "update_globalstrings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def update_globalstrings(address, userData):\n    \"\"\"\n    Extract stackstrings in global memory and update userData value.\n    :param address: current instruction address\n    :param userData: user-provided data\n    :return: None\n    \"\"\"\n    globalstrings = userData[\"globalstrings\"]\n    mem_writes = userData[\"mem_writes\"]\n    # consolidate memory write ranges",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "extract_all_strings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def extract_all_strings(stack_buf):\n    \"\"\"\n    Extract ASCII and UTF-16 strings from buffer.\n    :param stack_buf: memory buffer\n    :return: Extracted String namedtuples\n    \"\"\"\n    for s in strings.extract_ascii_strings(stack_buf):\n        yield s\n    for s in strings.extract_unicode_strings(stack_buf):\n        yield s",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "get_offset_written_at",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def get_offset_written_at(ss_va, mem_writes):\n    \"\"\"\n    Get instruction address where string was initially written.\n    Removes false positives, e.g. when addresses got pushed that contain a part in ASCII range\n    :param ss_va: identified string offset\n    :param mem_writes: record of all memory writes\n    :return: tuple: string offset, address where string was written\n    \"\"\"\n    offset = 0\n    written_at = None",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "consolidate",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def consolidate(intervals):\n    \"\"\"\n    Consolidate interval ranges via https://codereview.stackexchange.com/a/69249.\n    :param intervals: set of tuples with start and end address\n    :return: list of consolidated intervals\n    \"\"\"\n    sorted_by_lower_bound = sorted(intervals, key=lambda tup: tup[0])\n    merged = []\n    for higher in sorted_by_lower_bound:\n        if not merged:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "does_contain",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def does_contain(stackstrings, ss):\n    \"\"\"\n    Check existence of stackstring in list.\n    :param stackstrings: list of all recovered stackstrings\n    :param ss: new stackstring candidate\n    :return: True if candidate already in stackstring list, False otherwise\n    \"\"\"\n    hashable_ss = (ss.fva, ss.s, ss.written_at)\n    for s in stackstrings:\n        hashable = (s.fva, s.s, s.written_at)",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "does_contain_substr",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def does_contain_substr(stackstrings, new_ss):\n    \"\"\"\n    Check if new string is a substring of an existing stackstring.\n    :param stackstrings: list of all recovered stackstrings\n    :param new_ss: new stackstring candidate\n    :return: True if candidate substring of an existing stackstring, False otherwise\n    \"\"\"\n    # IMPROVEMENT incorporate written_at in check\n    for ss in filter(lambda es: es.fva == new_ss.fva, stackstrings):\n        if new_ss.s in ss.s:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "extend_existing",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def extend_existing(new_string, existing_strings):\n    \"\"\"\n    Update an existing string if a new string extends it.\n    :param new_string: new recovered string\n    :param existing_strings: list of already recovered strings\n    :return: True if extended existing string, False otherwise\n    \"\"\"\n    for i, existing in enumerate(existing_strings):\n        if existing.s in new_string.s:\n            logging.debug(\"updating string %s to %s\", existing.s, new_string.s)",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "print_header",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def print_header():\n    \"\"\"\n    Print formatted header\n    :return: None\n    \"\"\"\n    print(\"{:16}   {:16}   {:16}   {:16}\".format(\"Function\", \"Written at\", \"Offset\", \"String\"))\n    print(\"{s:-<16}   {s:-<16}   {s:-<16}   {s:-<16}\".format(s=\"\"))\ndef print_string(fva, written_at, offset, s):\n    \"\"\"\n    Print formatted stackstring",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "print_string",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def print_string(fva, written_at, offset, s):\n    \"\"\"\n    Print formatted stackstring\n    :param fva: function address containing stackstring\n    :param written_at: instruction address where stackstring was written\n    :param offset: memory offset (stack relative or global) where string was written\n    :param s: recovered stackstring\n    :return: None\n    \"\"\"\n    if written_at:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "print_summary",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def print_summary(cnt_functions, cnt_analyzed, cnt_found, cnt_commented, errors):\n    \"\"\"\n    Print analysis summary.\n    :param cnt_functions: number of identified functions\n    :param cnt_analyzed: number of successfully analyzed functions\n    :param cnt_found: number of recovered stackstrings\n    :param cnt_commented: number of commented stackstrings\n    :param errors: list of encountered error message strings\n    :return: None\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "print_plain_summary",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def print_plain_summary(stackstrings):\n    unique = get_unique_strings(stackstrings)\n    print(\"\\nRecovered {:d} unique stackstrings\\n{:-<24}\".format(len(unique), \"\"))\n    for s in unique:\n        print(\"{}\".format(s))\ndef get_unique_strings(stackstrings):\n    \"\"\"\n    Get unique recovered stackstrings.\n    :param stackstrings: list of all stackstrings\n    :return: list of unique stackstrings",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "get_unique_strings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def get_unique_strings(stackstrings):\n    \"\"\"\n    Get unique recovered stackstrings.\n    :param stackstrings: list of all stackstrings\n    :return: list of unique stackstrings\n    \"\"\"\n    unique = set()\n    for ss in stackstrings:\n        unique.add(ss.s)\n    return unique",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "format_comment",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def format_comment(comment):\n    \"\"\"\n    Wrap comment with prefix and suffix.\n    :param comment: comment string\n    :return: formatted comment string\n    \"\"\"\n    return \"{prefix}{cmt}{suffix}\".format(prefix=COMMENT_STACKSTRING_PREFIX, cmt=comment,\n                                          suffix=COMMENT_STACKSTRING_SUFFIX)\ndef append_comment(va, new_cmt, repeatable=False):\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "append_comment",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "def append_comment(va, new_cmt, repeatable=False):\n    \"\"\"\n    Append a comment to an address in IDA Pro.\n    :param va: comment address\n    :param new_cmt: comment string\n    :param repeatable: if True, append as repeatable comment\n    :return: True if success\n    \"\"\"\n    cmt = idc.get_cmt(va, repeatable)\n    if not cmt:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "ANALYZE_SINGLE_FUNC",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "ANALYZE_SINGLE_FUNC = False\n# jump to currently analyzed function\nJUMP_TO_FUNC = False\n# print listing of unique stackstrings after running\nPRINT_PLAIN_SUMMARY = True\n# add comments for recovered stackstrings\nCOMMENT_STACKSTRINGS = True\n# use a repeatable comment on the global memory address\nCOMMENT_STACKSTRING_GLOBAL_REPEATABLE = False\n# prefix used for stackstring comment",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "JUMP_TO_FUNC",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "JUMP_TO_FUNC = False\n# print listing of unique stackstrings after running\nPRINT_PLAIN_SUMMARY = True\n# add comments for recovered stackstrings\nCOMMENT_STACKSTRINGS = True\n# use a repeatable comment on the global memory address\nCOMMENT_STACKSTRING_GLOBAL_REPEATABLE = False\n# prefix used for stackstring comment\nCOMMENT_STACKSTRING_PREFIX = \"stackstring: '\"\n# suffix used for stackstring comment",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "PRINT_PLAIN_SUMMARY",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "PRINT_PLAIN_SUMMARY = True\n# add comments for recovered stackstrings\nCOMMENT_STACKSTRINGS = True\n# use a repeatable comment on the global memory address\nCOMMENT_STACKSTRING_GLOBAL_REPEATABLE = False\n# prefix used for stackstring comment\nCOMMENT_STACKSTRING_PREFIX = \"stackstring: '\"\n# suffix used for stackstring comment\nCOMMENT_STACKSTRING_SUFFIX = \"'\"\n#",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "COMMENT_STACKSTRINGS",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "COMMENT_STACKSTRINGS = True\n# use a repeatable comment on the global memory address\nCOMMENT_STACKSTRING_GLOBAL_REPEATABLE = False\n# prefix used for stackstring comment\nCOMMENT_STACKSTRING_PREFIX = \"stackstring: '\"\n# suffix used for stackstring comment\nCOMMENT_STACKSTRING_SUFFIX = \"'\"\n#\n# STACKSTRINGS RECOVERY OPTIONS\n#",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "COMMENT_STACKSTRING_GLOBAL_REPEATABLE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "COMMENT_STACKSTRING_GLOBAL_REPEATABLE = False\n# prefix used for stackstring comment\nCOMMENT_STACKSTRING_PREFIX = \"stackstring: '\"\n# suffix used for stackstring comment\nCOMMENT_STACKSTRING_SUFFIX = \"'\"\n#\n# STACKSTRINGS RECOVERY OPTIONS\n#\n# maximum number of code paths to find through each function\nMAX_CODE_PATHS = 10",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "COMMENT_STACKSTRING_PREFIX",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "COMMENT_STACKSTRING_PREFIX = \"stackstring: '\"\n# suffix used for stackstring comment\nCOMMENT_STACKSTRING_SUFFIX = \"'\"\n#\n# STACKSTRINGS RECOVERY OPTIONS\n#\n# maximum number of code paths to find through each function\nMAX_CODE_PATHS = 10\n# minimum number of memory writes in a basic block to trigger stackstring recovery\nMIN_MEM_WRITE_COUNT = 5",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "COMMENT_STACKSTRING_SUFFIX",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "COMMENT_STACKSTRING_SUFFIX = \"'\"\n#\n# STACKSTRINGS RECOVERY OPTIONS\n#\n# maximum number of code paths to find through each function\nMAX_CODE_PATHS = 10\n# minimum number of memory writes in a basic block to trigger stackstring recovery\nMIN_MEM_WRITE_COUNT = 5\n# maximum number an instruction is repeated\nMAX_INSTR_REP = 0x100",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "MAX_CODE_PATHS",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "MAX_CODE_PATHS = 10\n# minimum number of memory writes in a basic block to trigger stackstring recovery\nMIN_MEM_WRITE_COUNT = 5\n# maximum number an instruction is repeated\nMAX_INSTR_REP = 0x100\n# maximum size of current stack frame\n# IMPROVEMENT fine tune this value\nMAX_STACK_SIZE = 0x10000\nStackString = namedtuple(\"StackString\",\n                         [",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "MIN_MEM_WRITE_COUNT",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "MIN_MEM_WRITE_COUNT = 5\n# maximum number an instruction is repeated\nMAX_INSTR_REP = 0x100\n# maximum size of current stack frame\n# IMPROVEMENT fine tune this value\nMAX_STACK_SIZE = 0x10000\nStackString = namedtuple(\"StackString\",\n                         [\n                             # function address from which the stackstring was extracted\n                             \"fva\",",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "MAX_INSTR_REP",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "MAX_INSTR_REP = 0x100\n# maximum size of current stack frame\n# IMPROVEMENT fine tune this value\nMAX_STACK_SIZE = 0x10000\nStackString = namedtuple(\"StackString\",\n                         [\n                             # function address from which the stackstring was extracted\n                             \"fva\",\n                             # program counter at which the stackstring existed\n                             \"pc\",",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "MAX_STACK_SIZE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "MAX_STACK_SIZE = 0x10000\nStackString = namedtuple(\"StackString\",\n                         [\n                             # function address from which the stackstring was extracted\n                             \"fva\",\n                             # program counter at which the stackstring existed\n                             \"pc\",\n                             # string contents\n                             \"s\",\n                             # for local stackstring: offset from the function frame at which the stackstring",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "StackString",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "description": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "peekOfCode": "StackString = namedtuple(\"StackString\",\n                         [\n                             # function address from which the stackstring was extracted\n                             \"fva\",\n                             # program counter at which the stackstring existed\n                             \"pc\",\n                             # string contents\n                             \"s\",\n                             # for local stackstring: offset from the function frame at which the stackstring\n                             # existed, for globalstring: offset in global memory",
        "detail": "plugins.flare-ida.python.flare.ironstrings.ironstrings",
        "documentation": {}
    },
    {
        "label": "buf_filled_with",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "def buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]\n        if dupe_chunk[:len(new_chunk)] != new_chunk:\n            return False\n    return True\ndef extract_ascii_strings(buf, n=4):\n    '''\n    Extract ASCII strings from the given binary data.",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "extract_ascii_strings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "def extract_ascii_strings(buf, n=4):\n    '''\n    Extract ASCII strings from the given binary data.\n    :param buf: A bytestring.\n    :type buf: str\n    :param n: The minimum length of strings to extract.\n    :type n: int\n    :rtype: Sequence[String]\n    '''\n    if not buf:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "extract_unicode_strings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "def extract_unicode_strings(buf, n=4):\n    '''\n    Extract naive UTF-16 strings from the given binary data.\n    :param buf: A bytestring.\n    :type buf: str\n    :param n: The minimum length of strings to extract.\n    :type n: int\n    :rtype: Sequence[String]\n    '''\n    if not buf:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "def main():\n    import sys\n    with open(sys.argv[1], 'rb') as f:\n        b = f.read()\n    for s in extract_ascii_strings(b):\n        print('0x{:x}: {:s}'.format(s.offset, s.s))\n    for s in extract_unicode_strings(b):\n        print('0x{:x}: {:s}'.format(s.offset, s.s))\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "ASCII_BYTE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "ASCII_BYTE = r\" !\\\"#\\$%&\\'\\(\\)\\*\\+,-\\./0123456789:;<=>\\?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\]\\^_`abcdefghijklmnopqrstuvwxyz\\{\\|\\}\\\\\\~\\t\"\nASCII_RE_4 = re.compile(b\"([%s]{%d,})\" % (ASCII_BYTE.encode(\"ascii\"), 4))\nUNICODE_RE_4 = re.compile(b\"((?:[%s]\\x00){%d,})\" % (ASCII_BYTE.encode(\"ascii\"), 4))\nREPEATS = [\"A\", \"\\x00\", \"\\xfe\", \"\\xff\"]\nSLICE_SIZE = 4096\nString = namedtuple(\"String\", [\"s\", \"offset\"])\ndef buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "ASCII_RE_4",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "ASCII_RE_4 = re.compile(b\"([%s]{%d,})\" % (ASCII_BYTE.encode(\"ascii\"), 4))\nUNICODE_RE_4 = re.compile(b\"((?:[%s]\\x00){%d,})\" % (ASCII_BYTE.encode(\"ascii\"), 4))\nREPEATS = [\"A\", \"\\x00\", \"\\xfe\", \"\\xff\"]\nSLICE_SIZE = 4096\nString = namedtuple(\"String\", [\"s\", \"offset\"])\ndef buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]\n        if dupe_chunk[:len(new_chunk)] != new_chunk:",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "UNICODE_RE_4",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "UNICODE_RE_4 = re.compile(b\"((?:[%s]\\x00){%d,})\" % (ASCII_BYTE.encode(\"ascii\"), 4))\nREPEATS = [\"A\", \"\\x00\", \"\\xfe\", \"\\xff\"]\nSLICE_SIZE = 4096\nString = namedtuple(\"String\", [\"s\", \"offset\"])\ndef buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]\n        if dupe_chunk[:len(new_chunk)] != new_chunk:\n            return False",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "REPEATS",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "REPEATS = [\"A\", \"\\x00\", \"\\xfe\", \"\\xff\"]\nSLICE_SIZE = 4096\nString = namedtuple(\"String\", [\"s\", \"offset\"])\ndef buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]\n        if dupe_chunk[:len(new_chunk)] != new_chunk:\n            return False\n    return True",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "SLICE_SIZE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "SLICE_SIZE = 4096\nString = namedtuple(\"String\", [\"s\", \"offset\"])\ndef buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]\n        if dupe_chunk[:len(new_chunk)] != new_chunk:\n            return False\n    return True\ndef extract_ascii_strings(buf, n=4):",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "String",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.ironstrings.strings",
        "description": "plugins.flare-ida.python.flare.ironstrings.strings",
        "peekOfCode": "String = namedtuple(\"String\", [\"s\", \"offset\"])\ndef buf_filled_with(buf, character):\n    dupe_chunk = character * SLICE_SIZE\n    for offset in xrange(0, len(buf), SLICE_SIZE):\n        new_chunk = buf[offset: offset + SLICE_SIZE]\n        if dupe_chunk[:len(new_chunk)] != new_chunk:\n            return False\n    return True\ndef extract_ascii_strings(buf, n=4):\n    '''",
        "detail": "plugins.flare-ida.python.flare.ironstrings.strings",
        "documentation": {}
    },
    {
        "label": "MSDNAnnotationDialog",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "description": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "peekOfCode": "class MSDNAnnotationDialog(QtWidgets.QDialog):\n    def read_config(self):\n        config = {}\n        if not self.config_parser.has_section('Functions') or \\\n           not self.config_parser.has_section('Arguments') or \\\n           not self.config_parser.has_section('Constants'):\n            # Create default\n            self.config_parser.add_section('Functions')\n            self.config_parser.add_section('Arguments')\n            self.config_parser.add_section('Constants')",
        "detail": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "documentation": {}
    },
    {
        "label": "getDefaultMsdnDataDir",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "description": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "peekOfCode": "def getDefaultMsdnDataDir():\n    return os.path.abspath(os.path.join(idaapi.get_user_idadir(), 'MSDN_data'))\nclass MSDNAnnotationDialog(QtWidgets.QDialog):\n    def read_config(self):\n        config = {}\n        if not self.config_parser.has_section('Functions') or \\\n           not self.config_parser.has_section('Arguments') or \\\n           not self.config_parser.has_section('Constants'):\n            # Create default\n            self.config_parser.add_section('Functions')",
        "detail": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "description": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "peekOfCode": "CONFIG_FILE = 'MSDN_annotations.cfg'\ng_logger = logging.getLogger(__name__)\ndef getDefaultMsdnDataDir():\n    return os.path.abspath(os.path.join(idaapi.get_user_idadir(), 'MSDN_data'))\nclass MSDNAnnotationDialog(QtWidgets.QDialog):\n    def read_config(self):\n        config = {}\n        if not self.config_parser.has_section('Functions') or \\\n           not self.config_parser.has_section('Arguments') or \\\n           not self.config_parser.has_section('Constants'):",
        "detail": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "documentation": {}
    },
    {
        "label": "g_logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "description": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "peekOfCode": "g_logger = logging.getLogger(__name__)\ndef getDefaultMsdnDataDir():\n    return os.path.abspath(os.path.join(idaapi.get_user_idadir(), 'MSDN_data'))\nclass MSDNAnnotationDialog(QtWidgets.QDialog):\n    def read_config(self):\n        config = {}\n        if not self.config_parser.has_section('Functions') or \\\n           not self.config_parser.has_section('Arguments') or \\\n           not self.config_parser.has_section('Constants'):\n            # Create default",
        "detail": "plugins.flare-ida.python.flare.annotate_IDB_MSDN",
        "documentation": {}
    },
    {
        "label": "ApplyCalleeTypeRunner",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "class ApplyCalleeTypeRunner(object):\n    #def __init__(self):\n    #    self.logger = jayutils.getLogger('ApplyCalleeType')\n    def getUserDeclType(self, decl):\n        tinfo = idaapi.tinfo_t()\n        #logger.debug('Trying to parse declaration: %r', decl)\n        ret = idaapi.parse_decl(tinfo, idaapi.cvar.idati, decl, idaapi.PT_TYP)\n        #logger.debug('Return from parse_decl2: %r', ret)\n        if ret is None:\n            logger.info('parse_decl failed')",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "ApplyCalleeTypeWidget",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "class ApplyCalleeTypeWidget(QtWidgets.QDialog):\n    UNKNOWN_TYPE    = 0\n    USER_TYPE       = 1\n    STANDARD_TYPE   = 2\n    LOCAL_TYPE      = 3\n    def __init__(self, parent=None):\n        QtWidgets.QDialog.__init__(self, parent)\n        try:\n            self.tinfo = None\n            self.inputType = self.USER_TYPE",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "predFunc",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "def predFunc(*args):\n    print('Running predFunc: %s' % str(args))\ndef manualTypeCopy(dest, destOff, destLen, src):\n    '''Copies an IDA type 'string' to the given location'''\n    i = 0\n    while (i+destOff) < destLen:\n        dest[i+destOff] = chr(src[i])\n        if (src[i] == 0) or (src[i] == '\\x00'):\n            break\n        i += 1",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "manualTypeCopy",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "def manualTypeCopy(dest, destOff, destLen, src):\n    '''Copies an IDA type 'string' to the given location'''\n    i = 0\n    while (i+destOff) < destLen:\n        dest[i+destOff] = chr(src[i])\n        if (src[i] == 0) or (src[i] == '\\x00'):\n            break\n        i += 1\nclass ApplyCalleeTypeRunner(object):\n    #def __init__(self):",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "def main():\n    try:\n        global logger\n        #logger = jayutils.configLogger(__name__, logging.DEBUG)\n        logger = jayutils.configLogger(__name__, logging.INFO)\n        launcher = ApplyCalleeTypeRunner()\n        launcher.run()\n    except Exception as err:\n        import traceback\n        print(('Error in act: %s: %s' % (str(err), traceback.format_exc())))",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "logger = None\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nMSDN_MACROS = [\n' _In_ ',\n' _Out_ ',\n' _Inout_ ',\n]\ndef predFunc(*args):",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nMSDN_MACROS = [\n' _In_ ',\n' _Out_ ',\n' _Inout_ ',\n]\ndef predFunc(*args):\n    print('Running predFunc: %s' % str(args))\ndef manualTypeCopy(dest, destOff, destLen, src):\n    '''Copies an IDA type 'string' to the given location'''",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "MSDN_MACROS",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type",
        "description": "plugins.flare-ida.python.flare.apply_callee_type",
        "peekOfCode": "MSDN_MACROS = [\n' _In_ ',\n' _Out_ ',\n' _Inout_ ',\n]\ndef predFunc(*args):\n    print('Running predFunc: %s' % str(args))\ndef manualTypeCopy(dest, destOff, destLen, src):\n    '''Copies an IDA type 'string' to the given location'''\n    i = 0",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type",
        "documentation": {}
    },
    {
        "label": "Ui_ApplyCalleeDialog",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.apply_callee_type_widget",
        "description": "plugins.flare-ida.python.flare.apply_callee_type_widget",
        "peekOfCode": "class Ui_ApplyCalleeDialog(object):\n    def setupUi(self, ApplyCalleeDialog):\n        ApplyCalleeDialog.setObjectName(\"ApplyCalleeDialog\")\n        ApplyCalleeDialog.resize(682, 313)\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout(ApplyCalleeDialog)\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.verticalLayout = QtWidgets.QVBoxLayout()\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")",
        "detail": "plugins.flare-ida.python.flare.apply_callee_type_widget",
        "documentation": {}
    },
    {
        "label": "RegMonitor",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "class RegMonitor(viv_imp_monitor.EmulationMonitor):\n    '''\n    This tracks all register changes, even if it's not currently an interesting reg\n    because we need to trace register changes backwards.\n    '''\n    def __init__(self, regs):\n        viv_imp_monitor.EmulationMonitor.__init__(self)\n        self.logger = jayutils.getLogger('argracker.RegMonitor')\n        self.regs = regs[:]\n        self.reg_map = {}",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "TrackerState",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "class TrackerState(object):\n    def __init__(self, tracker, baseEntry, num, regs):\n        '''\n        desiredState: list of stackArgNums and register names\n        '''\n        self.tracker = tracker\n        self.baseEntry = baseEntry\n        self.num = num\n        self.regs = regs[:]\n        self.ptrsize = tracker.ptrsize",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "ArgTracker",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "class ArgTracker(object):\n    def __init__(self, vw, maxIters=1000):\n        self.logger = jayutils.getLogger('argracker.ArgTracker')\n        self.logger.debug('Starting up here')\n        self.vw = vw\n        self.lastFunc = 0\n        self.va_write_map = None\n        self.codesize = jayutils.getx86CodeSize()\n        self.ptrsize = self.codesize/8\n        self.queue = []",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "build_emu_va_map",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "def build_emu_va_map(node, **kwargs):\n    res = kwargs.get('res')\n    emu = kwargs.get('emu')\n    logtype = kwargs.get('logtype')\n    if (res is None) or (emu is None) or (logtype is None):\n        return\n    #for va in vg_path.getNodeProp(node, 'valist'):\n    #    res[va] = node\n    #for pc, va, bytes in vg_path.getNodeProp(node, 'writelog'):\n    for entry in vg_path.getNodeProp(node, logtype):",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "formatWriteLogEntry",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "def formatWriteLogEntry(entry):\n    pc, va, bytes = entry\n    return '0x%08x: 0x%08x: %s' % (pc, va, binascii.hexlify(bytes))\ndef transformWriteLogEntry(entry, bigend=False):\n    '''\n    Tranforms a writelog entry to a (pc, value) tuple\n    '''\n    pc, va, bytes = entry\n    blen = len(bytes)\n    if blen == 1:",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "transformWriteLogEntry",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "def transformWriteLogEntry(entry, bigend=False):\n    '''\n    Tranforms a writelog entry to a (pc, value) tuple\n    '''\n    pc, va, bytes = entry\n    blen = len(bytes)\n    if blen == 1:\n        return (pc, struct.unpack_from('<B', bytes)[0])\n    elif blen == 2:\n        return (pc, struct.unpack_from('<H', bytes)[0])",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.argtracker",
        "description": "plugins.flare-ida.python.flare.argtracker",
        "peekOfCode": "def main():\n    #jayutils.configLogger(__name__, logging.DEBUG)\n    jayutils.configLogger(__name__, logging.INFO)\n    logger = jayutils.getLogger('')\n    logger.debug('Starting up in main')\n    #name = idc.AskStr('CreateThread', 'Enter function to find args for')\n    #argNum = idc.AskLong(6)\n    filePath = jayutils.getInputFilepath()\n    if filePath is None:\n        self.logger.info('No input file provided. Stopping')",
        "detail": "plugins.flare-ida.python.flare.argtracker",
        "documentation": {}
    },
    {
        "label": "CodeGraftingUnsupportedFunc",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "class CodeGraftingUnsupportedFunc(Exception):\n    pass\nclass CodeGraftingUnsupportedArch(Exception):\n    pass\nclass CodeGraftingDisplacementError(Exception):\n    pass\nclass CodeGraftingAlreadyPresent(Exception):\n    pass\nclass CodeGrafter():\n    \"\"\"Graft code into IDA database to allow emulation of functions that call",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "CodeGraftingUnsupportedArch",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "class CodeGraftingUnsupportedArch(Exception):\n    pass\nclass CodeGraftingDisplacementError(Exception):\n    pass\nclass CodeGraftingAlreadyPresent(Exception):\n    pass\nclass CodeGrafter():\n    \"\"\"Graft code into IDA database to allow emulation of functions that call\n    certain imports and memory allocators.\n    To use:",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "CodeGraftingDisplacementError",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "class CodeGraftingDisplacementError(Exception):\n    pass\nclass CodeGraftingAlreadyPresent(Exception):\n    pass\nclass CodeGrafter():\n    \"\"\"Graft code into IDA database to allow emulation of functions that call\n    certain imports and memory allocators.\n    To use:\n    1. Instantiate a `CodeGrafter`\n    2. Call the `graftCodeToIdb()` method",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "CodeGraftingAlreadyPresent",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "class CodeGraftingAlreadyPresent(Exception):\n    pass\nclass CodeGrafter():\n    \"\"\"Graft code into IDA database to allow emulation of functions that call\n    certain imports and memory allocators.\n    To use:\n    1. Instantiate a `CodeGrafter`\n    2. Call the `graftCodeToIdb()` method\n    \"\"\"\n    def __init__(self, cpu=None, bits=None):",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "CodeGrafter",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "class CodeGrafter():\n    \"\"\"Graft code into IDA database to allow emulation of functions that call\n    certain imports and memory allocators.\n    To use:\n    1. Instantiate a `CodeGrafter`\n    2. Call the `graftCodeToIdb()` method\n    \"\"\"\n    def __init__(self, cpu=None, bits=None):\n        self.cpu = cpu or idaapi.get_inf_structure().procname\n        self.bits = bits or mykutils.get_bitness()",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "patch_pointer_width",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "def patch_pointer_width(va, value):\n    g_patch_pointer_width[mykutils.get_bitness()](va, value)\ndef patch_import(va, target):\n    \"\"\"Patch the import corresponding to the call at @va to point to @target.\n    Args:\n        va (numbers.Integral): Address of call site for imported function\n        target (str): Name or address of new call destination for import entry\n    Returns:\n        bool: True if successful\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "patch_import",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "def patch_import(va, target):\n    \"\"\"Patch the import corresponding to the call at @va to point to @target.\n    Args:\n        va (numbers.Integral): Address of call site for imported function\n        target (str): Name or address of new call destination for import entry\n    Returns:\n        bool: True if successful\n    \"\"\"\n    is_call = idc.print_insn_mnem(va) == 'call'\n    if is_call:",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "patch_call",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "def patch_call(va, new_nm):\n    \"\"\"Patch the call at @va to target @new_nm.\n    Args:\n        va (numbers.Integral): Address of the call site\n        new_nm (str): Name of the new call destination\n    Returns:\n        bool: True if successful\n    \"\"\"\n    is_call = idc.print_insn_mnem(va) == 'call'\n    if is_call:",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "revert_patch",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "def revert_patch(va, nr):\n    \"\"\"Unpatch the opcodes at @va, reverting them to their original value.\n    Args:\n        va (numbers.Integral): Address of the location of the patch to revert\n        nr (numbers.Integral): Number of bytes to scan and revert\n    Returns:\n        bool: True if patched bytes were restored\n    \"\"\"\n    ret = False\n    orig = [ida_bytes.get_original_byte(va + i) for i in range(nr)]",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "__author__ = 'Michael Bailey'\n__copyright__ = 'Copyright (C) 2019 FireEye, Inc.'\n__license__ = 'Apache License 2.0'\n__version__ = '1.0'\nlogger = logging.getLogger()\nlogging.basicConfig(format='%(message)s', level=logging.INFO)\n###############################################################################\n# Constants\n###############################################################################\nMETAPC = 'metapc'",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "__copyright__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "__copyright__ = 'Copyright (C) 2019 FireEye, Inc.'\n__license__ = 'Apache License 2.0'\n__version__ = '1.0'\nlogger = logging.getLogger()\nlogging.basicConfig(format='%(message)s', level=logging.INFO)\n###############################################################################\n# Constants\n###############################################################################\nMETAPC = 'metapc'\n###############################################################################",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "__license__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "__license__ = 'Apache License 2.0'\n__version__ = '1.0'\nlogger = logging.getLogger()\nlogging.basicConfig(format='%(message)s', level=logging.INFO)\n###############################################################################\n# Constants\n###############################################################################\nMETAPC = 'metapc'\n###############################################################################\n# Globals",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "__version__ = '1.0'\nlogger = logging.getLogger()\nlogging.basicConfig(format='%(message)s', level=logging.INFO)\n###############################################################################\n# Constants\n###############################################################################\nMETAPC = 'metapc'\n###############################################################################\n# Globals\n###############################################################################",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(format='%(message)s', level=logging.INFO)\n###############################################################################\n# Constants\n###############################################################################\nMETAPC = 'metapc'\n###############################################################################\n# Globals\n###############################################################################\n# Code Carving/Grafting",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "METAPC",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "METAPC = 'metapc'\n###############################################################################\n# Globals\n###############################################################################\n# Code Carving/Grafting\ng_seg_sig_code_grafter = 'Segment added by FLARE Code Grafter'\ng_patched_call_cmt = 'Patched for emulation, was:'\ng_cmt_pointed = '(Pointed'\n# Name tuple -> implementation lookup\ng_patch_pointer_width = {",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_seg_sig_code_grafter",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_seg_sig_code_grafter = 'Segment added by FLARE Code Grafter'\ng_patched_call_cmt = 'Patched for emulation, was:'\ng_cmt_pointed = '(Pointed'\n# Name tuple -> implementation lookup\ng_patch_pointer_width = {\n    32: idc.patch_dword,\n    64: idc.patch_qword,\n}\n# Per-architecture/bitness library of native function implementations. Each\n# entry is a hexadecimal ASCII string of native opcodes compiled from C and",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_patched_call_cmt",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_patched_call_cmt = 'Patched for emulation, was:'\ng_cmt_pointed = '(Pointed'\n# Name tuple -> implementation lookup\ng_patch_pointer_width = {\n    32: idc.patch_dword,\n    64: idc.patch_qword,\n}\n# Per-architecture/bitness library of native function implementations. Each\n# entry is a hexadecimal ASCII string of native opcodes compiled from C and\n# specially crafted not to access globals or call other functions.",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_cmt_pointed",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_cmt_pointed = '(Pointed'\n# Name tuple -> implementation lookup\ng_patch_pointer_width = {\n    32: idc.patch_dword,\n    64: idc.patch_qword,\n}\n# Per-architecture/bitness library of native function implementations. Each\n# entry is a hexadecimal ASCII string of native opcodes compiled from C and\n# specially crafted not to access globals or call other functions.\ng_fnbytes = {",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_patch_pointer_width",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_patch_pointer_width = {\n    32: idc.patch_dword,\n    64: idc.patch_qword,\n}\n# Per-architecture/bitness library of native function implementations. Each\n# entry is a hexadecimal ASCII string of native opcodes compiled from C and\n# specially crafted not to access globals or call other functions.\ng_fnbytes = {\n    METAPC: {\n        32: {},",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes = {\n    METAPC: {\n        32: {},\n        64: {},\n    }\n}\ng_fnbytes[METAPC][32]['memcpy'] = (\n    '55'                        # 0x1000: push     ebp\n    '8BEC'                      # 0x1001: mov      ebp, esp\n    '83EC08'                    # 0x1003: sub      esp, 8",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['memcpy']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['memcpy'] = (\n    '55'                        # 0x1000: push     ebp\n    '8BEC'                      # 0x1001: mov      ebp, esp\n    '83EC08'                    # 0x1003: sub      esp, 8\n    '8B4508'                    # 0x1006: mov      eax, dword ptr [ebp + 8]\n    '8945F8'                    # 0x1009: mov      dword ptr [ebp - 8], eax\n    '8B4D0C'                    # 0x100c: mov      ecx, dword ptr [ebp + 0xc]\n    '894DFC'                    # 0x100f: mov      dword ptr [ebp - 4], ecx\n    '8B5510'                    # 0x1012: mov      edx, dword ptr [ebp + 0x10]\n    '8B4510'                    # 0x1015: mov      eax, dword ptr [ebp + 0x10]",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['memcpy']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['memcpy'] = (\n    '4C89442418'                # 0x1000: mov       qword ptr [rsp + 0x18], r8\n    '4889542410'                # 0x1005: mov       qword ptr [rsp + 0x10], rdx\n    '48894C2408'                # 0x100a: mov       qword ptr [rsp + 8], rcx\n    '4883EC18'                  # 0x100f: sub       rsp, 0x18\n    '488B442420'                # 0x1013: mov       rax, qword ptr [rsp + 0x20]\n    '4889442408'                # 0x1018: mov       qword ptr [rsp + 8], rax\n    '488B442428'                # 0x101d: mov       rax, qword ptr [rsp + 0x28]\n    '48890424'                  # 0x1022: mov       qword ptr [rsp], rax\n    '488B4C2430'                # 0x1026: mov       rcx, qword ptr [rsp + 0x30]",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['memset']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['memset'] = (\n    '55'                        # 0x1000: push     ebp\n    '8BEC'                      # 0x1001: mov      ebp, esp\n    '51'                        # 0x1003: push     ecx\n    '8B4508'                    # 0x1004: mov      eax, dword ptr [ebp + 8]\n    '8945FC'                    # 0x1007: mov      dword ptr [ebp - 4], eax\n    '8B4D10'                    # 0x100a: mov      ecx, dword ptr [ebp + 0x10]\n    '8B5510'                    # 0x100d: mov      edx, dword ptr [ebp + 0x10]\n    '83EA01'                    # 0x1010: sub      edx, 1\n    '895510'                    # 0x1013: mov      dword ptr [ebp + 0x10], edx",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['memset']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['memset'] = (\n    '4C89442418'                # 0x1000: mov       qword ptr [rsp + 0x18], r8\n    '89542410'                  # 0x1005: mov       dword ptr [rsp + 0x10], edx\n    '48894C2408'                # 0x1009: mov       qword ptr [rsp + 8], rcx\n    '4883EC18'                  # 0x100e: sub       rsp, 0x18\n    '488B442420'                # 0x1012: mov       rax, qword ptr [rsp + 0x20]\n    '48890424'                  # 0x1017: mov       qword ptr [rsp], rax\n    '488B4C2430'                # 0x101b: mov       rcx, qword ptr [rsp + 0x30]\n    '488B442430'                # 0x1020: mov       rax, qword ptr [rsp + 0x30]\n    '4883E801'                  # 0x1025: sub       rax, 1",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['strcpy']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['strcpy'] = (\n    '55'                        # 0x1000: push      ebp\n    '8BEC'                      # 0x1001: mov       ebp, esp\n    '51'                        # 0x1003: push      ecx\n    '8B4508'                    # 0x1004: mov       eax, dword ptr [ebp + 8]\n    '8945FC'                    # 0x1007: mov       dword ptr [ebp - 4], eax\n    '8B4DFC'                    # 0x100a: mov       ecx, dword ptr [ebp - 4]\n    '8B550C'                    # 0x100d: mov       edx, dword ptr [ebp + 0xc]\n    '8A02'                      # 0x1010: mov       al, byte ptr [edx]\n    '8801'                      # 0x1012: mov       byte ptr [ecx], al",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['strcpy']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['strcpy'] = (\n    '4889542410'                # 0x1000: mov       qword ptr [rsp + 0x10], rdx\n    '48894C2408'                # 0x1005: mov       qword ptr [rsp + 8], rcx\n    '4883EC18'                  # 0x100a: sub       rsp, 0x18\n    '488B442420'                # 0x100e: mov       rax, qword ptr [rsp + 0x20]\n    '48890424'                  # 0x1013: mov       qword ptr [rsp], rax\n    '488B0C24'                  # 0x1017: mov       rcx, qword ptr [rsp]\n    '488B442428'                # 0x101b: mov       rax, qword ptr [rsp + 0x28]\n    '0FB600'                    # 0x1020: movzx     eax, byte ptr [rax]\n    '8801'                      # 0x1023: mov       byte ptr [rcx], al",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_strlen_metapc_32bit",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_strlen_metapc_32bit = (\n    '55'                        # 0x1000: push      ebp\n    '8BEC'                      # 0x1001: mov       ebp, esp\n    '51'                        # 0x1003: push      ecx\n    'C745FC00000000'            # 0x1004: mov       dword ptr [ebp - 4], 0\n    '8B4508'                    # 0x100b: mov       eax, dword ptr [ebp + 8]\n    '0FBE08'                    # 0x100e: movsx     ecx, byte ptr [eax]\n    '8B5508'                    # 0x1011: mov       edx, dword ptr [ebp + 8]\n    '83C201'                    # 0x1014: add       edx, 1\n    '895508'                    # 0x1017: mov       dword ptr [ebp + 8], edx",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_strlen_metapc_64bit",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_strlen_metapc_64bit = (\n    '48894C2408'                # 0x1000: mov       qword ptr [rsp + 8], rcx\n    '4883EC18'                  # 0x1005: sub       rsp, 0x18\n    '48C7042400000000'          # 0x1009: mov       qword ptr [rsp], 0\n    '488B442420'                # 0x1011: mov       rax, qword ptr [rsp + 0x20]\n    '0FBE08'                    # 0x1016: movsx     ecx, byte ptr [rax]\n    '488B442420'                # 0x1019: mov       rax, qword ptr [rsp + 0x20]\n    '4883C001'                  # 0x101e: add       rax, 1\n    '4889442420'                # 0x1022: mov       qword ptr [rsp + 0x20], rax\n    '85C9'                      # 0x1027: test      ecx, ecx",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['strlen']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['strlen'] = g_strlen_metapc_32bit\ng_fnbytes[METAPC][64]['strlen'] = g_strlen_metapc_64bit\n# return \"en-US\";\ng_fnbytes[METAPC][32]['setlocale'] = (\n    'E800000000'                # 0x1000: call      0x1005\n    '58'                        # 0x1005: pop       eax\n    '83C007'                    # 0x1006: add       eax, 7\n    'C20800'                    # 0x1009: ret       8\n    '656e2d555300'              # db 'en-US',0\n    )",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['strlen']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['strlen'] = g_strlen_metapc_64bit\n# return \"en-US\";\ng_fnbytes[METAPC][32]['setlocale'] = (\n    'E800000000'                # 0x1000: call      0x1005\n    '58'                        # 0x1005: pop       eax\n    '83C007'                    # 0x1006: add       eax, 7\n    'C20800'                    # 0x1009: ret       8\n    '656e2d555300'              # db 'en-US',0\n    )\ng_fnbytes[METAPC][64]['setlocale'] = (",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['setlocale']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['setlocale'] = (\n    'E800000000'                # 0x1000: call      0x1005\n    '58'                        # 0x1005: pop       eax\n    '83C007'                    # 0x1006: add       eax, 7\n    'C20800'                    # 0x1009: ret       8\n    '656e2d555300'              # db 'en-US',0\n    )\ng_fnbytes[METAPC][64]['setlocale'] = (\n    '488B0501000000'            # 0x1000: mov     rax, qword ptr [rip + 1]\n    'C3'                        # 0x1007: ret",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['setlocale']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['setlocale'] = (\n    '488B0501000000'            # 0x1000: mov     rax, qword ptr [rip + 1]\n    'C3'                        # 0x1007: ret\n    '656e2d555300'              # db 'en-US',0\n    )\ng_fnbytes[METAPC][32]['wsetlocale'] = (\n    'E800000000'                # 0x1000: call     0x1005\n    '58'                        # 0x1005: pop      eax\n    '83C007'                    # 0x1006: add      eax, 7\n    'C20800'                    # 0x1009: ret      8",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['wsetlocale']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['wsetlocale'] = (\n    'E800000000'                # 0x1000: call     0x1005\n    '58'                        # 0x1005: pop      eax\n    '83C007'                    # 0x1006: add      eax, 7\n    'C20800'                    # 0x1009: ret      8\n    '65006e002d00550053000000'  # text \"UTF-16LE\", 'en-US',0\n    )\ng_fnbytes[METAPC][64]['wsetlocale'] = (\n    '488B0501000000'            # 0x1000: mov     rax, qword ptr [rip + 1]\n    'C3'                        # 0x1007: ret",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['wsetlocale']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['wsetlocale'] = (\n    '488B0501000000'            # 0x1000: mov     rax, qword ptr [rip + 1]\n    'C3'                        # 0x1007: ret\n    '65006e002d00550053000000'  # text \"UTF-16LE\", 'en-US',0\n    )\ng_retn0_metapc_64bit = (\n    '4831C0'                    # 0x1000: xor     rax, rax\n    'C3'                        # 0x1003: ret\n    )\ng_retn1_metapc_64bit = (",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_retn0_metapc_64bit",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_retn0_metapc_64bit = (\n    '4831C0'                    # 0x1000: xor     rax, rax\n    'C3'                        # 0x1003: ret\n    )\ng_retn1_metapc_64bit = (\n    '4831C0'                    # 0x1000: xor     rax, rax\n    '4883C001'                  # 0x1003: add     rax, 1\n    'C3'                        # 0x1007: ret\n    )\ng_fnbytes[METAPC][32]['retn0'] = (",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_retn1_metapc_64bit",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_retn1_metapc_64bit = (\n    '4831C0'                    # 0x1000: xor     rax, rax\n    '4883C001'                  # 0x1003: add     rax, 1\n    'C3'                        # 0x1007: ret\n    )\ng_fnbytes[METAPC][32]['retn0'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C3'                        # 0x1002: ret\n    )\ng_fnbytes[METAPC][64]['retn0'] = g_retn0_metapc_64bit",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn0']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn0'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C3'                        # 0x1002: ret\n    )\ng_fnbytes[METAPC][64]['retn0'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn0_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20400'                    # 0x1002: ret     4\n    )\ng_fnbytes[METAPC][64]['retn0_1arg'] = g_retn0_metapc_64bit",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn0']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn0'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn0_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20400'                    # 0x1002: ret     4\n    )\ng_fnbytes[METAPC][64]['retn0_1arg'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn0_3arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20C00'                    # 0x1002: ret     0xc\n    )",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn0_1arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn0_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20400'                    # 0x1002: ret     4\n    )\ng_fnbytes[METAPC][64]['retn0_1arg'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn0_3arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20C00'                    # 0x1002: ret     0xc\n    )\ng_fnbytes[METAPC][64]['retn0_3arg'] = g_retn0_metapc_64bit",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn0_1arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn0_1arg'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn0_3arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20C00'                    # 0x1002: ret     0xc\n    )\ng_fnbytes[METAPC][64]['retn0_3arg'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn1'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C3'                        # 0x1003: ret",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn0_3arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn0_3arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    'C20C00'                    # 0x1002: ret     0xc\n    )\ng_fnbytes[METAPC][64]['retn0_3arg'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn1'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C3'                        # 0x1003: ret\n    )",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn0_3arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn0_3arg'] = g_retn0_metapc_64bit\ng_fnbytes[METAPC][32]['retn1'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C3'                        # 0x1003: ret\n    )\ng_fnbytes[METAPC][64]['retn1'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn1']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn1'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C3'                        # 0x1003: ret\n    )\ng_fnbytes[METAPC][64]['retn1'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C20400'                    # 0x1003: ret     4",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn1']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn1'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C20400'                    # 0x1003: ret     4\n    )\ng_fnbytes[METAPC][64]['retn1_1arg'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_2arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn1_1arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn1_1arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C20400'                    # 0x1003: ret     4\n    )\ng_fnbytes[METAPC][64]['retn1_1arg'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_2arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C20800'                    # 0x1003: ret     8",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn1_1arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn1_1arg'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_2arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C20800'                    # 0x1003: ret     8\n    )\ng_fnbytes[METAPC][64]['retn1_2arg'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_6arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn1_2arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn1_2arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C20800'                    # 0x1003: ret     8\n    )\ng_fnbytes[METAPC][64]['retn1_2arg'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_6arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C21800'                    # 0x1003: ret     0x18",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn1_2arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn1_2arg'] = g_retn1_metapc_64bit\ng_fnbytes[METAPC][32]['retn1_6arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C21800'                    # 0x1003: ret     0x18\n    )\ng_fnbytes[METAPC][64]['retn1_6arg'] = g_retn1_metapc_64bit\n# Allocator => All names it is known by\ng_allocators_aliases = {\n    'malloc': ('??2@YAPAXI@Z', '_malloc', 'malloc',),",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][32]['retn1_6arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][32]['retn1_6arg'] = (\n    '31C0'                      # 0x1000: xor     eax, eax\n    '40'                        # 0x1002: inc     eax\n    'C21800'                    # 0x1003: ret     0x18\n    )\ng_fnbytes[METAPC][64]['retn1_6arg'] = g_retn1_metapc_64bit\n# Allocator => All names it is known by\ng_allocators_aliases = {\n    'malloc': ('??2@YAPAXI@Z', '_malloc', 'malloc',),\n    'HeapAlloc': ('HeapAlloc',),",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes[METAPC][64]['retn1_6arg']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes[METAPC][64]['retn1_6arg'] = g_retn1_metapc_64bit\n# Allocator => All names it is known by\ng_allocators_aliases = {\n    'malloc': ('??2@YAPAXI@Z', '_malloc', 'malloc',),\n    'HeapAlloc': ('HeapAlloc',),\n    'VirtualAlloc': ('VirtualAlloc',),\n}\n# Memory allocation templates cannot be handled as simply as static functions\n# can be, because they must access global data. Furthermore, these are all\n# basically the same allocator but they have different signatures.",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_allocators_aliases",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_allocators_aliases = {\n    'malloc': ('??2@YAPAXI@Z', '_malloc', 'malloc',),\n    'HeapAlloc': ('HeapAlloc',),\n    'VirtualAlloc': ('VirtualAlloc',),\n}\n# Memory allocation templates cannot be handled as simply as static functions\n# can be, because they must access global data. Furthermore, these are all\n# basically the same allocator but they have different signatures.\ng_fnbytes_allocators = {\n    METAPC: {",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators = {\n    METAPC: {\n        32: {},\n        64: {},\n    }\n}\n# Main differences among allocator implementations:\n#   * [ebp+size] is different per argument layout\n#   * cdecl (malloc) and various stdcall (HeapAlloc/VirtualAlloc) return\n#     opcodes",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators[METAPC][32]['malloc']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators[METAPC][32]['malloc'] = (\n    '55'                # push    ebp\n    '8bec'              # mov     ebp, esp\n    '51'                # push    ecx\n    'a1{next_}'         # mov     eax, _next\n    '05{arena}'         # add     eax, offset _arena\n    '8945fc'            # mov     [ebp+ret], eax\n    '8b4d08'            # mov     ecx, [ebp+size]\n    '8b15{next_}'       # mov     edx, _next\n    '8d440aff'          # lea     eax, [edx+ecx-1]",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators[METAPC][64]['malloc']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators[METAPC][64]['malloc'] = (\n    '48894c2408'        # mov     [rsp+arg_0], rcx\n    '4883ec18'          # sub     rsp, 18h\n  # '488d0570cd0100'    # lea     rax, arena        ; Original, RIP-relative\n    '48B8{arena}'       # mov     rax, &cs:arena    ; Hand-written, absolute64\n  # '48030529bf0100'    # add     rax, cs:next      ; Original, RIP-relative\n    '48B9{next_}'       # mov     rcx, &cs:next_    ; Hand-written, absolute64\n    '480301'            # add     rax, [rcx]        ; Hand-written\n    '48890424'          # mov     [rsp+18h+var_18], rax\n  # '488b0d1ebf0100'    # mov     rcx, cs:next      ; Original, RIP-relative",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators[METAPC][32]['HeapAlloc']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators[METAPC][32]['HeapAlloc'] = (\n    '55'                # push    ebp\n    '8bec'              # mov     ebp, esp\n    '51'                # push    ecx\n    'a1{next_}'         # mov     eax, _next\n    '05{arena}'         # add     eax, offset _arena\n    '8945fc'            # mov     [ebp+ret], eax\n    '8b4d10'            # mov     ecx, [ebp+size]\n    '8b15{next_}'       # mov     edx, _next\n    '8d440aff'          # lea     eax, [edx+ecx-1]",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators[METAPC][64]['HeapAlloc']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators[METAPC][64]['HeapAlloc'] = (\n    '4c89442418'        # mov     [rsp+arg_10], r8\n    '89542410'          # mov     [rsp+arg_8], edx\n    '48894c2408'        # mov     [rsp+arg_0], rcx\n    '4883ec18'          # sub     rsp, 18h\n  # '488d0517cd0100'    # lea     rax, arena        ; Original, RIP-relative\n    '48B8{arena}'       # mov     rax, &cs:arena    ; Hand-written, absolute64\n  # '480305d0be0100'    # add     rax, cs:next      ; Original, RIP-relative\n    '48B9{next_}'       # mov     rcx, &cs:next_    ; Hand-written, absolute64\n    '480301'            # add     rax, [rcx]        ; Hand-written",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators[METAPC][32]['VirtualAlloc']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators[METAPC][32]['VirtualAlloc'] = (\n    '55'                # push    ebp\n    '8bec'              # mov     ebp, esp\n    '51'                # push    ecx\n    'a1{next_}'         # mov     eax, _next\n    '05{arena}'         # add     eax, offset _arena\n    '8945fc'            # mov     [ebp+ret], eax\n    '8b4d0c'            # mov     ecx, [ebp+dwSize]\n    '8b15{next_}'       # mov     edx, _next\n    '8d440aff'          # lea     eax, [edx+ecx-1]",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "g_fnbytes_allocators[METAPC][64]['VirtualAlloc']",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.code_grafter",
        "description": "plugins.flare-ida.python.flare.code_grafter",
        "peekOfCode": "g_fnbytes_allocators[METAPC][64]['VirtualAlloc'] = (\n    '44894c2420'        # mov     [rsp+arg_18], r9d\n    '4489442418'        # mov     [rsp+arg_10], r8d\n    '4889542410'        # mov     [rsp+arg_8], rdx\n    '48894c2408'        # mov     [rsp+arg_0], rcx\n    '4883ec18'          # sub     rsp, 18h\n  # '488d05b1cc0100'    # lea     rax, arena        ; Original, RIP-relative\n    '48B8{arena}'       # mov     rax, &cs:arena    ; Hand-written, absolute64\n  # '4803056abe0100'    # add     rax, cs:next      ; Original, RIP-relative\n    '48B9{next_}'       # mov     rcx, &cs:next_    ; Hand-written, absolute64",
        "detail": "plugins.flare-ida.python.flare.code_grafter",
        "documentation": {}
    },
    {
        "label": "ConfigMode",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "class ConfigMode(Enum):\n    FUNCTION_MODE_MIN = auto()\n    NON_AUTO_FUNCTIONS = FUNCTION_MODE_MIN\n    LIBRARY_FUNCTIONS = auto()\n    PUBLIC_FUNCTIONS = auto()\n    ENTRY_POINT_FUNCTIONS = auto()\n    ALL_FUNCTIONS = auto()\n    USER_SELECT_FUNCTION = auto()\n    FUNCTION_MODE_MAX = USER_SELECT_FUNCTION\ndef get_ida_logging_handler():",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "class Config(object):\n    def __init__(self, min_func_length=6, pointer_size=4, mode=ConfigMode.ALL_FUNCTIONS, pat_append=False, logfile=\"\", loglevel=\"DEBUG\", logenabled=False):\n        super(Config, self).__init__()\n        self.min_func_length = min_func_length\n        # TODO: get pointer_size from IDA\n        self.pointer_size = pointer_size\n        if idc.__EA64__:\n            self.pointer_size = 8\n        self.mode = mode\n        self.pat_append = pat_append",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "FuncTooShortException",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "class FuncTooShortException(Exception):\n    pass\n# ported from IDB2SIG plugin updated by TQN\ndef make_func_sig(config, func):\n    \"\"\"\n    type config: Config\n    type func: idc.func_t\n    \"\"\"\n    logger = logging.getLogger(\"idb2pat:make_func_sig\")\n    if func.end_ea - func.start_ea < config.min_func_length:",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "get_ida_logging_handler",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def get_ida_logging_handler():\n    \"\"\"\n    IDA logger should always be the first one (since it inits the env)\n    \"\"\"\n    return logging.getLogger().handlers[0]\nlogging.basicConfig(level=logging.DEBUG)\nget_ida_logging_handler().setLevel(logging.INFO)\ng_logger = logging.getLogger(\"idb2pat\")\nclass Config(object):\n    def __init__(self, min_func_length=6, pointer_size=4, mode=ConfigMode.ALL_FUNCTIONS, pat_append=False, logfile=\"\", loglevel=\"DEBUG\", logenabled=False):",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "crc16",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def crc16(data, crc):\n    for byte in data:\n        crc = (crc >> 8) ^ CRC16_TABLE[(crc ^ ord(byte)) & 0xFF]\n    crc = (~crc) & 0xFFFF\n    crc = (crc << 8) | ((crc >> 8) & 0xFF)\n    return crc & 0xffff\ndef get_functions():\n   for i in range(get_func_qty()):\n        yield getn_func(i)\n# TODO: idaapi.get_func(ea)",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "get_functions",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def get_functions():\n   for i in range(get_func_qty()):\n        yield getn_func(i)\n# TODO: idaapi.get_func(ea)\n_g_function_cache = None\ndef get_func_at_ea(ea):\n    \"\"\"\n    type ea: idc.ea_t\n    \"\"\"\n    global _g_function_cache",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "get_func_at_ea",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def get_func_at_ea(ea):\n    \"\"\"\n    type ea: idc.ea_t\n    \"\"\"\n    global _g_function_cache\n    if _g_function_cache is None:\n        _g_function_cache = {}\n        for f in get_functions():\n            _g_function_cache[f.start_ea] = f\n    return _g_function_cache.get(f.start_ea, None)",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "to_bytestring",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def to_bytestring(seq):\n    \"\"\"\n    convert sequence of chr()-able items to a str of\n     their chr() values.\n    in reality, this converts a list of uint8s to a\n     bytestring.\n    \"\"\"\n    return \"\".join(map(chr, seq))\nclass FuncTooShortException(Exception):\n    pass",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "make_func_sig",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def make_func_sig(config, func):\n    \"\"\"\n    type config: Config\n    type func: idc.func_t\n    \"\"\"\n    logger = logging.getLogger(\"idb2pat:make_func_sig\")\n    if func.end_ea - func.start_ea < config.min_func_length:\n        logger.debug(\"Function is too short\")\n        raise FuncTooShortException()\n    ea = func.start_ea",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "make_func_sigs",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def make_func_sigs(config):\n    logger = logging.getLogger(\"idb2pat:make_func_sigs\")\n    sigs = []\n    if config.mode == ConfigMode.USER_SELECT_FUNCTION:\n        f = choose_func(\"Choose Function:\", BADADDR)\n        if f is None:\n            logger.error(\"No function selected\")\n            return []\n        jumpto(f.start_ea)\n        if not has_any_name(get_full_flags(f.start_ea)):",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "get_pat_file",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def get_pat_file():\n    logger = logging.getLogger(\"idb2pat:get_pat_file\")\n    name, extension = os.path.splitext(get_input_file_path())\n    name = name + \".pat\"\n    filename = ask_file(1, name, \"Enter the name of the pattern file\")\n    if filename is None:\n        logger.debug(\"User did not choose a pattern file\")\n        return None\n    return filename\ndef update_config(config):",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "update_config",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def update_config(config):\n    logger = logging.getLogger(\"idb2pat:update_config\")\n    name, extension = os.path.splitext(get_input_file_path())\n    name = name + \".conf\"\n    if not os.path.exists(name):\n        logger.debug(\"No configuration file provided, using defaults\")\n        return\n    with open(name, \"rb\") as f:\n        t = f.read()\n    try:",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "def main():\n    c = Config()\n    update_config(c)\n    if c.logenabled:\n        h = logging.FileHandler(c.logfile)\n        h.setLevel(c.loglevel)\n        logging.getLogger().addHandler(h)\n    filename = get_pat_file()\n    if filename is None:\n        g_logger.debug(\"No file selected\")",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "g_logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "g_logger = logging.getLogger(\"idb2pat\")\nclass Config(object):\n    def __init__(self, min_func_length=6, pointer_size=4, mode=ConfigMode.ALL_FUNCTIONS, pat_append=False, logfile=\"\", loglevel=\"DEBUG\", logenabled=False):\n        super(Config, self).__init__()\n        self.min_func_length = min_func_length\n        # TODO: get pointer_size from IDA\n        self.pointer_size = pointer_size\n        if idc.__EA64__:\n            self.pointer_size = 8\n        self.mode = mode",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "CRC16_TABLE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "CRC16_TABLE = [\n  0x0, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 0x8c48, 0x9dc1,\n  0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 0x1081, 0x108, 0x3393, 0x221a,\n  0x56a5, 0x472c, 0x75b7, 0x643e, 0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64,\n  0xf9ff, 0xe876, 0x2102, 0x308b, 0x210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,\n  0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 0x3183, 0x200a,\n  0x1291, 0x318, 0x77a7, 0x662e, 0x54b5, 0x453c, 0xbdcb, 0xac42, 0x9ed9, 0x8f50,\n  0xfbef, 0xea66, 0xd8fd, 0xc974, 0x4204, 0x538d, 0x6116, 0x709f, 0x420, 0x15a9,\n  0x2732, 0x36bb, 0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,\n  0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x528, 0x37b3, 0x263a, 0xdecd, 0xcf44,",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "_g_function_cache",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.idb2pat",
        "description": "plugins.flare-ida.python.flare.idb2pat",
        "peekOfCode": "_g_function_cache = None\ndef get_func_at_ea(ea):\n    \"\"\"\n    type ea: idc.ea_t\n    \"\"\"\n    global _g_function_cache\n    if _g_function_cache is None:\n        _g_function_cache = {}\n        for f in get_functions():\n            _g_function_cache[f.start_ea] = f",
        "detail": "plugins.flare-ida.python.flare.idb2pat",
        "documentation": {}
    },
    {
        "label": "isWideString",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def isWideString(inStr):\n    return (len(inStr) >= 2) and (inStr[0] != '\\x00') and (inStr[1] == '\\x00')\ndef extractBasicWideString(inStr):\n    return inStr[::2]\n########################################\ndef isValidPointer(va):\n    if using_ida7api:\n        return isValidPointer_ida7(va)\n    for segStart in idautils.Segments():\n        if (va >= segStart) and (va < idc.SegEnd(segStart)):",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "extractBasicWideString",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def extractBasicWideString(inStr):\n    return inStr[::2]\n########################################\ndef isValidPointer(va):\n    if using_ida7api:\n        return isValidPointer_ida7(va)\n    for segStart in idautils.Segments():\n        if (va >= segStart) and (va < idc.SegEnd(segStart)):\n            return True\n    return False",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "isValidPointer",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def isValidPointer(va):\n    if using_ida7api:\n        return isValidPointer_ida7(va)\n    for segStart in idautils.Segments():\n        if (va >= segStart) and (va < idc.SegEnd(segStart)):\n            return True\n    return False\ndef isValidPointer_ida7(va):\n    for segStart in idautils.Segments():\n        if (va >= segStart) and (va < idc.get_segm_end(segStart)):",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "isValidPointer_ida7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def isValidPointer_ida7(va):\n    for segStart in idautils.Segments():\n        if (va >= segStart) and (va < idc.get_segm_end(segStart)):\n            return True\n    return False\n########################################\ndef getString(ea, maxLen=0x200):\n    '''Returns up to 0x200 bytes, until a null is found'''\n    if using_ida7api:\n        return getString_ida7(ea, maxLen)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getString",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getString(ea, maxLen=0x200):\n    '''Returns up to 0x200 bytes, until a null is found'''\n    if using_ida7api:\n        return getString_ida7(ea, maxLen)\n    i = 0\n    retList = []\n    while i < maxLen:\n        b = idc.Byte(ea+i)\n        if b == 0x00:\n            break",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getString_ida7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getString_ida7(ea, maxLen=0x200):\n    '''Returns up to 0x200 bytes, until a null is found'''\n    i = 0\n    retList = []\n    while i < maxLen:\n        b = idc.get_db_byte(ea+i)\n        if b == 0x00:\n            break\n        retList.append(chr(b))\n        i += 1",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "makeNameHard",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def makeNameHard(ea, name):\n    '''Keeps trying to name the given ea until it works, adding the optional _%d suffix'''\n    if using_ida7api:\n        return makeNameHard_ida7(ea, name)\n    count = 0\n    ret = idc.MakeNameEx(ea, name, idc.SN_PUBLIC|idc.SN_NOWARN)\n    m = HARD_NAME_RE.match(name)\n    if m is not None:\n        #already a name in <name>_<count>  format\n        name, count = m.group(1,2)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "makeNameHard_ida7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def makeNameHard_ida7(ea, name):\n    '''Keeps trying to name the given ea until it works, adding the optional _%d suffix'''\n    count = 0\n    ret = idc.set_name(ea, name, idc.SN_PUBLIC|idc.SN_NOWARN)\n    m = HARD_NAME_RE.match(name)\n    if m is not None:\n        #already a name in <name>_<count>  format\n        name, count = m.group(1,2)\n        count = int(count)\n    if ret == 0:",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getx86CodeSize",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getx86CodeSize(ea=None):\n    '''\n    For a given EA, finds the code size. Returns 16 for-16bit, 32 for 32-bit, or 64 for 64-bit.\n    If no EA is given, searches through all segments for a code segment to use.\n    '''\n    if using_ida7api:\n        return getx86CodeSize_ida7(ea)\n    if ea is None:\n        for seg in idautils.Segments():\n            if idc.GetSegmentAttr(seg, idc.SEGATTR_TYPE) == idc.SEG_CODE:",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getx86CodeSize_ida7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getx86CodeSize_ida7(ea=None):\n    '''\n    For a given EA, finds the code size. Returns 16 for-16bit, 32 for 32-bit, or 64 for 64-bit.\n    If no EA is given, searches through all segments for a code segment to use.\n    '''\n    if ea is None:\n        for seg in idautils.Segments():\n            if idc.get_segm_attr(seg, idc.SEGATTR_TYPE) == idc.SEG_CODE:\n                ea = seg\n                break",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "configLogger",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def configLogger(rootname=None, level=logging.INFO, customLevels=None):\n    logger = logging.getLogger(rootname)\n    if len(logger.handlers) != 0:\n        return logger\n    logger = logging.getLogger(rootname)\n    logger.setLevel(level)\n    formatter = logging.Formatter(\"%(name)s: %(message)s\")\n    errStream = logging.StreamHandler(sys.stdout)\n    errStream.handleError = handleErrorRaiseError\n    errStream.setFormatter(formatter)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "handleErrorRaiseError",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def handleErrorRaiseError(record):\n    raise\ndef _getPrintChar(c):\n    if (ord(c) >= 0x20) and (ord(c) <= 0x7e):\n        return c\n    return '.'\ndef _formatLine(num, inBytes):\n    hexBytes = []\n    ascBytes = []\n    for i in range(16):",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "doHexLog",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def doHexLog(self, level, inBytes, msg='', *args, **kwargs):\n    if not self.isEnabledFor(level):\n        return\n    lines = ['\\n']\n    #lines = []\n    hexLine = []\n    base = 0\n    if len(inBytes) == 0:\n        self.log(level, msg, *args, **kwargs)\n        return ",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "debugHex",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def debugHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.DEBUG, inBytes, msg, *args, **kwargs)\ndef infoHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.INFO, inBytes, msg, *args, **kwargs)\ndef warningHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.WARNING, inBytes, msg, *args, **kwargs)\ndef errorHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.ERROR, inBytes, msg, *args, **kwargs)\n############################################################\n# add hexprinting to existing loggers that obey logging level semantics",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "infoHex",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def infoHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.INFO, inBytes, msg, *args, **kwargs)\ndef warningHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.WARNING, inBytes, msg, *args, **kwargs)\ndef errorHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.ERROR, inBytes, msg, *args, **kwargs)\n############################################################\n# add hexprinting to existing loggers that obey logging level semantics\ndef getLogger(name=None):\n    logger = logging.getLogger(name)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "warningHex",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def warningHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.WARNING, inBytes, msg, *args, **kwargs)\ndef errorHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.ERROR, inBytes, msg, *args, **kwargs)\n############################################################\n# add hexprinting to existing loggers that obey logging level semantics\ndef getLogger(name=None):\n    logger = logging.getLogger(name)\n    return _addHexLogging(logger)\ndef _addHexLogging(logger):",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "errorHex",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def errorHex(self, inBytes, msg, *args, **kwargs):\n     self.doHexLog(logging.ERROR, inBytes, msg, *args, **kwargs)\n############################################################\n# add hexprinting to existing loggers that obey logging level semantics\ndef getLogger(name=None):\n    logger = logging.getLogger(name)\n    return _addHexLogging(logger)\ndef _addHexLogging(logger):\n    logger.doHexLog = types.MethodType(doHexLog, logger)\n    logger.debugHex = types.MethodType(debugHex, logger)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getLogger",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getLogger(name=None):\n    logger = logging.getLogger(name)\n    return _addHexLogging(logger)\ndef _addHexLogging(logger):\n    logger.doHexLog = types.MethodType(doHexLog, logger)\n    logger.debugHex = types.MethodType(debugHex, logger)\n    logger.infoHex = types.MethodType(infoHex, logger)\n    logger.warningHex = types.MethodType(warningHex, logger)\n    logger.errorHex = types.MethodType(errorHex, logger)\n    return logger",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getInputFilepath",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getInputFilepath():\n    '''Returns None if the uesr cancels. Updates the filepath in the idb on success'''\n    if using_ida7api:\n        return getInputFilepath_ida7()\n    filePath = idc.GetInputFilePath()\n    if not os.path.exists(filePath):\n        print ('IDB input file not found. Prompting for new one: %s' % filePath)\n        filePath = idc.AskFile(False, '*.*', 'Enter path to idb input file')\n        if filePath is not None:\n            idc.SetInputFilePath(filePath)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getInputFilepath_ida7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getInputFilepath_ida7():\n    '''Returns None if the uesr cancels. Updates the filepath in the idb on success'''\n    filePath = idc.get_input_file_path()\n    if not os.path.exists(filePath):\n        print ('IDB input file not found. Prompting for new one: %s' % filePath)\n        filePath = idaapi.ask_file(False, '*.*', 'Enter path to idb input file')\n        if filePath is not None:\n            idc.set_root_filename(filePath)\n    return filePath\n############################################################",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "loadWorkspace",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def loadWorkspace(filename, fast=False):\n    import vivisect\n    logger = getLogger('loadWorkspace')\n    # haha - screw you ida! storing values in idaapi works - you cache yourselves but not me\n    #cacheDict = getattr(sys.modules['idaapi'], 'vw_cached_workspace', None)\n    cacheDict = None\n    if filename is None:\n        return None\n    if cacheDict is None:\n        cacheDict = {}",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "queryIdbNetnode",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def queryIdbNetnode(key):\n    n = idaapi.netnode(NETNODE_NAME, len(NETNODE_NAME), True)\n    return n.hashval(key)\ndef setIdbNetnode(key, value):\n    n = idaapi.netnode(NETNODE_NAME, len(NETNODE_NAME), True)\n    return n.hashset(key, value)\n######################################################################\n# visgraph traversal helpers\n######################################################################\n#orange TODO: path funtions aren't checking for duplicating traversal",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "setIdbNetnode",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def setIdbNetnode(key, value):\n    n = idaapi.netnode(NETNODE_NAME, len(NETNODE_NAME), True)\n    return n.hashset(key, value)\n######################################################################\n# visgraph traversal helpers\n######################################################################\n#orange TODO: path funtions aren't checking for duplicating traversal\n# since doing there's no path node ID, and doing a straight node-cmp\n# is too much\ndef path_dfs(node, func, **kwargs):",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "path_dfs",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def path_dfs(node, func, **kwargs):\n    todo = [node]\n    while len(todo) != 0:\n        #node is a tuple of (parent, child_list, prop_dict)\n        cur = todo.pop(0)\n        #insert children at start of queue\n        blah = cur[1][:]\n        blah.extend(todo)\n        todo = blah\n        func(cur, **kwargs)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "path_bfs",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def path_bfs(node, func, **kwargs):\n    todo = [node]\n    while len(todo) != 0:\n        #node is a tuple of (parent, child_list, prop_dict)\n        cur = todo.pop(0)\n        #append children to end of queue\n        todo.extend(cur[1])\n        func(cur, **kwargs)\n######################################################################\n# vivisect helpers ",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "getAllXrefsTo",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "def getAllXrefsTo(vw, va):\n    import vivisect\n    #manually parse the preceding instruction & look to see if it can fall through to us\n    #make a copy of the xrefs!!! or badness will ensue\n    init = vw.getXrefsTo(va)[:]\n    prev = vw.getPrevLocation(va)\n    if prev is None:\n        return init\n    lva, lsize, ltype, linfo = prev\n    if ltype != vivisect.const.LOC_OP:",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\",category=DeprecationWarning)\ndef isWideString(inStr):\n    return (len(inStr) >= 2) and (inStr[0] != '\\x00') and (inStr[1] == '\\x00')\ndef extractBasicWideString(inStr):\n    return inStr[::2]\n########################################\ndef isValidPointer(va):\n    if using_ida7api:",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "HARD_NAME_RE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "HARD_NAME_RE = re.compile(r'''(\\w+)_(\\d+)''')\ndef makeNameHard(ea, name):\n    '''Keeps trying to name the given ea until it works, adding the optional _%d suffix'''\n    if using_ida7api:\n        return makeNameHard_ida7(ea, name)\n    count = 0\n    ret = idc.MakeNameEx(ea, name, idc.SN_PUBLIC|idc.SN_NOWARN)\n    m = HARD_NAME_RE.match(name)\n    if m is not None:\n        #already a name in <name>_<count>  format",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "NETNODE_NAME",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "NETNODE_NAME = '$ jayutils'\nVIV_WORKSPACE_NAME = 'viv_workspace_path'\n############################################################\ndef getInputFilepath():\n    '''Returns None if the uesr cancels. Updates the filepath in the idb on success'''\n    if using_ida7api:\n        return getInputFilepath_ida7()\n    filePath = idc.GetInputFilePath()\n    if not os.path.exists(filePath):\n        print ('IDB input file not found. Prompting for new one: %s' % filePath)",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "VIV_WORKSPACE_NAME",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.jayutils",
        "description": "plugins.flare-ida.python.flare.jayutils",
        "peekOfCode": "VIV_WORKSPACE_NAME = 'viv_workspace_path'\n############################################################\ndef getInputFilepath():\n    '''Returns None if the uesr cancels. Updates the filepath in the idb on success'''\n    if using_ida7api:\n        return getInputFilepath_ida7()\n    filePath = idc.GetInputFilePath()\n    if not os.path.exists(filePath):\n        print ('IDB input file not found. Prompting for new one: %s' % filePath)\n        filePath = idc.AskFile(False, '*.*', 'Enter path to idb input file')",
        "detail": "plugins.flare-ida.python.flare.jayutils",
        "documentation": {}
    },
    {
        "label": "phex",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def phex(n):\n    \"\"\"Pretty hex.\n    The `hex()` function can append a trailing 'L' signifying the long\n    datatype. Stripping the trailing 'L' does two things:\n    1. Can double click it in the IDA output window to jump to that address\n    2. Looks cleaner\n    Args:\n        n (numbers.Integral): Number to prettify\n    Returns:\n        Hex string for `n` without trailing 'L'",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "align",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def align(n, a):\n    \"\"\"Align @n to @a bytes.\n    Examples:\n        align(4, 4) = 4\n        align(3, 4) = 4\n        align(0, 4) = 0\n        align(5, 4) = 8\n    Args:\n        n (numbers.Integral): Virtual address to align\n        a (numbers.Integral): Alignment",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "get_bitness",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def get_bitness():\n    \"\"\"Get the architecture bit width of this IDB.\"\"\"\n    inf = idaapi.get_inf_structure()\n    return 64 if inf.is_64bit() else 32 if inf.is_32bit() else 16\ndef makename_safe(va, nm, max_tries=10):\n    \"\"\"Attempt to name @va as @nm appending numbers up to @max_tries.\n    Appends _0, _1, etc. until successful or bails after the specified number\n    of tries.\n    Args:\n        va (numbers.Integral): Virtual address to name.",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "makename_safe",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def makename_safe(va, nm, max_tries=10):\n    \"\"\"Attempt to name @va as @nm appending numbers up to @max_tries.\n    Appends _0, _1, etc. until successful or bails after the specified number\n    of tries.\n    Args:\n        va (numbers.Integral): Virtual address to name.\n        nm (str): Name to apply\n        max_tries (numbers.Integral): Number of times to retry naming while\n            appending successive increasing number suffices\n    Returns:",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "for_each_call_to",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def for_each_call_to(callback, va=None):\n    \"\"\"For each xref to va that is a call, pass xref va to callback.\n    Falls back to highlighted identifier or current location if va is\n    unspecified.\n    \"\"\"\n    if not va:\n        v = ida_kernwin.get_current_viewer()\n        hi = ida_kernwin.get_highlight(v)\n        if hi and hi[1]:\n            nm = hi[0]",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "find_instr",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def find_instr(va_start, direction, mnems=None, op_specs=[], max_instrs=0):\n    \"\"\"Find an instruction in the current function conforming to the\n    specified mnemonics/operands.\n    Args:\n        va_start (numbers.Integral): Virtual address from whence to begin\n            search.\n        direction (str): Direction in assembly listing to proceed with search.\n            Valid directions are 'up' or 'down'.\n        mnems (str or iterable of str): Optional assembly language mnemonic(s)\n            to search for.",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "is_conformant_instr",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def is_conformant_instr(va, mnems, op_specs):\n    \"\"\"Check if instruction at @va conforms to operand specifications list.\n    Args:\n        va (numbers.Integral): Virtual address of instruction to assess.\n        mnems (str or iterable of str): Optional instruction mnemonic(s) to\n            check for.\n        op_specs (iterable of OpSpec): Iterable containing zero or more operand\n            specification tuples (operand position, type, and name).\n    Returns:\n        True if conformant",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "is_conformant_operand",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def is_conformant_operand(va, op_spec):\n    \"\"\"Check that operand conforms to specification.\n    Args:\n        va (numbers.Integral): Virtual address of instruction to assess.\n        op_spec (OpSpec): Operand specification tuple (operand position, type,\n            and name)\n    Returns:\n        True if conformant\n        False if nonconformant\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "emit_fnbytes_ascii",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def emit_fnbytes_ascii(fva=None, warn=True):\n    \"\"\"Emit function bytes as an ASCII hexlified string.\n    Args:\n        fva (numbers.Integral): function virtual address.\n            Defaults to here() if that is the start of a function, else\n            defaults to the start of the function that here() is a part of.\n        warn (bool): enable interactive warnings\n    Returns:\n        str: ASCII hexlified string of instruction opcode bytes for function.\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "emit_fnbytes_python",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def emit_fnbytes_python(fva=None, warn=True):\n    \"\"\"Emit function bytes as Python code with disassembly in comments.\n    Args:\n        fva (numbers.Integral): function virtual address.\n            Defaults to here() if that is the start of a function, else\n            defaults to the start of the function that here() is a part of.\n        warn (bool): enable interactive warnings\n    Returns:\n        str: Python code you can spruce up and paste into a script.\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "emit_fnbytes_c",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "def emit_fnbytes_c(fva=None, warn=True):\n    \"\"\"Emit function bytes as C code with disassembly in comments.\n    Args:\n        fva (numbers.Integral): function virtual address.\n            Defaults to here() if that is the start of a function, else\n            defaults to the start of the function that here() is a part of.\n        warn (bool): enable interactive warnings\n    Returns:\n        str: C code you can spruce up and paste into a script.\n    \"\"\"",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "__author__ = 'Michael Bailey'\n__copyright__ = 'Copyright (C) 2019 FireEye, Inc.'\n__license__ = 'Apache License 2.0'\n__version__ = '1.0'\n###############################################################################\n# Initialization\n###############################################################################\nlogger = logging.getLogger(__name__)\n###############################################################################\n# Useful tidbits",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "__copyright__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "__copyright__ = 'Copyright (C) 2019 FireEye, Inc.'\n__license__ = 'Apache License 2.0'\n__version__ = '1.0'\n###############################################################################\n# Initialization\n###############################################################################\nlogger = logging.getLogger(__name__)\n###############################################################################\n# Useful tidbits\n###############################################################################",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "__license__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "__license__ = 'Apache License 2.0'\n__version__ = '1.0'\n###############################################################################\n# Initialization\n###############################################################################\nlogger = logging.getLogger(__name__)\n###############################################################################\n# Useful tidbits\n###############################################################################\ndef phex(n):",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "__version__ = '1.0'\n###############################################################################\n# Initialization\n###############################################################################\nlogger = logging.getLogger(__name__)\n###############################################################################\n# Useful tidbits\n###############################################################################\ndef phex(n):\n    \"\"\"Pretty hex.",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "logger = logging.getLogger(__name__)\n###############################################################################\n# Useful tidbits\n###############################################################################\ndef phex(n):\n    \"\"\"Pretty hex.\n    The `hex()` function can append a trailing 'L' signifying the long\n    datatype. Stripping the trailing 'L' does two things:\n    1. Can double click it in the IDA output window to jump to that address\n    2. Looks cleaner",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "OpSpec",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.mykutils",
        "description": "plugins.flare-ida.python.flare.mykutils",
        "peekOfCode": "OpSpec = namedtuple('OpSpec', 'pos type name')\ndef find_instr(va_start, direction, mnems=None, op_specs=[], max_instrs=0):\n    \"\"\"Find an instruction in the current function conforming to the\n    specified mnemonics/operands.\n    Args:\n        va_start (numbers.Integral): Virtual address from whence to begin\n            search.\n        direction (str): Direction in assembly listing to proceed with search.\n            Valid directions are 'up' or 'down'.\n        mnems (str or iterable of str): Optional assembly language mnemonic(s)",
        "detail": "plugins.flare-ida.python.flare.mykutils",
        "documentation": {}
    },
    {
        "label": "Objc2Analyzer",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_analyzer",
        "description": "plugins.flare-ida.python.flare.objc2_analyzer",
        "peekOfCode": "class Objc2Analyzer():\n    def __init__(self):\n        self.magicMask64 = 0xabbadabbad000000\n        self.magicMask32 = 0xabba0000\n        self.magicMaskMask64 = 0xffffffffffff0000\n        self.magicMaskMask32 = 0xffff0000\n        self.callMnems = [\"call\", \"jmp\", \"BL\", \"BLX\", \"BLEQ\", \"BLXEQ\", \"BLR\", \"BLREQ\", \"B\"]\n        self.objcData = None\n        self.objcSelRefs = None\n        self.objcMsgRefs = None",
        "detail": "plugins.flare-ida.python.flare.objc2_analyzer",
        "documentation": {}
    },
    {
        "label": "UNKNOWN",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.objc2_analyzer",
        "description": "plugins.flare-ida.python.flare.objc2_analyzer",
        "peekOfCode": "UNKNOWN = \"??\"\nMAX_STR_DISPLAY_LEN = 20\nclass Objc2Analyzer():\n    def __init__(self):\n        self.magicMask64 = 0xabbadabbad000000\n        self.magicMask32 = 0xabba0000\n        self.magicMaskMask64 = 0xffffffffffff0000\n        self.magicMaskMask32 = 0xffff0000\n        self.callMnems = [\"call\", \"jmp\", \"BL\", \"BLX\", \"BLEQ\", \"BLXEQ\", \"BLR\", \"BLREQ\", \"B\"]\n        self.objcData = None",
        "detail": "plugins.flare-ida.python.flare.objc2_analyzer",
        "documentation": {}
    },
    {
        "label": "MAX_STR_DISPLAY_LEN",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.objc2_analyzer",
        "description": "plugins.flare-ida.python.flare.objc2_analyzer",
        "peekOfCode": "MAX_STR_DISPLAY_LEN = 20\nclass Objc2Analyzer():\n    def __init__(self):\n        self.magicMask64 = 0xabbadabbad000000\n        self.magicMask32 = 0xabba0000\n        self.magicMaskMask64 = 0xffffffffffff0000\n        self.magicMaskMask32 = 0xffff0000\n        self.callMnems = [\"call\", \"jmp\", \"BL\", \"BLX\", \"BLEQ\", \"BLXEQ\", \"BLR\", \"BLREQ\", \"B\"]\n        self.objcData = None\n        self.objcSelRefs = None",
        "detail": "plugins.flare-ida.python.flare.objc2_analyzer",
        "documentation": {}
    },
    {
        "label": "AArch64LDRInstruction",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class AArch64LDRInstruction(object):\n    \"\"\"A class to decode and patch arm64 LDR (literal) instructions\n    Decodes instruction byte string into opcode, offset, and register\n    Provides method to patch offset and regenerate instruction bytestring\n    \"\"\"\n    ENDIANNESS_BIG=0\n    ENDIANNESS_LITTLE=1\n    def __init__(self,instruction_bytes,endianness=1):\n        \"\"\"Decode the byte string for an arm64 LDR (literal) instruction\n        Arguments:",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjCException",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjCException(Exception):\n    pass\nclass ObjcClass(object):\n    \"\"\"Class to parse an Objective-C class structure\n    \"\"\"\n    OBJC2_CLASS_RO_OFFSET=0x20 #offset into a _class_t of the ro member\n    OBJC2_CLASS_RO_BASE_METHODS_OFFSET=0x20 #offset into a _class_ro_t of the baseMethods member\n    OBJC2_CLASS_RO_NAME_OFFSET=0x18\n    def __init__(self,objc_class_va,segment_map,arch=ARCH_X86_64):\n        \"\"\"Create a new ObjcClass instance",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjcClass",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjcClass(object):\n    \"\"\"Class to parse an Objective-C class structure\n    \"\"\"\n    OBJC2_CLASS_RO_OFFSET=0x20 #offset into a _class_t of the ro member\n    OBJC2_CLASS_RO_BASE_METHODS_OFFSET=0x20 #offset into a _class_ro_t of the baseMethods member\n    OBJC2_CLASS_RO_NAME_OFFSET=0x18\n    def __init__(self,objc_class_va,segment_map,arch=ARCH_X86_64):\n        \"\"\"Create a new ObjcClass instance\n        Arguments:\n            objc_class_va {number} -- Virtual address of the Objective-C class to parse",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjCMethodAbstract",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjCMethodAbstract(object):\n    \"\"\"Abstract class to parse Objective-C method structures\n    This class cannot be instantiated as-is. It must be extended to override add_method_xref()\n    \"\"\"\n    OBJC_METHOD_SIZE=0x18 #sizeof(struct _objc_method)\n    OBJC_METHOD_TYPE_OFFSET=8\n    OBJC_METHOD_IMP_OFFSET=0x10\n    #TODO: override for other architectures\n    CALL_MNEMONIC=\"call\"\n    def __init__(self,method_va,segment_map):",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjCMethodX86_64",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjCMethodX86_64(ObjCMethodAbstract):\n    \"\"\"x86_64-specific class to parse Objective-C method structures\n    Provides x86_64-specific implementation to patch method references in code.\n    Extends:\n        ObjCMethodAbstract\n    \"\"\"\n    X86_64_MOV_INSTRUCTION_SIZE=7\n    def __init__(self,method_va,segment_map):\n        \"\"\"\n        Create an x86-64-specific Objective-C method object",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjCMethodArm64",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjCMethodArm64(ObjCMethodAbstract):\n    \"\"\"Arm64-specific class to parse Objective-C method structures\n    Provides Arm64-specific implementation to patch method references in code.\n    Extends:\n        ObjCMethodAbstract\n    \"\"\"\n    ARM64_INSTRUCTION_SIZE=4\n    def __init__(self,method_va,segment_map):\n        \"\"\"\n        Create an Arm64-specific Objective-C method object",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjcMethodList",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjcMethodList(list):\n    \"\"\"A class to parse Objective-C method list structures\n    Creates an iterable list of Object-C Method objects\n    Extends:\n        list\n    \"\"\"\n    METHOD_LIST_OFFSET=DWORD_SIZE*2 # method_list array starts after entsize and method_count (both ints)\n    OBJC_METHOD_CLASSES=[ObjCMethodX86_64,ObjCMethodArm64]\n    def __init__(self,method_list_va,segment_map,arch=ARCH_X86_64):\n        \"\"\"Create a new list of Objective-C method objects",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjcMethodXref",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjcMethodXref(object):\n    \"\"\"A class to represent patched method crosss references\n    \"\"\"\n    def __init__(self,frm_va,to_va,old_to_va):\n        \"\"\"Create a new ObjcMethodXref object\n        Arguments:\n            frm_va {number} -- Virtual address location of the reference\n            to_va {[type]} -- Virtual address that is pointed to by the reference\n            old_to_va {[type]} -- Virtual address that was pointed to by the reference prior to patching\n        \"\"\"",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "ObjCMethodXRefs",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "class ObjCMethodXRefs(list):\n    \"\"\"A class to parse Objective-C class and method structures\n    Parses class and method structures and locates cross-references to the method selectors.\n    If the class that references the selectors is unambiguous, all code references to the selectors\n    are replaced with references to the method implementation.\n    What results is an iterable list of all cross references that were patched.\n    Extends:\n        list\n    \"\"\"\n    objc2ClassSize = 0x28",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "detect_arch",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "def detect_arch():\n    #heuristically determine what architecture we're on\n    #only x86-64 and arm64 are supported\n    is_le=False\n    bits=0\n    info = get_inf_structure()\n    arch=ARCH_UNKNOWN\n    if info.is_64bit():\n        bits=64\n    elif info.is_32bit():",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "description": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "peekOfCode": "def main():\n    arch=detect_arch()\n    xref_list=ObjCMethodXRefs(arch=arch)\n    msg(\"Patched the following method references:\\n\")\n    for xref in xref_list:\n        msg(\"%s\\n\" % str(xref))\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.flare-ida.python.flare.objc2_xrefs_helper",
        "documentation": {}
    },
    {
        "label": "RC4_crypt",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "description": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "peekOfCode": "def RC4_crypt(key, buffer):\n    arc4 = ARC4(key)\n    result = list(arc4.decrypt(buffer))\n    string_result = ''\n    for each in result:\n        if each != 0:\n            string_result += chr(each)\n    return string_result\ndef decode_callback(eh, address, argv, userData):\n    encoded_str_ea = eh.getRegVal('edx')",
        "detail": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "documentation": {}
    },
    {
        "label": "decode_callback",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "description": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "peekOfCode": "def decode_callback(eh, address, argv, userData):\n    encoded_str_ea = eh.getRegVal('edx')\n    ENCRYPTED_STRING_BUFFER = argv[0]\n    key_offset = argv[1]\n    key_length = argv[2]\n    data_length = argv[3]\n    RC4_key = idaapi.get_bytes(ENCRYPTED_STRING_BUFFER + key_offset, key_length)\n    RC4_encrypted_buffer = idaapi.get_bytes(ENCRYPTED_STRING_BUFFER + key_offset + key_length, data_length)\n    decrypted_str = RC4_crypt(RC4_key, RC4_encrypted_buffer)\n    print(hex(address) + ' ' + decrypted_str)",
        "detail": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "documentation": {}
    },
    {
        "label": "eh",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "description": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "peekOfCode": "eh = flare_emu.EmuHelper()\n# Change \"string_decrypt\" to the string decryption function name on IDA Pro\neh.iterate(eh.analysisHelper.getNameAddr(\"string_decrypt\"), decode_callback)",
        "detail": "plugins.flare-ida.python.flare.revil_string_decrypt",
        "documentation": {}
    },
    {
        "label": "Segment",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.seghelper",
        "description": "plugins.flare-ida.python.flare.seghelper",
        "peekOfCode": "class Segment(namedtuple('Segment', 'start end')):\n    \"\"\"For reasoning over segments.\"\"\"\n    def __repr__(self):\n        return 'Segment(start=%s, end=%s)' % (phex(self.start), phex(self.end))\n    def __contains__(self, item):\n        if isinstance(item, Segment):\n            return self._contains_segment(item)\n        return self._contains_va(item)\n    def _contains_segment(self, some_seg):\n        return ((self.start in some_seg) or ((self.end - 1) in some_seg) or",
        "detail": "plugins.flare-ida.python.flare.seghelper",
        "documentation": {}
    },
    {
        "label": "SegPlanner",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.seghelper",
        "description": "plugins.flare-ida.python.flare.seghelper",
        "peekOfCode": "class SegPlanner():\n    \"\"\"For planning (but not implementing) where to add segments.\"\"\"\n    def __init__(self):\n        self._segs = [Segment(va, idc.get_segm_end(va))\n                      for va in idautils.Segments()]\n        self._segs.sort()\n    def __iter__(self):\n        return iter(self._segs)\n    def __contains__(self, va_or_seg):\n        try:",
        "detail": "plugins.flare-ida.python.flare.seghelper",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.seghelper",
        "description": "plugins.flare-ida.python.flare.seghelper",
        "peekOfCode": "__author__ = 'Michael Bailey'\n__copyright__ = 'Copyright (C) 2019 FireEye, Inc.'\n__license__ = 'Apache License 2.0'\n__version__ = '1.0'\nclass Segment(namedtuple('Segment', 'start end')):\n    \"\"\"For reasoning over segments.\"\"\"\n    def __repr__(self):\n        return 'Segment(start=%s, end=%s)' % (phex(self.start), phex(self.end))\n    def __contains__(self, item):\n        if isinstance(item, Segment):",
        "detail": "plugins.flare-ida.python.flare.seghelper",
        "documentation": {}
    },
    {
        "label": "__copyright__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.seghelper",
        "description": "plugins.flare-ida.python.flare.seghelper",
        "peekOfCode": "__copyright__ = 'Copyright (C) 2019 FireEye, Inc.'\n__license__ = 'Apache License 2.0'\n__version__ = '1.0'\nclass Segment(namedtuple('Segment', 'start end')):\n    \"\"\"For reasoning over segments.\"\"\"\n    def __repr__(self):\n        return 'Segment(start=%s, end=%s)' % (phex(self.start), phex(self.end))\n    def __contains__(self, item):\n        if isinstance(item, Segment):\n            return self._contains_segment(item)",
        "detail": "plugins.flare-ida.python.flare.seghelper",
        "documentation": {}
    },
    {
        "label": "__license__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.seghelper",
        "description": "plugins.flare-ida.python.flare.seghelper",
        "peekOfCode": "__license__ = 'Apache License 2.0'\n__version__ = '1.0'\nclass Segment(namedtuple('Segment', 'start end')):\n    \"\"\"For reasoning over segments.\"\"\"\n    def __repr__(self):\n        return 'Segment(start=%s, end=%s)' % (phex(self.start), phex(self.end))\n    def __contains__(self, item):\n        if isinstance(item, Segment):\n            return self._contains_segment(item)\n        return self._contains_va(item)",
        "detail": "plugins.flare-ida.python.flare.seghelper",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.seghelper",
        "description": "plugins.flare-ida.python.flare.seghelper",
        "peekOfCode": "__version__ = '1.0'\nclass Segment(namedtuple('Segment', 'start end')):\n    \"\"\"For reasoning over segments.\"\"\"\n    def __repr__(self):\n        return 'Segment(start=%s, end=%s)' % (phex(self.start), phex(self.end))\n    def __contains__(self, item):\n        if isinstance(item, Segment):\n            return self._contains_segment(item)\n        return self._contains_va(item)\n    def _contains_segment(self, some_seg):",
        "detail": "plugins.flare-ida.python.flare.seghelper",
        "documentation": {}
    },
    {
        "label": "Ui_ShellcodeChooser",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcodechooser",
        "description": "plugins.flare-ida.python.flare.shellcodechooser",
        "peekOfCode": "class Ui_ShellcodeChooser(object):\n    def setupUi(self, ShellcodeChooser):\n        ShellcodeChooser.setObjectName(\"ShellcodeChooser\")\n        ShellcodeChooser.resize(450, 249)\n        self.verticalLayout_3 = QtWidgets.QVBoxLayout(ShellcodeChooser)\n        self.verticalLayout_3.setObjectName(\"verticalLayout_3\")\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout()\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")",
        "detail": "plugins.flare-ida.python.flare.shellcodechooser",
        "documentation": {}
    },
    {
        "label": "RejectionException",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class RejectionException(Exception):\n    pass\nif using_ida7api:\n    import ida_ua\n    OPERAND_MASK = {\n        ida_ua.dt_byte:                0xFF,  # 1 byte\n        ida_ua.dt_word:              0xFFFF,  # 2 bytes\n        ida_ua.dt_dword:         0xFFFFFFFF,  # 4 bytes\n        ida_ua.dt_qword: 0xFFFFFFFFFFFFFFFF,  # 8 bytes\n    }",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "SymbolHash",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class SymbolHash(object):\n    def __init__(self, hashVal, symbolName, libName, hashName, hashSize):\n        self.hashVal = hashVal\n        self.symbolName = symbolName\n        self.libName = libName\n        self.hashName = hashName\n        self.hashSize = hashSize\n    def __str__(self):\n        return '%s:0x%08x %s!%s' % (self.hashName, self.hashVal, self.libName, self.symbolName )\nclass HashType(object):",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "HashType",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class HashType(object):\n    def __init__(self, hashType, hashSize, hashName, hashCode):\n        self.hashType = hashType\n        self.hashSize = hashSize\n        self.hashName = hashName\n        self.hashCode = hashCode\nclass HashHit(object):\n    def __init__(self, ea, symHash):\n        self.ea = ea\n        self.symHash = symHash",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "HashHit",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class HashHit(object):\n    def __init__(self, ea, symHash):\n        self.ea = ea\n        self.symHash = symHash\n############################################################\n# \n############################################################\nclass DbStore(object):\n    '''\n    Used to access the hash db.",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "DbStore",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class DbStore(object):\n    '''\n    Used to access the hash db.\n    '''\n    def __init__(self, dbPath):\n        self.dbPath = dbPath\n        self.conn = sqlite3.connect(dbPath)\n        self.conn.execute(sql_adjust_cache_size)\n    def close(self):\n        self.conn.close()",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "SearchParams",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class SearchParams(object):\n    '''\n    Just used to track the user provided search parameters.\n    '''\n    def __init__(self):\n        self.searchDwordArray = False\n        self.searchPushArgs = False\n        self.createStruct = False\n        self.useDecompiler = False\n        self.useXORSeed = False",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "ShellcodeHashSearcher",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class ShellcodeHashSearcher(object):\n    def __init__(self, dbstore, params):\n        self.dbstore = dbstore\n        self.params = params\n        self.hits = []\n        self.hitSet = set()\n        self.ptrSize = jayutils.getx86CodeSize()/ 8\n        logger.debug('Using pointer size: %d bytes', self.ptrSize)\n    def addHit(self, ea, sym):\n        if ea in self.hitSet:",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "SearchLauncher",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "class SearchLauncher(object):\n    def __init__(self):\n        self.params = SearchParams()\n    def run(self):\n        try:\n            logger.debug(\"Starting up\")\n            dbFile = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'shellcode_hashes', 'sc_hashes.db'))\n            logger.debug('Trying default db path: %s', dbFile)\n            if not os.path.exists(dbFile):\n                if using_ida7api:",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "def main():\n    launcher = SearchLauncher()\n    launcher.run()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "QT_AVAILABLE",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "QT_AVAILABLE = True\ntry:\n    from PyQt5 import QtWidgets, QtCore\n    from .shellcode_widget import ShellcodeWidget\nexcept ImportError as err:\n    print('ImportError: %s' % err)\n    print ('Falling back to simple dialog-based GUI. \\nPlease consider installing the HexRays PyQt5 build available at \\n\"http://hex-rays.com/products/ida/support/download.shtml\"')\n    QT_AVAILABLE = False\n# get the IDA version number\nida_major, ida_minor = map(int, idaapi.get_kernel_version().split(\".\"))",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "using_ida7api = (ida_major > 6)\n#logger = jayutils.configLogger('shellcode_hash', logging.DEBUG)\nlogger = jayutils.configLogger('shellcode_hash', logging.INFO)\nclass RejectionException(Exception):\n    pass\nif using_ida7api:\n    import ida_ua\n    OPERAND_MASK = {\n        ida_ua.dt_byte:                0xFF,  # 1 byte\n        ida_ua.dt_word:              0xFFFF,  # 2 bytes",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "#logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "#logger = jayutils.configLogger('shellcode_hash', logging.DEBUG)\nlogger = jayutils.configLogger('shellcode_hash', logging.INFO)\nclass RejectionException(Exception):\n    pass\nif using_ida7api:\n    import ida_ua\n    OPERAND_MASK = {\n        ida_ua.dt_byte:                0xFF,  # 1 byte\n        ida_ua.dt_word:              0xFFFF,  # 2 bytes\n        ida_ua.dt_dword:         0xFFFFFFFF,  # 4 bytes",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "description": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "peekOfCode": "logger = jayutils.configLogger('shellcode_hash', logging.INFO)\nclass RejectionException(Exception):\n    pass\nif using_ida7api:\n    import ida_ua\n    OPERAND_MASK = {\n        ida_ua.dt_byte:                0xFF,  # 1 byte\n        ida_ua.dt_word:              0xFFFF,  # 2 bytes\n        ida_ua.dt_dword:         0xFFFFFFFF,  # 4 bytes\n        ida_ua.dt_qword: 0xFFFFFFFFFFFFFFFF,  # 8 bytes",
        "detail": "plugins.flare-ida.python.flare.shellcode_hash_search",
        "documentation": {}
    },
    {
        "label": "ShellcodeWidget",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.shellcode_widget",
        "description": "plugins.flare-ida.python.flare.shellcode_widget",
        "peekOfCode": "class ShellcodeWidget(QtWidgets.QDialog):\n    def __init__(self, dbstore, params, parent=None):\n        QtWidgets.QDialog.__init__(self, parent)\n        try:\n            self.logger = jayutils.getLogger('ShellcodeWidget')\n            self.logger.debug('Hello debug')\n            self.dbstore = dbstore\n            self.params = params\n            self.configData = {}\n            self.ui=Ui_ShellcodeChooser()",
        "detail": "plugins.flare-ida.python.flare.shellcode_widget",
        "documentation": {}
    },
    {
        "label": "StringAccumulator",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "class StringAccumulator(object):\n    def __init__(self):\n        self.logger = jayutils.getLogger('StringAccumulator')\n        self.stringDict = {}\n        self.stackDict = {}\n        self.buffReuseDetected = False\n    def addString(self, item):\n        entry, string = item\n        idx = string.find('\\x00')\n        if idx >= 0:",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "stack_track_visitor",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def stack_track_visitor(node, **kwargs):\n    vw = kwargs.get('vw')\n    res = kwargs.get('res')\n    emu = kwargs.get('emu')\n    agg = kwargs.get('agg')\n    logger = kwargs.get('logger')\n    if (vw is None) or (emu is None) or (logger is None):\n        raise RuntimeError('Bad arguments to stack_track_visitor')\n    if agg is None:\n        agg = StringAccumulator()",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "isAscii",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def isAscii(val):\n    if isinstance(val, str) or isinstance(val, unicode):\n        val = ord(val)\n    #if it's printable, or newline, tab\n    return ((val >= 0x20) and (val < 0x7f)) or val in [0x0d, 0x0a, 0x09]\n################################################################################\nclass StringAccumulator(object):\n    def __init__(self):\n        self.logger = jayutils.getLogger('StringAccumulator')\n        self.stringDict = {}",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "runStrings",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def runStrings(vw, ea, uselocalagg=True):\n    '''\n    Returns a list of (write log entry, decoded strings)\n    where the write log is the tuple (pc, va, bytes)  \n    for the instruction that wrote the first byte of the string\n    '''\n    emu = vw.getEmulator(True, True)\n    #modify the stack base for the emulator - smaller mask & frame size\n    # wasn't working for funcs with large locals frame size\n    emu.stack_map_mask = e_bits.sign_extend(0xfff00000, 4, vw.psize)",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "getFuncRanges",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def getFuncRanges(ea, doAllFuncs):\n    if using_ida7api:\n        return getFuncRanges_ida7(ea, doAllFuncs)\n    if doAllFuncs:\n        funcs = []\n        funcGen = idautils.Functions(idc.SegStart(ea), idc.SegEnd(ea))\n        for i in funcGen:\n            funcs.append(i)\n        funcRanges = []\n        for i in range(len(funcs) - 1):",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "getFuncRanges_ida7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def getFuncRanges_ida7(ea, doAllFuncs):\n    if doAllFuncs:\n        funcs = []\n        funcGen = idautils.Functions(idc.get_segm_start(ea), idc.get_segm_end(ea))\n        for i in funcGen:\n            funcs.append(i)\n        funcRanges = []\n        for i in range(len(funcs) - 1):\n            funcRanges.append( (funcs[i], funcs[i+1]) )\n        funcRanges.append( (funcs[-1], idc.get_segm_end(ea)) )",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "isLikelyFalsePositiveString",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def isLikelyFalsePositiveString(instr):\n    #if a string is all 'A' chars, very likely that it's a false positive\n    return all([a == 'A' for a in instr])\ndef main(doAllFuncs=True):\n    #doAllFuncs=False\n    #jayutils.configLogger(__name__, logging.DEBUG)\n    jayutils.configLogger(__name__, logging.INFO)\n    logger = jayutils.getLogger('stackstrings')\n    logger.debug('Starting up now')\n    filePath = jayutils.getInputFilepath()",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "def main(doAllFuncs=True):\n    #doAllFuncs=False\n    #jayutils.configLogger(__name__, logging.DEBUG)\n    jayutils.configLogger(__name__, logging.INFO)\n    logger = jayutils.getLogger('stackstrings')\n    logger.debug('Starting up now')\n    filePath = jayutils.getInputFilepath()\n    if filePath is None:\n        self.logger.info('No input file provided. Stopping')\n        return",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.stackstrings",
        "description": "plugins.flare-ida.python.flare.stackstrings",
        "peekOfCode": "using_ida7api = (ida_major > 6)\n#TODO: make option for binary buffers on the stack also?\ndef stack_track_visitor(node, **kwargs):\n    vw = kwargs.get('vw')\n    res = kwargs.get('res')\n    emu = kwargs.get('emu')\n    agg = kwargs.get('agg')\n    logger = kwargs.get('logger')\n    if (vw is None) or (emu is None) or (logger is None):\n        raise RuntimeError('Bad arguments to stack_track_visitor')",
        "detail": "plugins.flare-ida.python.flare.stackstrings",
        "documentation": {}
    },
    {
        "label": "StructTyperWidget",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "class StructTyperWidget(QtWidgets.QDialog):\n    def __init__(self, parent=None):\n        QtWidgets.QDialog.__init__(self, parent)\n        try:\n            logger.debug('StructTyperWidget starting up')\n            self.ui=Ui_Dialog()\n            self.ui.setupUi(self)\n            self.ui.lineEdit.setText(g_DefaultPrefixRegexp)\n            self.ui.checkBox.setChecked(Qt.Unchecked)\n        except Exception as err:",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "StructTypeRunner",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "class StructTypeRunner(object):\n    def run(self):\n        try:\n            logger.debug('Starting up')\n            dlg = StructTyperWidget()\n            dlg.setStructs(loadStructs())\n            oldTo = idaapi.set_script_timeout(0)\n            res = dlg.exec_()\n            idaapi.set_script_timeout(oldTo)\n            if res == QtWidgets.QDialog.Accepted:",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "manualTypeCopy",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "def manualTypeCopy(dest, destOff, destLen, src):\n    '''Copies an IDA type 'string' to the given location'''\n    i = 0\n    while (i+destOff) < destLen:\n        dest[i+destOff] = chr(src[i])\n        if (src[i] == 0) or (src[i] == '\\x00'):\n            break\n        i += 1\ng_NUMBERS = '0123456789'\ndef stripNumberedName(name):",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "stripNumberedName",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "def stripNumberedName(name):\n    '''Remove trailing unique ID like IDA does for same names'''\n    idx = len(name) -1\n    while idx >= 0:\n        if (name[idx] == '_'):\n            if (len(name)-1) == idx:\n                #last char is '_', not allowed so return name\n                return name\n            else:\n                #encountered a '_', strip here",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "loadMembersIDA7",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "def loadMembersIDA7(struc, sid):\n    '''Returns list of tuples of (offset, memberName, member)'''\n    #mixing idc & idaapi, kinda annoying but need low-level idaapi for a \n    # type access, but cant dig into structs...\n    members = []\n    off = idaapi.get_struc_first_offset(struc) \n    while off != idc.BADADDR:\n        logger.debug('struc offset: 0x%x (%d)', off, off)\n        member = idaapi.get_member(struc, off)\n        if (member == 0) or (member is None):",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "loadMembers",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "def loadMembers(struc, sid):\n    '''Returns list of tuples of (offset, memberName, member)'''\n    #mixing idc & idaapi, kinda annoying but need low-level idaapi for a \n    # type access, but cant dig into structs...\n    if using_ida7api:\n        return loadMembersIDA7(struc, sid)\n    members = []\n    off = g_dll.get_struc_first_offset(struc) \n    while off >= 0:\n        member = g_dll.get_member(struc, ctypes.c_int(off))",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "loadStructs",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "def loadStructs():\n    idx = idaapi.get_first_struc_idx()\n    existingStructs = []\n    while idx != idc.BADADDR:\n        tid = idaapi.get_struc_by_idx(idx)\n        existingStructs.append(idaapi.get_struc_name(tid))\n        idx = idaapi.get_next_struc_idx(idx)\n    existingStructs.sort()\n    return existingStructs\n############################################################",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "def main():\n    global logger\n    #logger = jayutils.configLogger(__name__, logging.DEBUG)\n    logger = jayutils.configLogger(__name__, logging.INFO)\n    launcher = StructTypeRunner()\n    launcher.run()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nlogger = None\n############################################################\n# In older IDAPython, several type-related functions aren't accessible\n# so have to do things with ctypes\nif not using_ida7api:\n    idaname = \"ida64\" if idc.__EA64__ else \"ida\"\n    if sys.platform == \"win32\":\n        g_dll = ctypes.windll[idaname + \".wll\"]\n    elif sys.platform == \"linux2\":",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "logger = None\n############################################################\n# In older IDAPython, several type-related functions aren't accessible\n# so have to do things with ctypes\nif not using_ida7api:\n    idaname = \"ida64\" if idc.__EA64__ else \"ida\"\n    if sys.platform == \"win32\":\n        g_dll = ctypes.windll[idaname + \".wll\"]\n    elif sys.platform == \"linux2\":\n        g_dll = ctypes.cdll[\"lib\" + idaname + \".so\"]",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "g_NUMBERS",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "g_NUMBERS = '0123456789'\ndef stripNumberedName(name):\n    '''Remove trailing unique ID like IDA does for same names'''\n    idx = len(name) -1\n    while idx >= 0:\n        if (name[idx] == '_'):\n            if (len(name)-1) == idx:\n                #last char is '_', not allowed so return name\n                return name\n            else:",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "g_DefaultPrefixRegexp",
        "kind": 5,
        "importPath": "plugins.flare-ida.python.flare.struct_typer",
        "description": "plugins.flare-ida.python.flare.struct_typer",
        "peekOfCode": "g_DefaultPrefixRegexp = r'field_.*_'\nclass StructTyperWidget(QtWidgets.QDialog):\n    def __init__(self, parent=None):\n        QtWidgets.QDialog.__init__(self, parent)\n        try:\n            logger.debug('StructTyperWidget starting up')\n            self.ui=Ui_Dialog()\n            self.ui.setupUi(self)\n            self.ui.lineEdit.setText(g_DefaultPrefixRegexp)\n            self.ui.checkBox.setChecked(Qt.Unchecked)",
        "detail": "plugins.flare-ida.python.flare.struct_typer",
        "documentation": {}
    },
    {
        "label": "Ui_Dialog",
        "kind": 6,
        "importPath": "plugins.flare-ida.python.flare.struct_typer_widget",
        "description": "plugins.flare-ida.python.flare.struct_typer_widget",
        "peekOfCode": "class Ui_Dialog(object):\n    def setupUi(self, Dialog):\n        Dialog.setObjectName(\"Dialog\")\n        Dialog.resize(502, 364)\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout(Dialog)\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.verticalLayout = QtWidgets.QVBoxLayout()\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.rb_useStackFrame = QtWidgets.QRadioButton(Dialog)\n        self.rb_useStackFrame.setObjectName(\"rb_useStackFrame\")",
        "detail": "plugins.flare-ida.python.flare.struct_typer_widget",
        "documentation": {}
    },
    {
        "label": "ShellcodeDbCreator",
        "kind": 6,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "class ShellcodeDbCreator(object):\n    def __init__(self, dbPath, dirName):\n        self.dbPath = dbPath\n        self.dirName = dirName\n        self.conn = sqlite3.connect(dbPath)\n        self.initDb() \n        self.initHashesDict()\n    def close(self):\n        self.conn.close()\n        self.conn = None",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rcr",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rcr(inVal, numShifts, cb, dataSize=32):\n    '''rotate carry right instruction emulation'''\n    if numShifts == 0:\n        return inVal\n    if (numShifts < 0) or (numShifts > dataSize):\n        raise ValueError('Bad numShifts')\n    #make sure carry in bit is only 0 or 1\n    cb = cb & 1\n    if (dataSize != 8) and (dataSize != 16) and (dataSize != 32) and (dataSize != 64):\n        raise ValueError('Bad dataSize')",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror(inVal, numShifts, dataSize=32):\n    '''rotate right instruction emulation'''\n    if numShifts == 0:\n        return inVal\n    if (numShifts < 0) or (numShifts > dataSize):\n        raise ValueError('Bad numShifts')\n    if (dataSize != 8) and (dataSize != 16) and (dataSize != 32) and (dataSize != 64):\n        raise ValueError('Bad dataSize')\n    bitMask = ROTATE_BITMASK[dataSize]\n    return bitMask & ((inVal >> numShifts) | (inVal << (dataSize-numShifts)))",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol(inVal, numShifts, dataSize=32):\n    '''rotate left instruction emulation'''\n    if numShifts == 0:\n        return inVal\n    if (numShifts < 0) or (numShifts > dataSize):\n        raise ValueError('Bad numShifts')\n    if (dataSize != 8) and (dataSize != 16) and (dataSize != 32) and (dataSize != 64):\n        raise ValueError('Bad dataSize')\n    bitMask = ROTATE_BITMASK[dataSize]\n    currVal = inVal",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "poisonIvyHash",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def poisonIvyHash(inStr,fName):\n    #need a null at the end of the string\n    if inStr[-1] != b'\\x00':\n        inStr = inStr + b'\\x00'\n    cx = 0xffff\n    dx = 0xffff\n    for b1 in inStr:\n        bx = 0\n        ax = b1 ^ (cx & 0xff)\n        cx =  ((cx>>8)&0xff) | ((dx&0xff)<<8)",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol3XorEax",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol3XorEax(inString,fName):\n    if inString is None:\n        return 0\n    ecx = 0\n    eax = 0\n    for i in inString:\n        eax = eax | i\n        ecx = ecx ^ eax\n        ecx = rol(ecx, 0x3, 32)\n        ecx += 1",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol7AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol7AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x7, 32)\n        val += i\n    return val\npseudocode_rol7AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol5AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol5AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x5, 32)\n        val += i\n    return val\npseudocode_rol5AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "addRor4WithNullHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def addRor4WithNullHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString + b\"\\x00\":\n        val = (val & 0xffffff00) + ((val + i) & 0xff)\n        val = ror(val, 0x4, 32)\n    return val\npseudocode_addRor4WithNullHash32 = '''acc := 0;\nfor c in input_string_with_trailing_NULL {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror7AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror7AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = ror(val, 0x7, 32)\n        val += i\n    return val\npseudocode_ror7AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror9AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror9AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = ror(val, 0x9, 32)\n        val += i\n    return val\npseudocode_ror9AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror11AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror11AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = ror(val, 0xb, 32)\n        val += i\n    return val\npseudocode_ror11AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror13AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror13AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = ror(val, 0xd, 32)\n        val += i\n    return val\npseudocode_ror13AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror13AddWithNullHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror13AddWithNullHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString + b\"\\x00\":\n        val = ror(val, 0xd, 32)\n        val += i\n    return val\npseudocode_ror13AddWithNullHash32 = '''acc := 0;\nfor c in input_string_with_trailing_NULL {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror13AddHash32Sub1",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror13AddHash32Sub1(inString,fName):\n    '''Same as ror13AddHash32, but subtract 1 afterwards'''\n    return ror13AddHash32(inString,fName) - 1\npseudocode_ror13AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 13);\n   acc := acc + c;\n}\nacc := acc - 1;\n'''",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "shl7Shr19XorHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def shl7Shr19XorHash32(inString,fName):\n    val = 0\n    for i in inString:\n        edx = 0xffffffff & (val << 7)\n        ecx = 0xffffffff & (val >> 0x19)\n        eax = edx | ecx\n        t = 0xff & (i ^ 0xf4)\n        val = eax ^ t\n    return val\npseudocode_shl7Shr19XorHash32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "sll1AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def sll1AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        b = i\n        b = 0xff & (b | 0x60)\n        val = val + b\n        val = val << 1\n        val = 0xffffffff & val",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "crc32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def crc32(inString,fName):\n    return 0xffffffff & (zlib.crc32(inString))\ndef ror13AddHash32AddDll(inString,fName):\n    dllHash = 0\n    for c in fName:\n        dllHash = ror(dllHash, 0xd, 32)\n        if ord(c) < 97:\n            dllHash = int(dllHash) + ord(c)\n        else:\n            dllHash = int(dllHash) + ord(c) - 32",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror13AddHash32AddDll",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror13AddHash32AddDll(inString,fName):\n    dllHash = 0\n    for c in fName:\n        dllHash = ror(dllHash, 0xd, 32)\n        if ord(c) < 97:\n            dllHash = int(dllHash) + ord(c)\n        else:\n            dllHash = int(dllHash) + ord(c) - 32\n        dllHash = ror(dllHash, 0xd, 32)\n    dllHash = ror(dllHash, 0xd, 32)",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "mult21AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def mult21AddHash32(inString,fName):\n    acc = 0\n    for i in inString:\n        acc = 0xffffffff & (acc * 0x21)\n        acc = 0xffffffff & (acc + i)\n    return acc\npseudocode_hashMult21 = '''acc := 0;\nfor c in input_string {\n   acc := acc * 0x21;\n   acc := acc + c;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "add1505Shl5Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def add1505Shl5Hash32(inString,fName):\n  val = 0x1505\n  for ch in inString:\n    val += (val << 5)\n    val &= 0xFFFFFFFF\n    val += ch\n    val &= 0xFFFFFFFF\n  return val\npseudocode_add1505Shl5Hash32 = '''val := 0x1505;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol7XorHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol7XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x7, 32)\n        val = val ^ (0xff & i)\n    return val\npseudocode_rol7XorHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol7AddXor2Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol7AddXor2Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x7, 32)\n        val += (i ^ 2)\n    return val\npseudocode_rol7AddXor2Hash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "dualaccModFFF1Hash",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def dualaccModFFF1Hash(inString,fName):\n    if inString is None:\n        return 0\n    v4, v8 = 0, 1\n    for ltr in inString:\n        v8 = (ltr + v8) % 0x0FFF1\n        v4 = (v4 + v8) % 0x0FFF1\n    return (v4 << 0x10) | v8\npseudocode_dualaccModFFF1Hash = '''\nacc_1 := 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "hash_Carbanak",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def hash_Carbanak(inString,fName):\n    ctr = 0\n    for i in inString:\n        ctr = (ctr << 4) + i\n        if (ctr & 0xF0000000):\n            ctr = (((ctr & 0xF0000000) >> 24) ^ ctr) & 0x0FFFFFFF\n    return ctr\npseudocode_hash_Carbanak = '''\n    acc_1 = 0\n    for c in input_string:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "hash_ror13AddUpperDllnameHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def hash_ror13AddUpperDllnameHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    dllHash = 0\n    for i in fName:\n        dllHash = ror(dllHash, 0xd, 32)\n        b = ord(i)\n        if b >= 0x61:\n            b -= 0x20",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "fnv1Xor67f",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def fnv1Xor67f(inString,fName):\n    val = 0x811c9dc5\n    for c in inString:\n        val = (0x1000193 * (c ^ val)) & 0xffffffff\n    return val ^ 0x67f\npseudocode_fnv1Xor67f = '''\n    acc = 0x811c9dc5\n    for c in inString:\n        acc = (0x1000193 * (ord(c) ^ acc)) & 0xffffffff\n    return acc ^ 0x67f",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror13AddHash32DllSimple",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror13AddHash32DllSimple(inString,fName):\n    dll_hash = 0\n    for c in fName:\n        dll_hash = ror(dll_hash, 0xd, 32)\n        if ord(c) < 97:\n            dll_hash = int(dll_hash) + ord(c)\n        else:\n            dll_hash = int(dll_hash) + ord(c) - 32\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "imul83hAdd",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def imul83hAdd(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = val * 131\n        val += i\n    val = val & 0xFFFFFFFF\n    return val\npseudocode_imul83hAdd = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ror13AddHash32Sub20h",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def ror13AddHash32Sub20h(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = ror(val, 0xd, 32)\n        if i < 97:\n            val = int(val) + i\n        else:\n            val = int(val) + i - 32",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol3XorHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol3XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x3, 32)\n        val = val ^ i\n    return val\npseudocode_rol3XorHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "chAddRol8Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def chAddRol8Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = val ^ (i * 256)\n        val = rol(val, 0x8, 32)\n        val_hex = \"%08x\"%val\n        valh_str = val_hex[4:6]\n        valh = int(valh_str, 16)",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "xorShr8Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def xorShr8Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0xFFFFFFFF\n    for i in inString:\n        ci = i\n        ci = ci ^ val\n        ci = ci * val\n        ci_hex = \"%16x\"%ci\n        ci_hex = ci_hex[8:16]",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "addRor13Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def addRor13Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val += i\n        val = ror(val, 0xd, 32)\n    return val\npseudocode_addRor13Hash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "addRor13HashOncemore32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def addRor13HashOncemore32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val += i\n        val = ror(val, 0xd, 32)\n    val = ror(val, 0xd, 32)\n    return val\npseudocode_addRor13HashOncemore32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "addRol5HashOncemore32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def addRol5HashOncemore32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val += i\n        val = rol(val, 0x5, 32)\n    val = rol(val, 0x5, 32)\n    return val\npseudocode_addRol5HashOncemore32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "or21hXorRor11Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def or21hXorRor11Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    ors = 0\n    for i in inString:\n        ors = i | 33\n        val = val ^ ors\n        val = rol(val, 0xb, 32)\n    return val",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "or23hXorRor17Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def or23hXorRor17Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    ors = 0\n    for i in inString:\n        ors = i | 35\n        val = val ^ ors\n        val = rol(val, 0x11, 32)\n    return val",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol9AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol9AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x9, 32)\n        val += i\n    return val\npseudocode_rol9AddHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol9XorHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol9XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x9, 32)\n        val = val ^ i\n    return val\npseudocode_rol9XorHash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "xorRol9Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def xorRol9Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = val ^ i\n        val = rol(val, 0x9, 32)\n    return val\npseudocode_xorRol9Hash32 = '''acc := 0;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "shl7Shr19AddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def shl7Shr19AddHash32(inString,fName):\n    val = 0\n    for i in inString:\n        edx = 0xffffffff & (val << 7)\n        ecx = 0xffffffff & (val >> 0x19)\n        eax = edx | ecx\n        t = 0xff & i\n        val = eax + t\n    return val\npseudocode_shl7Shr19AddHash32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "playWith0xe8677835Hash",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def playWith0xe8677835Hash(inString,fName):\n    val = 0xFFFFFFFF\n    for i in inString:\n        val ^= i\n        for j in range(0, 8):\n            if (val&0x1) == 1:\n                val ^= 0xe8677835\n            val >>= 1\n    return val ^ 0xFFFFFFFF\npseudocode_playWith0xe8677835Hash = '''",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol5XorHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol5XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x5, 32)\n        ors = i | 32\n        val = val ^ ors\n    return val\npseudocode_rol5XorHash32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "shl7SubHash32DoublePulser",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def shl7SubHash32DoublePulser(inString,fName):\n    eax = 0\n    edi = 0\n    for i in inString:\n        edi = 0xffffffff & (eax << 7)\n        eax = 0xffffffff & (edi - eax)\n        eax = eax + (0xff & i)\n    edi = 0xffffffff & (eax << 7)\n    eax = 0xffffffff & (edi - eax)\n    return eax",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "imul21hAddHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def imul21hAddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0x1505\n    for i in inString:\n        val = (val * 0x21) & 0xFFFFFFFF\n        val = (val + (i & 0xFFFFFFDF)) & 0xFFFFFFFF\n    return val\npseudocode_imul21hAddHash32 = '''acc := 0x1505;\nfor c in input_string {",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "crc32bzip2lower",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def crc32bzip2lower(inString,fName):\n    crc32_table = [0] * 256\n    for i in range(256):\n        v = i << 24\n        for j in range(8):\n            if (v & 0x80000000) == 0:\n                v = (2 * v) & 0xffffffff\n            else:\n                v = ((2 * v) ^ 0x4C11DB7) & 0xffffffff\n        crc32_table[i] = v",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "shr2Shl5XorHash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def shr2Shl5XorHash32(inString,fName):\n    result = 0x4e67c6a7\n    if inString.startswith(b\"Nt\") or inString.startswith(b\"Zw\"):\n        inString = inString[2:]\n    for i in inString:\n        result ^= (i + (result >> 2) + (result << 5)) & 0xffffffff\n    return result\npseudocode_shr2Shl5XorHash32 = '''acc := 0x4e67c6a7;\nif input_string.startswith(\"Nt\") or input_string.startswith(\"Zw\") {\n   input_string += 2;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "rol8Xor0xB0D4D06Hash32",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def rol8Xor0xB0D4D06Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = val ^ (i & 0xDF)\n        val = rol(val, 0x8, 32)\n        val = val + (i & 0xDF)\n    return (val ^ 0xB0D4D06) & 0xffffffff\npseudocode_rol8Xor0xB0D4D06Hash32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "crc32Xor0xca9d4d4e",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def crc32Xor0xca9d4d4e(inString,fName):\n    return (0xffffffff & (zlib.crc32(inString))) ^ 0xca9d4d4e\ndef adler32_666(inString,fName):\n    return zlib.adler32(inString.upper(), 666) & 0xffffffff\ndef shift0x82F63B78(inString,fName):\n    val = 0\n    for i in inString:\n        v1 = ((((i | 0x20) ^ val) >> 1) ^ (0x82F63B78 * (((i | 0x20) ^ val) & 1))) & 0xffffffff\n        v2 = ((((v1 >> 1) ^ (0x82F63B78 * (v1 & 1))) >> 1) ^ (0x82F63B78 * (((v1 >> 1) ^ (0x78 * (v1 & 1))) & 1))) & 0xffffffff\n        v3 = ((((v2 >> 1) ^ (0x82F63B78 * (v2 & 1))) >> 1) ^ (0x82F63B78 * (((v2 >> 1) ^ (0x78 * (v2 & 1))) & 1))) & 0xffffffff",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "adler32_666",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def adler32_666(inString,fName):\n    return zlib.adler32(inString.upper(), 666) & 0xffffffff\ndef shift0x82F63B78(inString,fName):\n    val = 0\n    for i in inString:\n        v1 = ((((i | 0x20) ^ val) >> 1) ^ (0x82F63B78 * (((i | 0x20) ^ val) & 1))) & 0xffffffff\n        v2 = ((((v1 >> 1) ^ (0x82F63B78 * (v1 & 1))) >> 1) ^ (0x82F63B78 * (((v1 >> 1) ^ (0x78 * (v1 & 1))) & 1))) & 0xffffffff\n        v3 = ((((v2 >> 1) ^ (0x82F63B78 * (v2 & 1))) >> 1) ^ (0x82F63B78 * (((v2 >> 1) ^ (0x78 * (v2 & 1))) & 1))) & 0xffffffff\n        v4 = ((((v3 >> 1) ^ (0x82F63B78 * (v3 & 1))) >> 1) ^ (0x82F63B78 * (((v3 >> 1) ^ (0x78 * (v3 & 1))) & 1))) & 0xffffffff\n        val = ((v4 >> 1) ^ (0x82F63B78 * (v4 & 1))) & 0xffffffff",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "shift0x82F63B78",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def shift0x82F63B78(inString,fName):\n    val = 0\n    for i in inString:\n        v1 = ((((i | 0x20) ^ val) >> 1) ^ (0x82F63B78 * (((i | 0x20) ^ val) & 1))) & 0xffffffff\n        v2 = ((((v1 >> 1) ^ (0x82F63B78 * (v1 & 1))) >> 1) ^ (0x82F63B78 * (((v1 >> 1) ^ (0x78 * (v1 & 1))) & 1))) & 0xffffffff\n        v3 = ((((v2 >> 1) ^ (0x82F63B78 * (v2 & 1))) >> 1) ^ (0x82F63B78 * (((v2 >> 1) ^ (0x78 * (v2 & 1))) & 1))) & 0xffffffff\n        v4 = ((((v3 >> 1) ^ (0x82F63B78 * (v3 & 1))) >> 1) ^ (0x82F63B78 * (((v3 >> 1) ^ (0x78 * (v3 & 1))) & 1))) & 0xffffffff\n        val = ((v4 >> 1) ^ (0x82F63B78 * (v4 & 1))) & 0xffffffff\n    return val ^ 0xBC\npseudocode_contiApiHashing = '''Too hard to explain.\\nAPI string hash function from Conti ransomware.\\nSee code for information'''",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "contiApiHashing",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def contiApiHashing(inString, fName):\n    API_buffer = []\n    i = len(inString) >> 3\n    count = 0\n    while i != 0:\n        for index in range(0, 8):\n            API_buffer.append(inString[index + count])\n        count += 8\n        i -= 1\n    if len(inString) & 7 != 0:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "fnv1",
        "kind": 2,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "def fnv1(inString,fName):\n    val = 0x811c9dc5\n    for c in inString:\n        val = (0x1000193 * (c ^ val)) & 0xffffffff\n    return val\npseudocode_fnv1 = '''\n    acc = 0x811c9dc5\n    for c in inString:\n        acc = (0x1000193 * (ord(c) ^ acc)) & 0xffffffff\n    return acc",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "INTERESTING_DLLS",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "INTERESTING_DLLS = [\n    'kernel32.dll', 'comctl32.dll', 'advapi32.dll', 'comdlg32.dll',\n    'gdi32.dll',    'msvcrt.dll',   'netapi32.dll', 'ntdll.dll',\n    'ntoskrnl.exe', 'oleaut32.dll', 'psapi.dll',    'shell32.dll',\n    'shlwapi.dll',  'srsvc.dll',    'urlmon.dll',   'user32.dll',\n    'winhttp.dll',  'wininet.dll',  'ws2_32.dll',   'wship6.dll',\n    'advpack.dll', 'ole32.dll', 'rstrtmgr.dll', 'iphlpapi.dll',\n]\nVERBOSE=False\n############################################################",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "ROTATE_BITMASK",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "ROTATE_BITMASK = {\n    8  : 0xff,\n    16 : 0xffff,\n    32 : 0xffffffff,\n    64 : 0xffffffffffffffff,\n}\ndef rcr(inVal, numShifts, cb, dataSize=32):\n    '''rotate carry right instruction emulation'''\n    if numShifts == 0:\n        return inVal",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_poisonIvyHash",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_poisonIvyHash = '''Too hard to explain.\\nString hash function from POISON IVY RAT.\\nSee code for information'''\ndef rol3XorEax(inString,fName):\n    if inString is None:\n        return 0\n    ecx = 0\n    eax = 0\n    for i in inString:\n        eax = eax | i\n        ecx = ecx ^ eax\n        ecx = rol(ecx, 0x3, 32)",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol3XorEax",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol3XorEax = '''eax := 0;\necx := 0;\nfor c in input_string {\n    eax := eax | c ;\n    ecx := ecx ^ eax;\n    ecx := ROL(ecx, 0x3);\n    ecx : ecx + 1;\n    eax := 0xffffffff & (eax << 8);\n};\nreturn ecx;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol7AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol7AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 7):\n   acc := acc + c;\n}\n'''\ndef rol5AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol5AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol5AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 5):\n   acc := acc + c;\n}\n'''\ndef addRor4WithNullHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_addRor4WithNullHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_addRor4WithNullHash32 = '''acc := 0;\nfor c in input_string_with_trailing_NULL {\n   acc := (acc & 0xffffff00) + ((acc + c) & 0xff);\n   acc := ROR(acc, 4):\n}\n'''\ndef ror7AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror7AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror7AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 7):\n   acc := acc + c;\n}\n'''\ndef ror9AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror9AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror9AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 9);\n   acc := acc + c;\n}\n'''\ndef ror11AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror11AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror11AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 11);\n   acc := acc + c;\n}\n'''\ndef ror13AddHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror13AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror13AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 13);\n   acc := acc + c;\n}\n'''\ndef ror13AddWithNullHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror13AddWithNullHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror13AddWithNullHash32 = '''acc := 0;\nfor c in input_string_with_trailing_NULL {\n   acc := ROR(acc, 13);\n   acc := acc + c;\n}\n'''\ndef ror13AddHash32Sub1(inString,fName):\n    '''Same as ror13AddHash32, but subtract 1 afterwards'''\n    return ror13AddHash32(inString,fName) - 1\npseudocode_ror13AddHash32 = '''acc := 0;",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror13AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror13AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 13);\n   acc := acc + c;\n}\nacc := acc - 1;\n'''\ndef shl7Shr19XorHash32(inString,fName):\n    val = 0\n    for i in inString:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_shl7Shr19XorHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_shl7Shr19XorHash32 = '''acc := 0;\nfor c in input_string {\n   t0 = (acc << 7);\n   t1 = (acc >> 0x19);\n   t2 = t0 | t1;\n   acc = t2 ^ c ^ 0xf4;\n}\n'''\ndef sll1AddHash32(inString,fName):\n    if inString is None:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_sll1AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_sll1AddHash32 = '''acc := 0;\nfor c in input_string {\n    acc = acc + (c | 0x60);\n    acc = acc << 1;\n}\n'''\ndef crc32(inString,fName):\n    return 0xffffffff & (zlib.crc32(inString))\ndef ror13AddHash32AddDll(inString,fName):\n    dllHash = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror13AddHash32AddDll",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror13AddHash32AddDll = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 13);\n   acc := acc + c;\n}\nacc := acc + ror13add(DllName);\n'''\ndef mult21AddHash32(inString,fName):\n    acc = 0\n    for i in inString:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_hashMult21",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_hashMult21 = '''acc := 0;\nfor c in input_string {\n   acc := acc * 0x21;\n   acc := acc + c;\n}\n'''\ndef add1505Shl5Hash32(inString,fName):\n  val = 0x1505\n  for ch in inString:\n    val += (val << 5)",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_add1505Shl5Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_add1505Shl5Hash32 = '''val := 0x1505;\nfor c in input_string {\n   val := val +  (val << 5);\n   val := val + c;\n}\n'''\ndef rol7XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol7XorHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol7XorHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 7):\n   acc := acc ^ c;\n}\n'''\ndef rol7AddXor2Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol7AddXor2Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol7AddXor2Hash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 7):\n   acc := acc + (c ^ 2);\n}\n'''\ndef dualaccModFFF1Hash(inString,fName):\n    if inString is None:\n        return 0\n    v4, v8 = 0, 1",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_dualaccModFFF1Hash",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_dualaccModFFF1Hash = '''\nacc_1 := 0\nacc_2 := 0\nfor c in input_string {\n    acc_2 = (acc_2 + c) % 0x0FFF1\n    acc_1 = (acc_1 + acc2) % 0x0FFF1\n}\nreturn (acc_1 << 0x10) | acc2\n'''\ndef hash_Carbanak(inString,fName):",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_hash_Carbanak",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_hash_Carbanak = '''\n    acc_1 = 0\n    for c in input_string:\n        acc_1 = (acc_1 << 4) + c\n        if (acc_1 & 0xF0000000):\n            acc_1 = (((acc_1 & 0xF0000000) >> 24) ^ acc_1) & 0x0FFFFFFF\n    return acc_1\n'''\ndef hash_ror13AddUpperDllnameHash32(inString,fName):\n    if inString is None:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_hash_ror13AddUpperDllnameHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_hash_ror13AddUpperDllnameHash32 = '''\nacc := 0\ndllhash := 0\nfor i in dllname {\n   dllhash := ROR(acc, 13);\n   dllhash := dllhash + toupper(c);\n}\nfor i in input_string {\n   acc := ROR(acc, 13);\n   acc := acc + toupper(c);",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_fnv1Xor67f",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_fnv1Xor67f = '''\n    acc = 0x811c9dc5\n    for c in inString:\n        acc = (0x1000193 * (ord(c) ^ acc)) & 0xffffffff\n    return acc ^ 0x67f\n    return acc\n'''\ndef ror13AddHash32DllSimple(inString,fName):\n    dll_hash = 0\n    for c in fName:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror13AddHash32DllSimple",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror13AddHash32DllSimple = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 13);\n   acc := acc + c;\n}\nacc := acc + ror13add(dll_name);\n'''\ndef imul83hAdd(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_imul83hAdd",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_imul83hAdd = '''acc := 0;\nfor c in input_string {\n   acc := acc * 83h:\n   acc := acc + c;\n}\n'''\ndef ror13AddHash32Sub20h(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_ror13AddHash32Sub20h",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_ror13AddHash32Sub20h = '''acc := 0;\nfor c in input_string {\n   acc := ROR(acc, 13);\n   if (c > 0x61)\n       c = c - 0x20;\n   acc := acc + c;\n}\n'''\ndef rol3XorHash32(inString,fName):\n    if inString is None:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol3XorHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol3XorHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 3):\n   acc := acc ^ c;\n}\n'''\ndef chAddRol8Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_chAddRol8Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_chAddRol8Hash32 = '''acc := 0;\nfor c in input_string {\n   acc := ch ^ c\n   acc := ROL(acc, 8):\n   acc := cl ^ ch;\n}\n'''\ndef xorShr8Hash32(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_xorShr8Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_xorShr8Hash32 = '''acc := 0;\nfor c in input_string {\n   acc = (acc >> 8) ^ acc * (acc ^ c);\n}\n'''\ndef addRor13Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_addRor13Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_addRor13Hash32 = '''acc := 0;\nfor c in input_string {\n   acc := acc + c;\n   acc := ROR(acc, 13);\n}\n'''\ndef addRor13HashOncemore32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_addRor13HashOncemore32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_addRor13HashOncemore32 = '''acc := 0;\nfor c in input_string {\n   acc := acc + c;\n   acc := ROR(acc, 13);\n}\nacc := ROR(acc, 13);\n'''\ndef addRol5HashOncemore32(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_addRol5HashOncemore32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_addRol5HashOncemore32 = '''acc := 0;\nfor c in input_string {\n   acc := acc + c;\n   acc := ROL(acc, 5);\n}\nacc := ROL(acc, 5);\n'''\ndef or21hXorRor11Hash32(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_or21hXorRor11Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_or21hXorRor11Hash32 = '''acc := 0;\nfor c in input_string {\n   chr_or := chr | 21h;\n   acc := acc ^ chr_or;\n   acc := ROR(acc, 11);\n}\n'''\ndef or23hXorRor17Hash32(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_or23hXorRor17Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_or23hXorRor17Hash32 = '''acc := 0;\nfor c in input_string {\n   chr_or := chr | 23h;\n   acc := acc ^ chr_or;\n   acc := ROR(acc, 17);\n}\n'''\ndef rol9AddHash32(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol9AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol9AddHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 9):\n   acc := acc + c;\n}\n'''\ndef rol9XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol9XorHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol9XorHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 9):\n   acc := acc ^ c;\n}\n'''\ndef xorRol9Hash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_xorRol9Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_xorRol9Hash32 = '''acc := 0;\nfor c in input_string {\n   acc := acc ^ c;\n   acc := ROL(acc, 9):\n}\n'''\ndef shl7Shr19AddHash32(inString,fName):\n    val = 0\n    for i in inString:\n        edx = 0xffffffff & (val << 7)",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_shl7Shr19AddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_shl7Shr19AddHash32 = '''acc := 0;\nfor c in input_string {\n   t0 = (acc << 7);\n   t1 = (acc >> 0x19);\n   t2 = t0 | t1;\n   acc = t2 + c;\n}\n'''\ndef playWith0xe8677835Hash(inString,fName):\n    val = 0xFFFFFFFF",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_playWith0xe8677835Hash",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_playWith0xe8677835Hash = '''\nTBC\n'''\ndef rol5XorHash32(inString,fName):\n    if inString is None:\n        return 0\n    val = 0\n    for i in inString:\n        val = rol(val, 0x5, 32)\n        ors = i | 32",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol5XorHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol5XorHash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 5):\n   acc := acc ^ c;\n}\n'''\ndef shl7SubHash32DoublePulser(inString,fName):\n    eax = 0\n    edi = 0\n    for i in inString:",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_shl7SubHash32DoublePulser",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_shl7SubHash32DoublePulser = '''acc := 0;\nfor c in input_string {\n   t0 = (acc << 7);\n   t2 = t0 - t1;\n   acc = t2 + c;\n}\n'''\ndef imul21hAddHash32(inString,fName):\n    if inString is None:\n        return 0",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_imul21hAddHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_imul21hAddHash32 = '''acc := 0x1505;\nfor c in input_string {\n   acc := acc * 21h;\n   acc := acc + (c & 0xFFFFFFDF);\n}\nacc := SHL(acc, 7) - acc\n'''\ndef crc32bzip2lower(inString,fName):\n    crc32_table = [0] * 256\n    for i in range(256):",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_shr2Shl5XorHash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_shr2Shl5XorHash32 = '''acc := 0x4e67c6a7;\nif input_string.startswith(\"Nt\") or input_string.startswith(\"Zw\") {\n   input_string += 2;\n}\nfor c in input_string {\n   t0 := (acc >> 2);\n   t1 := (acc << 5);\n   acc := acc ^ (c + t0 + t1);\n}\n'''",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_rol8Xor0xB0D4D06Hash32",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_rol8Xor0xB0D4D06Hash32 = '''acc := 0;\nfor c in input_string {\n   acc := ROL(acc, 8):\n   acc := acc ^ c ^ 0xB0D4D06;\n}\nSmork_bot\n'''\ndef crc32Xor0xca9d4d4e(inString,fName):\n    return (0xffffffff & (zlib.crc32(inString))) ^ 0xca9d4d4e\ndef adler32_666(inString,fName):",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_contiApiHashing",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_contiApiHashing = '''Too hard to explain.\\nAPI string hash function from Conti ransomware.\\nSee code for information'''\ndef contiApiHashing(inString, fName):\n    API_buffer = []\n    i = len(inString) >> 3\n    count = 0\n    while i != 0:\n        for index in range(0, 8):\n            API_buffer.append(inString[index + count])\n        count += 8\n        i -= 1",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "pseudocode_fnv1",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "pseudocode_fnv1 = '''\n    acc = 0x811c9dc5\n    for c in inString:\n        acc = (0x1000193 * (ord(c) ^ acc)) & 0xffffffff\n    return acc\n'''\n############################################################\n# The list of tuples of (supported hash name, hash size, pseudo_code)\nHASH_TYPES = [\n    ('ror7AddHash32',       32, pseudocode_ror7AddHash32),",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "HASH_TYPES",
        "kind": 5,
        "importPath": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "description": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "peekOfCode": "HASH_TYPES = [\n    ('ror7AddHash32',       32, pseudocode_ror7AddHash32),\n    ('ror9AddHash32',       32, pseudocode_ror9AddHash32),\n    ('ror11AddHash32',      32, pseudocode_ror11AddHash32),\n    ('ror13AddHash32',      32, pseudocode_ror13AddHash32),\n    ('ror13AddWithNullHash32',  32, pseudocode_ror13AddWithNullHash32),\n    ('ror13AddHash32AddDll',   32, pseudocode_ror13AddHash32AddDll),\n    ('ror13AddHash32DllSimple',   32, pseudocode_ror13AddHash32DllSimple),\n    ('ror13AddHash32Sub20h', 32, pseudocode_ror13AddHash32Sub20h),\n    ('ror13AddHash32Sub1',  32, pseudocode_ror13AddHash32),",
        "detail": "plugins.flare-ida.shellcode_hashes.make_sc_hash_db",
        "documentation": {}
    },
    {
        "label": "init_regs",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.slow.trace_slow",
        "description": "plugins.frinet.tracer.slow.trace_slow",
        "peekOfCode": "def init_regs(arch):\n    if len(regs):return\n    if arch == \"arm64\":\n        for i in range(29):\n            regs.append(\"x\"+str(i))\n        regs.append(\"fp\")\n        regs.append(\"sp\")\n        regs.append(\"lr\")\n        regs.append(\"pc\")\n    elif arch == \"arm\":",
        "detail": "plugins.frinet.tracer.slow.trace_slow",
        "documentation": {}
    },
    {
        "label": "do_slowmode_output",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.slow.trace_slow",
        "description": "plugins.frinet.tracer.slow.trace_slow",
        "peekOfCode": "def do_slowmode_output(payload, arch):\n    init_regs(arch)\n    lastctx = None\n    lines = []\n    for ctx in payload:\n        line = []\n        for k in regs:\n            if k in ctx and (not lastctx or not k in lastctx or lastctx[k]!=ctx[k]):\n                line.append(k+\"=\"+ctx[k])\n        for k in [\"mw\", \"mr\"]:",
        "detail": "plugins.frinet.tracer.slow.trace_slow",
        "documentation": {}
    },
    {
        "label": "regs",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.slow.trace_slow",
        "description": "plugins.frinet.tracer.slow.trace_slow",
        "peekOfCode": "regs = []\ndef init_regs(arch):\n    if len(regs):return\n    if arch == \"arm64\":\n        for i in range(29):\n            regs.append(\"x\"+str(i))\n        regs.append(\"fp\")\n        regs.append(\"sp\")\n        regs.append(\"lr\")\n        regs.append(\"pc\")",
        "detail": "plugins.frinet.tracer.slow.trace_slow",
        "documentation": {}
    },
    {
        "label": "file_read",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "def file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:\n        return fd.read()\ndef file_append(path: str, data: str):\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    filepath = os.path.join(root_dir, path)\n    if not os.path.isfile(filepath):\n        logging.info(\"Creating trace file \"+filepath)\n    with open(filepath, 'a') as fd:",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "file_append",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "def file_append(path: str, data: str):\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    filepath = os.path.join(root_dir, path)\n    if not os.path.isfile(filepath):\n        logging.info(\"Creating trace file \"+filepath)\n    with open(filepath, 'a') as fd:\n        return fd.write(data)\ndef do_spawn(args):\n    do_trace(args, False)\ndef do_attach(args):",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "do_spawn",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "def do_spawn(args):\n    do_trace(args, False)\ndef do_attach(args):\n    do_trace(args, True)\ndef do_trace(args, attach):\n    global arch\n    devmgr = frida.get_device_manager()\n    if args.device:\n        logging.info('Connecting to device...')\n        try:",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "do_attach",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "def do_attach(args):\n    do_trace(args, True)\ndef do_trace(args, attach):\n    global arch\n    devmgr = frida.get_device_manager()\n    if args.device:\n        logging.info('Connecting to device...')\n        try:\n            dev = devmgr.get_device(args.device)\n        except frida.InvalidArgumentError as exc:",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "do_trace",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "def do_trace(args, attach):\n    global arch\n    devmgr = frida.get_device_manager()\n    if args.device:\n        logging.info('Connecting to device...')\n        try:\n            dev = devmgr.get_device(args.device)\n        except frida.InvalidArgumentError as exc:\n            logging.error(f'Cannot connect to device: `{exc}`.')\n            return 1",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser('Tenet Frida Tracer')\n    parser.add_argument(\n        '-v', '--verbose',\n        action='store_true',\n        help='verbose output'\n    )\n    parser.add_argument(\n        '-D', '--device',\n        type=str,",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "wd",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "wd = os.path.dirname(os.path.abspath(__file__))\nMODULE_JS_PATH = os.path.join(wd,'trace.js')\nMODULE_C_X64_PATH = os.path.join(wd,'trace_x64.c')\nMODULE_C_ARM64_PATH = os.path.join(wd,'trace_arm64.c')\nMODULE_C_ARM_PATH = os.path.join(wd,'trace_arm.c')\nMODULE_JS_SLOW_PATH = os.path.join(wd,'slow','trace_slow.js')\nTRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "MODULE_JS_PATH",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "MODULE_JS_PATH = os.path.join(wd,'trace.js')\nMODULE_C_X64_PATH = os.path.join(wd,'trace_x64.c')\nMODULE_C_ARM64_PATH = os.path.join(wd,'trace_arm64.c')\nMODULE_C_ARM_PATH = os.path.join(wd,'trace_arm.c')\nMODULE_JS_SLOW_PATH = os.path.join(wd,'slow','trace_slow.js')\nTRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "MODULE_C_X64_PATH",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "MODULE_C_X64_PATH = os.path.join(wd,'trace_x64.c')\nMODULE_C_ARM64_PATH = os.path.join(wd,'trace_arm64.c')\nMODULE_C_ARM_PATH = os.path.join(wd,'trace_arm.c')\nMODULE_JS_SLOW_PATH = os.path.join(wd,'slow','trace_slow.js')\nTRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:\n        return fd.read()",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "MODULE_C_ARM64_PATH",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "MODULE_C_ARM64_PATH = os.path.join(wd,'trace_arm64.c')\nMODULE_C_ARM_PATH = os.path.join(wd,'trace_arm.c')\nMODULE_JS_SLOW_PATH = os.path.join(wd,'slow','trace_slow.js')\nTRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:\n        return fd.read()\ndef file_append(path: str, data: str):",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "MODULE_C_ARM_PATH",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "MODULE_C_ARM_PATH = os.path.join(wd,'trace_arm.c')\nMODULE_JS_SLOW_PATH = os.path.join(wd,'slow','trace_slow.js')\nTRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:\n        return fd.read()\ndef file_append(path: str, data: str):\n    root_dir = os.path.dirname(os.path.realpath(__file__))",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "MODULE_JS_SLOW_PATH",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "MODULE_JS_SLOW_PATH = os.path.join(wd,'slow','trace_slow.js')\nTRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:\n        return fd.read()\ndef file_append(path: str, data: str):\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    filepath = os.path.join(root_dir, path)",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "TRACES_DIR",
        "kind": 5,
        "importPath": "plugins.frinet.tracer.trace",
        "description": "plugins.frinet.tracer.trace",
        "peekOfCode": "TRACES_DIR = os.path.join(wd,\"traces\")\npathlib.Path(TRACES_DIR).mkdir(exist_ok=True)\ndef file_read(path: str) -> str:\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    with open(os.path.join(root_dir, path), 'r') as fd:\n        return fd.read()\ndef file_append(path: str, data: str):\n    root_dir = os.path.dirname(os.path.realpath(__file__))\n    filepath = os.path.join(root_dir, path)\n    if not os.path.isfile(filepath):",
        "detail": "plugins.frinet.tracer.trace",
        "documentation": {}
    },
    {
        "label": "has_segment",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def has_segment(ea):\n    return bool(sark.Segment(ea).name)\nea = idaapi.next_unknown(0, idaapi.BADADDR)\nwhile ea != idaapi.BADADDR:\n    if not has_segment(ea):\n        print(f\"disabling address {ea:#x}\")\n        idaapi.disable_flags(ea, ea + 4)\n    ea = idaapi.next_unknown(ea, idaapi.BADADDR)\n# look for dangling clones metadata and:\n# 1. remove clones for missing sources",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "get_original_bytes",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def get_original_bytes(start_ea, size):\n    orig = bytearray()\n    for ea in range(start_ea, start_ea + size):\n        orig.append(idaapi.get_original_byte(ea))\n    return bytes(orig)\ndef revert_patched_BL(src_ea, original_bytes=None):\n    if original_bytes is None:\n        original_bytes = get_original_bytes(src_ea, 4)\n        if original_bytes == b\"\\xff\\xff\\xff\\xff\":\n            print(f\"cannot revert patch @ {src_ea:#x}!\")",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "revert_patched_BL",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def revert_patched_BL(src_ea, original_bytes=None):\n    if original_bytes is None:\n        original_bytes = get_original_bytes(src_ea, 4)\n        if original_bytes == b\"\\xff\\xff\\xff\\xff\":\n            print(f\"cannot revert patch @ {src_ea:#x}!\")\n            return\n    else:\n        assert len(original_bytes) == 4\n    print(f\"reverting patch @ {src_ea:#x}\")\n    idaapi.patch_bytes(src_ea, original_bytes)",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "is_valid_branch",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def is_valid_branch(src_ea, target_ea):\n    if not idaapi.is_mapped(src_ea):\n        return False\n    src = sark.Line(src_ea)\n    try:\n        if src.insn.mnem == \"B\" and src.insn.operands[0].addr == target_ea:\n            return True\n    except sark.exceptions.SarkNoInstruction:\n        return False\ndef fix_func_tail(src_ea, clone_ea):",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "fix_func_tail",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def fix_func_tail(src_ea, clone_ea):\n    try:\n        src_func = sark.Function(src_ea)\n        clone_end_ea = sark.Segment(clone_ea).end_ea\n        # we used to just call append_func_tail, but on some IDA version\n        # we started getting occasional internal errors on some of these\n        if src_func.ea not in functioninliner.function_chunk_parent_eas(clone_ea):\n            idaapi.append_func_tail(src_func._func, clone_ea, clone_end_ea)\n    except sark.exceptions.SarkNoFunction:\n        pass",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "find_clone_info",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def find_clone_info(clone_ea):\n    storage = functioninliner.ClonesStorage()\n    for func_ea, clones in storage.items():\n        for src_ea, clone_info in clones.items():\n            if clone_info.clone_ea == clone_ea:\n                return (func_ea, src_ea, clone_info)\nfor seg in list(sark.segments()):\n    if not seg.name.startswith(\"inlined_\"):\n        continue\n    clone_ea = seg.ea",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "patch_size",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def patch_size(p):\n    size_bits = max(p.original.bit_length(), p.patched.bit_length())\n    return (size_bits + 7) // 8\ndef revert_range(start_ea, size):\n    for ea in range(start_ea, start_ea + size):\n        idaapi.revert_byte(ea)\nstorage = functioninliner.ClonesStorage()\nfor patch in sark.data.get_patched_bytes().values():\n    size = patch_size(patch)\n    for l in sark.lines(patch.ea & ~0x3, patch.ea + size):",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "revert_range",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "def revert_range(start_ea, size):\n    for ea in range(start_ea, start_ea + size):\n        idaapi.revert_byte(ea)\nstorage = functioninliner.ClonesStorage()\nfor patch in sark.data.get_patched_bytes().values():\n    size = patch_size(patch)\n    for l in sark.lines(patch.ea & ~0x3, patch.ea + size):\n        try:\n            if l.insn.mnem != \"B\":\n                continue",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "ea",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "ea = idaapi.next_unknown(0, idaapi.BADADDR)\nwhile ea != idaapi.BADADDR:\n    if not has_segment(ea):\n        print(f\"disabling address {ea:#x}\")\n        idaapi.disable_flags(ea, ea + 4)\n    ea = idaapi.next_unknown(ea, idaapi.BADADDR)\n# look for dangling clones metadata and:\n# 1. remove clones for missing sources\n# 2. undo patched BLs to missing clones\nprint(\"FIXING CLONES METADATA\")",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "storage = functioninliner.ClonesStorage()\npatches = sark.data.get_patched_bytes()\nfor func_ea, clones in list(storage.items()):\n    for src_ea, clone_info in list(clones.items()):\n        valid_src = is_valid_branch(src_ea, clone_info.clone_ea)\n        if idaapi.is_mapped(clone_info.clone_ea):\n            clone_seg_name = sark.Segment(clone_info.clone_ea).name\n            parts = functioninliner.ClonesStorage.parse_storage_key(clone_seg_name)\n            if parts:\n                valid_target = parts[\"src_ea\"] == src_ea",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "patches",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "patches = sark.data.get_patched_bytes()\nfor func_ea, clones in list(storage.items()):\n    for src_ea, clone_info in list(clones.items()):\n        valid_src = is_valid_branch(src_ea, clone_info.clone_ea)\n        if idaapi.is_mapped(clone_info.clone_ea):\n            clone_seg_name = sark.Segment(clone_info.clone_ea).name\n            parts = functioninliner.ClonesStorage.parse_storage_key(clone_seg_name)\n            if parts:\n                valid_target = parts[\"src_ea\"] == src_ea\n            else:",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "storage = functioninliner.ClonesStorage()\nfor patch in sark.data.get_patched_bytes().values():\n    size = patch_size(patch)\n    for l in sark.lines(patch.ea & ~0x3, patch.ea + size):\n        try:\n            if l.insn.mnem != \"B\":\n                continue\n        except sark.exceptions.SarkNoInstruction:\n            continue\n        target_ea = l.insn.operands[0].addr",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "storage = functioninliner.ClonesStorage()\nfor func_ea in storage.keys():\n    f = sark.Function(func_ea)\n    if list(functioninliner.external_callers(f)):\n        functioninliner.inline_function(sark.Function(func_ea))\n# recalculate SP delta for all outlined chunks\nprint(\"FIXING CLONE SP ANALYSIS\")\nstorage = functioninliner.ClonesStorage()\nfor func_ea, clones in list(storage.items()):\n    for src_ea, clone_info in list(clones.items()):",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.fix_state",
        "description": "plugins.FunctionInliner.fix_state",
        "peekOfCode": "storage = functioninliner.ClonesStorage()\nfor func_ea, clones in list(storage.items()):\n    for src_ea, clone_info in list(clones.items()):\n        clone_ea = clone_info.clone_ea\n        clone_end_ea = ida_funcs.get_fchunk(clone_ea).end_ea\n        pfn = ida_funcs.get_func(src_ea)\n        for ea in range(clone_ea, clone_end_ea, 4):\n            ida_frame.recalc_spd_for_basic_block(pfn, ea)\nidaapi.plan_and_wait(0, idaapi.BADADDR)",
        "detail": "plugins.FunctionInliner.fix_state",
        "documentation": {}
    },
    {
        "label": "LoggerWithTrace",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class LoggerWithTrace(logging.getLoggerClass()):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if TRACE:\n            # add TRACE level\n            logging.TRACE = 5\n            logging.addLevelName(logging.TRACE, \"TRACE\")\n    def trace(self, msg, *args, **kwargs):\n        if TRACE:\n            self.log(logging.TRACE, msg, *args, **kwargs)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerException",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerException(Exception):\n    pass\nclass FunctionInlinerUnsupportedException(FunctionInlinerException):\n    pass\nclass FunctionInlinerUnknownFlowException(FunctionInlinerException):\n    pass\n# HELPERS\n@contextlib.contextmanager\ndef autoanalysis(enabled):\n    ida_auto.enable_auto(enabled)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerUnsupportedException",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerUnsupportedException(FunctionInlinerException):\n    pass\nclass FunctionInlinerUnknownFlowException(FunctionInlinerException):\n    pass\n# HELPERS\n@contextlib.contextmanager\ndef autoanalysis(enabled):\n    ida_auto.enable_auto(enabled)\n    try:\n        yield None",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerUnknownFlowException",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerUnknownFlowException(FunctionInlinerException):\n    pass\n# HELPERS\n@contextlib.contextmanager\ndef autoanalysis(enabled):\n    ida_auto.enable_auto(enabled)\n    try:\n        yield None\n    finally:\n        ida_auto.enable_auto(not enabled)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "PickleNetnode",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class PickleNetnode(netnode.Netnode):\n    @staticmethod\n    def _encode(data):\n        return pickle.dumps(data)\n    @staticmethod\n    def _decode(data):\n        return pickle.loads(data)\nclass RenamesStorage(PickleNetnode):\n    NETNODE = \"$ FunctionInliner.renames\"\n    RenameInfo = collections.namedtuple(\"RenameInfo\", (\"orig_name\", \"new_name\"))",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "RenamesStorage",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class RenamesStorage(PickleNetnode):\n    NETNODE = \"$ FunctionInliner.renames\"\n    RenameInfo = collections.namedtuple(\"RenameInfo\", (\"orig_name\", \"new_name\"))\n    def __init__(self):\n        super().__init__(self.NETNODE)\n    def __setitem__(self, func_ea, rename_info):\n        if not isinstance(rename_info, RenamesStorage.RenameInfo):\n            raise ValueError(\"value must be of type RenamesStorage.RenameInfo\")\n        super().__setitem__(func_ea, tuple(rename_info))\n    def __getitem__(self, func_ea):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "SingletonUserDict",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class SingletonUserDict(type(collections.UserDict)):\n    _instance = None\n    def __call__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super(SingletonUserDict, cls).__call__(*args, **kwargs)\n        return cls._instance\nclass ClonesStorage(collections.UserDict, metaclass=SingletonUserDict):\n    NETNODE = \"$ functioninliner.clones\"\n    CloneInfo = collections.namedtuple(\"CloneInfo\", (\"clone_ea\", \"orig_bytes\"))\n    class InlinedFunctionInfo(collections.UserDict):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "ClonesStorage",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class ClonesStorage(collections.UserDict, metaclass=SingletonUserDict):\n    NETNODE = \"$ functioninliner.clones\"\n    CloneInfo = collections.namedtuple(\"CloneInfo\", (\"clone_ea\", \"orig_bytes\"))\n    class InlinedFunctionInfo(collections.UserDict):\n        def __init__(self, update_callback):\n            super().__init__()\n            self._update_callback = update_callback\n        def __setitem__(self, src_ea, clone):\n            if not isinstance(clone, ClonesStorage.CloneInfo):\n                raise ValueError(\"value must be of type ClonesStorage.CloneInfo\")",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerActionBase",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerActionBase(ida_kernwin.action_handler_t):\n    def __init__(self, plugin):\n        super().__init__()\n        self.plugin = plugin\n    @property\n    def name(self):\n        return f\"{self.plugin.wanted_name}:{self.__class__.__name__}\"\n    @property\n    def label(self):\n        return \"Inline function under cursor\"",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerInlineAction",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerInlineAction(FunctionInlinerActionBase):\n    @property\n    def label(self):\n        return \"Inline function\"\n    @property\n    def shortcut(self):\n        return \"Meta-P\"\n    def activate(self, ctx):\n        func = get_function_under_cursor()\n        inline_function(func)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerUndoInlineAction",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerUndoInlineAction(FunctionInlinerActionBase):\n    @property\n    def label(self):\n        return \"Undo function inlining\"\n    def activate(self, ctx):\n        outlined_func = get_inlined_function_under_cursor()\n        undo_inline_function(outlined_func)\n        return 1\n    def update(self, ctx):\n        if get_inlined_function_under_cursor():",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerInlineAllAction",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerInlineAllAction(FunctionInlinerActionBase):\n    @property\n    def label(self):\n        return \"Inline all outlined functions\"\n    def activate(self, ctx):\n        if not explore_idb():\n            return 1\n        if not preprocess_idb():\n            return 1\n        if not inline_all_functions():",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerPatchConstantBLRs",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerPatchConstantBLRs(FunctionInlinerActionBase):\n    @property\n    def label(self):\n        return \"Patch constant register-based calls to regular calls\"\n    def activate(self, ctx):\n        if not explore_idb():\n            return 1\n        with wait_box(\"patching constant BRs...\"):\n            if not patch_constant_BRs():\n                return 1",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerHooks",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerHooks(ida_kernwin.UI_Hooks):\n    def __init__(self, ctx_actions, menu_actions):\n        super().__init__()\n        self.ctx_actions = ctx_actions\n        self.menu_actions = menu_actions\n    def ready_to_run(self):\n        for action in self.menu_actions:\n            ida_kernwin.attach_action_to_menu(action.path, action.name, ida_kernwin.SETMENU_APP)\n    def finish_populating_widget_popup(self, form, popup):\n        if ida_kernwin.get_widget_type(form) in (ida_kernwin.BWN_DISASM, ida_kernwin.BWN_PSEUDOCODE):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "FunctionInlinerPlugin",
        "kind": 6,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "class FunctionInlinerPlugin(ida_idaapi.plugin_t):\n    version = ida_idp.IDP_INTERFACE_VERSION\n    flags = ida_idaapi.PLUGIN_MOD | ida_idaapi.PLUGIN_HIDE\n    comment = \"inlines functions that were outlined\"\n    help = \"\"\n    wanted_name = \"FunctionInliner\"\n    wanted_hotkey = \"\"\n    ctx_actions_types = (FunctionInlinerInlineAction, FunctionInlinerUndoInlineAction)\n    menu_actions_types = (FunctionInlinerPatchConstantBLRs, FunctionInlinerInlineAllAction)\n    @staticmethod",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "autoanalysis",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def autoanalysis(enabled):\n    ida_auto.enable_auto(enabled)\n    try:\n        yield None\n    finally:\n        ida_auto.enable_auto(not enabled)\ndef with_autoanalysis(enabled):\n    @wrapt.decorator\n    def decorator(wrapped, instance, args, kwargs):\n        with autoanalysis(enabled):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "with_autoanalysis",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def with_autoanalysis(enabled):\n    @wrapt.decorator\n    def decorator(wrapped, instance, args, kwargs):\n        with autoanalysis(enabled):\n            return wrapped(*args, **kwargs)\n    return decorator\n@contextlib.contextmanager\ndef wait_box(msg, hide_cancel=False):\n    prefix = \"HIDECANCEL\\n\" if hide_cancel else \"\"\n    ida_kernwin.show_wait_box(prefix + msg)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "wait_box",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def wait_box(msg, hide_cancel=False):\n    prefix = \"HIDECANCEL\\n\" if hide_cancel else \"\"\n    ida_kernwin.show_wait_box(prefix + msg)\n    try:\n        yield None\n    finally:\n        ida_kernwin.hide_wait_box()\ndef get_function_under_cursor():\n    line = sark.Line()\n    # abort on unmapped addresses",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_function_under_cursor",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_function_under_cursor():\n    line = sark.Line()\n    # abort on unmapped addresses\n    if not ida_bytes.is_mapped(line.ea):\n        return None\n    # if we're on a call -> return its target\n    for xref in line.xrefs_from:\n        if xref.type.is_jump or xref.type.is_call:\n            try:\n                f = sark.Function(xref.to)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "align_downwards",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def align_downwards(ea, alignment):\n    return ea & ~(alignment - 1)\ndef align_upwards(ea, alignment):\n    return align_downwards(ea + (alignment - 1), alignment)\ndef reanalyze_line(line):\n    ida_auto.plan_range(line.ea, line.end_ea)\ndef reanalyze_program():\n    \"\"\" we used to not reanalyze the entire program, but for some reason when we surgically marked\n    for reanalysis only the stuff that we've changed, sometimes the auto analysis didn't recursively\n    go through to everything \"\"\"",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "align_upwards",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def align_upwards(ea, alignment):\n    return align_downwards(ea + (alignment - 1), alignment)\ndef reanalyze_line(line):\n    ida_auto.plan_range(line.ea, line.end_ea)\ndef reanalyze_program():\n    \"\"\" we used to not reanalyze the entire program, but for some reason when we surgically marked\n    for reanalysis only the stuff that we've changed, sometimes the auto analysis didn't recursively\n    go through to everything \"\"\"\n    ida_auto.plan_range(0, ida_idaapi.BADADDR)\ndef is_conditional_insn(insn):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "reanalyze_line",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def reanalyze_line(line):\n    ida_auto.plan_range(line.ea, line.end_ea)\ndef reanalyze_program():\n    \"\"\" we used to not reanalyze the entire program, but for some reason when we surgically marked\n    for reanalysis only the stuff that we've changed, sometimes the auto analysis didn't recursively\n    go through to everything \"\"\"\n    ida_auto.plan_range(0, ida_idaapi.BADADDR)\ndef is_conditional_insn(insn):\n    # is having a condition suffix\n    return insn._insn.segpref != 0xe  # see module/arm/arm.hpp in the IDA SDK",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "reanalyze_program",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def reanalyze_program():\n    \"\"\" we used to not reanalyze the entire program, but for some reason when we surgically marked\n    for reanalysis only the stuff that we've changed, sometimes the auto analysis didn't recursively\n    go through to everything \"\"\"\n    ida_auto.plan_range(0, ida_idaapi.BADADDR)\ndef is_conditional_insn(insn):\n    # is having a condition suffix\n    return insn._insn.segpref != 0xe  # see module/arm/arm.hpp in the IDA SDK\ndef is_chunked_function(func):\n    return len(list(function_chunk_eas(func))) > 1",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_conditional_insn",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_conditional_insn(insn):\n    # is having a condition suffix\n    return insn._insn.segpref != 0xe  # see module/arm/arm.hpp in the IDA SDK\ndef is_chunked_function(func):\n    return len(list(function_chunk_eas(func))) > 1\ndef function_chunk_eas(func):\n    ea = idc.first_func_chunk(func.ea)\n    while ea != ida_idaapi.BADADDR:\n        yield ea\n        ea = idc.next_func_chunk(func.ea, ea)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_chunked_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_chunked_function(func):\n    return len(list(function_chunk_eas(func))) > 1\ndef function_chunk_eas(func):\n    ea = idc.first_func_chunk(func.ea)\n    while ea != ida_idaapi.BADADDR:\n        yield ea\n        ea = idc.next_func_chunk(func.ea, ea)\ndef function_chunk_lines(ea):\n    start_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_START)\n    end_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_END)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "function_chunk_eas",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def function_chunk_eas(func):\n    ea = idc.first_func_chunk(func.ea)\n    while ea != ida_idaapi.BADADDR:\n        yield ea\n        ea = idc.next_func_chunk(func.ea, ea)\ndef function_chunk_lines(ea):\n    start_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_START)\n    end_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_END)\n    ea = start_ea\n    l = sark.Line(start_ea)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "function_chunk_lines",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def function_chunk_lines(ea):\n    start_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_START)\n    end_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_END)\n    ea = start_ea\n    l = sark.Line(start_ea)\n    while l.ea < end_ea:\n        yield l\n        l = l.next\ndef function_chunk_crefs(ea, ret_ea=None):\n    start_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_START)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "function_chunk_crefs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def function_chunk_crefs(ea, ret_ea=None):\n    start_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_START)\n    end_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_END)\n    for l in function_chunk_lines(ea):\n        try:\n            if l.insn.mnem == \"RET\" and ret_ea is not None:\n                external_cref_eas = (ret_ea,)\n            else:\n                external_cref_eas = (c for c in l.crefs_from if c < start_ea or c >= end_ea)\n            for target_ea in external_cref_eas:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "function_chunk_parent_eas",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def function_chunk_parent_eas(ea):\n    fchunk = ida_funcs.get_fchunk(ea)\n    fpi = ida_funcs.func_parent_iterator_t(fchunk)\n    if not fpi.first():\n        return\n    while True:\n        yield fpi.parent()\n        if not fpi.next():\n            break\ndef containing_funcs(line):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "containing_funcs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def containing_funcs(line):\n    funcs = set()\n    for parent_ea in function_chunk_parent_eas(line.ea):\n        try:\n            funcs.add(sark.Function(parent_ea))\n        except sark.exceptions.SarkNoFunction:\n            pass\n    try:\n        funcs.add(sark.Function(line.ea))\n    except sark.exceptions.SarkNoFunction:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "unreachable_function_chunks_eas",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def unreachable_function_chunks_eas(func):\n    # map all chunks in our function\n    remaining_chunks = set()\n    for start_ea in function_chunk_eas(func):\n        end_ea = idc.get_fchunk_attr(start_ea, idc.FUNCATTR_END)\n        remaining_chunks.add((start_ea, end_ea))\n    if len(remaining_chunks) == 1:\n        return\n    # discard reachable chunks\n    def discard_reachable_chunks(chunk):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "function_crefs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def function_crefs(func, ret_ea=None):\n    chunk_eas = list(function_chunk_eas(func))\n    for chunk_ea in chunk_eas:\n        for off, target_ea in function_chunk_crefs(chunk_ea, ret_ea):\n            if ida_funcs.func_contains(func._func, target_ea):\n                continue\n            src_ea = chunk_ea + off\n            src = sark.Line(src_ea)\n            if src.insn.mnem == \"BL\" and target_ea == src.end_ea:\n                # we have a flow xref going from a BL which is the last instruction of a function",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "has_function_flow_xref",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def has_function_flow_xref(line):\n    for xref in line.xrefs_to:\n        # we're only interested in flow xrefs\n        if not xref.type.is_flow:\n            continue\n        # sometimes there are useless NOPs before real code, so we discard xrefs from code\n        # which isn't in a function\n        try:\n            sark.Function(xref.frm)\n        except sark.exceptions.SarkNoFunction:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "external_callers",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def external_callers(line, functions_only=False, include_flow=False):\n    funcs = containing_funcs(line)\n    for xref in line.xrefs_to:\n        caller = sark.Line(xref.frm)\n        # skip non-code xrefs\n        if not xref.type.is_code:\n            continue\n        # skip flow xrefs\n        if not include_flow and xref.type.is_flow:\n            continue",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "linegroups",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def linegroups(n):\n    iters = [sark.lines() for _ in range(n)]\n    for i, it in enumerate(iters):\n        for _ in range(i):\n            next(it)\n    return zip(*iters)\ndef register_parts(r):\n    w = r[0]\n    n = r[1:]\n    families = (",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "register_parts",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def register_parts(r):\n    w = r[0]\n    n = r[1:]\n    families = (\n        (\"W\", \"X\"),\n        (\"B\", \"H\", \"S\", \"D\", \"Q\")\n    )\n    for f in families:\n        if w in f:\n            return (ww + n for ww in f)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "add_comment",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def add_comment(line, cmt, prepend=True):\n    if line.comments.regular is None:\n        line.comments.regular = cmt\n    elif prepend:\n        line.comments.regular = cmt + \"\\n\" + line.comments.regular\n    else:\n        line.comments.regular = line.comments.regular + \"\\n\" + cmt\ndef get_branch_target_ea(line):\n    crefs_from = set()\n    for xref in line.xrefs_from:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_branch_target_ea",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_branch_target_ea(line):\n    crefs_from = set()\n    for xref in line.xrefs_from:\n        if not xref.iscode:\n            continue\n        if xref.type.is_flow:\n            continue\n        crefs_from.add(xref.to)\n    assert len(crefs_from) == 1\n    return crefs_from.pop()",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "drefs_from_eas",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def drefs_from_eas(line):\n    # IDA marks enum refs as drefs with top address byte set to 0xff, so we filter out\n    # drefs that are not actually mapped\n    return (ea for ea in line.drefs_from if ida_bytes.is_mapped(ea))\n# NETNODE\nclass PickleNetnode(netnode.Netnode):\n    @staticmethod\n    def _encode(data):\n        return pickle.dumps(data)\n    @staticmethod",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_cloned_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_cloned_function(ea):\n    seg = sark.Segment(ea)\n    if not seg.name:\n        return None\n    parts = parse.parse(CLONE_NAME_FMT, seg.name)\n    if not parts:\n        return None\n    return sark.Function(parts[\"func_ea\"])\ndef is_originally_chunked_function(func):\n    for chunk_ea in function_chunk_eas(func):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_originally_chunked_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_originally_chunked_function(func):\n    for chunk_ea in function_chunk_eas(func):\n        # dismiss the \"main\" chunk\n        if chunk_ea == func.ea:\n            continue\n        # dismiss chunks which are inlined clones of outlined functions\n        if get_cloned_function(chunk_ea):\n            continue\n        # we found a \"real\" chunk\n        return True",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "create_code_segment",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def create_code_segment(name, size, close_to=None, page_align=False):\n    if page_align:\n        alignment = 0x1000\n    else:\n        alignment = 0x4\n    size = align_upwards(size, alignment)\n    segs = list(sorted(sark.segments(), key=lambda s: s.ea))\n    # delete a previously cloned segment if such exists\n    for s in segs:\n        if s.name == name:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "validate_branch_displacements",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def validate_branch_displacements(func, src_ea, clone_ea, ret_ea):\n    # we only go over the first function chunk since that's the one we're cloning\n    max_b_displ = 0x8000000\n    def b_displ(src, target):\n        return abs(target - (src + 4))\n    # this isn't the most accurate condition since the clone offsets may move because of\n    # our translation, but we discard that. if anything, the assembly later will fail\n    clone_cref_displs = (b_displ(clone_ea + src_off, target_ea) for src_off, target_ea in\n                         function_chunk_crefs(func.ea, ret_ea))\n    if b_displ(src_ea, clone_ea) >= max_b_displ or \\",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "fix_outlined_function_call",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def fix_outlined_function_call(src, clone_ea, clone_end_ea, func_ea, kp_asm=None):\n    if kp_asm is None:\n        kp_asm = keypatch.Keypatch_Asm()\n    # unfortunately, we've seen cases where IDA creates a function out of our clone instead of a\n    # function chunk, and this also happens sometimes when calling auto_apply_tail.\n    # therefore, we first ida_funcs.append_func_tail and only then patch and plan to reanalyze the\n    # caller\n    ida_funcs.append_func_tail(ida_funcs.get_func(src.ea), clone_ea, clone_end_ea)\n    # replace the source instruction with a B to our clone\n    mnem = src.insn.mnem",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "inline_function_call",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def inline_function_call(src, func, kp_asm=None):\n    storage = ClonesStorage()\n    func_storage = storage[func.ea]\n    if kp_asm is None:\n        kp_asm = keypatch.Keypatch_Asm()\n    # verify that the function isn't chunked\n    if is_chunked_function(func):\n        raise FunctionInlinerUnsupportedException(\"chunked functions are currently unsupported\")\n    # clone and inline the function for each of its callers\n    size = func.end_ea - func.start_ea",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "function_chunk_inlined_functions",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def function_chunk_inlined_functions(ea):\n    start_ea = idc.get_fchunk_attr(ea, idc.FUNCATTR_START)\n    for off, target_ea in function_chunk_crefs(ea):\n        func = get_cloned_function(target_ea)\n        if func:\n            src = sark.Line(start_ea + off)\n            yield (src, func)\ndef rename_outlined_function(func):\n    storage = RenamesStorage()\n    rename_info = storage.get(func.ea)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "rename_outlined_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def rename_outlined_function(func):\n    storage = RenamesStorage()\n    rename_info = storage.get(func.ea)\n    if rename_info and func.name == rename_info.new_name:\n        return\n    new_name = f\"outlined_{func.name}\"\n    rename_info = RenamesStorage.RenameInfo(func.name, new_name)\n    func.name = new_name\n    storage[func.ea] = rename_info\ndef undo_rename_outlined_function(func):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "undo_rename_outlined_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def undo_rename_outlined_function(func):\n    storage = RenamesStorage()\n    rename_info = storage.get(func.ea)\n    if not rename_info:\n        return\n    if func.name == rename_info.new_name:\n        func.name = rename_info.orig_name\n    del storage[func.ea]\ndef inline_function(func, kp_asm=None):\n    # verify that the function doesn't have any chunks which aren't inlined clones of outlined",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "inline_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def inline_function(func, kp_asm=None):\n    # verify that the function doesn't have any chunks which aren't inlined clones of outlined\n    # functions\n    if is_originally_chunked_function(func):\n        raise FunctionInlinerUnsupportedException(\"chunked functions are currently unsupported\")\n    # find functions that we've inlined into this function\n    inlined_function_calls = list(function_chunk_inlined_functions(func.ea))\n    # temporarily undo inlining into our function\n    for src, inlined_func in inlined_function_calls:\n        logger.debug(f\"temporarily undoing inlining of {inlined_func.name} into {src.ea:#x}\")",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "inline_all_functions",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def inline_all_functions():\n    logger.info(\"inlining all outlined functions...\")\n    failed_analysis = 0\n    inlined = 0\n    skipped = 0\n    erroronous = 0\n    kp_asm = keypatch.Keypatch_Asm()\n    all_funcs = list(sark.functions())\n    with wait_box(\"finding outlined functions...\"):\n        outlined_funcs = []",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "clone_insn_ret",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def clone_insn_ret(kp_asm, line, dst_ea, ret_ea):\n    assert line.insn.mnem == \"RET\" and not is_conditional_insn(line.insn)\n    asm = f\"B #{ret_ea:#x}\"  # we drop PAC flags\n    code = bytes(kp_asm.assemble(asm, dst_ea)[0])\n    logger.trace(f\"   translated to: {asm}\")\n    return code\ndef clone_insn_branch(kp_asm, line, dst_ea, func, ret_ea):\n    mnem = line.insn.mnem\n    # resolve the the branch target\n    if mnem == \"BR\":",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "clone_insn_branch",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def clone_insn_branch(kp_asm, line, dst_ea, func, ret_ea):\n    mnem = line.insn.mnem\n    # resolve the the branch target\n    if mnem == \"BR\":\n        target_ea = None\n    else:\n        target_ea = get_branch_target_ea(line)\n    if target_ea and func.start_ea <= target_ea < func.end_ea:  # local target -> copy as-is\n        logger.trace(\"   local target -> copied as-is\")\n        return line.bytes, target_ea - func.ea",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "clone_insn_mem",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def clone_insn_mem(kp_asm, line, dst_ea):\n    drefs_from = set(drefs_from_eas(line))\n    insn = line.insn\n    if len(drefs_from) == 1:\n        target_ea = drefs_from.pop()\n    else:  # this may happen with LDR when the target contains another address\n        assert len(drefs_from) == 2 and insn.mnem == \"LDR\"\n        xref = [x for x in line.xrefs_from if x.type.is_read][0]\n        target_ea = xref.to\n    target_page = target_ea & ~0xfff",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "fix_cloned_branch",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def fix_cloned_branch(kp_asm, src_ea, current_target_ea, fixed_target_ea):\n    # analyze this single instruction\n    idc.set_flag(idc.INF_AF, idc.AF_CODE, 0)\n    ida_ua.create_insn(src_ea)\n    idc.set_flag(idc.INF_AF, idc.AF_CODE, 1)\n    line = sark.Line(src_ea)\n    insn = line.insn\n    # we believe that our handling here won't match all cases, but we've never even encountered\n    # a case where this fixup has been required so we don't want to spend too much effort around it\n    # try finding and replacing the target operand with the fixed one",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "clone_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def clone_function(func, dst_ea, ret_ea=None, kp_asm=None):\n    if kp_asm is None:\n        kp_asm = keypatch.Keypatch_Asm()\n    clone_ea = dst_ea\n    # maps func_offset to clone_offset, for each cloned instruction\n    clone_offsets = {}\n    # maps source_func_offset to target_func_offset, for cloned branches which point internally\n    # to the cloned function\n    potential_target_fixups = {}\n    # go over all instructions in the first function chunk",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_inlined_function_under_cursor",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_inlined_function_under_cursor():\n    line = sark.Line()\n    # abort on unmapped addresses\n    if not ida_bytes.is_mapped(line.ea):\n        return None\n    # if we're on a branch/call -> analyze its target instead\n    for xref in line.xrefs_from:\n        if xref.type.is_jump or xref.type.is_call:\n            line = sark.Line(xref.to)\n            break",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "undo_inline_function_call",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def undo_inline_function_call(src, func):\n    storage = ClonesStorage()\n    func_storage = storage[func.ea]\n    clone_info = func_storage[src.ea]\n    logger.debug(f\"undoing clone of {func.name} at {clone_info.clone_ea:#x} for caller at {src.ea:#x}\")\n    # delete the cloned function\n    ida_segment.del_segm(clone_info.clone_ea, ida_segment.SEGMOD_KILL)\n    if ida_bytes.is_mapped(src.ea):  # maybe this was into another clone that has been undone as well\n        # revert the BL patch\n        # we don't want to do revert_byte() here, since the patched opcode may have been",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "undo_inline_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def undo_inline_function(func):\n    storage = ClonesStorage()\n    func_storage = storage[func.ea]\n    # pre-iterate the generator since we're deleting items inside\n    for src_ea, clone_info in list(func_storage.items()):\n        src = sark.Line(src_ea)\n        undo_inline_function_call(src, func)\n    undo_rename_outlined_function(func)\n# FUNCTION EXPLORATION\ndef fix_function_noret_flags():",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "fix_function_noret_flags",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def fix_function_noret_flags():\n    found = False\n    # pre-iterate since we might be adding functions inside\n    for func in list(sark.functions()):\n        for src_ea, target_ea in function_crefs(func):\n            try:\n                sark.Function(target_ea)\n                continue\n            except sark.exceptions.SarkNoFunction:\n                pass",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "create_missing_functions",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def create_missing_functions():\n    found = False\n    # pre-iterate since we might be adding functions inside\n    for func in list(sark.functions()):\n        for src_ea, target_ea in function_crefs(func):\n            try:\n                sark.Function(target_ea)\n                continue\n            except sark.exceptions.SarkNoFunction:\n                pass",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_data_heuristic",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_data_heuristic(line):\n    if line.is_code:\n        return False\n    # data with refs (e.g. jumptable)\n    if list(line.drefs_to):\n        return True\n    # all 00s (alignment data)\n    if not any(line.bytes):\n        return True\n    return False",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "detach_chunk",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def detach_chunk(chunk_ea):\n    # check whether we should dechunk this\n    chunk = sark.Line(chunk_ea)\n    if has_function_flow_xref(chunk):\n        logger.debug(f\"  found flow xref to {chunk_ea:#x} -> shouldn't dechunk\")\n        return None\n    logger.debug(f\"  detaching chunk @ {chunk_ea:#x}\")\n    chunk_end_ea = idc.get_fchunk_attr(chunk_ea, idc.FUNCATTR_END)\n    # pre-iterate the generator since we're removing fchunks inside\n    parents = list(function_chunk_parent_eas(chunk_ea))",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "dechunk_functions",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def dechunk_functions():\n    # pre-iterate since we're adding functions inside\n    functions = list(sark.functions())\n    for func in functions:\n        if ida_kernwin.user_cancelled():\n            return False\n        if not is_originally_chunked_function(func):\n            continue\n        logger.debug(f\"dechunking {func.name}...\")\n        # pre-iterate the generator since we're removing fchunks inside",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "split_outlined_function_trampolines",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def split_outlined_function_trampolines():\n    for l in sark.lines():\n        try:\n            insn = l.insn\n        except sark.exceptions.SarkNoInstruction:\n            continue  # nothing to do here...\n        if insn.mnem != \"B\" or is_conditional_insn(insn):\n            continue  # we're looking for unconditional branches\n        target_ea = insn.operands[0].addr\n        if target_ea != l.end_ea:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "make_function_chunk",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def make_function_chunk(line):\n    to_reprocess = []\n    try:\n        func = sark.Function(line)\n        # check whether we need to split target's chunk\n        chunk_start_ea = idc.get_fchunk_attr(line.ea, idc.FUNCATTR_START)\n        should_split = chunk_start_ea != line.ea\n        chunk_end_ea = idc.get_fchunk_attr(line.ea, idc.FUNCATTR_END)\n    except sark.exceptions.SarkNoFunction:\n        func = None",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "split_function",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def split_function(line):\n    chunk_start_ea = idc.get_fchunk_attr(line.ea, idc.FUNCATTR_START)\n    chunk_end_ea = idc.get_fchunk_attr(line.ea, idc.FUNCATTR_END)\n    # verify that there's no flow xref into this line\n    if has_function_flow_xref(line):\n        # try adding it as a function tail to src\n        logger.debug(f\"  found flow xref to {line.ea:#x} -> cannot split function. making function \"\n                     \"chunk instead\")\n        return make_function_chunk(line)\n    # if there's a flow xref back into *all* of our callers, create a function chunk instead",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "split_adjacent_functions",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def split_adjacent_functions():\n    # pre-iterate since we're adding functions inside\n    functions = list(sark.functions())\n    while True:\n        to_reprocess = []\n        for func in functions:\n            for src_ea, target_ea in function_crefs(func):\n                src = sark.Line(src_ea)\n                target = sark.Line(target_ea)\n                # check whether we're jumping to the middle of another function",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "explore_idb",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def explore_idb():\n    logger.info(\"exploring IDB...\")\n    logger.debug(\"reanalyzing program...\")\n    reanalyze_program()\n    exploration_steps = {\n        # some times IDA misses some trivial functions on reanalysis, I'm not sure why, so we do\n        # this ourselves as well\n        \"creating missing functions...\": create_missing_functions,\n        \"fixing missing NORET flags on functions...\": fix_function_noret_flags,\n    }",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "preprocess_idb",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def preprocess_idb():\n    logger.info(\"preprocessing IDB...\")\n    preprocessing_steps = {\n        \"dechunking functions...\": dechunk_functions,\n        \"splitting trampolines from adjacent functions...\": split_outlined_function_trampolines,\n        \"splitting adjacent functions...\": split_adjacent_functions,\n    }\n    with wait_box(\"preprocessing...\"):\n        for msg, func in preprocessing_steps.items():\n            logger.debug(\"waiting for auto-analysis to complete...\")",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "code_flow_iterator",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def code_flow_iterator(line, forward=True, stop=None, abort_on_calls=True, dfs=False,\n                       _visited_eas=None):\n    func = sark.Function(line)\n    if stop is None:\n        if forward:\n            stop = sark.Line(func.end_ea - 4)\n        else:\n            stop = sark.Line(func.start_ea)\n    if _visited_eas is None:\n        _visited_eas = set()",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "find_function_ends",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def find_function_ends(func):\n    def is_internal(ea):\n        return ida_funcs.func_contains(func._func, ea)\n    def finder(ea, visited):\n        end_eas = set()\n        while ea not in visited:\n            visited.add(ea)\n            next_eas = [next_ea for next_ea in sark.Line(ea).crefs_from if is_internal(next_ea)]\n            # handle ret/tail-call\n            if len(next_eas) == 0:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_function_prologue",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_function_prologue(line):\n    # check LR is signed (relevant only ARMv8.3 code which uses it)\n    if line.disasm == \"PACIBSP\":\n        return True\n    # check for BTI (relevant only ARMv8.5 code which uses it)\n    if line.insn.mnem == \"BTI\" and line.insn.operands[0].text == \"c\":\n        return True\n    # expect stack space to be allocated\n    insn = line.insn\n    ops = insn.operands",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_op_regs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_op_regs(op):\n    # regular vector operands will be shown as Qn in op.regs, so we don't have\n    # to treat them specially. multiple-registers are arch specific so they're not\n    # parsed by sark and we have to resolve them on our own\n    if op.type.is_special and op.text.startswith(\"{V\"):\n        m = re.fullmatch(r\"\\{V(\\d+)\\.\\d+.\\}\", op.text)\n        if m:\n            reg = f\"Q{m.group(1)}\"\n            return set((reg,))\n        else:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_insn_using_condition_flags",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_insn_using_condition_flags(insn):\n    if insn.mnem in (\"ADC\", \"CSEL\", \"CSINC\", \"CSINV\", \"CSNEG\", \"CSET\", \"CSETM\", \"CINC\", \"CINV\",\n                     \"CNEG\", \"SBC\", \"NGC\", \"FCSEL\", \"VSEL\"):\n        return True\n    else:\n        return is_conditional_insn(insn)\ndef is_insn_setting_condition_flags(insn):\n    if insn.mnem in (\"TST\", \"CMP\", \"CMN\", \"CCMP\", \"CCMN\", \"FCMP\", \"FCCMP\", \"FCMPE\", \"FCCMPE\",\n                     \"VCMP\", \"VCMPE\"):\n        return True",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_insn_setting_condition_flags",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_insn_setting_condition_flags(insn):\n    if insn.mnem in (\"TST\", \"CMP\", \"CMN\", \"CCMP\", \"CCMN\", \"FCMP\", \"FCCMP\", \"FCMPE\", \"FCCMPE\",\n                     \"VCMP\", \"VCMPE\"):\n        return True\n    else:\n        # is using the S suffix\n        return insn._insn.auxpref & 1  # see module/arm/arm.hpp in the IDA SDK\ndef get_fake_condition_flags_ops(insn):\n    # check whether this instruction uses/affects condition flags\n    is_read = is_insn_using_condition_flags(insn)",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_fake_condition_flags_ops",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_fake_condition_flags_ops(insn):\n    # check whether this instruction uses/affects condition flags\n    is_read = is_insn_using_condition_flags(insn)\n    is_write = is_insn_setting_condition_flags(insn)\n    if not (is_read or is_write):\n        return tuple()\n    # we don't bother with creating a fake operand per each read/set condition flag\n    # so create an operand reading/writing a fake NZCV reg\n    # create a fake IDA op_t\n    fake_op_t = types.SimpleNamespace(",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "get_insn_ops_with_condition_flags",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def get_insn_ops_with_condition_flags(insn):\n    # we create fake operands for condition flags used/set by the instruction\n    yield from itertools.chain(insn.operands, get_fake_condition_flags_ops(insn))\ndef is_function_using_uninitialized_regs(func):\n    logger.trace(f\"analyzing {func.name} for uninitialized reg usage\")\n    initialized_regs = set((\"SP\", \"X30\", \"LR\", \"WZR\", \"XZR\"))\n    # assume arg registers are initialized\n    for i in range(8):\n        initialized_regs.add(f\"W{i}\")\n        initialized_regs.add(f\"X{i}\")",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_function_using_uninitialized_regs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_function_using_uninitialized_regs(func):\n    logger.trace(f\"analyzing {func.name} for uninitialized reg usage\")\n    initialized_regs = set((\"SP\", \"X30\", \"LR\", \"WZR\", \"XZR\"))\n    # assume arg registers are initialized\n    for i in range(8):\n        initialized_regs.add(f\"W{i}\")\n        initialized_regs.add(f\"X{i}\")\n    # callee saved regs can be STR/STP-ed but nothing else\n    callee_saved_allowed_mnems = {\n        \"STR\": \"LDR\",",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_function_affecting_non_result_regs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_function_affecting_non_result_regs(func):\n    logger.trace(f\"analyzing {func.name} for non-result-registers effects\")\n    # these special regs can also be affected in the function epilogue\n    result_regs = set((\"SP\", \"X29\", \"X30\", \"LR\", \"WZR\", \"XZR\"))\n    for i in range(8):\n        result_regs.add(f\"W{i}\")\n        result_regs.add(f\"X{i}\")\n    # callee saved regs can be STR/STP-ed but nothing else\n    callee_saved_allowed_mnems = {\n        \"LDR\": \"STR\",",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "is_function_outlined",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def is_function_outlined(func, include_inlined=False):\n    if include_inlined:\n        if func.ea in ClonesStorage().items:\n            return True\n    # nothing to do here if we have no callers\n    if not list(external_callers(func)):\n        return False\n    # i'm not really sure about whether outlined functions never have prologues, but we'll see\n    if is_function_prologue(sark.Line(func.ea)):\n        return False",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "find_next_reg_use",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def find_next_reg_use(line, reg):\n    reg_parts = set(register_parts(reg))\n    for l in code_flow_iterator(line, abort_on_calls=False, dfs=True):\n        for op in l.insn.operands:\n            if not op.regs & reg_parts:\n                continue\n            if op.is_write:\n                return None\n            else:\n                return l",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "apply_code_patch",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def apply_code_patch(start_ea, end_ea, code, kp_asm=None):\n    if kp_asm is None:\n        kp_asm = keypatch.Keypatch_Asm()\n    size = end_ea - start_ea\n    assert len(code) <= size\n    if len(code) < size:\n        nop = bytes(kp_asm.assemble(\"NOP\", 0)[0])\n        nop_slide_size = size - len(code)\n        assert nop_slide_size % len(nop) == 0\n        code += nop * (nop_slide_size // len(nop))",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "patch_constant_BRs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def patch_constant_BRs(kp_asm=None):\n    \"\"\"patches snippets of the form:\n                ADR/L     Xn, sub_1337\n                NOP/-\n                BR/BLR    Xn\n        to:\n                B/BL      sub_1337\n    \"\"\"\n    if kp_asm is None:\n        kp_asm = keypatch.Keypatch_Asm()",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "patch_constant_tested_BRs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def patch_constant_tested_BRs(kp_asm=None):\n    \"\"\"patches snippets of the form:\n                ADR/L     Xn, sub_1337\n                NOP/-\n                CBNZ      Xn, do_call\n                B         dont_call\n            do_call:\n                BR/BLR    Xn\n            dont_call:\n        to:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "patch_constant_data_BLRs",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def patch_constant_data_BLRs(kp_asm=None):\n    \"\"\"patches snippets of the form:\n                NOP/ADRP\n                LDR       Xn, =sub_1337\n                BLR       Xn\n        where the data lives in a const segment\n        to:\n                BL      sub_1337\n    \"\"\"\n    if kp_asm is None:",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return FunctionInlinerPlugin()",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "INLINED_FUNCTION_PREFIX",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "INLINED_FUNCTION_PREFIX = \"inlined_\"\nCLONE_NAME_FMT = \"inlined_0x{func_ea:x}_for_0x{src_ea:x}\"\nTRACE = False\n# LOGGING\nclass LoggerWithTrace(logging.getLoggerClass()):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if TRACE:\n            # add TRACE level\n            logging.TRACE = 5",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "CLONE_NAME_FMT",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "CLONE_NAME_FMT = \"inlined_0x{func_ea:x}_for_0x{src_ea:x}\"\nTRACE = False\n# LOGGING\nclass LoggerWithTrace(logging.getLoggerClass()):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if TRACE:\n            # add TRACE level\n            logging.TRACE = 5\n            logging.addLevelName(logging.TRACE, \"TRACE\")",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "TRACE",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "TRACE = False\n# LOGGING\nclass LoggerWithTrace(logging.getLoggerClass()):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if TRACE:\n            # add TRACE level\n            logging.TRACE = 5\n            logging.addLevelName(logging.TRACE, \"TRACE\")\n    def trace(self, msg, *args, **kwargs):",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.FunctionInliner.functioninliner",
        "description": "plugins.FunctionInliner.functioninliner",
        "peekOfCode": "logger = LoggerWithTrace(\"FunctionInliner\")\n# EXCEPTIONS\nclass FunctionInlinerException(Exception):\n    pass\nclass FunctionInlinerUnsupportedException(FunctionInlinerException):\n    pass\nclass FunctionInlinerUnknownFlowException(FunctionInlinerException):\n    pass\n# HELPERS",
        "detail": "plugins.FunctionInliner.functioninliner",
        "documentation": {}
    },
    {
        "label": "GepettoCLI",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.cli",
        "description": "plugins.gepetto.ida.cli",
        "peekOfCode": "class GepettoCLI(ida_kernwin.cli_t):\n    flags = 0\n    sname = \"Gepetto\"\n    lname  = \"Gepetto - \" + _(\"LLM chat\")\n    hint = \"Gepetto\"\n    def OnExecuteLine(self, line):\n        MESSAGES.append({\"role\": \"user\", \"content\": line})\n        gepetto.config.model.query_model_async(MESSAGES, functools.partial(gepetto.ida.handlers.conversation_callback,\n                                                         memory=MESSAGES))\n        return True",
        "detail": "plugins.gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "cli_lifecycle_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.cli",
        "description": "plugins.gepetto.ida.cli",
        "peekOfCode": "def cli_lifecycle_callback(code, old=0):\n    if code == ida_idaapi.NW_OPENIDB:\n        CLI.register()\n    elif code == ida_idaapi.NW_CLOSEIDB or code == ida_idaapi.NW_TERMIDA:\n        CLI.unregister()\n# -----------------------------------------------------------------------------\ndef register_cli():\n    global CLI\n    if CLI:\n        CLI.unregister()",
        "detail": "plugins.gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "register_cli",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.cli",
        "description": "plugins.gepetto.ida.cli",
        "peekOfCode": "def register_cli():\n    global CLI\n    if CLI:\n        CLI.unregister()\n        cli_lifecycle_callback(ida_idaapi.NW_TERMIDA)\n    CLI = GepettoCLI()\n    if CLI.register():\n        ida_idaapi.notify_when(ida_idaapi.NW_TERMIDA | ida_idaapi.NW_OPENIDB | ida_idaapi.NW_CLOSEIDB, cli_lifecycle_callback)",
        "detail": "plugins.gepetto.ida.cli",
        "documentation": {}
    },
    {
        "label": "ExplainHandler",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "class ExplainHandler(idaapi.action_handler_t):\n    \"\"\"\n    This handler is tasked with querying the model for an explanation of the\n    given function. Once the reply is received, it is added as a function\n    comment.\n    \"\"\"\n    def __init__(self):\n        idaapi.action_handler_t.__init__(self)\n    def activate(self, ctx):\n        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "RenameHandler",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "class RenameHandler(idaapi.action_handler_t):\n    \"\"\"\n    This handler requests new variable names from the model and updates the\n    decompiler's output.\n    \"\"\"\n    def __init__(self):\n        idaapi.action_handler_t.__init__(self)\n    def activate(self, ctx):\n        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())\n        v = ida_hexrays.get_widget_vdui(ctx.widget)",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "SwapModelHandler",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "class SwapModelHandler(idaapi.action_handler_t):\n    \"\"\"\n    This handler replaces the model currently in use with another one selected by the user,\n    and updates the configuration.\n    \"\"\"\n    def __init__(self, new_model, plugin):\n        self.new_model = new_model\n        self.plugin = plugin\n    def activate(self, ctx):\n        try:",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "comment_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "def comment_callback(address, view, response):\n    \"\"\"\n    Callback that sets a comment at the given address.\n    :param address: The address of the function to comment\n    :param view: A handle to the decompiler window\n    :param response: The comment to add\n    \"\"\"\n    response = \"\\n\".join(textwrap.wrap(response, 80, replace_whitespace=False))\n    # Add the response as a comment in IDA, but preserve any existing non-Gepetto comment\n    comment = idc.get_func_cmt(address, 0)",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "conversation_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "def conversation_callback(response, memory):\n    \"\"\"\n    Callback that simply prints the model's response in IDA's output window.\n    :param response: The response returned by the model\n    :param memory: The list of messages exchanged so far, so that it can be updated.\n    :return:\n    \"\"\"\n    memory.append({\"role\": \"assistant\", \"content\": response})\n    print()\n    for line in response.split(\"\\n\"):",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "rename_callback",
        "kind": 2,
        "importPath": "plugins.gepetto.ida.handlers",
        "description": "plugins.gepetto.ida.handlers",
        "peekOfCode": "def rename_callback(address, view, response):\n    \"\"\"\n    Callback that extracts a JSON array of old names and new names from the\n    response and sets them in the pseudocode.\n    :param address: The address of the function to work on\n    :param view: A handle to the decompiler window\n    :param response: The response from the model\n    \"\"\"\n    names = json.loads(response)\n    # The rename function needs the start address of the function",
        "detail": "plugins.gepetto.ida.handlers",
        "documentation": {}
    },
    {
        "label": "GepettoPlugin",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.ui",
        "description": "plugins.gepetto.ida.ui",
        "peekOfCode": "class GepettoPlugin(idaapi.plugin_t):\n    flags = 0\n    explain_action_name = \"gepetto:explain_function\"\n    explain_menu_path = \"Edit/Gepetto/\" + _(\"Explain function\")\n    rename_action_name = \"gepetto:rename_function\"\n    rename_menu_path = \"Edit/Gepetto/\" + _(\"Rename variables\")\n    wanted_name = 'Gepetto'\n    wanted_hotkey = ''\n    comment = _(\"Uses {model} to enrich the decompiler's output\").format(model=str(gepetto.config.model))\n    help = _(\"See usage instructions on GitHub\")",
        "detail": "plugins.gepetto.ida.ui",
        "documentation": {}
    },
    {
        "label": "ContextMenuHooks",
        "kind": 6,
        "importPath": "plugins.gepetto.ida.ui",
        "description": "plugins.gepetto.ida.ui",
        "peekOfCode": "class ContextMenuHooks(idaapi.UI_Hooks):\n    def finish_populating_widget_popup(self, form, popup):\n        # Add actions to the context menu of the Pseudocode view\n        if idaapi.get_widget_type(form) == idaapi.BWN_PSEUDOCODE:\n            idaapi.attach_action_to_popup(form, popup, GepettoPlugin.explain_action_name, \"Gepetto/\")\n            idaapi.attach_action_to_popup(form, popup, GepettoPlugin.rename_action_name, \"Gepetto/\")",
        "detail": "plugins.gepetto.ida.ui",
        "documentation": {}
    },
    {
        "label": "LanguageModel",
        "kind": 6,
        "importPath": "plugins.gepetto.models.base",
        "description": "plugins.gepetto.models.base",
        "peekOfCode": "class LanguageModel(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def query_model_async(self, query, cb, additional_model_options) -> None:\n        pass\n    def __eq__(self, other):\n        return self.get_menu_name() == other.get_menu_name()\n    def __hash__(self):\n        return self.get_menu_name().__hash__()\n    @staticmethod\n    @abc.abstractmethod",
        "detail": "plugins.gepetto.models.base",
        "documentation": {}
    },
    {
        "label": "Groq",
        "kind": 6,
        "importPath": "plugins.gepetto.models.groq",
        "description": "plugins.gepetto.models.groq",
        "peekOfCode": "class Groq(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Groq\"\n    @staticmethod\n    def supported_models():\n        return [GROQ_MODEL_NAME]\n    def __init__(self, model):\n        try:\n            super().__init__(model)",
        "detail": "plugins.gepetto.models.groq",
        "documentation": {}
    },
    {
        "label": "GROQ_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.groq",
        "description": "plugins.gepetto.models.groq",
        "peekOfCode": "GROQ_MODEL_NAME = \"llama-3.1-70b-versatile\"\nclass Groq(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Groq\"\n    @staticmethod\n    def supported_models():\n        return [GROQ_MODEL_NAME]\n    def __init__(self, model):\n        try:",
        "detail": "plugins.gepetto.models.groq",
        "documentation": {}
    },
    {
        "label": "Ollama",
        "kind": 6,
        "importPath": "plugins.gepetto.models.local_ollama",
        "description": "plugins.gepetto.models.local_ollama",
        "peekOfCode": "class Ollama(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Ollama\"\n    @staticmethod\n    def supported_models():\n        global OLLAMA_MODELS\n        if OLLAMA_MODELS is None:\n            try:\n                OLLAMA_MODELS = [m[\"name\"] for m in create_client().list()[\"models\"]]",
        "detail": "plugins.gepetto.models.local_ollama",
        "documentation": {}
    },
    {
        "label": "create_client",
        "kind": 2,
        "importPath": "plugins.gepetto.models.local_ollama",
        "description": "plugins.gepetto.models.local_ollama",
        "peekOfCode": "def create_client():\n    host = gepetto.config.get_config(\"Ollama\", \"HOST\", default=\"http://localhost:11434\")\n    return ollama.Client(host=host)\nclass Ollama(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Ollama\"\n    @staticmethod\n    def supported_models():\n        global OLLAMA_MODELS",
        "detail": "plugins.gepetto.models.local_ollama",
        "documentation": {}
    },
    {
        "label": "OLLAMA_MODELS",
        "kind": 5,
        "importPath": "plugins.gepetto.models.local_ollama",
        "description": "plugins.gepetto.models.local_ollama",
        "peekOfCode": "OLLAMA_MODELS = None\ndef create_client():\n    host = gepetto.config.get_config(\"Ollama\", \"HOST\", default=\"http://localhost:11434\")\n    return ollama.Client(host=host)\nclass Ollama(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Ollama\"\n    @staticmethod\n    def supported_models():",
        "detail": "plugins.gepetto.models.local_ollama",
        "documentation": {}
    },
    {
        "label": "register_model",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def register_model(model: LanguageModel):\n    if not issubclass(model, LanguageModel):\n        return\n    if any(existing.get_menu_name() == model.get_menu_name() for existing in MODEL_LIST):\n        return\n    MODEL_LIST.append(model)\ndef list_models():\n    return MODEL_LIST\ndef instantiate_model(model):\n    \"\"\"",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "list_models",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def list_models():\n    return MODEL_LIST\ndef instantiate_model(model):\n    \"\"\"\n    Instantiates a model based on its name\n    :param model: The model to use\n    :return:\n    \"\"\"\n    for m in MODEL_LIST:\n        if model in m.supported_models():",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "instantiate_model",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def instantiate_model(model):\n    \"\"\"\n    Instantiates a model based on its name\n    :param model: The model to use\n    :return:\n    \"\"\"\n    for m in MODEL_LIST:\n        if model in m.supported_models():\n            return m(model)\n    # If nothing was found, use the default model.",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "load_available_models",
        "kind": 2,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "def load_available_models():\n    folder = pathlib.Path(os.path.dirname(__file__))\n    for py_file in folder.glob(\"*.py\"):\n        module_name = py_file.stem  # Get the file name without extension\n        spec = importlib.util.spec_from_file_location(module_name, py_file)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "FALLBACK_MODEL",
        "kind": 5,
        "importPath": "plugins.gepetto.models.model_manager",
        "description": "plugins.gepetto.models.model_manager",
        "peekOfCode": "FALLBACK_MODEL = \"gpt-4o\"\ndef register_model(model: LanguageModel):\n    if not issubclass(model, LanguageModel):\n        return\n    if any(existing.get_menu_name() == model.get_menu_name() for existing in MODEL_LIST):\n        return\n    MODEL_LIST.append(model)\ndef list_models():\n    return MODEL_LIST\ndef instantiate_model(model):",
        "detail": "plugins.gepetto.models.model_manager",
        "documentation": {}
    },
    {
        "label": "GPT",
        "kind": 6,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "class GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]\n    def __init__(self, model):\n        self.model = model\n        # Get API key",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT3_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "GPT3_MODEL_NAME = \"gpt-3.5-turbo-0125\"\nGPT4_MODEL_NAME = \"gpt-4-turbo\"\nGPT4o_MODEL_NAME = \"gpt-4o\"\nclass GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT4_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "GPT4_MODEL_NAME = \"gpt-4-turbo\"\nGPT4o_MODEL_NAME = \"gpt-4o\"\nclass GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]\n    def __init__(self, model):",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "GPT4o_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.openai",
        "description": "plugins.gepetto.models.openai",
        "peekOfCode": "GPT4o_MODEL_NAME = \"gpt-4o\"\nclass GPT(LanguageModel):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"OpenAI\"\n    @staticmethod\n    def supported_models():\n        return [GPT3_MODEL_NAME, GPT4_MODEL_NAME, GPT4o_MODEL_NAME]\n    def __init__(self, model):\n        self.model = model",
        "detail": "plugins.gepetto.models.openai",
        "documentation": {}
    },
    {
        "label": "Together",
        "kind": 6,
        "importPath": "plugins.gepetto.models.together",
        "description": "plugins.gepetto.models.together",
        "peekOfCode": "class Together(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Together\"\n    @staticmethod\n    def supported_models():\n        return [MISTRAL_MODEL_NAME]\n    def __init__(self, model):\n        try:\n            super().__init__(model)",
        "detail": "plugins.gepetto.models.together",
        "documentation": {}
    },
    {
        "label": "MISTRAL_MODEL_NAME",
        "kind": 5,
        "importPath": "plugins.gepetto.models.together",
        "description": "plugins.gepetto.models.together",
        "peekOfCode": "MISTRAL_MODEL_NAME = \"mistralai/Mixtral-8x22B-Instruct-v0.1\"\nclass Together(GPT):\n    @staticmethod\n    def get_menu_name() -> str:\n        return \"Together\"\n    @staticmethod\n    def supported_models():\n        return [MISTRAL_MODEL_NAME]\n    def __init__(self, model):\n        try:",
        "detail": "plugins.gepetto.models.together",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "def load_config():\n    \"\"\"\n    Loads the configuration of the plugin from the INI file. Sets up the correct locale and language model.\n    Also prepares an OpenAI client configured accordingly to the user specifications.\n    :return:\n    \"\"\"\n    global model, parsed_ini\n    parsed_ini = configparser.RawConfigParser()\n    parsed_ini.read(os.path.join(os.path.abspath(os.path.dirname(__file__)), \"config.ini\"))\n    # Set up translations",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "def get_config(section, option, environment_variable=None, default=None):\n    \"\"\"\n    Returns a value from the configuration, by looking successively in the configuration file and the environment\n    variables, returning the default value provided if nothing can be found.\n    :param section: The section containing the option.\n    :param option: The requested option.\n    :param environment_variable: The environment variable possibly containing the value.\n    :param default: Default value to return if nothing can be found.\n    :return: The value of the requested option.\n    \"\"\"",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "update_config",
        "kind": 2,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "def update_config(section, option, new_value):\n    \"\"\"\n    Updates a single entry in the configuration.\n    :param section: The section in which the option is located\n    :param option: The option to update\n    :param new_value: The new value to set\n    :return:\n    \"\"\"\n    path = os.path.join(os.path.abspath(os.path.dirname(__file__)), \"config.ini\")\n    config = configparser.RawConfigParser()",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "model = None\nparsed_ini = None\ndef load_config():\n    \"\"\"\n    Loads the configuration of the plugin from the INI file. Sets up the correct locale and language model.\n    Also prepares an OpenAI client configured accordingly to the user specifications.\n    :return:\n    \"\"\"\n    global model, parsed_ini\n    parsed_ini = configparser.RawConfigParser()",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "parsed_ini",
        "kind": 5,
        "importPath": "plugins.gepetto.config",
        "description": "plugins.gepetto.config",
        "peekOfCode": "parsed_ini = None\ndef load_config():\n    \"\"\"\n    Loads the configuration of the plugin from the INI file. Sets up the correct locale and language model.\n    Also prepares an OpenAI client configured accordingly to the user specifications.\n    :return:\n    \"\"\"\n    global model, parsed_ini\n    parsed_ini = configparser.RawConfigParser()\n    parsed_ini.read(os.path.join(os.path.abspath(os.path.dirname(__file__)), \"config.ini\"))",
        "detail": "plugins.gepetto.config",
        "documentation": {}
    },
    {
        "label": "HyaraBinaryNinja",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "description": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "peekOfCode": "class HyaraBinaryNinja(HyaraGUI):\n    def __init__(self):\n        super(HyaraBinaryNinja, self).__init__()\n    @property\n    def bv(self):\n        return binja_get_bv_from_dock()\n    def get_disasm(self, start_address, end_address) -> list:\n        result = []\n        bv = self.bv\n        while start_address < end_address:",
        "detail": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "documentation": {}
    },
    {
        "label": "binja_get_bv_from_dock",
        "kind": 2,
        "importPath": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "description": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "peekOfCode": "def binja_get_bv_from_dock():\n    dh = DockHandler.getActiveDockHandler()\n    if not dh:\n        return None\n    vf = dh.getViewFrame()\n    if not vf:\n        return None\n    vi = vf.getCurrentViewInterface()\n    bv = vi.getData()\n    return bv",
        "detail": "plugins.hyara_lib.integration.bn_hyara.binaryninja_api",
        "documentation": {}
    },
    {
        "label": "HyaraCutter",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.cutter_api",
        "description": "plugins.hyara_lib.integration.cutter_api",
        "peekOfCode": "class HyaraCutter(HyaraGUI):\n    def __init__(self):\n        super(HyaraCutter, self).__init__()\n    def get_disasm(self, start_address, end_address) -> list:\n        length = end_address - start_address\n        return cutter.cmd(f\"pI {length} @ {start_address}\").split(\"\\n\")\n    def get_hex(self, start_address, end_address) -> str:\n        length = end_address - start_address\n        return cutter.cmd(f\"p8 {length} @ {start_address}\").strip()\n    def get_comment_hex(self, start_address, end_address) -> list:",
        "detail": "plugins.hyara_lib.integration.cutter_api",
        "documentation": {}
    },
    {
        "label": "HyaraGhidra",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.ghidra_api",
        "description": "plugins.hyara_lib.integration.ghidra_api",
        "peekOfCode": "class HyaraGhidra(HyaraGUI):\n    def __init__(self):\n        super(HyaraGhidra, self).__init__()\n    def get_disasm(self, start_address, end_address) -> list:\n        result = []\n        current_address = toAddr(start_address)\n        while int(current_address.toString(), 16) < end_address:\n            data = getInstructionAt(current_address)\n            result.append(data.toString())\n            current_address = data.getNext().getMinAddress()",
        "detail": "plugins.hyara_lib.integration.ghidra_api",
        "documentation": {}
    },
    {
        "label": "HyaraIDA",
        "kind": 6,
        "importPath": "plugins.hyara_lib.integration.ida_api",
        "description": "plugins.hyara_lib.integration.ida_api",
        "peekOfCode": "class HyaraIDA(HyaraGUI):\n    def __init__(self):\n        super(HyaraIDA, self).__init__()\n    def get_disasm(self, start_address, end_address) -> list:\n        result = []\n        current_start = start_address\n        while current_start < end_address:\n            # https://github.com/idapython/src/blob/master/python/idautils.py#L202\n            result.append(idc.GetDisasm(current_start))\n            current_start = ida_bytes.next_head(current_start, ida_ida.cvar.inf.max_ea)",
        "detail": "plugins.hyara_lib.integration.ida_api",
        "documentation": {}
    },
    {
        "label": "YaraChecker",
        "kind": 6,
        "importPath": "plugins.hyara_lib.plugins.yara_checker",
        "description": "plugins.hyara_lib.plugins.yara_checker",
        "peekOfCode": "class YaraChecker(QtWidgets.QDialog):\n    def __init__(self, rule_text):\n        super(YaraChecker, self).__init__()\n        self.setObjectName(\"YaraChecker\")\n        self.setWindowTitle(\"YaraChecker\")\n        self.rule_text = rule_text\n    def _ui_init(self):\n        self._ui_setting()\n        self._ui_init_layout()\n        self._ui_clicked_connect()",
        "detail": "plugins.hyara_lib.plugins.yara_checker",
        "documentation": {}
    },
    {
        "label": "YaraDetector",
        "kind": 6,
        "importPath": "plugins.hyara_lib.plugins.yara_detector",
        "description": "plugins.hyara_lib.plugins.yara_detector",
        "peekOfCode": "class YaraDetector(QtWidgets.QDialog):\n    def __init__(self, rule_text, file_path, jump_to):\n        super(YaraDetector, self).__init__()\n        self.setObjectName(\"YaraDetector\")\n        self.setWindowTitle(\"YaraDetector\")\n        self.rule_text = rule_text\n        self.file_path = file_path\n        self.jump_to = jump_to\n    def _ui_init(self):\n        try:",
        "detail": "plugins.hyara_lib.plugins.yara_detector",
        "documentation": {}
    },
    {
        "label": "YaraIcon",
        "kind": 6,
        "importPath": "plugins.hyara_lib.plugins.yara_icon",
        "description": "plugins.hyara_lib.plugins.yara_icon",
        "peekOfCode": "class YaraIcon(QtWidgets.QDialog):\n    def __init__(self, file_path, rule_list, _ui_populate_table):\n        super(YaraIcon, self).__init__()\n        self.setObjectName(\"YaraIcon\")\n        self.setWindowTitle(\"YaraIcon\")\n        self.file_path = file_path\n        self.rule_list = rule_list\n        self._ui_populate_table = _ui_populate_table\n    def _ui_init(self):\n        self._ui_setting()",
        "detail": "plugins.hyara_lib.plugins.yara_icon",
        "documentation": {}
    },
    {
        "label": "ICON_HEADER",
        "kind": 5,
        "importPath": "plugins.hyara_lib.plugins.yara_icon",
        "description": "plugins.hyara_lib.plugins.yara_icon",
        "peekOfCode": "ICON_HEADER = (\n    b\"\\x00\\x00\\x01\\x00\\x01\\x00\\x30\\x30\\x00\\x00\\x01\\x00\\x08\\x00\\xA8\\x0E\\x00\\x00\\x16\\x00\\x00\\x00\"\n)\nclass YaraIcon(QtWidgets.QDialog):\n    def __init__(self, file_path, rule_list, _ui_populate_table):\n        super(YaraIcon, self).__init__()\n        self.setObjectName(\"YaraIcon\")\n        self.setWindowTitle(\"YaraIcon\")\n        self.file_path = file_path\n        self.rule_list = rule_list",
        "detail": "plugins.hyara_lib.plugins.yara_icon",
        "documentation": {}
    },
    {
        "label": "WildcardPlainTextEdit",
        "kind": 6,
        "importPath": "plugins.hyara_lib.ui.settings",
        "description": "plugins.hyara_lib.ui.settings",
        "peekOfCode": "class WildcardPlainTextEdit(QtWidgets.QPlainTextEdit):\n    def __init__(self, parent=None):\n        QtWidgets.QPlainTextEdit.__init__(self, parent)\n    def contextMenuEvent(self, event):\n        menu = QtWidgets.QMenu(self)\n        wildcard_action = menu.addAction(\"Modify the values to &wild-cards\")\n        action = menu.exec_(self.mapToGlobal(event.pos()))\n        if action == wildcard_action:\n            self._wildcard_trigger()\n    def _wildcard_trigger(self):",
        "detail": "plugins.hyara_lib.ui.settings",
        "documentation": {}
    },
    {
        "label": "MainGUI",
        "kind": 6,
        "importPath": "plugins.hyara_lib.ui.settings",
        "description": "plugins.hyara_lib.ui.settings",
        "peekOfCode": "class MainGUI:\n    def __init__(self):\n        self.layout = QtWidgets.QVBoxLayout()\n        self.rule_list = {}\n        self._ui_init()\n    def _ui_init(self):\n        self._ui_setting()\n        self._ui_init_layout()\n        self._ui_init_table()\n    def _ui_setting(self):",
        "detail": "plugins.hyara_lib.ui.settings",
        "documentation": {}
    },
    {
        "label": "HyaraGUI",
        "kind": 6,
        "importPath": "plugins.hyara_lib.ui.settings",
        "description": "plugins.hyara_lib.ui.settings",
        "peekOfCode": "class HyaraGUI(MainGUI):\n    __metaclass__ = ABCMeta\n    def __init__(self):\n        super(HyaraGUI, self).__init__()\n        self._ui_clicked_connect()\n    @abstractmethod\n    def get_disasm(self, start_address, end_address) -> list:\n        pass\n    @abstractmethod\n    def get_hex(self, start_address, end_address) -> list:",
        "detail": "plugins.hyara_lib.ui.settings",
        "documentation": {}
    },
    {
        "label": "ColorTheme",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.colortheme",
        "description": "plugins.idabincat.hexview.colortheme",
        "peekOfCode": "class ColorTheme(object):\n    \"\"\" interface \"\"\"\n    def get_accent(self, index):\n        \"\"\"\n        :rtype: PyQt5.QtGui.QColor\n        \"\"\"\n        raise NotImplementedError()\nclass LightPastelColorTheme(ColorTheme):\n    \"\"\"\n    #####  Color Palette by Paletton.com",
        "detail": "plugins.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "LightPastelColorTheme",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.colortheme",
        "description": "plugins.idabincat.hexview.colortheme",
        "peekOfCode": "class LightPastelColorTheme(ColorTheme):\n    \"\"\"\n    #####  Color Palette by Paletton.com\n    #####  Palette URL: http://paletton.com/#uid=75a0u0kcglL4Zvw8Eq6eXhmkwen\n    *** Primary color:\n       shade 0 = #8B5674 = rgb(139, 86,116) = rgba(139, 86,116,1) = rgb0(0.545,0.337,0.455)\n       shade 1 = #C9AABC = rgb(201,170,188) = rgba(201,170,188,1) = rgb0(0.788,0.667,0.737)\n       shade 2 = #A77A93 = rgb(167,122,147) = rgba(167,122,147,1) = rgb0(0.655,0.478,0.576)\n       shade 3 = #6F3B58 = rgb(111, 59, 88) = rgba(111, 59, 88,1) = rgb0(0.435,0.231,0.345)\n       shade 4 = #5C2142 = rgb( 92, 33, 66) = rgba( 92, 33, 66,1) = rgb0(0.361,0.129,0.259)",
        "detail": "plugins.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "SolarizedColorTheme",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.colortheme",
        "description": "plugins.idabincat.hexview.colortheme",
        "peekOfCode": "class SolarizedColorTheme(ColorTheme):\n    \"\"\"\n    via http://ethanschoonover.com/solarized\n    solarized accent colors:\n        $yellow:    #b58900;\n        $orange:    #cb4b16;\n        $red:       #dc322f;\n        $magenta:   #d33682;\n        $violet:    #6c71c4;\n        $blue:      #268bd2;",
        "detail": "plugins.idabincat.hexview.colortheme",
        "documentation": {}
    },
    {
        "label": "LoggingObject",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.common",
        "description": "plugins.idabincat.hexview.common",
        "peekOfCode": "class LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):\n        FUNCTION_NAME_INDEX = 3\n        return inspect.stack()[3][FUNCTION_NAME_INDEX]\n    def _formatFormatString(self, args):\n        return [self._getCallerFunction() + \": \" + args[0]] + [a for a in args[1:]]\n    def d(self, *args, **kwargs):",
        "detail": "plugins.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 2,
        "importPath": "plugins.idabincat.hexview.common",
        "description": "plugins.idabincat.hexview.common",
        "peekOfCode": "def h(i):\n    return hex(i).strip(\"L\")\ndef one(s):\n    for c in s:\n        return c\nclass LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):",
        "detail": "plugins.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "one",
        "kind": 2,
        "importPath": "plugins.idabincat.hexview.common",
        "description": "plugins.idabincat.hexview.common",
        "peekOfCode": "def one(s):\n    for c in s:\n        return c\nclass LoggingObject(object):\n    def __init__(self):\n        self._logger = logging.getLogger(\"{:s}.{:s}\".format(\n            self.__module__, self.__class__.__name__))\n    def _getCallerFunction(self):\n        FUNCTION_NAME_INDEX = 3\n        return inspect.stack()[3][FUNCTION_NAME_INDEX]",
        "detail": "plugins.idabincat.hexview.common",
        "documentation": {}
    },
    {
        "label": "HexItemDelegate",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexItemDelegate(QStyledItemDelegate):\n    pixcache = {}\n    def __init__(self, model, parent, *args):\n        super(HexItemDelegate, self).__init__(parent)\n        # compute size hint for hex view\n        dh = QTextDocument()\n        dh.setHtml(\"<font color='green'>DF</font>\")\n        self.hex_hint = QtCore.QSize(int(dh.idealWidth()-dh.documentMargin()), 22)\n        # compute size hint for char view\n        dc = QTextDocument()",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexTableModel",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexTableModel(QAbstractTableModel):\n    FILTER = ''.join(\n        [(len(repr(chr(x))) == 3 or chr(x) == \"\\\\\") and chr(x) or\n         '.' for x in range(256)])\n    def __init__(self, meminfo, parent=None, *args):\n        super(HexTableModel, self).__init__(parent, *args)\n        self._meminfo = None\n        self._rowcount = None\n        self.setNewMem(meminfo)\n    def setNewMem(self, meminfo):",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexItemSelectionModel",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexItemSelectionModel(QItemSelectionModel):\n    selectionRangeChanged = pyqtSignal([int])\n    def __init__(self, model, view):\n        \"\"\"\n        :type view: HexTableView\n        \"\"\"\n        super(HexItemSelectionModel, self).__init__(model)\n        self._model = model\n        self._view = view\n        self._start_qindex = None",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexTableView",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexTableView(QTableView, LoggingObject):\n    \"\"\" table view that handles click events for better selection handling \"\"\"\n    leftMousePressed = pyqtSignal([QMouseEvent])\n    leftMousePressedIndex = pyqtSignal([QModelIndex])\n    leftMouseMoved = pyqtSignal([QMouseEvent])\n    leftMouseMovedIndex = pyqtSignal([QModelIndex])\n    leftMouseReleased = pyqtSignal([QMouseEvent])\n    leftMouseReleasedIndex = pyqtSignal([QModelIndex])\n    moveKeyPressed = pyqtSignal([QKeySequence])\n    selectKeyPressed = pyqtSignal([QKeySequence])",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "HexViewWidget",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "class HexViewWidget(QWidget, HexViewBase, LoggingObject):\n    originsChanged = pyqtSignal()\n    newOverride = pyqtSignal(int, int, bool)\n    def __init__(self, meminfo, parent=None):\n        super(HexViewWidget, self).__init__()\n        self.setupUi(self)\n        self._meminfo = meminfo\n        self._model = HexTableModel(self._meminfo)\n        self._origins = []\n        # ripped from pyuic5 ui/hexview.ui",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "bc_log = logging.getLogger('bincat.hexview')\nbc_log.setLevel(logging.DEBUG)\nclass HexItemDelegate(QStyledItemDelegate):\n    pixcache = {}\n    def __init__(self, model, parent, *args):\n        super(HexItemDelegate, self).__init__(parent)\n        # compute size hint for hex view\n        dh = QTextDocument()\n        dh.setHtml(\"<font color='green'>DF</font>\")\n        self.hex_hint = QtCore.QSize(int(dh.idealWidth()-dh.documentMargin()), 22)",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "Origin",
        "kind": 5,
        "importPath": "plugins.idabincat.hexview.hexview",
        "description": "plugins.idabincat.hexview.hexview",
        "peekOfCode": "Origin = namedtuple(\"Origin\", [\"offset\", \"name\"])\nclass HexViewWidget(QWidget, HexViewBase, LoggingObject):\n    originsChanged = pyqtSignal()\n    newOverride = pyqtSignal(int, int, bool)\n    def __init__(self, meminfo, parent=None):\n        super(HexViewWidget, self).__init__()\n        self.setupUi(self)\n        self._meminfo = meminfo\n        self._model = HexTableModel(self._meminfo)\n        self._origins = []",
        "detail": "plugins.idabincat.hexview.hexview",
        "documentation": {}
    },
    {
        "label": "Ui_Form",
        "kind": 6,
        "importPath": "plugins.idabincat.hexview.hexview_auto",
        "description": "plugins.idabincat.hexview.hexview_auto",
        "peekOfCode": "class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(\"Form\")\n        Form.resize(400, 300)\n        self.verticalLayout = QtWidgets.QVBoxLayout(Form)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.mainLayout = QtWidgets.QVBoxLayout()\n        self.mainLayout.setObjectName(\"mainLayout\")\n        self.statusLabel = QtWidgets.QLabel(Form)\n        self.statusLabel.setMaximumSize(QtCore.QSize(16777215, 15))",
        "detail": "plugins.idabincat.hexview.hexview_auto",
        "documentation": {}
    },
    {
        "label": "pesection_t",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),\n                (\"s_lnnoptr\", ctypes.c_int),\n                (\"s_nreloc\", ctypes.c_ushort),\n                (\"s_nlnno\", ctypes.c_ushort),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "elf_ph_t",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class elf_ph_t(ctypes.Structure):\n    _fields_ = [(\"p_type\", ctypes.c_uint),\n                (\"p_flags\", ctypes.c_uint),\n                (\"p_offset\", ctypes.c_ulonglong),\n                (\"p_vaddr\", ctypes.c_ulonglong),\n                (\"p_paddr\", ctypes.c_ulonglong),\n                (\"p_filesz\", ctypes.c_ulonglong),\n                (\"p_memsz\", ctypes.c_ulonglong),\n                (\"p_align\", ctypes.c_ulonglong)]\nclass ConfigHelpers(object):",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "ConfigHelpers",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class ConfigHelpers(object):\n    \"\"\"\n    Holds helpers, that transform data obtained from ida API.\n    Used to generate default configuration.\n    \"\"\"\n    ftypes = {idaapi.f_PE: \"pe\",\n              idaapi.f_ELF: \"elf\",\n              idaapi.f_MACHO: \"macho\"}\n    @staticmethod\n    def get_file_type():",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "InitialState",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class InitialState(object):\n    \"\"\"\n    Stores the initial state configuration:\n        * registers\n        * memory\n    \"\"\"\n    def __init__(self, entrypoint=None, config=None):\n        if config:\n            arch = config.get('program', 'architecture')\n            self.mem = []",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfig",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class AnalyzerConfig(object):\n    \"\"\"\n    Handles configuration files for the analyzer.\n    \"\"\"\n    def __init__(self, config=None):\n        self.version = \"0.0\"\n        if config:\n            self._config = config\n            self.init_state = InitialState(config=config)\n        else:",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerConfigurations",
        "kind": 6,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "class AnalyzerConfigurations(object):\n    def __init__(self, state):\n        self._state = state\n        self._netnode = idabincat.netnode.Netnode()\n        #: name -> serialized AnalyzerConfig\n        self._configs = {}\n        #: address (int) -> name\n        self._prefs = {}\n        #: list of functions to be called prior to updating overrides\n        self.pre_callbacks = []",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "bc_log = logging.getLogger('bincat-cfg')\nbc_log.setLevel(logging.INFO)\nX64_GPR = ['rax', 'rcx', 'rdx', 'rbx', 'rbp', 'rsi', 'rdi', 'rsp']+[\"r%d\" % d for d in range(8, 16)]\nX86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X64_GPR",
        "kind": 5,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "X64_GPR = ['rax', 'rcx', 'rdx', 'rbx', 'rbp', 'rsi', 'rdi', 'rsp']+[\"r%d\" % d for d in range(8, 16)]\nX86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "X86_GPR",
        "kind": 5,
        "importPath": "plugins.idabincat.analyzer_conf",
        "description": "plugins.idabincat.analyzer_conf",
        "peekOfCode": "X86_GPR = ['eax', 'ecx', 'edx', 'ebx', 'ebp', 'esi', 'edi', 'esp']\n# Needed because IDA doesn't store s_psize\nclass pesection_t(ctypes.Structure):\n    _fields_ = [(\"s_name\", ctypes.c_char * 8),\n                (\"s_vsize\", ctypes.c_uint),\n                (\"s_vaddr\", ctypes.c_uint),\n                (\"s_psize\", ctypes.c_uint),\n                (\"s_scnptr\", ctypes.c_int),\n                (\"s_relptr\", ctypes.c_int),\n                (\"s_lnnoptr\", ctypes.c_int),",
        "detail": "plugins.idabincat.analyzer_conf",
        "documentation": {}
    },
    {
        "label": "AnalyzerUnavailable",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class AnalyzerUnavailable(Exception):\n    pass\nclass BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "BincatPlugin",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(BincatPlugin, self).__init__()",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class Analyzer(object):\n    def __init__(self, path, finish_cb):\n        self.path = path\n        self.finish_cb = finish_cb\n    def generate_tnpk(self, fname=None, destfname=None):\n        \"\"\"\n        Generates TNPK file for provided fname. If None, generate one for the\n        binary that is currently being analyzed in IDA, using IDA-provided\n        headers.\n        Returns file path to generated tnpk (string), or None if generation was",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzerTimer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class LocalAnalyzerTimer(object):\n    \"\"\"\n    IDA timer used to kill the BinCAT analyzer if the user\n    cancels the analysis\n    \"\"\"\n    def __init__(self, qprocess):\n        self.interval = 500  # ms\n        self.qprocess = qprocess\n        self.timer = idaapi.register_timer(self.interval, self)\n        if self.timer is None:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class LocalAnalyzer(Analyzer, QtCore.QProcess):\n    \"\"\"\n    Runs BinCAT locally using QProcess.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        QtCore.QProcess.__init__(self)\n        Analyzer.__init__(self, *args, **kwargs)\n        # Qprocess signal handlers\n        self.error.connect(self.procanalyzer_on_error)\n        self.stateChanged.connect(self.procanalyzer_on_state_change)",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "WebAnalyzer",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class WebAnalyzer(Analyzer):\n    API_VERSION = \"1.2\"\n    def __init__(self, *args, **kwargs):\n        Analyzer.__init__(self, *args, **kwargs)\n        self.server_url = PluginOptions.get(\"server_url\").rstrip(\"/\")\n        self.reachable_server = False\n        self.check_version()  # raises exception if server is unreachable\n        self.reachable_server = True\n    def check_version(self):\n        try:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class State(object):\n    \"\"\"\n    Container for (static) plugin state related data & methods.\n    \"\"\"\n    def __init__(self):\n        self.current_ea = None\n        self.cfa = None\n        self.current_node = None\n        #: list of node ids (int)\n        self.current_node_ids = []",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "CallbackWrappedList",
        "kind": 6,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "class CallbackWrappedList(MutableSequence):\n    \"\"\"\n    Acts as a List object, wraps write access with calls to properly invalidate\n    models associated with View GUI objects.\n    Should store only immutable objects.\n    \"\"\"\n    def __init__(self):\n        self._data = []\n        #: list of functions to be called prior to updating list\n        self.pre_callbacks = []",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "dedup_loglines",
        "kind": 2,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "def dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:\n                return True\n        if n == 2:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return BincatPlugin()",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.bcplugin",
        "description": "plugins.idabincat.bcplugin",
        "peekOfCode": "bc_log = logging.getLogger('bincat.plugin')\nbc_log.setLevel(logging.INFO)\ndef dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:",
        "detail": "plugins.idabincat.bcplugin",
        "documentation": {}
    },
    {
        "label": "dump_binary",
        "kind": 2,
        "importPath": "plugins.idabincat.dump_binary",
        "description": "plugins.idabincat.dump_binary",
        "peekOfCode": "def dump_binary(path):\n    sections = []\n    current_offset = 0\n    with open(path, 'wb+') as f:\n        # over all segments\n        for n in range(ida_segment.get_segm_qty()):\n            seg = ida_segment.getnseg(n)\n            start_ea = seg.start_ea\n            end_ea = seg.end_ea\n            size = end_ea - start_ea",
        "detail": "plugins.idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "dump_log",
        "kind": 5,
        "importPath": "plugins.idabincat.dump_binary",
        "description": "plugins.idabincat.dump_binary",
        "peekOfCode": "dump_log = logging.getLogger('bincat.plugin.dump_binary')\ndump_log.setLevel(logging.DEBUG)\n# Dumps a remapped binary (as seen in IDA to disk)\n# returns a list of sections\n# [(name, va, vasize, raw_addr, raw_size)]\ndef dump_binary(path):\n    sections = []\n    current_offset = 0\n    with open(path, 'wb+') as f:\n        # over all segments",
        "detail": "plugins.idabincat.dump_binary",
        "documentation": {}
    },
    {
        "label": "EditConfigurationFileForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()\n        self.configtxt.setSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                     QtWidgets.QSizePolicy.Expanding)\n        self.btn_save = QtWidgets.QPushButton('&Save', self)\n        self.btn_save.clicked.connect(self.use_config)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATOptionsForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATOptionsForm_t(QtWidgets.QDialog):\n    def __init__(self, state):\n        super(BinCATOptionsForm_t, self).__init__()\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        lbl_default_bhv = QtWidgets.QLabel(\"Default behaviour\")\n        # Save config in IDB by default\n        self.chk_save = QtWidgets.QCheckBox('Save &configuration to IDB')\n        self.chk_load = QtWidgets.QCheckBox('&Load configuration from IDB')\n        btn_start = QtWidgets.QPushButton('&Save', self)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "Meminfo",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class Meminfo(object):\n    \"\"\"\n    Helper class to access memory as a str\n    \"\"\"\n    def __init__(self, unrel, region, ranges):\n        self.unrel = unrel\n        self.region = region\n        #: list of ranges: [[begin int, end int], ...]\n        self.ranges = ranges\n        self.start = ranges[0][0]",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATMemForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATMemForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT memory display form.\n    \"\"\"\n    def __init__(self, state):\n        super(BinCATMemForm_t, self).__init__()\n        self.s = state\n        self.shown = False\n        self.created = False\n        self.hexwidget = None",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATConfigForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATConfigForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT initial configuration form\n    This form allows the definition and edition of\n    initial registers and memory\n    \"\"\"\n    def __init__(self, state, cfgregmodel, cfgmemmodel):\n        super(BinCATConfigForm_t, self).__init__()\n        self.s = state\n        self.cfgregmodel = cfgregmodel",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATDebugForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATDebugForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Debug form: display IL and instruction bytes, if present in BinCAT\n    output.\n    \"\"\"\n    def __init__(self, state):\n        super(BinCATDebugForm_t, self).__init__()\n        self.s = state\n        self.shown = False\n        self.created = False",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "RegisterItemDelegate",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class RegisterItemDelegate(QtWidgets.QStyledItemDelegate):\n    \"\"\"\n    http://stackoverflow.com/questions/35397943/how-to-make-a-fast-qtableview-with-html-formatted-and-clickable-cells\n    Represents tainted data with colors in the BinCATRegistersForm_t\n    \"\"\"\n    def paint(self, painter, options, index):\n        self.initStyleOption(options, index)\n        painter.save()\n        doc = QtGui.QTextDocument()\n        doc.setHtml(options.text)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATRegistersForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATRegistersForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Register values form\n    This form displays the values of tainted registers\n    \"\"\"\n    def __init__(self, state, regsinfo_model):\n        super(BinCATRegistersForm_t, self).__init__()\n        self.s = state\n        self.regsinfo_model = regsinfo_model\n        self.shown = False",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "InitConfigMemModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class InitConfigMemModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATConfigForm_t TableView memory widget.\n    Contains tainting and values for memory\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(InitConfigMemModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"region\", \"address\", \"value\"]\n        #: list of Value (addresses)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "InitConfigRegModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class InitConfigRegModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATConfigForm_t TableView register's widget.\n    Contains tainting and values for registers\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(InitConfigRegModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"register\", \"value\", \"top\", \"taint\"]\n        #: list of Value (addresses)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "RegistersInfoModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class RegistersInfoModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Used as model in BinCATRegistersForm TableView widgets.\n    Contains tainting and values for registers\n    \"\"\"\n    def __init__(self, state, *args, **kwargs):\n        super(RegistersInfoModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.headers = [\"register\", \"value\"]\n        self.colswidths = [90, 90]",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATOverridesForm_t",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATOverridesForm_t(ida_kernwin.PluginForm):\n    \"\"\"\n    BinCAT Overrides display form\n    Displays taint overrides defined by the user.\n    An override is defined by:\n    * an address\n    * a register name (memory: not supported yet)\n    * a taint value\n    \"\"\"\n    def __init__(self, state, overrides_model, nops_model, skips_model):",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "OverridesModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class OverridesModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(OverridesModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"eip\", \"addr or reg\", \"[value][!taint]\"]\n    def data(self, index, role):\n        if role not in (Qt.ForegroundRole, Qt.DisplayRole,\n                        Qt.EditRole, Qt.ToolTipRole):\n            return",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BinCATTableView",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class BinCATTableView(QtWidgets.QTableView):\n    def __init__(self, model, parent=None):\n        super(BinCATTableView, self).__init__(parent)\n        self.m = model\n        self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)\n    def contextMenuEvent(self, event):\n        if (self.m.rowCount(None) == 0 or\n                len(self.selectedIndexes()) == 0):\n            return",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "SkipsModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class SkipsModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(SkipsModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"address or function name\", \"arg_nb\", \"ret_val\"]\n    def data(self, index, role):\n        if role not in (Qt.DisplayRole, Qt.EditRole, Qt.ToolTipRole):\n            return\n        col = index.column()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "NopsModel",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class NopsModel(QtCore.QAbstractTableModel):\n    def __init__(self, state, *args, **kwargs):\n        super(NopsModel, self).__init__(*args, **kwargs)\n        self.s = state\n        self.clickedIndex = None\n        self.headers = [\"address or function name\"]\n    def data(self, index, role):\n        if role not in (Qt.DisplayRole, Qt.EditRole, Qt.ToolTipRole):\n            return\n        row = index.row()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleAnalyzeHere",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleAnalyzeHere(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/ Taint from here\n    base class is not a newstyle class...\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        self.s.gui.BinCATConfigForm.launch_analysis()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleAddOverride",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleAddOverride(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Add Override\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        v = ida_kernwin.get_current_viewer()\n        thing = ida_kernwin.get_highlight(v)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleNopThisInstruction",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleNopThisInstruction(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Replace this instruction with nop\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        self.s.nops.append([\"0x%x\" % self.s.current_ea])\n        return 1",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleSkipThisFunction",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleSkipThisFunction(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Skip this function...\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        self.s.gui.show_windows()\n        argret, res = QtWidgets.QInputDialog.getText(\n            None,",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleOptions",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleOptions(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Options\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        # display config window\n        bc_conf_form = BinCATOptionsForm_t(self.s)\n        bc_conf_form.exec_()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleRemap",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleRemap(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Options\n    \"\"\"\n    def __init__(self, state):\n        self.s = state\n    def activate(self, ctx):\n        # display config window\n        fname = ConfigHelpers.askfile(\"*.*\", \"Save to binary\")\n        if fname:",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "HandleShowWindows",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class HandleShowWindows(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for BinCAT/Show windows\n    \"\"\"\n    def __init__(self, gui):\n        self.gui = gui\n    def activate(self, ctx):\n        self.gui.show_windows()\n        return 1\n    def update(self, ctx):",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    \"\"\"\n    Class Hooks for BinCAT menu\n    \"\"\"\n    def __init__(self, state, gui):\n        super(Hooks, self).__init__()\n        self.s = state\n        self.gui = gui\n    def ready_to_run(self):\n        self.gui.show_windows()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GUI",
        "kind": 6,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "class GUI(object):\n    def __init__(self, state):\n        \"\"\"\n        Instanciate BinCAT views\n        \"\"\"\n        self.s = state\n        self.regsinfo_model = RegistersInfoModel(state)\n        self.configregmodel = InitConfigRegModel(state)\n        self.configmemmodel = InitConfigMemModel(state)\n        self.BinCATRegistersForm = BinCATRegistersForm_t(state, self.regsinfo_model)",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "taint_color",
        "kind": 2,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "def taint_color(n):\n    r, g, b = COLS[n % len(COLS)]\n    return b | g << 8 | r << 16\nclass EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()\n        self.configtxt.setSizePolicy(QtWidgets.QSizePolicy.Expanding,",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "bc_log = logging.getLogger('bincat.gui')\nbc_log.setLevel(logging.DEBUG)\nGREENS = [\n    (169, 241, 100),\n    (207, 207, 154),\n    (192, 195, 188),\n    (158, 199, 191),\n    (195, 238, 153),\n    (179, 179, 135),\n    (118, 155, 148),",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "GREENS",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "GREENS = [\n    (169, 241, 100),\n    (207, 207, 154),\n    (192, 195, 188),\n    (158, 199, 191),\n    (195, 238, 153),\n    (179, 179, 135),\n    (118, 155, 148),\n    (195, 207, 184),\n    (241, 242, 184),",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "BLUES_AND_YELLOWS",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "BLUES_AND_YELLOWS = [\n    (173, 109,   0),\n    (  2,  28,  66),\n    (173, 170,   0),\n    ( 41,   2,  67),\n    (140,  88,   0),\n    (  4,  68, 162),\n    (246, 241,   0),\n    ( 57,   2,  94),\n    (207, 130,   0),",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "COLS",
        "kind": 5,
        "importPath": "plugins.idabincat.gui",
        "description": "plugins.idabincat.gui",
        "peekOfCode": "COLS = GREENS  # BLUES_AND_YELLOWS\ndef taint_color(n):\n    r, g, b = COLS[n % len(COLS)]\n    return b | g << 8 | r << 16\nclass EditConfigurationFileForm_t(QtWidgets.QDialog):\n    def __init__(self, parent, state):\n        super(EditConfigurationFileForm_t, self).__init__(parent)\n        self.s = state\n        layout = QtWidgets.QGridLayout()\n        self.configtxt = QtWidgets.QPlainTextEdit()",
        "detail": "plugins.idabincat.gui",
        "documentation": {}
    },
    {
        "label": "NetnodeCorruptError",
        "kind": 6,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "class NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2\n    Conceptually, this netnode class represents is a key-value store",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "Netnode",
        "kind": 6,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "class Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2\n    Conceptually, this netnode class represents is a key-value store\n      uniquely identified by a namespace.\n    This class abstracts over some of the peculiarities of the low-level",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "BLOB_SIZE",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "BLOB_SIZE = 1024\nOUR_NETNODE = \"$ com.bincat\"\nINT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "OUR_NETNODE",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "OUR_NETNODE = \"$ com.bincat\"\nINT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "INT_KEYS_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "INT_KEYS_TAG = 'M'\nSTR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "STR_KEYS_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "STR_KEYS_TAG = 'N'\nSTR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "STR_TO_INT_MAP_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "STR_TO_INT_MAP_TAG = 'O'\nINT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "INT_TO_INT_MAP_TAG",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "INT_TO_INT_MAP_TAG = 'P'\nlogger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# get the IDA version number\nida_major, ida_minor = list(map(int, idaapi.get_kernel_version().split(\".\")))\nusing_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "using_ida7api",
        "kind": 5,
        "importPath": "plugins.idabincat.netnode",
        "description": "plugins.idabincat.netnode",
        "peekOfCode": "using_ida7api = (ida_major > 6)\nclass NetnodeCorruptError(RuntimeError):\n    pass\nclass Netnode(object):\n    \"\"\"\n    A netnode is a way to persistently store data in an IDB database.\n    The underlying interface is a bit weird, so you should read the IDA\n      documentation on the subject. Some places to start:\n      - https://www.hex-rays.com/products/ida/support/sdkdoc/netnode_8hpp.html\n      - The IDA Pro Book, version 2",
        "detail": "plugins.idabincat.netnode",
        "documentation": {}
    },
    {
        "label": "NpkGenException",
        "kind": 6,
        "importPath": "plugins.idabincat.npkgen",
        "description": "plugins.idabincat.npkgen",
        "peekOfCode": "class NpkGenException(Exception):\n    pass\nclass NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later\n        self.structs = set()\n        # add missing #defines",
        "detail": "plugins.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "NpkGen",
        "kind": 6,
        "importPath": "plugins.idabincat.npkgen",
        "description": "plugins.idabincat.npkgen",
        "peekOfCode": "class NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later\n        self.structs = set()\n        # add missing #defines\n        self.imports.append(\"#define __cdecl\")\n        nimps = idaapi.get_import_module_qty()",
        "detail": "plugins.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "npk_log",
        "kind": 5,
        "importPath": "plugins.idabincat.npkgen",
        "description": "plugins.idabincat.npkgen",
        "peekOfCode": "npk_log = logging.getLogger('bincat.plugin.npkgen')\nnpk_log.setLevel(logging.INFO)\nclass NpkGenException(Exception):\n    pass\nclass NpkGen(object):\n    def get_header_data(self):\n        self.imports = []\n        #: Types we have already inspected\n        self.seen = set()\n        #: List of structures, to patch .h later",
        "detail": "plugins.idabincat.npkgen",
        "documentation": {}
    },
    {
        "label": "PluginOptions",
        "kind": 6,
        "importPath": "plugins.idabincat.plugin_options",
        "description": "plugins.idabincat.plugin_options",
        "peekOfCode": "class PluginOptions(object):\n    _options = None\n    @classmethod\n    def init(cls):\n        # Configuration files path\n        idausr = ida_diskio.get_user_idadir()\n        cls.config_path = os.path.join(idausr, \"plugins\", \"idabincat\")\n        # Plugin options\n        def_options = {\n            \"save_to_idb\": \"False\",  # config only - results are always saved",
        "detail": "plugins.idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.idabincat.plugin_options",
        "description": "plugins.idabincat.plugin_options",
        "peekOfCode": "bc_log = logging.getLogger('bincat.gui.pluginoptions')\nbc_log.setLevel(logging.DEBUG)\nclass PluginOptions(object):\n    _options = None\n    @classmethod\n    def init(cls):\n        # Configuration files path\n        idausr = ida_diskio.get_user_idadir()\n        cls.config_path = os.path.join(idausr, \"plugins\", \"idabincat\")\n        # Plugin options",
        "detail": "plugins.idabincat.plugin_options",
        "documentation": {}
    },
    {
        "label": "qInitResources",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "def qInitResources():\n    QtCore.qRegisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\ndef qCleanupResources():\n    QtCore.qUnregisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\nqInitResources()",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "qCleanupResources",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "def qCleanupResources():\n    QtCore.qUnregisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\nqInitResources()",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "qt_resource_data",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "qt_resource_data = b\"\\\n\\x00\\x00\\x13\\x90\\\n\\x89\\\n\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52\\x00\\\n\\x00\\x00\\x40\\x00\\x00\\x00\\x40\\x08\\x06\\x00\\x00\\x00\\xaa\\x69\\x71\\xde\\\n\\x00\\x00\\x00\\xc5\\x7a\\x54\\x58\\x74\\x52\\x61\\x77\\x20\\x70\\x72\\x6f\\x66\\\n\\x69\\x6c\\x65\\x20\\x74\\x79\\x70\\x65\\x20\\x65\\x78\\x69\\x66\\x00\\x00\\x78\\\n\\xda\\x6d\\x50\\xdb\\x0d\\xc3\\x30\\x08\\xfc\\x67\\x8a\\x8e\\xc0\\xcb\\x0e\\x1e\\\n\\xc7\\x69\\x53\\xa9\\x1b\\x74\\xfc\\x62\\x43\\xa2\\xa4\\xed\\x49\\x3e\\x03\\x67\\\n\\x1d\\x18\\xd8\\xde\\xaf\\x27\\xdc\\x06\\x98\\x14\\xb4\\x2c\\x56\\x5b\\xad\\xe8\\",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "qt_resource_name",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "qt_resource_name = b\"\\\n\\x00\\x06\\\n\\x06\\xfa\\x7a\\x35\\\n\\x00\\x69\\\n\\x00\\x64\\x00\\x61\\x00\\x63\\x00\\x6c\\x00\\x75\\\n\\x00\\x0d\\\n\\x01\\x8e\\x32\\x47\\\n\\x00\\x73\\\n\\x00\\x61\\x00\\x76\\x00\\x65\\x00\\x5f\\x00\\x31\\x00\\x5f\\x00\\x36\\x00\\x34\\x00\\x2e\\x00\\x70\\x00\\x6e\\x00\\x67\\\n\\x00\\x0b\\",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "qt_resource_struct_v1",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "qt_resource_struct_v1 = b\"\\\n\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\\n\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x02\\\n\\x00\\x00\\x00\\x6c\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1b\\xac\\\n\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x00\\x84\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x1d\\xd2\\\n\\x00\\x00\\x00\\x32\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x13\\x94\\\n\\x00\\x00\\x00\\x4e\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x1a\\x5a\\\n\"\nqt_resource_struct_v2 = b\"\\",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "qt_resource_struct_v2",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "qt_resource_struct_v2 = b\"\\\n\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x02\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x00\\x6c\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1b\\xac\\\n\\x00\\x00\\x01\\x8c\\x58\\xee\\x7c\\x38\\\n\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x01\\x92\\xfd\\x56\\x1a\\xa2\\\n\\x00\\x00\\x00\\x84\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x1d\\xd2\\",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "qt_version",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.assets.resource",
        "description": "plugins.IdaClu.idaclu.assets.resource",
        "peekOfCode": "qt_version = [int(v) for v in QtCore.qVersion().split('.')]\nif qt_version < [5, 8, 0]:\n    rcc_version = 1\n    qt_resource_struct = qt_resource_struct_v1\nelse:\n    rcc_version = 2\n    qt_resource_struct = qt_resource_struct_v2\ndef qInitResources():\n    QtCore.qRegisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\ndef qCleanupResources():",
        "detail": "plugins.IdaClu.idaclu.assets.resource",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_xref_count = len(list(idautils.XrefsTo(func_addr)))\n        xref_key = \"xrefs: {}\".format(func_xref_count)\n        report['data'][xref_key].append(func_addr)\n        report['stat'][xref_key] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Xref Count')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_func_item_eas",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "def get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_leaf(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    for item_ea in item_eas:\n        if ida_shims.ua_mnem(item_ea) == 'call':\n            return False\n    else:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "is_func_leaf",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "def is_func_leaf(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    for item_ea in item_eas:\n        if ida_shims.ua_mnem(item_ea) == 'call':\n            return False\n    else:\n        if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':\n            return False\n        else:\n            return True",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "is_func_expl",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "def is_func_expl(func_addr):\n    call_afacts = [\n        'call sub_',\n        'call _',\n        'call ds:',\n        'call nullsub_',\n        'call loc_',\n        'call off_',\n        'call j_',\n        'call ??',",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_func_type_src",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "def get_func_type_src(func_addr):\n    if is_func_leaf(func_addr):\n        return 'leaf'\n    is_wrap, wrap_mod = ida_utils.is_func_wrapper(func_addr)\n    if is_wrap:\n        return \"wrap_{}\".format(\"_\".join(sorted(wrap_mod)))\n    if is_func_expl(func_addr):\n        return 'expl'\n    else:\n        return 'impl'",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_type = get_func_type_src(func_addr)\n        report['data'][func_type].append(func_addr)\n        report['stat'][func_type] += 1\n    report['data'] = collections.OrderedDict(sorted(report['data'].items()))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('Xref Source')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_leaf(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_leaf(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    for item_ea in item_eas:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_leaf(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    for item_ea in item_eas:\n        if ida_shims.ua_mnem(item_ea) == 'call':",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_leaf(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    for item_ea in item_eas:\n        if ida_shims.ua_mnem(item_ea) == 'call':\n            return False",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_2",
        "documentation": {}
    },
    {
        "label": "is_fname_main",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()\n    return is_main\ndef is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)\n    func_flags = ida_shims.get_func_flags(func_addr)\n    is_lib_flag = func_flags & idaapi.FUNC_LIB\n    return is_lib_flag and not is_dummy and not is_main",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_func_lib",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)\n    func_flags = ida_shims.get_func_flags(func_addr)\n    is_lib_flag = func_flags & idaapi.FUNC_LIB\n    return is_lib_flag and not is_dummy and not is_main\ndef is_func_thunk(func_addr):\n    func_flags = ida_shims.get_func_flags(func_addr)\n    return func_flags & idaapi.FUNC_THUNK",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_func_thunk",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_func_thunk(func_addr):\n    func_flags = ida_shims.get_func_flags(func_addr)\n    return func_flags & idaapi.FUNC_THUNK\ndef is_func_imp(func_addr):\n    dasm_line = ida_shims.generate_disasm_line(func_addr, idaapi.GENDSM_FORCE_CODE)\n    dasm_norm = ' '.join(dasm_line.split())\n    return dasm_norm.startswith('jmp ds:__imp_')\ndef is_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    if (is_func_lib(func_addr) or",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_func_imp",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_func_imp(func_addr):\n    dasm_line = ida_shims.generate_disasm_line(func_addr, idaapi.GENDSM_FORCE_CODE)\n    dasm_norm = ' '.join(dasm_line.split())\n    return dasm_norm.startswith('jmp ds:__imp_')\ndef is_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    if (is_func_lib(func_addr) or\n        is_fname_lib(func_name, True) or\n        ida_shims.get_segm_name(func_addr) == 'extern'):\n        return True",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_lib",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    if (is_func_lib(func_addr) or\n        is_fname_lib(func_name, True) or\n        ida_shims.get_segm_name(func_addr) == 'extern'):\n        return True\n    else:\n        return False\ndef is_fname_lib(func_name, is_main=True):\n    exclude_funcs = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_fname_lib",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_fname_lib(func_name, is_main=True):\n    exclude_funcs = []\n    if is_main == True:\n        exclude_funcs.extend(['_main', '_wmain', '_WinMain@16'])\n    if (not func_name in exclude_funcs) and \\\n        (\n            func_name.startswith('_') or\n            func_name.startswith('?') or\n            func_name.startswith('unknown_libname_') or\n            func_name.startswith('@_') or",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_fname_payload",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_fname_payload(func_name):\n    lib_payload = [\n        \"`anonymous namespace'\",\n        \"??1exception@boost@@MAE@XZ\",\n        \"___std_parallel_algorithms_hw_threads@0\",\n        \"?try_lock_for@stl_critical_section_concrt@details@Concurrency@@UAE_NI@Z\",\n        \"?source_line@dbg_eng_data@?A0xbc047679@@QAEIQBX@Z\"\n    ]\n    return any(func_name.startswith(x) for x in lib_payload)\ndef get_lib_prefixes():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_lib_prefixes",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def get_lib_prefixes():\n    lib_prefix = [\n        'lib_explicit_',\n        'lib_implicit_',\n        'j_lib_explicit_',\n        'j_lib_implicit_'\n    ]\n    return lib_prefix\ndef is_fname_prefix(func_name):\n    return any(func_name.startswith(p) for p in get_lib_prefixes())",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "is_fname_prefix",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def is_fname_prefix(func_name):\n    return any(func_name.startswith(p) for p in get_lib_prefixes())\ndef get_xref_addrs(func_addr):\n    for xref in idautils.XrefsTo(func_addr):\n        yield xref.frm\ndef get_cref_addrs(func_addr):\n    for cref in idautils.CodeRefsTo(func_addr, 1):\n        yield cref\ndef get_func_types_dst(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_xref_addrs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def get_xref_addrs(func_addr):\n    for xref in idautils.XrefsTo(func_addr):\n        yield xref.frm\ndef get_cref_addrs(func_addr):\n    for cref in idautils.CodeRefsTo(func_addr, 1):\n        yield cref\ndef get_func_types_dst(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    func_type_dst = []\n    for xref_addr in get_xref_addrs(func_addr):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_cref_addrs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def get_cref_addrs(func_addr):\n    for cref in idautils.CodeRefsTo(func_addr, 1):\n        yield cref\ndef get_func_types_dst(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    func_type_dst = []\n    for xref_addr in get_xref_addrs(func_addr):\n        if ida_shims.is_code(ida_shims.get_full_flags(xref_addr)):\n            xref_desc = idaapi.get_func(xref_addr)\n            xref_name = ida_shims.get_func_name(xref_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_func_types_dst",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def get_func_types_dst(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    func_type_dst = []\n    for xref_addr in get_xref_addrs(func_addr):\n        if ida_shims.is_code(ida_shims.get_full_flags(xref_addr)):\n            xref_desc = idaapi.get_func(xref_addr)\n            xref_name = ida_shims.get_func_name(xref_addr)\n            if is_lib(xref_addr) and not is_fname_payload(xref_name):\n                func_type_dst.append('lib_explicit')\n            elif is_fname_prefix(xref_name):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "cleanup_lib_funcs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def cleanup_lib_funcs(func_gen):\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        if is_fname_prefix(func_name):\n            lib_prefix = get_lib_prefixes()\n            func_name = re.sub(\"|\".join(lib_prefix), \"\", func_name)\n            ida_shims.set_name(func_addr, func_name, idaapi.SN_NOWARN)\ndef discover_lib_funcs(func_gen):\n    pass_count = 2\n    for i in range(pass_count):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "discover_lib_funcs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def discover_lib_funcs(func_gen):\n    pass_count = 2\n    for i in range(pass_count):\n        for func_addr in func_gen():\n            prefix = None\n            func_name = ida_shims.get_func_name(func_addr)\n            if is_fname_prefix(func_name):\n                continue\n            if is_lib(func_addr) or is_func_imp(func_addr) or is_fname_main(func_name):\n                continue",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    cleanup_lib_funcs(func_gen)\n    discover_lib_funcs(func_gen)\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        func_types_dst = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "SCRIPT_NAME = i18n('Xref Destination')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()\n    return is_main\ndef is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()\n    return is_main\ndef is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()\n    return is_main\ndef is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)\n    func_flags = ida_shims.get_func_flags(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "peekOfCode": "SCRIPT_ARGS = []\ndef is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()\n    return is_main\ndef is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)\n    func_flags = ida_shims.get_func_flags(func_addr)\n    is_lib_flag = func_flags & idaapi.FUNC_LIB",
        "detail": "plugins.IdaClu.idaclu.plugins.group_1.plugin_3",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_desc = idaapi.get_func(func_addr)\n        for head in idautils.Heads(ida_shims.start_ea(func_desc), ida_shims.end_ea(func_desc)):\n            for opnd_index in range(idaapi.UA_MAXOP):\n                opnd_type = ida_shims.get_operand_type(head, opnd_index)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Common Constants')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_1",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "def get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    strs = list(idautils.Strings())\n    strs_count = len(strs)\n    for i, tstr in enumerate(strs):\n        str_raw = ida_shims.get_strlit_contents(tstr)\n        str_dec = str_raw.decode('utf-8', errors='replace').encode('ascii', errors='replace').decode(\"utf-8\")",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data()\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('String Refs')\nSCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_data(progress_callback=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_2",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_global_type(name_addr):\n    flags = ida_shims.get_full_flags(name_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_global_type",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "def get_global_type(name_addr):\n    flags = ida_shims.get_full_flags(name_addr)\n    types = [\n        'dword',\n        'strlit',\n        'char0',\n        'byte',\n        'word',\n        'unknown',\n        'struct',",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "def get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    names = list(idautils.Names())\n    names_count = len(names)\n    for i, (name_addr, name_line) in enumerate(names):\n        g_type = get_global_type(name_addr)\n        if g_type:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "def debug():\n    data_obj = get_data()\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "SCRIPT_NAME = i18n('Global Variable Analysis')\nSCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "SCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_global_type(name_addr):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_3",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "is_fname_main",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "def is_fname_main(func_name):\n    is_main = func_name.startswith('_') and 'main' in func_name.lower()\n    return is_main\ndef is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)\n    func_flags = ida_shims.get_func_flags(func_addr)\n    is_lib_flag = func_flags & idaapi.FUNC_LIB\n    return is_lib_flag and not is_dummy and not is_main",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "is_func_lib",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "def is_func_lib(func_addr):\n    func_name = ida_shims.get_func_name(func_addr)\n    is_dummy = func_name.startswith('sub_')\n    is_main = is_fname_main(func_name)\n    func_flags = ida_shims.get_func_flags(func_addr)\n    is_lib_flag = func_flags & idaapi.FUNC_LIB\n    return is_lib_flag and not is_dummy and not is_main\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        if is_func_lib(func_addr):\n            func_name = ida_shims.get_func_name(func_addr)\n            xrefs = idautils.XrefsTo(func_addr)\n            for xref in xrefs:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "SCRIPT_NAME = i18n('Lib Usage Analysis')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef is_fname_main(func_name):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_4",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_idata():\n        imports = {}",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "get_idata",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "def get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):\n            module = idaapi.get_import_module_name(i)\n            imports[module] = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "def get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    imps = list(get_idata())\n    imps_count = len(imps)\n    for i, (addr, module, name, ordi) in enumerate(imps):\n        for xref in idautils.XrefsTo(addr):\n            xref_addr = xref.frm",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "def debug():\n    data_obj = get_data()\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "SCRIPT_NAME = i18n('API Usage Analysis')\nSCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "SCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_idata():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_5",
        "documentation": {}
    },
    {
        "label": "get_idata",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "def get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):\n            module = idaapi.get_import_module_name(i)\n            imports[module] = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "def get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    imps = list(get_idata())\n    imps_count = len(imps)\n    sem_cats = []\n    plugin_path = os.path.abspath(os.path.dirname(__file__))\n    with open(os.path.join(plugin_path, \"winapi_semantics.json\"), \"r\") as jh:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "def debug():\n    data_obj = get_data()\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "SCRIPT_NAME = i18n('Windows API Semantics')\nSCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "SCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):\n            module = idaapi.get_import_module_name(i)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_6",
        "documentation": {}
    },
    {
        "label": "get_idata",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "def get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):\n            module = idaapi.get_import_module_name(i)\n            imports[module] = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "def get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    imps = list(get_idata())\n    imps_count = len(imps)\n    sem_cats = []\n    plugin_path = os.path.abspath(os.path.dirname(__file__))\n    with open(os.path.join(plugin_path, \"winapi_malware.json\"), \"r\") as jh:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "def debug():\n    data_obj = get_data()\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "SCRIPT_NAME = i18n('Windows API / Malware')\nSCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "SCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_idata():\n        imports = {}\n        module = \"\"\n        def callback(ea, name, ordinal):\n            imports[module].append((ea, name, ordinal))\n            return True\n        nimps = idaapi.get_import_module_qty()\n        for i in range(0, nimps):\n            module = idaapi.get_import_module_name(i)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_2.plugin_7",
        "documentation": {}
    },
    {
        "label": "get_func_item_eas",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_proxy(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':\n        return True\n    else:\n        return False",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "is_func_proxy",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def is_func_proxy(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':\n        return True\n    else:\n        return False\ndef is_func_switch(func_addr):\n    for (f_beg, f_end) in idautils.Chunks(func_addr):\n        for head_ea in idautils.Heads(f_beg, f_end):\n            if ida_shims.is_code(ida_shims.get_full_flags(head_ea)):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "is_func_switch",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def is_func_switch(func_addr):\n    for (f_beg, f_end) in idautils.Chunks(func_addr):\n        for head_ea in idautils.Heads(f_beg, f_end):\n            if ida_shims.is_code(ida_shims.get_full_flags(head_ea)):\n                si = ida_shims.get_switch_info(head_ea)\n                if si == None:\n                    continue\n                results = idaapi.calc_switch_cases(head_ea, si)\n                if results:\n                    return True",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "is_func_loop",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def is_func_loop(func_desc):\n    func_start_ea = ida_shims.start_ea(func_desc)\n    blocks = [func_start_ea]\n    for block in idaapi.FlowChart(func_desc):\n        end_ea = ida_shims.end_ea(block)\n        blocks.append(end_ea)\n    for block in blocks:\n        for xref in idautils.XrefsTo(block):\n            xref_func = idaapi.get_func(xref.frm)\n            xref_start_ea = ida_shims.start_ea(xref_func)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "is_func_simple_recursion",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def is_func_simple_recursion(func_addr):\n    for h in idautils.FuncItems(func_addr):\n        for r in idautils.XrefsFrom(h, 0):\n            if ((r.type == idaapi.fl_CF or r.type == idaapi.fl_CN) and\n                r.to == func_addr):\n                return True\n    return False\nstack = []\ndef is_func_recursion(func_addr):\n    global stack",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "is_func_recursion",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def is_func_recursion(func_addr):\n    global stack\n    if func_addr in stack:\n        # print \"This is recursive function\", hex(func_addr), Name(func_addr)\n        # for x in stack:\n        #     print \"\\t\", hex(x)\n        # #insert your renaming here, it should be idc.MakeName\n        return\n    stack.append(func_addr)\n    for h in idautils.FuncItems(func_addr):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "is_func_condition",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def is_func_condition(func_desc):\n    bb_list = list(idaapi.FlowChart(func_desc))\n    bb_num = len(bb_list)\n    bb_conn_count = len(list(bb_list[0].succs()))\n    if ((bb_num == 1 and bb_conn_count == 0) or\n        (bb_num == 2 and bb_conn_count == 1 and is_func_proxy(ida_shims.start_ea(func_desc)))):\n        return False\n    return True\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    global stack",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    global stack\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_desc = idaapi.get_func(func_addr)\n        func_groups = []\n        if is_func_proxy(func_addr):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Control Flow Analysis')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_proxy(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_proxy(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_proxy(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':\n        return True",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_func_item_eas(func_addr):\n    for item_ea in list(idautils.FuncItems(func_addr)):\n        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):\n            yield item_ea\ndef is_func_proxy(func_addr):\n    item_eas = list(get_func_item_eas(func_addr))\n    if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':\n        return True\n    else:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "stack",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "peekOfCode": "stack = []\ndef is_func_recursion(func_addr):\n    global stack\n    if func_addr in stack:\n        # print \"This is recursive function\", hex(func_addr), Name(func_addr)\n        # for x in stack:\n        #     print \"\\t\", hex(x)\n        # #insert your renaming here, it should be idc.MakeName\n        return\n    stack.append(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_1",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_psdo_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "def get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:\n       decomp_str = idaapi.decompile(func_ea)\n    except idaapi.DecompilationFailure:\n       return []\n    for line in str(decomp_str).split('\\n'):\n        if '//' in line:\n            code = line.split('//')[0]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_psdo_body",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "def get_psdo_body(func_ea):\n    psdo_list = get_psdo_list(func_ea)\n    return psdo_list[2:-1]\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_psdo_size = len(get_psdo_body(func_addr))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_psdo_size = len(get_psdo_body(func_addr))\n        key_name = \"size: {}\".format(func_psdo_size)\n        report['data'][key_name].append(func_addr)\n        report['stat'][key_name] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('Pseudocode Size')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_psdo_list(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_psdo_list(func_ea):\n    func_pseudocode = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))\ndef get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"",
        "detail": "plugins.IdaClu.idaclu.plugins.group_3.plugin_2",
        "documentation": {}
    },
    {
        "label": "DrcovData",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "peekOfCode": "class DrcovData(object):\n    \"\"\"\n    A drcov log parser.\n    \"\"\"\n    def __init__(self, filepath=None):\n        self.filepath = filepath\n        # drcov header attributes\n        self.version = 0\n        self.flavor = None\n        # drcov module table",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "documentation": {}
    },
    {
        "label": "DrcovModule",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "peekOfCode": "class DrcovModule(object):\n    \"\"\"\n    Parser & wrapper for module details as found in a drcov coverage log.\n    A 'module' in this context is a .EXE, .DLL, ELF, MachO, etc.\n    \"\"\"\n    def __init__(self, module_data, version):\n        self.id    = 0\n        self.base  = 0\n        self.end   = 0\n        self.size  = 0",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "documentation": {}
    },
    {
        "label": "DrcovBasicBlock",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "peekOfCode": "class DrcovBasicBlock(Structure):\n    \"\"\"\n    Parser & wrapper for basic block details as found in a drcov coverage log.\n    NOTE:\n      Based off the C structure as used by drcov -\n        /* Data structure for the coverage info itself */\n        typedef struct _bb_entry_t {\n            uint   start;      /* offset of bb start from the image base */\n            ushort size;\n            ushort mod_id;",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.drcov",
        "documentation": {}
    },
    {
        "label": "find_function",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "def find_function(block_start, function_ranges):\n    index = bisect.bisect_right(function_ranges, (block_start, block_start))\n    if index > 0 and block_start <= function_ranges[index - 1][1]:\n        return function_ranges[index - 1]\n    return None\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    REPORT = {\n        'data': {},\n        'stat': {},\n        'tree': [",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    REPORT = {\n        'data': {},\n        'stat': {},\n        'tree': [\n            {'unique_id': 1, 'parent_id': 0, 'Function': '', 'VA': ' ', 'Size': ' '}\n        ]\n    }\n    raw_data = {}\n    unseen_functions = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "def debug():\n    env_desc = lambda: None\n    env_desc.ida_module = os.path.basename(ida_shims.get_input_file_path())\n    log_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'drcov.proc.log')\n    plug_params = { 'file_path': log_path }\n    data_obj = get_data(func_gen=idautils.Functions, env_desc=env_desc, plug_params=plug_params)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Covered Functions')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [('filePath', 'file_path', 'input the file path')]\ndef find_function(block_start, function_ranges):\n    index = bisect.bisect_right(function_ranges, (block_start, block_start))\n    if index > 0 and block_start <= function_ranges[index - 1][1]:\n        return function_ranges[index - 1]\n    return None\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [('filePath', 'file_path', 'input the file path')]\ndef find_function(block_start, function_ranges):\n    index = bisect.bisect_right(function_ranges, (block_start, block_start))\n    if index > 0 and block_start <= function_ranges[index - 1][1]:\n        return function_ranges[index - 1]\n    return None\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    REPORT = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [('filePath', 'file_path', 'input the file path')]\ndef find_function(block_start, function_ranges):\n    index = bisect.bisect_right(function_ranges, (block_start, block_start))\n    if index > 0 and block_start <= function_ranges[index - 1][1]:\n        return function_ranges[index - 1]\n    return None\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    REPORT = {\n        'data': {},",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = [('filePath', 'file_path', 'input the file path')]\ndef find_function(block_start, function_ranges):\n    index = bisect.bisect_right(function_ranges, (block_start, block_start))\n    if index > 0 and block_start <= function_ranges[index - 1][1]:\n        return function_ranges[index - 1]\n    return None\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    REPORT = {\n        'data': {},\n        'stat': {},",
        "detail": "plugins.IdaClu.idaclu.plugins.group_4.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_items",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)\n        dasm_clean = dasm.split(';')[0]  # remove comments\n        func_instructs.append(dasm_clean)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_dasm_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)\n        dasm_clean = dasm.split(';')[0]  # remove comments\n        func_instructs.append(dasm_clean)\n    return func_instructs\ndef get_mnem_list(func_ea):\n    func_mnemonics = []\n    for item in get_items(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_mnem_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_mnem_list(func_ea):\n    func_mnemonics = []\n    for item in get_items(func_ea):\n        mnem = ida_shims.print_insn_mnem(item)\n        func_mnemonics.append(mnem)\n    return func_mnemonics\ndef get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_psdo_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:\n        decomp_str = idaapi.decompile(func_ea)\n    except idaapi.DecompilationFailure:\n        return []\n    for line in str(decomp_str).split('\\n'):\n        if '//' in line:\n            code = line.split('//')[0]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_psdo_body",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_psdo_body(func_ea):\n    psdo_list = get_psdo_list(func_ea)\n    return psdo_list[2:-1]\ndef get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef get_number_ratio(num1, num2):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_func_bytes",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef get_number_ratio(num1, num2):\n    if num1 == num2:\n        return 1\n    if num1 > num2:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_number_ratio",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_number_ratio(num1, num2):\n    if num1 == num2:\n        return 1\n    if num1 > num2:\n        return num2 / num1\n    if num1 < num2:\n        return num1 / num2\ndef get_func_descriptors(func_gen):\n    func_dscs = []\n    for func_addr in func_gen():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_func_descriptors",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_func_descriptors(func_gen):\n    func_dscs = []\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        func_desc = idaapi.get_func(func_addr)\n        func_inst = get_dasm_list(func_addr)\n        func_mnem = get_mnem_list(func_addr)\n        func_psdo = get_psdo_list(func_addr)\n        func_size = ida_shims.calc_func_size(func_desc)\n        func_byts_line = get_func_bytes(func_addr)    # get_bytes(func_addr, func_size)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_func_clusters",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_func_clusters(func_descriptors):\n    clusters = collections.defaultdict(list)\n    data_type = [('byts', 48), ('mnem', 80), ('inst', 80), ('psdo', 80)]\n    for idx, sup in enumerate(func_descriptors):\n        for jdx, sub in enumerate(func_descriptors):\n            if sup['func_addr'] != sub['func_addr']:\n                byts_score = None\n                for (dt, th) in data_type:\n                    size_key = '{}_size'.format(dt)\n                    hash_key = '{}_hash'.format(dt)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    func_descriptors = get_func_descriptors(func_gen)\n    func_clusters = get_func_clusters(func_descriptors)\n    for idx, clu in enumerate(func_clusters['aggregated']):\n        for addr in clu:\n            key_name = \"cluster: {}\".format(idx)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('SSDEEP Similarity')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)\n        dasm_clean = dasm.split(';')[0]  # remove comments",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_items",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)\n        dasm_clean = dasm.split(';')[0]  # remove comments\n        func_instructs.append(dasm_clean)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_dasm_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)\n        dasm_clean = dasm.split(';')[0]  # remove comments\n        func_instructs.append(dasm_clean)\n    return func_instructs\ndef get_mnem_list(func_ea):\n    func_mnemonics = []\n    for item in get_items(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_mnem_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_mnem_list(func_ea):\n    func_mnemonics = []\n    for item in get_items(func_ea):\n        mnem = ida_shims.print_insn_mnem(item)\n        func_mnemonics.append(mnem)\n    return func_mnemonics\ndef get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_psdo_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:\n        decomp_str = idaapi.decompile(func_ea)\n    except idaapi.DecompilationFailure:\n        return []\n    for line in str(decomp_str).split('\\n'):\n        if '//' in line:\n            code = line.split('//')[0]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_psdo_body",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_psdo_body(func_ea):\n    psdo_list = get_psdo_list(func_ea)\n    return psdo_list[2:-1]\ndef get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef get_number_ratio(num1, num2):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_func_bytes",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef get_number_ratio(num1, num2):\n    if num1 == num2:\n        return 1\n    if num1 > num2:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_number_ratio",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_number_ratio(num1, num2):\n    if num1 == num2:\n        return 1\n    if num1 > num2:\n        return num2 / num1\n    if num1 < num2:\n        return num1 / num2\ndef get_func_descriptors(func_gen):\n    func_dscs = []\n    for func_addr in func_gen():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_func_descriptors",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_func_descriptors(func_gen):\n    func_dscs = []\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        func_desc = idaapi.get_func(func_addr)\n        func_inst = get_dasm_list(func_addr)\n        func_mnem = get_mnem_list(func_addr)\n        func_psdo = get_psdo_list(func_addr)\n        func_size = ida_shims.calc_func_size(func_desc)\n        func_byts_line = get_func_bytes(func_addr)    # get_bytes(func_addr, func_size)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_func_clusters",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_func_clusters(func_descriptors):\n    clusters = collections.defaultdict(list)\n    data_type = [('byts', 100), ('mnem', 60), ('inst', 60), ('psdo', 60)]\n    for idx, sup in enumerate(func_descriptors):\n        for jdx, sub in enumerate(func_descriptors):\n            if sup['func_addr'] != sub['func_addr']:\n                byts_score = None\n                for (dt, th) in data_type:\n                    size_key = '{}_size'.format(dt)\n                    hash_key = '{}_hash'.format(dt)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    func_descriptors = get_func_descriptors(func_gen)\n    func_clusters = get_func_clusters(func_descriptors)\n    for idx, clu in enumerate(func_clusters['aggregated']):\n        for addr in clu:\n            key_name = \"cluster: {}\".format(idx)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('TLSH Similarity')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_items(func_ea):\n    for item in idautils.FuncItems(func_ea):\n        if ida_shims.is_code(ida_shims.get_full_flags(item)):\n            yield item\ndef get_dasm_list(func_ea):\n    func_instructs = []\n    for item in get_items(func_ea):\n        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)\n        dasm_clean = dasm.split(';')[0]  # remove comments",
        "detail": "plugins.IdaClu.idaclu.plugins.group_5.plugin_2",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_psdo_list(func_ea):\n    func_pseudocode = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_psdo_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "def get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:\n       decomp_str = idaapi.decompile(func_ea)\n    except idaapi.DecompilationFailure:\n       return []\n    for line in str(decomp_str).split('\\n'):\n        if '//' in line:\n            code = line.split('//')[0]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_psdo_body",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "def get_psdo_body(func_ea):\n    psdo_list = get_psdo_list(func_ea)\n    return psdo_list[2:-1]\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        caller_name = idaapi.get_func_name(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        caller_name = idaapi.get_func_name(func_addr)\n        caller_psdo = get_psdo_body(func_addr)\n        for psdo_line in caller_psdo:\n            is_func_matched = re.match('(?:(?:.*\\s)?)([0-9a-zA-Z\\_\\:]+)\\(.*\\)(?:(?:.*)?)', psdo_line)  # (?:(?:.*\\s)?)([0-9a-zA-Z\\_\\:]+)\\(.*\\)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Explicit Calls')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_psdo_list(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_1",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_psdo_list(func_ea):\n    func_pseudocode = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_psdo_list",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "def get_psdo_list(func_ea):\n    func_pseudocode = []\n    decomp_str = \"\"\n    try:\n        decomp_str = idaapi.decompile(func_ea)\n    except idaapi.DecompilationFailure:\n        return []\n    for line in str(decomp_str).split('\\n'):\n        if '//' in line:\n            code = line.split('//')[0]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_psdo_body",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "def get_psdo_body(func_ea):\n    psdo_list = get_psdo_list(func_ea)\n    return psdo_list[2:-1]\ndef remove_casts(call_str):\n    call_res = call_str\n    for m in re.finditer('\\(\\*(\\([a-zA-Z0-9_\\s\\*\\,\\.\\(\\)]+\\)\\))\\(', call_res):\n        call_res = call_res.replace(m.group(1), '')\n    call_res = re.sub(r\"\\(_.*\\*\\)\", \"\", call_res)\n    return call_res\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "remove_casts",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "def remove_casts(call_str):\n    call_res = call_str\n    for m in re.finditer('\\(\\*(\\([a-zA-Z0-9_\\s\\*\\,\\.\\(\\)]+\\)\\))\\(', call_res):\n        call_res = call_res.replace(m.group(1), '')\n    call_res = re.sub(r\"\\(_.*\\*\\)\", \"\", call_res)\n    return call_res\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        caller_name = idaapi.get_func_name(func_addr)\n        caller_psdo = get_psdo_body(func_addr)\n        psdo_size = len(caller_psdo)\n        for i in range(psdo_size):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('Implicit Calls')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_psdo_list(func_ea):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_2",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "def get_data(progress_callback=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    if ida_utils.is_GCC_auto():\n        pass\n    else:\n        PTR_SIZE = ida_utils.get_ptr_size()\n        vf_tables = {}",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "def debug():\n    data_obj = get_data()\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "SCRIPT_NAME = i18n('Virtual Funtion Tables (MSVC)')\nSCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "SCRIPT_TYPE = 'custom'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_data(progress_callback=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_6.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_dirs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "def get_dirs(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = [root_dir]\n    while len(s_folders):\n        curr_path = s_folders.pop()\n        func_dir.chdir(curr_path)\n        status = func_dir.findfirst(ite, \"*\")\n        while status:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_dir_funcs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "def get_dir_funcs(folders):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    idx = 0\n    funcs = {}\n    while idx < len(folders):\n        curr_path = folders[idx]\n        func_dir.chdir(curr_path)\n        status = func_dir.findfirst(ite, \"*\")\n        while status:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    dirs = get_dirs('/')\n    dir_funcs = get_dir_funcs(dirs)\n    for func_addr in func_gen():\n        if func_addr in dir_funcs:\n            dir_name = dir_funcs[func_addr]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Distinct Folders')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_dirs(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = [root_dir]\n    while len(s_folders):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_dirs(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = [root_dir]\n    while len(s_folders):\n        curr_path = s_folders.pop()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_dirs(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = [root_dir]\n    while len(s_folders):\n        curr_path = s_folders.pop()\n        func_dir.chdir(curr_path)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_dirs(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = [root_dir]\n    while len(s_folders):\n        curr_path = s_folders.pop()\n        func_dir.chdir(curr_path)\n        status = func_dir.findfirst(ite, \"*\")",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    sep_char = '%'\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        prefs = set()\n        if sep_char in func_name:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('Distinct Prefixes (IdaClu)')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    sep_char = '%'",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    sep_char = '%'\n    for func_addr in func_gen():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    sep_char = '%'\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    sep_char = '%'\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        prefs = set()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_2",
        "documentation": {}
    },
    {
        "label": "RgbColor",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "class RgbColor:\n    def __init__(self, color_ref, color_nam='unknown'):\n        ver_py = sys.version_info.major\n        self.palette_val = {\n            13107199: 'blue',    # '#C7FFFF'\n            16777151: 'yellow',  # '#FFFFBF'\n            12582847: 'green',   # '#BFFFBF'\n            16760815: 'pink',    # '#FFBFEF'\n            16777215: 'none'     # '#FFFFFF'\n        }",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_colr = ida_shims.get_color(func_addr, idc.CIC_FUNC)\n        color = RgbColor(func_colr)\n        color.invert_color()\n        color_name = color.get_to_name()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "SCRIPT_NAME = i18n('Distinct Colors')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\nclass RgbColor:\n    def __init__(self, color_ref, color_nam='unknown'):\n        ver_py = sys.version_info.major\n        self.palette_val = {\n            13107199: 'blue',    # '#C7FFFF'\n            16777151: 'yellow',  # '#FFFFBF'",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\nclass RgbColor:\n    def __init__(self, color_ref, color_nam='unknown'):\n        ver_py = sys.version_info.major\n        self.palette_val = {\n            13107199: 'blue',    # '#C7FFFF'\n            16777151: 'yellow',  # '#FFFFBF'\n            12582847: 'green',   # '#BFFFBF'",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\nclass RgbColor:\n    def __init__(self, color_ref, color_nam='unknown'):\n        ver_py = sys.version_info.major\n        self.palette_val = {\n            13107199: 'blue',    # '#C7FFFF'\n            16777151: 'yellow',  # '#FFFFBF'\n            12582847: 'green',   # '#BFFFBF'\n            16760815: 'pink',    # '#FFBFEF'",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "peekOfCode": "SCRIPT_ARGS = []\nclass RgbColor:\n    def __init__(self, color_ref, color_nam='unknown'):\n        ver_py = sys.version_info.major\n        self.palette_val = {\n            13107199: 'blue',    # '#C7FFFF'\n            16777151: 'yellow',  # '#FFFFBF'\n            12582847: 'green',   # '#BFFFBF'\n            16760815: 'pink',    # '#FFBFEF'\n            16777215: 'none'     # '#FFFFFF'",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_3",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_name = ida_shims.get_func_name(func_addr)\n        prefs = set()\n        func_prefs = ida_utils.get_func_prefs(func_name, False)\n        prefs.update(func_prefs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "SCRIPT_NAME = i18n('Distinct Prefixes')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "peekOfCode": "SCRIPT_ARGS = []\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_7.plugin_4",
        "documentation": {}
    },
    {
        "label": "MbaVisitor",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "class MbaVisitor(idaapi.ctree_visitor_t):\n    def __init__(self):\n        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_PARENTS)\n        self.mba_eas = set([])\n    def list_parents(self, op_found):\n        for parent in self.parents:\n            if (parent is not None):\n                if op_found == 'b':\n                    if (parent.op in ARITHMETIC_OPERATION or\n                        parent.op in ARITHMETIC_OPERATION_ASG):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calc_flattening_score",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calc_flattening_score(function):\n    score = 0.0\n    # 0: get the basic blocks of the function\n    basic_blocks = idaapi.FlowChart(idaapi.get_func(function))\n    # 1: walk over all basic blocks\n    for block in basic_blocks:\n        # 2: get all blocks that are dominated by the current block\n        dominated = get_dominated_by(block)\n        # 3: check for a back edge\n        dominators = [d.start_ea for d in block.preds()]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "get_dominated_by",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def get_dominated_by(dominator):\n    worked_on_eas = set()\n    # 1: initialize worklist\n    worklist = [dominator]\n    # 2: perform a depth-first search on the dominator tree\n    while worklist:\n        # get next block\n        block = worklist.pop(0)\n        worked_on_eas.add(block.start_ea)\n        for child in block.succs():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calculate_entropy",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calculate_entropy(data):\n    # count byte occurrences and calculate total bytes\n    byte_count = collections.Counter(data)\n    total_bytes = len(data)\n    # calculate entropy using the counted byte occurrences\n    entropy = 0.0\n    for count in byte_count.values():\n        # calculate byte probability and update entropy\n        probability = count / total_bytes\n        entropy -= probability * math.log2(probability)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "get_top_10_functions",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def get_top_10_functions(functions, scoring_function):\n    # sort functions by scoring function\n    sorted_functions = sorted(((f, scoring_function(f))\n                               for f in functions), key=lambda x: x[1])\n    # bound to locate the top 10%, but 10 minimum, 1k maximum\n    bound = max(min(math.ceil(((len(functions) * 10) / 100)), 1000), 10)\n    # yield top 10% (iterate in descending order)\n    for function, score in list(reversed(sorted_functions))[:bound]:\n        yield function, score\ndef sort_elements(iterator, scoring_function):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "sort_elements",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def sort_elements(iterator, scoring_function):\n    # sort elements by scoring function\n    sorted_elements = sorted(((elem, scoring_function(elem))\n                              for elem in iterator), key=lambda x: x[1])\n    # yield in descending order\n    for element, score in list(reversed(sorted_elements)):\n        yield element, score\ndef calc_cyclomatic_complexity(func_addr):\n    # number of basic blocks\n    child = set([])",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calc_cyclomatic_complexity",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calc_cyclomatic_complexity(func_addr):\n    # number of basic blocks\n    child = set([])\n    num_blocks = 0\n    num_edges = 0\n    basic_blocks = idaapi.FlowChart(idaapi.get_func(func_addr), flags=(idaapi.FC_PREDS | idaapi.FC_NOEXT))\n    for block in basic_blocks:\n        for succ_block in block.succs():\n            child.add(succ_block.id)     \n        for pred_block in block.preds():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calc_average_instructions_per_block",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calc_average_instructions_per_block(function):\n    # number of basic blocks -- set to 1 if 0\n    basic_blocks = idaapi.FlowChart(idaapi.get_func(function))\n    num_blocks = max(1, basic_blocks.size)\n    # number of instructions\n    num_instructions = sum(\n        (len([i for i in idautils.Heads(b.start_ea, b.end_ea)]) for b in basic_blocks))\n    return num_instructions / num_blocks\ndef block_is_in_loop(block):\n    # 0: get the blocks dominated by this block",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "block_is_in_loop",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def block_is_in_loop(block):\n    # 0: get the blocks dominated by this block\n    dominated = get_dominated_by(block)\n    # 1: get the predecessors of this block\n    dominators = [d.start_ea for d in block.preds()]\n    # 2: check if any predecessor is also dominated by this block\n    return any((p in dominated for p in dominators))\ndef computes_xor_const(insn):\n    # check for a xor operation\n    if insn.get_canon_mnem() == 'xor':",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "computes_xor_const",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def computes_xor_const(insn):\n    # check for a xor operation\n    if insn.get_canon_mnem() == 'xor':\n        # check if one operand is a constant\n        ops = [op for op in insn.ops]\n        if ops[1].type == idaapi.o_imm or ops[0].type == idaapi.o_imm:\n            return True\n    return False\ndef contains_xor_decryption_loop(function):\n    # walk over all blocks which are part of a loop",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "contains_xor_decryption_loop",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def contains_xor_decryption_loop(function):\n    # walk over all blocks which are part of a loop\n    basic_blocks = idaapi.FlowChart(idaapi.get_func(function))\n    for block in basic_blocks:\n        if not block_is_in_loop(block):\n            continue\n        # walk over all instructions\n        addr = block.start_ea\n        while addr < block.end_ea:\n            # get instruction",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "sliding_window",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def sliding_window(l, window_size):\n    # yields all sliding windows of size `window_size` for a given list\n    for index in range(len(l) - window_size + 1):\n        yield l[index:index + window_size]\ndef calc_ngrams(function, n):\n    fn = idaapi.get_func(function)\n    hi = [h for h in fn.head_items()]\n    mnemonics_sorted = [idc.print_insn_mnem(ea) for ea in hi]\n    # calculate all n-grams\n    grams_n = collections.Counter([\"\".join(w) for w in sliding_window(mnemonics_sorted, n)])",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calc_ngrams",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calc_ngrams(function, n):\n    fn = idaapi.get_func(function)\n    hi = [h for h in fn.head_items()]\n    mnemonics_sorted = [idc.print_insn_mnem(ea) for ea in hi]\n    # calculate all n-grams\n    grams_n = collections.Counter([\"\".join(w) for w in sliding_window(mnemonics_sorted, n)])\n    return grams_n\ndef calc_uncommon_instruction_sequences_score(function):\n    # determine ngram database based on function's architecture\n    bitness = idaapi.get_func_bitness(function)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calc_uncommon_instruction_sequences_score",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calc_uncommon_instruction_sequences_score(function):\n    # determine ngram database based on function's architecture\n    bitness = idaapi.get_func_bitness(function)\n    if bitness == 1:\n        arch = \"x86\"\n    elif bitness == 2:\n        arch = \"x86_64\"\n    else:\n        arch = None\n    use_llil, ngram_database = determine_ngram_database(arch)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "get_basic_blocks",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def get_basic_blocks(func_addr, is_attached):\n    'identfies basic blocks that do not have an entry point and are not the entry point of a function' \n    child = set([])\n    # ignore external blocks referenced by the function!\n    basic_blocks = idaapi.FlowChart(idaapi.get_func(func_addr), flags=(idaapi.FC_PREDS | idaapi.FC_NOEXT))  \n    for block in basic_blocks:\n        for succ_block in block.succs():\n            child.add(succ_block.id)     \n        for pred_block in block.preds():\n            child.add(pred_block.id)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calc_cyclomatic_complexity",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calc_cyclomatic_complexity(func_addr):\n    num_blocks = 0\n    num_edges = 0\n    for bb in get_basic_blocks(func_addr, True):\n        num_blocks += 1\n        num_edges += len([b for b in bb.succs()])\n        # number of edges in the graph\n    return num_edges - num_blocks + 2\ndef get_orph_eas(func_addr):\n    for bb in get_basic_blocks(func_addr, False):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "get_orph_eas",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def get_orph_eas(func_addr):\n    for bb in get_basic_blocks(func_addr, False):\n        yield (bb.start_ea, bb.end_ea)\ndef get_orph_count(func_addr):\n    orph_num = len(list(get_orph_eas(func_addr)))\n    return orph_num\n# ex- uses_mixed_boolean_arithmetic()\nclass MbaVisitor(idaapi.ctree_visitor_t):\n    def __init__(self):\n        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_PARENTS)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "get_orph_count",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def get_orph_count(func_addr):\n    orph_num = len(list(get_orph_eas(func_addr)))\n    return orph_num\n# ex- uses_mixed_boolean_arithmetic()\nclass MbaVisitor(idaapi.ctree_visitor_t):\n    def __init__(self):\n        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_PARENTS)\n        self.mba_eas = set([])\n    def list_parents(self, op_found):\n        for parent in self.parents:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "calculate_complex_arithmetic_expressions",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "def calculate_complex_arithmetic_expressions(function):  \n    instr_mba = 0\n    cfunc = idaapi.decompile(function)\n    if cfunc:\n        mba_visitor = MbaVisitor()\n        mba_visitor.apply_to(cfunc.body, None)\n        # if an expression has a boolean and an arithmetic operation, the expression has some arithmetic complexity\n        if len(mba_visitor.mba_eas):\n            instr_mba = len(mba_visitor.mba_eas)\n    return instr_mba",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "ARITHMETIC_OPERATION",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "ARITHMETIC_OPERATION = set([\n    idaapi.cot_add,   # x + y\n    idaapi.cot_lnot,  # !x\n    idaapi.cot_sub,   # x - y\n    idaapi.cot_mul,   # x * y\n    idaapi.cot_fmul,  # x * y fp\n    idaapi.cot_sdiv,  # x / y signed\n    idaapi.cot_udiv,  # x / y unsigned\n    idaapi.cot_fdiv,  # x / y fp\n    idaapi.cot_smod,  # x % y signed",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "ARITHMETIC_OPERATION_ASG",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "ARITHMETIC_OPERATION_ASG = set([\n    idaapi.cot_asgadd,   # x += y\n    idaapi.cot_asgsub,   # x -= y\n    idaapi.cot_asgmul,   # x *= y\n    idaapi.cot_asgsdiv,  # x /= y signed\n    idaapi.cot_asgudiv,  # x /= y unsigned\n    idaapi.cot_asgsmod,  # x %= y signed\n    idaapi.cot_asgumod   # x %= y unsigned\n])\nBOOLEAN_OPERATION = set([",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "BOOLEAN_OPERATION",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "BOOLEAN_OPERATION = set([\n    idaapi.cot_bnot,  # ~x\n    idaapi.cot_band,  # x & y\n    idaapi.cot_bor,   # x | y\n    idaapi.cot_xor,   # x ^ y\n    idaapi.cot_sshr,  # x >> y signed\n    idaapi.cot_ushr,  # x >> y unsigned\n    idaapi.cot_shl,   # x << y\n])\nBOOLEAN_OPERATION_ASG = set([",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "BOOLEAN_OPERATION_ASG",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "peekOfCode": "BOOLEAN_OPERATION_ASG = set([\n    idaapi.cot_asgbor,   # x |= y\n    idaapi.cot_asgxor,   # x ^= y\n    idaapi.cot_asgband,  # x &= y\n    idaapi.cot_asgsshr,  # x >>= y signed\n    idaapi.cot_asgushr,  # x >>= y unsigned\n    idaapi.cot_asgshl,   # x <<= y\n])\ndef calc_flattening_score(function):\n    score = 0.0",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.helpers",
        "documentation": {}
    },
    {
        "label": "determine_ngram_database",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "peekOfCode": "def determine_ngram_database(arch):\n    if arch == \"x86_64\":\n        return False, MOST_COMMON_3GRAMS_X86_64\n    elif arch == \"x86\":\n        return False, MOST_COMMON_3GRAMS_X86_32\n    elif arch == \"aarch64\":\n        return False, MOST_COMMON_3GRAMS_AARCH64\n    elif arch == \"armv7\":\n        return False, MOST_COMMON_3GRAMS_ARM32\n    else:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "documentation": {}
    },
    {
        "label": "MOST_COMMON_3GRAMS_X86_64",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "peekOfCode": "MOST_COMMON_3GRAMS_X86_64 = {\n    'addaddadd',\n    'addaddcmp',\n    'addaddmov',\n    'addaddpop',\n    'addcallcmp',\n    'addcallmov',\n    'addcalltest',\n    'addcmpja',\n    'addcmpjae',",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "documentation": {}
    },
    {
        "label": "MOST_COMMON_3GRAMS_X86_32",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "peekOfCode": "MOST_COMMON_3GRAMS_X86_32 = {\n    'adcmovmov',\n    'addadcadd',\n    'addadcmov',\n    'addaddadd',\n    'addaddcmp',\n    'addaddjmp',\n    'addaddmov',\n    'addaddpop',\n    'addaddpush',",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "documentation": {}
    },
    {
        "label": "MOST_COMMON_3GRAMS_AARCH64",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "peekOfCode": "MOST_COMMON_3GRAMS_AARCH64 = {\n    'addaddadd',\n    'addaddadrp',\n    'addaddb',\n    'addaddbl',\n    'addaddcmp',\n    'addaddldar',\n    'addaddldr',\n    'addaddmov',\n    'addaddstp',",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "documentation": {}
    },
    {
        "label": "MOST_COMMON_3GRAMS_ARM32",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "peekOfCode": "MOST_COMMON_3GRAMS_ARM32 = {\n    'adc.sadcorr',\n    'adcorr.sbiceq',\n    'adcsubhscmp',\n    'adctstsubeq',\n    'add.sadccmp',\n    'add.sadcorr.s',\n    'add.sbgtadd',\n    'add.sbleadd',\n    'addaddadd',",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.ngrams",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    flattened_funcs = []\n    func_count = 0\n    for func_addr in func_gen():\n        func_score = helpers.calc_flattening_score(func_addr)\n        flattened_funcs.append((func_addr, func_score))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Flattened Functions')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    flattened_funcs = []",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    flattened_funcs = []\n    func_count = 0",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    flattened_funcs = []\n    func_count = 0\n    for func_addr in func_gen():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    flattened_funcs = []\n    func_count = 0\n    for func_addr in func_gen():\n        func_score = helpers.calc_flattening_score(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_1",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        func_score = helpers.calc_cyclomatic_complexity(func_addr)\n        xref_key = \"score: {}\".format(func_score)\n        report['data'][xref_key].append(func_addr)\n        report['stat'][xref_key] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "SCRIPT_NAME = i18n('Complex Functions')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_2",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        orphs_num = helpers.get_orph_count(func_addr)\n        orph_key = \"blocks: {}\".format(orphs_num)\n        report['data'][orph_key].append(func_addr)\n        report['stat'][orph_key] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "SCRIPT_NAME = i18n('Orphan Blocks')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(-?\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_3",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        instr_num = helpers.calc_average_instructions_per_block(func_addr)\n        instr_key = \"instr/block: {}\".format(round(instr_num))\n        report['data'][instr_key].append(func_addr)\n        report['stat'][instr_key] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "SCRIPT_NAME = i18n('Large Basic Blocks')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [] \ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [] \ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [] \ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "peekOfCode": "SCRIPT_ARGS = [] \ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_4",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, float(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d\\.\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        unique_score = helpers.calc_uncommon_instruction_sequences_score(func_addr)\n        unique_key = \"score: {}\".format(round(unique_score, 2))\n        report['data'][unique_key].append(func_addr)\n        report['stat'][unique_key] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "SCRIPT_NAME = i18n('Uncommon Instruction Sequences')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, float(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d\\.\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, float(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d\\.\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, float(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d\\.\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, float(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z/\\: ]+)(\\d\\.\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_5",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        is_xor = helpers.contains_xor_decryption_loop(func_addr)\n        if is_xor:\n            report['data']['xor'].append(func_addr)\n            report['stat']['xor'] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "peekOfCode": "SCRIPT_NAME = i18n('XOR Const Decryption Loops')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        is_xor = helpers.contains_xor_decryption_loop(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        is_xor = helpers.contains_xor_decryption_loop(func_addr)\n        if is_xor:",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "peekOfCode": "SCRIPT_ARGS = []\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        is_xor = helpers.contains_xor_decryption_loop(func_addr)\n        if is_xor:\n            report['data']['xor'].append(func_addr)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_6",
        "documentation": {}
    },
    {
        "label": "sort_nat",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "def sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    for func_addr in func_gen():\n        compl_score = helpers.calculate_complex_arithmetic_expressions(func_addr)\n        compl_key = \"score: {}\".format(compl_score)\n        report['data'][compl_key].append(func_addr)\n        report['stat'][compl_key] += 1",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "SCRIPT_NAME = i18n('Complex Arithmetic Expressions')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "description": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "peekOfCode": "SCRIPT_ARGS = []\ndef sort_nat(input_dict):\n    def fun(k, v):\n        return [k, int(v)]\n    def cmp_key(t):\n        return fun(*re.match(r'([a-zA-Z\\: ]+)(\\d+)', t[0]).groups())\n    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))\ndef get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),",
        "detail": "plugins.IdaClu.idaclu.plugins.group_8.plugin_7",
        "documentation": {}
    },
    {
        "label": "get_func_bytes",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "def get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "order_item_len",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "def order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]\n        if isinstance(fs, int):\n            return fs\n        elif isinstance(fs, list):\n            return len(fs)\n    return collections.OrderedDict(\n        sorted(input_dict.items(), key=get_len, reverse=True)\n    )",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "get_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "def get_data(func_gen=None, env_desc=None, plug_params=None):\n    report = {\n        'data': collections.defaultdict(list),\n        'stat': collections.defaultdict(int)\n    }\n    dist_path = plug_params['file_path']\n    yar_paths = [\n        os.path.join(dist_path, f) \n        for f in os.listdir(dist_path) \n        if os.path.isfile(os.path.join(dist_path, f)) and f.endswith('.yar')",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "def debug():\n    data_obj = get_data(func_gen=idautils.Functions)\n    ida_shims.msg(json.dumps(data_obj, indent=4))\nif __name__ == '__main__':\n    debug()",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "SCRIPT_NAME = i18n('Rule Match')\nSCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [('filePath', 'file_path', 'path to folder with .yar files')]\ndef get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_TYPE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "SCRIPT_TYPE = 'func'\nSCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [('filePath', 'file_path', 'path to folder with .yar files')]\ndef get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef order_item_len(input_dict):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_VIEW",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "SCRIPT_VIEW = 'tree'\nSCRIPT_ARGS = [('filePath', 'file_path', 'path to folder with .yar files')]\ndef get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef order_item_len(input_dict):\n    def get_len(val):",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "SCRIPT_ARGS",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "description": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "peekOfCode": "SCRIPT_ARGS = [('filePath', 'file_path', 'path to folder with .yar files')]\ndef get_func_bytes(func_addr):\n    func_bytes = b''\n    for beg, end in idautils.Chunks(func_addr):\n        fb = ida_shims.get_bytes(beg, end-beg)\n        func_bytes += fb\n    return func_bytes\ndef order_item_len(input_dict):\n    def get_len(val):\n        fs = val[1]",
        "detail": "plugins.IdaClu.idaclu.plugins.group_9.plugin_1",
        "documentation": {}
    },
    {
        "label": "InstrumentedCallback",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.idaclu_gui",
        "description": "plugins.IdaClu.idaclu.idaclu_gui",
        "peekOfCode": "class InstrumentedCallback:\n    \"\"\"A wrapper class to count accesses to a callback.\"\"\"\n    def __init__(self, func, pass_count=0):\n        self.func = func\n        self.pass_count = pass_count\n        self.call_count = 0\n    def reset(self):\n        self.call_count = 0\n    def __call__(self, *args):\n        self.call_count += 1",
        "detail": "plugins.IdaClu.idaclu.idaclu_gui",
        "documentation": {}
    },
    {
        "label": "AppendTextEditDelegate",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.idaclu_gui",
        "description": "plugins.IdaClu.idaclu.idaclu_gui",
        "peekOfCode": "class AppendTextEditDelegate(QStyledItemDelegate):\n    def createEditor(self, parent, option, index):\n        editor = QLineEdit(parent)\n        return editor\n    def setEditorData(self, editor, index):\n        current_text = index.data()\n        editor.setText(current_text)\n    def setModelData(self, editor, model, index):\n        current_text = index.data()\n        new_text = editor.text()",
        "detail": "plugins.IdaClu.idaclu.idaclu_gui",
        "documentation": {}
    },
    {
        "label": "IdaCluDialog",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.idaclu_gui",
        "description": "plugins.IdaClu.idaclu.idaclu_gui",
        "peekOfCode": "class IdaCluDialog(QWidget):\n    def __init__(self, env_desc):\n        super(IdaCluDialog, self).__init__()\n        self.env_desc = env_desc\n        self.ui = Ui_PluginDialog(env_desc)\n        self.ui.setupUi(self)\n        self.ui.rvTable.setItemDelegate(AppendTextEditDelegate())\n        self.is_sidebar_on_left = True\n        self.is_filters_shown = True\n        self.option_sender = None",
        "detail": "plugins.IdaClu.idaclu.idaclu_gui",
        "documentation": {}
    },
    {
        "label": "print_insn_mnem",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def print_insn_mnem(ea):\n    '''\n    Get instruction mnemonics.\n    :param ea: Linear address of the instruction.\n    :type ea: int\n    :return: Instruction mnemonic. \"\" if not instruction is found.\n    :note: *Heavy breath* This function may not return exactly the same\n    mnemonics as you see on the screen.\n    '''\n    fn = _get_fn_by_version(idc, 'print_insn_mnem', 'GetMnem')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "print_operand",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def print_operand(ea, n):\n    '''\n    Get operand of an instruction or data.\n    :param ea: Linear address of the item.\n    :type ea: int\n    :param n: Number of operand: 0 - the first operand 1 - the second operand.\n    :type n: int\n    :return: The current text representation of operand or \"\".\n    '''\n    fn = _get_fn_by_version(idc, 'print_operand', 'GetOpnd')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_switch_info",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_switch_info(ea):\n    fn = _get_fn_by_version(idaapi, 'get_switch_info', 'get_switch_info_ex', idaapi)\n    return fn(ea)\ndef get_operand_type(head, opnd_index):\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_operand_type', 'GetOpType')\n    return fn(head, opnd_index)\ndef define_local_var(start, end, location, name):\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_operand_type",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_operand_type(head, opnd_index):\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_operand_type', 'GetOpType')\n    return fn(head, opnd_index)\ndef define_local_var(start, end, location, name):\n    '''\n    Create a local variable.\n    :param start: Start address range for the local variable.\n    :type start: int",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "define_local_var",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def define_local_var(start, end, location, name):\n    '''\n    Create a local variable.\n    :param start: Start address range for the local variable.\n    :type start: int\n    :param end: End of address range for the local variable.\n    :type end: int\n    :param location: The variable location in the \"[bp+xx]\" form where xx is\n                     a number. The location can also be specified as a\n                     register name.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "find_func_end",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def find_func_end(ea):\n    '''\n    Determine a new function boundaries.\n    :param ea: Start address of the new function.\n    :type ea: int\n    :return: If a function already exists, then return its end address. If a\n    function end cannot be determine, the return BADADDR otherwise return the\n    end address of the new function.\n    '''\n    fn = _get_fn_by_version(idc, 'find_func_end', 'FindFuncEnd')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_code",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_code(flag):\n    '''\n    Does flag denote start of an instruction.\n    :param flag: Flag for an instruction.\n    :type flag: int\n    :return: True if flags indicate code, False otherwise.\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_code', 'isCode', idaapi)\n    return fn(flag)\ndef is_data(flag):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_data",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_data(flag):\n    '''\n    Does flag denote start of an instruction.\n    :param flag: Flag for an instruction.\n    :type flag: int\n    :return: True if flags indicate code, False otherwise.\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_code', 'isData', idaapi)\n    return fn(flag)\ndef is_dword(flag):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_dword",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_dword(flag):\n    '''\n    Does flag denote start of an instruction.\n    :param flag: Flag for an instruction.\n    :type flag: int\n    :return: True if flags indicate code, False otherwise.\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_dword', 'isDwrd', idaapi)\n    return fn(flag)\ndef is_qword(flag):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_qword",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_qword(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_qword', 'isQwrd', idaapi)\n    return fn(flag)\ndef is_word(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_word', 'isWord', idaapi)\n    return fn(flag)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_word",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_word(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_word', 'isWord', idaapi)\n    return fn(flag)\ndef is_struct(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_struct', 'isStruct', idaapi)\n    return fn(flag)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_struct",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_struct(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_struct', 'isStruct', idaapi)\n    return fn(flag)\ndef is_float(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_float', 'isFloat', idaapi)\n    return fn(flag)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_float",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_float(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_float', 'isFloat', idaapi)\n    return fn(flag)\ndef is_double(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_double', 'isDouble', idaapi)\n    return fn(flag)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_double",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_double(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_double', 'isDouble', idaapi)\n    return fn(flag)\ndef is_enum0(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_enum0', 'isEnum0', idaapi)\n    return fn(flag)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_enum0",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_enum0(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_enum0', 'isEnum0', idaapi)\n    return fn(flag)\ndef is_off0(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_off0', 'isOff0', idaapi)\n    return fn(flag)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_off0",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_off0(flag):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_off0', 'isOff0', idaapi)\n    return fn(flag)\ndef is_loaded(ea):\n    fn = _get_fn_by_version(ida_bytes, 'is_loaded', 'isLoaded', idc)\n    return fn(ea)\ndef has_xref(ea):\n    fn = _get_fn_by_version(ida_bytes, 'has_xref', 'hasRef', idaapi)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_loaded",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_loaded(ea):\n    fn = _get_fn_by_version(ida_bytes, 'is_loaded', 'isLoaded', idc)\n    return fn(ea)\ndef has_xref(ea):\n    fn = _get_fn_by_version(ida_bytes, 'has_xref', 'hasRef', idaapi)\n    return fn(ea)\ndef get_flags(ea):\n    '''\n    Get flags value for address 'ea'\n    :param ea: Linear address.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "has_xref",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def has_xref(ea):\n    fn = _get_fn_by_version(ida_bytes, 'has_xref', 'hasRef', idaapi)\n    return fn(ea)\ndef get_flags(ea):\n    '''\n    Get flags value for address 'ea'\n    :param ea: Linear address.\n    :type ea: int\n    :return: 0 if flags not present in the program\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_flags",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_flags(ea):\n    '''\n    Get flags value for address 'ea'\n    :param ea: Linear address.\n    :type ea: int\n    :return: 0 if flags not present in the program\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'get_flags', 'get_flags_novalue')\n    return fn(ea)\ndef get_full_flags(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_full_flags",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_full_flags(ea):\n    '''\n    Get flags value for address 'ea'\n    :param ea: Linear address.\n    :type ea: int\n    :return: 0 if flags not present in the program\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'get_full_flags', 'getFlags', idaapi)\n    return fn(ea)\ndef get_idb_path():",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_idb_path",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_idb_path():\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_idb_path', 'GetIdbPath', idc)\n    return fn()\ndef ua_mnem(ea):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_ua, 'ua_mnem', 'GetMnem', idc)\n    return fn(ea)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "ua_mnem",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def ua_mnem(ea):\n    '''\n    '''\n    fn = _get_fn_by_version(ida_ua, 'ua_mnem', 'GetMnem', idc)\n    return fn(ea)\ndef get_operand_value(ea, idx):\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_operand_value', 'GetOperandValue', idc)\n    return fn(ea, idx)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_operand_value",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_operand_value(ea, idx):\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_operand_value', 'GetOperandValue', idc)\n    return fn(ea, idx)\ndef get_bytes(func_addr, func_size):\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_bytes', 'GetManyBytes', idc)\n    return fn(func_addr, func_size)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_bytes",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_bytes(func_addr, func_size):\n    '''\n    '''\n    fn = _get_fn_by_version(idc, 'get_bytes', 'GetManyBytes', idc)\n    return fn(func_addr, func_size)\ndef get_name(ea):\n    '''\n    Get name at the specified address.\n    :param ea: Linear address\n    :type ea: int",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_name",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_name(ea):\n    '''\n    Get name at the specified address.\n    :param ea: Linear address\n    :type ea: int\n    :return: \"\" - byte has no name.\n    '''\n    fn = _get_fn_by_version(idc, 'get_name', 'Name')\n    if idaapi.IDA_SDK_VERSION > 700:\n        return fn(ea, ida_name.GN_VISIBLE)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "generate_disasm_line",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def generate_disasm_line(ea, flags):\n    fn = _get_fn_by_version(idc, 'generate_disasm_line', 'GetDisasmEx')\n    return fn(ea, flags)\ndef get_func_off_str(ea):\n    '''\n    Convert address to 'funcname+offset' string.\n    :param ea: Address to convert.\n    :type ea: int\n    :return: If the address belongs to a function then return a string formed as\n    'name+offset' where 'name' is a function name, 'offset' is offset within",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_func_off_str",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_func_off_str(ea):\n    '''\n    Convert address to 'funcname+offset' string.\n    :param ea: Address to convert.\n    :type ea: int\n    :return: If the address belongs to a function then return a string formed as\n    'name+offset' where 'name' is a function name, 'offset' is offset within\n    the function else return null string.\n    '''\n    fn = _get_fn_by_version(idc, 'get_func_off_str', 'GetFuncOffset')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "jumpto",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def jumpto(ea, opnum=-1, uijmp_flags=0x0001):\n    '''\n    Jump to the specified address.\n    :param ea: Destination\n    :type ea: int\n    :param opnum: -1: don't change the x coord.\n    :type opnum: int\n    :param uijmp_flags: Jump flags.\n    :type uijmp_flags: int\n    :return: success",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "ask_yn",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def ask_yn(default, format_str):\n    '''\n    Display a dialog box and get choice from \"Yes\", \"No\", \"Cancel\".\n    :param default: Default choice: one of Button IDs\n    :type default: int\n    :param format_str: The question in printf() style format.\n    :type format_str: str\n    :return: The selected button (one of Button IDs).\n    '''\n    fn = _get_fn_by_version(ida_kernwin, 'ask_yn', 'AskYN', idc)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "ask_file",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def ask_file(for_saving, default, dialog):\n    '''\n    Get file from user.\n    :param for_saving: File is for saving.\n    :type for_saving: int\n    :param default: File extension.\n    :type default: str\n    :param dialog: Dialog box to display to the user.\n    :type dialog: str\n    :return: file path.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_func_attr",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_func_attr(ea, attr):\n    '''\n    Get a function attribute.\n    :param ea: Any address belonging to the function.\n    :type ea: int\n    :param attr: One of FUNCATTR_... constants\n    :return: BADADDR - error otherwise returns the attribute value.\n    '''\n    fn = _get_fn_by_version(idc, 'get_func_attr', 'GetFunctionAttr')\n    return fn(ea, attr)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_name_ea_simple",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_name_ea_simple(name):\n    '''\n    Get linear address of a name.\n    :param name: Name of program byte.\n    :type name: str\n    :return: Address of the name or BADADDR - No such name.\n    '''\n    fn = _get_fn_by_version(idc, 'get_name_ea_simple', 'LocByName')\n    return fn(name)\ndef get_name_ea(afrom, fname):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_name_ea",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_name_ea(afrom, fname):\n    '''\n    '''\n    fn = _get_fn_by_version(idaapi, 'get_name_ea', 'LocByNameEx', idc)\n    return fn(afrom, fname)\ndef next_head(ea, maxea=4294967295):\n    '''\n    Get next defined item (instruction or data) in the program.\n    :param ea: Linear address to start search from.\n    :type ea: int",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "next_head",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def next_head(ea, maxea=4294967295):\n    '''\n    Get next defined item (instruction or data) in the program.\n    :param ea: Linear address to start search from.\n    :type ea: int\n    :param maxea: The search will stop at the address maxea. maxea is not\n                  included in the search range\n    :type maxea: int\n    :return: BADADDR - no (more) defined items\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "find_text",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def find_text(ea, y, x, searchstr, flag):\n    fn = _get_fn_by_version(ida_search, 'find_text', 'FindText', idc)\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return fn(ea, y, x, searchstr, flag)\n    return fn(ea, flag, y, x, searchstr)\ndef get_screen_ea():\n    '''\n    Return the linear address of the current screen location.\n    :return: Address of screen focus.\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_screen_ea",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_screen_ea():\n    '''\n    Return the linear address of the current screen location.\n    :return: Address of screen focus.\n    '''\n    fn = _get_fn_by_version(idc, 'get_screen_ea', 'ScreenEA')\n    return fn()\ndef choose_func(title):\n    '''\n    Ask the user to select a function.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "choose_func",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def choose_func(title):\n    '''\n    Ask the user to select a function.\n    :param title: Title of the dialog box.\n    :type title: str\n    :return: -1 user refused to select a function, otherwise function start addr\n    '''\n    fn = _get_fn_by_version(idc, 'choose_func', 'ChooseFunction')\n    return fn(title)\ndef ask_ident(default, prompt):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "ask_ident",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def ask_ident(default, prompt):\n    '''\n    Ask for a long text.\n    :param default: The default value.\n    :type default: str\n    :param prompt: The prompt value.\n    :type prompt: str\n    :return: None or the entered string.\n    '''\n    fn = _get_fn_by_version(ida_kernwin, 'ask_str', 'AskIdent', idc)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "set_name",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def set_name(ea, name, flags):\n    '''\n    Rename an address.\n    :param ea: Linear address.\n    :type ea: int\n    :param name: New name of address. If name == \"\" then delete old name.\n    :type name: str\n    :return: 1-ok, 0-failure\n    '''\n    fn = _get_fn_by_version(idc, 'set_name', 'MakeName')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_wide_dword",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_wide_dword(ea):\n    '''\n    Get one wide word of the program at 'ea'\n    :param ea: linear address.\n    :type ea: int\n    :return: uint64\n    '''\n    fn = _get_fn_by_version(idc, 'get_wide_dword', 'Dword')\n    return fn(ea)\ndef get_strlit_contents(str_obj):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_strlit_contents",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_strlit_contents(str_obj):\n    '''\n    Get string contents.\n    :param ea: Linear address.\n    :type ea: int\n    :return: String contents or empty string.\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'get_strlit_contents', 'GetString', idc)\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return fn(str_obj.ea, str_obj.length, str_obj.strtype)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_func_name",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_func_name(ea):\n    '''\n    Retrieve function name.\n    :param ea: Any address belonging to the function.\n    :type ea: int\n    :return: Null string if not found, otherwise the functions name.\n    '''\n    fn = _get_fn_by_version(idc, 'get_func_name', 'GetFunctionName')\n    return fn(ea)\ndef get_first_seg():",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_first_seg",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_first_seg():\n    '''\n    Get first segment.\n    :return: Address of the start of the first segment or BADADDR if no\n    segments found.\n    '''\n    fn = _get_fn_by_version(idc, 'get_first_seg', 'FirstSeg')\n    return fn()\ndef get_segm_attr(segea, attr):\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_segm_attr",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_segm_attr(segea, attr):\n    '''\n    Get segment attribute.\n    :param segea: Any address within the segment.\n    :type segea: int\n    :param attr: One of SEGATTR_... constants.\n    :type attr: int\n    :return: Segment attributes.\n    '''\n    fn = _get_fn_by_version(idc, 'get_segm_attr', 'GetSegmentAttr')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_next_seg",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_next_seg(ea):\n    '''\n    Get next segment.\n    :param ea: Linear address.\n    :type ea: int\n    :return: Start of the next segment or BADADDR\n    '''\n    fn = _get_fn_by_version(idc, 'get_next_seg', 'NextSeg')\n    return fn(ea)\ndef is_strlit(flags):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_strlit",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_strlit(flags):\n    '''\n    Do flags indicate a string.\n    :param flags: Flags for address.\n    :type flags: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_strlit', 'isASCII', idc)\n    return fn(flags)\ndef create_strlit(start, length):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "create_strlit",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def create_strlit(start, length):\n    '''\n    Convert to string literal and give a meaningful name.\n    :param start: Start ea.\n    :type start: int\n    :param length: Length of string, or 0 to determine dynamically.\n    :type length: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'create_strlit', 'MakeStr', idc)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_unknown",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_unknown(flags):\n    '''\n    Do flags indicate an unknown type.\n    :param flags: Flags for address.\n    :type flags: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_unknown', 'isUnknown', idc)\n    return fn(flags)\ndef refresh_idaview_anyway():",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "refresh_idaview_anyway",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def refresh_idaview_anyway():\n    '''\n    '''\n    fn = _get_fn_by_version(idaapi, 'refresh_idaview_anyway', 'Refresh', idc)\n    return fn()\ndef get_current_widget():\n    '''\n    '''\n    fn = _get_fn_by_version(idaapi, 'get_current_widget', 'get_current_tform', idaapi)\n    return fn()",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_current_widget",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_current_widget():\n    '''\n    '''\n    fn = _get_fn_by_version(idaapi, 'get_current_widget', 'get_current_tform', idaapi)\n    return fn()\ndef get_widget_vdui(form_widget_ref):\n    '''\n    '''\n    fn = _get_fn_by_version(idaapi, 'get_widget_vdui', 'get_tform_vdui', idaapi)\n    return fn(form_widget_ref)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_widget_vdui",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_widget_vdui(form_widget_ref):\n    '''\n    '''\n    fn = _get_fn_by_version(idaapi, 'get_widget_vdui', 'get_tform_vdui', idaapi)\n    return fn(form_widget_ref)\ndef is_byte(flags):\n    '''\n    Do flags indicate a byte type.\n    :param flags: Flags for address.\n    :type flags: int",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_byte",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_byte(flags):\n    '''\n    Do flags indicate a byte type.\n    :param flags: Flags for address.\n    :type flags: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_byte', 'isByte', idc)\n    return fn(flags)\ndef is_char0(flags):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "is_char0",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def is_char0(flags):\n    '''\n    Do flags indicate a byte type.\n    :param flags: Flags for address.\n    :type flags: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'is_char0', 'isChar0', idc)\n    return fn(flags)\ndef create_dword(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "create_dword",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def create_dword(ea):\n    '''\n    Convert to data.\n    :param ea: Linear address .\n    :type ea: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'create_data', 'MakeDword', idc)\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return fn(ea, ida_bytes.FF_DWORD, 4, idaapi.BADADDR)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "op_plain_offset",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def op_plain_offset(ea, n, base):\n    '''\n    Convert operand to an offset.\n    :param ea: Linear address.\n    :type ea: int\n    :param n: Number of operands.\n    :type n: int\n    :param base: Base of the offset.\n    :type base: int\n    :return:",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "next_addr",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def next_addr(ea):\n    '''\n    Get next address in the program.\n    :param ea: Linear address.\n    :type ea: int\n    :return: Next address or BADADDR\n    '''\n    fn = _get_fn_by_version(ida_bytes, 'next_addr', 'NextAddr', idc)\n    return fn(ea)\ndef can_decode(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "can_decode",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def can_decode(ea):\n    '''\n    Can the bytes at ea be decoded as an instruction?\n    :param ea: Linear address\n    :type ea: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_ua, 'can_decode', 'decode_insn', idaapi)\n    return fn(ea)\ndef get_operands(insn):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_operands",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_operands(insn):\n    '''\n    Get operands for the current address.\n    :return:\n    '''\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return insn.ops\n    return idaapi.cmd.Operands\ndef get_canon_feature(insn):\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_canon_feature",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_canon_feature(insn):\n    '''\n    Get operands for the provided instruction.\n    :return:\n    '''\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return insn.get_canon_feature()\n    return idaapi.cmd.get_canon_feature()\ndef get_segm_name(ea):\n    '''",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_segm_name",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_segm_name(ea):\n    '''\n    Get name of a segment.\n    :param ea: Any address within the segment.\n    :type ea: int\n    :return: Segement name.\n    '''\n    fn = _get_fn_by_version(idc, 'get_segm_name', 'SegName')\n    return fn(ea)\ndef add_func(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "add_func",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def add_func(ea):\n    '''\n    Add a new function.\n    :param ea: Start address.\n    :type ea: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(ida_funcs, 'add_func', 'MakeFunction', idc)\n    return fn(ea)\ndef create_insn(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "create_insn",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def create_insn(ea):\n    '''\n    Create instruction.\n    :param ea: Linear address\n    :type ea: int\n    :return: bool\n    '''\n    fn = _get_fn_by_version(idc, 'create_insn', 'MakeCode')\n    return fn(ea)\ndef get_segm_end(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_segm_end",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_segm_end(ea):\n    '''\n    Get end address of a segment.\n    :param ea: Linear address\n    :type ea: int\n    :return: Address\n    '''\n    fn = _get_fn_by_version(idc, 'get_segm_end', 'SegEnd')\n    return fn(ea)\ndef get_segm_start(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_segm_start",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_segm_start(ea):\n    '''\n    Get start address of a segment.\n    :param ea: Linear address\n    :type ea: int\n    :return: Address\n    '''\n    fn = _get_fn_by_version(idc, 'get_segm_start', 'SegStart')\n    return fn(ea)\ndef insn_t():",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "insn_t",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def insn_t():\n    prop = _get_fn_by_version(idaapi, 'insn_t', 'cmd', idaapi)\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return prop()\n    else:\n        return prop\ndef decode_insn(ea):\n    \"\"\"\n    Decode instruction.\n    :param ea: Linear address.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "decode_insn",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def decode_insn(ea):\n    \"\"\"\n    Decode instruction.\n    :param ea: Linear address.\n    :type ea: int\n    :return: Instruction at ea.\n    \"\"\"\n    fn = _get_fn_by_version(ida_ua, 'decode_insn', 'decode_insn', idaapi)\n    if idaapi.IDA_SDK_VERSION >= 700:\n        insn = ida_ua.insn_t()",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_bookmark",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_bookmark(index):\n    \"\"\"\n    Get bookmark\n    :param index: Index of bookmark\n    :type index: int\n    :return: Address of bookmark\n    \"\"\"\n    fn = _get_fn_by_version(idc, 'get_bookmark', 'GetMarkedPos')\n    return fn(index)\ndef get_bookmark_desc(index):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_bookmark_desc",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_bookmark_desc(index):\n    \"\"\"\n    Get bookmark description.\n    :param index: Index of bookmark\n    :type index: int\n    :return:\n    \"\"\"\n    fn = _get_fn_by_version(idc, 'get_bookmark_desc', 'GetMarkComment')\n    return fn(index)\ndef set_color(ea, what, color):",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "set_color",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def set_color(ea, what, color):\n    \"\"\"\n    Set item color.\n    :param ea: Linear address.\n    :type ea: int\n    :param what: Type of the item, one of CIC_... contstants\n    :type what: int\n    :param color: New color code in RGB.\n    :type color: int\n    :return: bool",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_color",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_color(ea, what):\n    \"\"\"\n    \"\"\"\n    fn = _get_fn_by_version(idc, 'get_color', 'GetColor')\n    return fn(ea, what) & 0xFFFFFF\ndef msg(message):\n    \"\"\"\n    Display a UTF-8 string in the message window.\n    :param message: Message to print.\n    :type message: str",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "msg",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def msg(message):\n    \"\"\"\n    Display a UTF-8 string in the message window.\n    :param message: Message to print.\n    :type message: str\n    :return: PyObject * (what?)\n    \"\"\"\n    fn = _get_fn_by_version(ida_kernwin, 'msg', 'Message', idc)\n    return fn(message)\ndef get_highlighted_identifier():",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_highlighted_identifier",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_highlighted_identifier():\n    \"\"\"\n    Get currently highlighted text.\n    :return: Highlighted text or \"\"\n    \"\"\"\n    fn = _get_fn_by_version(ida_kernwin, 'get_highlight',\n                            'get_highlighted_identifier', idaapi)\n    if idaapi.IDA_SDK_VERSION >= 700:\n        viewer = ida_kernwin.get_current_viewer()\n        highlight = fn(viewer)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "user_cancelled",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def user_cancelled():\n    fn = _get_fn_by_version(idaapi, 'user_cancelled', 'wasBreak', idaapi)\n    return fn()\ndef start_ea(obj):\n    \"\"\"\n    Return start ea for supplied object.\n    :param obj: Object to retrieve start ea.\n    :return: start ea.\n    \"\"\"\n    if not obj:",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "start_ea",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def start_ea(obj):\n    \"\"\"\n    Return start ea for supplied object.\n    :param obj: Object to retrieve start ea.\n    :return: start ea.\n    \"\"\"\n    if not obj:\n        return None\n    try:\n        return obj.startEA",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "end_ea",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def end_ea(obj):\n    \"\"\"\n    Return end ea for supplied object.\n    :param obj: Object to retrieve end ea.\n    :return: end ea.\n    \"\"\"\n    if not obj:\n        return None\n    try:\n        return obj.endEA",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "set_func_flags",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def set_func_flags(ea, flags):\n    \"\"\"\n    Change function flags.\n    :param ea: Any address belonging to the function.\n    :type ea: int\n    :param flags: Flags to set.\n    :type flags: int\n    :return: 0 - ok\n    \"\"\"\n    fn = _get_fn_by_version(idc, 'set_func_attr', 'SetFunctionFlags')",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "set_func_attr",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def set_func_attr(ea, flags, value):\n    \"\"\"\n    \"\"\"\n    fn = _get_fn_by_version(idc, 'set_func_attr', 'SetFunctionFlags')\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return fn(ea, 36, value)\n    return fn(ea, 36, value)\ndef get_func_flags(ea):\n    \"\"\"\n    Get function flags.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_func_flags",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_func_flags(ea):\n    \"\"\"\n    Get function flags.\n    :param ea: Any address belonging to the function.\n    :type ea: int\n    :return: Flags\n    \"\"\"\n    fn = _get_fn_by_version(idc, 'get_func_attr', 'GetFunctionFlags')\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return fn(ea, idc.FUNCATTR_FLAGS)",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_input_file_path",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_input_file_path():\n    fn = _get_fn_by_version(idaapi, 'get_input_file_path', 'GetInputFilePath', idc)\n    return fn()\ndef get_ida_subdirs(sub_folder):\n    if idaapi.IDA_SDK_VERSION > 700:\n        return idaapi.get_ida_subdirs(\"plugins\")\n    else:\n        USR_PLUGIN_PATH = os.path.join(idaapi.get_user_idadir(), sub_folder)\n        SYS_PLUGIN_PATH = os.path.join(idaapi.idadir(idaapi.PLG_SUBDIR))\n        return [USR_PLUGIN_PATH, SYS_PLUGIN_PATH]",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_ida_subdirs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_ida_subdirs(sub_folder):\n    if idaapi.IDA_SDK_VERSION > 700:\n        return idaapi.get_ida_subdirs(\"plugins\")\n    else:\n        USR_PLUGIN_PATH = os.path.join(idaapi.get_user_idadir(), sub_folder)\n        SYS_PLUGIN_PATH = os.path.join(idaapi.idadir(idaapi.PLG_SUBDIR))\n        return [USR_PLUGIN_PATH, SYS_PLUGIN_PATH]\ndef get_chunk_eas(func_addr):\n    \"\"\"\n    Check if a function is divided into chunks.",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "get_chunk_eas",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def get_chunk_eas(func_addr):\n    \"\"\"\n    Check if a function is divided into chunks.\n    \"\"\"\n    # logger.debug('is_func_chunked {}'.format(func_addr))\n    # Idea for this code is from:\n    # http://code.google.com/p/idapython/source/browse/trunk/python/idautils.py?r=344\n    func_iter = idaapi.func_tail_iterator_t(idaapi.get_func(func_addr))\n    status = func_iter.main()\n    while status:",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "calc_func_size",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def calc_func_size(func_desc):\n    if idaapi.IDA_SDK_VERSION >= 720:\n        return ida_funcs.calc_func_size(func_desc)\n    else:\n        beg_addr = start_ea(func_desc)\n        if _is_func_chunked(beg_addr):\n            func_size = 0\n            for beg, end in idautils.Chunks(beg_addr):\n                func_size += end - beg\n            return func_size",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "inf_get_cc_id",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_shims",
        "description": "plugins.IdaClu.idaclu.ida_shims",
        "peekOfCode": "def inf_get_cc_id():\n    if idaapi.IDA_SDK_VERSION >= 900:\n        return ida_ida.inf_get_cc_id()\n    else:\n        inf = idaapi.get_inf_structure()\n        return inf.cc.id",
        "detail": "plugins.IdaClu.idaclu.ida_shims",
        "documentation": {}
    },
    {
        "label": "manage_dir",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def manage_dir(dir_name, operation, is_abs):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    dir_ops = {\n        'mkdir': False,\n        'rmdir': True,\n        'chdir': True\n    }\n    if is_abs:\n        func_dir.chdir('/')\n    is_dir = func_dir.isdir(dir_name)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "create_dir",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def create_dir(dir_name, is_abs=True):\n    return manage_dir(dir_name, 'mkdir', is_abs)\ndef remove_dir(dir_name, is_abs=True):\n    return manage_dir(dir_name, 'rmdir', is_abs)\ndef change_dir(dir_name, is_abs=True):\n    return manage_dir(dir_name, 'chdir', is_abs)\n# logic / prefixes '%' and '_' are the opposites:\n# 1. '%' - has always single occurence, '_' - not;\n# 2. '%' cannot appear at the very beginning of a function name, '_' - can;\n# 3. '%' is purely internal prefix representation, '_' - human representation;",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "remove_dir",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def remove_dir(dir_name, is_abs=True):\n    return manage_dir(dir_name, 'rmdir', is_abs)\ndef change_dir(dir_name, is_abs=True):\n    return manage_dir(dir_name, 'chdir', is_abs)\n# logic / prefixes '%' and '_' are the opposites:\n# 1. '%' - has always single occurence, '_' - not;\n# 2. '%' cannot appear at the very beginning of a function name, '_' - can;\n# 3. '%' is purely internal prefix representation, '_' - human representation;\n# 4. '%' are the prefixes added automatically, '_' - manually\ndef is_pfx_valid(pfx):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "change_dir",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def change_dir(dir_name, is_abs=True):\n    return manage_dir(dir_name, 'chdir', is_abs)\n# logic / prefixes '%' and '_' are the opposites:\n# 1. '%' - has always single occurence, '_' - not;\n# 2. '%' cannot appear at the very beginning of a function name, '_' - can;\n# 3. '%' is purely internal prefix representation, '_' - human representation;\n# 4. '%' are the prefixes added automatically, '_' - manually\ndef is_pfx_valid(pfx):\n    a_facts = ['@', '$', '?', '-', '+']\n    is_complex = any(a in pfx for a in a_facts)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_pfx_valid",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_pfx_valid(pfx):\n    a_facts = ['@', '$', '?', '-', '+']\n    is_complex = any(a in pfx for a in a_facts)\n    is_numeric = re.match('^[0-9]+', pfx)\n    is_blanked = pfx == ''\n    return not (is_complex or is_numeric or is_blanked)\ndef get_func_prefs(func_name, is_dummy=True):\n    if ((func_name.startswith('?') and '@' in func_name) or\n        func_name.startswith('_')):\n        return []",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_prefs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_prefs(func_name, is_dummy=True):\n    if ((func_name.startswith('?') and '@' in func_name) or\n        func_name.startswith('_')):\n        return []\n    pfx_dummy = 'sub_'\n    prefs = []\n    pfx = ''\n    idx = 0\n    func_name = func_name.rstrip('_%:')\n    while idx < len(func_name):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_cleaned_funcname",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_cleaned_funcname(func_name, is_diff=False):\n    bad_part = ''\n    for char in func_name:\n        if not char.isalpha():\n            bad_part += char\n        else:\n            break\n    if is_diff:\n        return bad_part\n    else:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "refresh_ui",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def refresh_ui():\n    ida_shims.refresh_idaview_anyway()\n    widget = ida_shims.get_current_widget()\n    widget_vdui = ida_shims.get_widget_vdui(widget)\n    if widget_vdui:\n        widget_vdui.refresh_ctext()\ndef graph_down(ea, path=set()):\n    path.add(ea)\n    call_instructions = []\n    for address in idautils.FuncItems(ea):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "graph_down",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def graph_down(ea, path=set()):\n    path.add(ea)\n    call_instructions = []\n    for address in idautils.FuncItems(ea):\n        if not ida_shims.decode_insn(address):\n            continue\n        if not idaapi.is_call_insn(address):\n            continue\n        call_instructions.append(address)\n    for x in call_instructions:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "recursive_prefix",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def recursive_prefix(addr):\n    func_addr = ida_shims.get_name_ea(idaapi.BADADDR, ida_shims.get_func_name(addr))\n    if func_addr == idaapi.BADADDR:\n        ida_shims.msg(\"ERROR: function is not defined at 0x%08X\\n\" % addr)\n        return\n    nodes_xref_down = graph_down(func_addr, path=set([]))\n    return nodes_xref_down\ndef get_nodes_edges(func_addr):\n    func = idaapi.get_func(func_addr)\n    g = idaapi.FlowChart(func)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_nodes_edges",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_nodes_edges(func_addr):\n    func = idaapi.get_func(func_addr)\n    g = idaapi.FlowChart(func)\n    node_count = len(list(g))\n    edge_count = 0\n    for x in g:\n        succ_count = len(list(x.succs()))\n        pred_count = len(list(x.preds()))\n        edge_count += (succ_count + pred_count)\n    return (node_count, edge_count)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_ea_by_ref",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_ea_by_ref(func_ref):\n    if isinstance(func_ref, int):\n        return func_ref\n    elif isinstance(func_ref, str):\n        return idc.get_name_ea_simple(func_ref)\n    elif isinstance(func_ref, func_t):\n        return func_ref.start_ea\ndef get_func_item_eas(func_ref):\n    func_ea = get_func_ea_by_ref(func_ref)\n    for item_ea in list(idautils.FuncItems(func_ea)):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_item_eas",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_item_eas(func_ref):\n    func_ea = get_func_ea_by_ref(func_ref)\n    for item_ea in list(idautils.FuncItems(func_ea)):\n        if idaapi.is_code(ida_shims.get_full_flags(func_ea)):\n            yield item_ea\ndef get_func_item_eas_once(func_ref):\n    item_eas = []\n    for ea in get_func_item_eas(func_ref):\n        item_eas.append(ea)\n    return item_eas",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_item_eas_once",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_item_eas_once(func_ref):\n    item_eas = []\n    for ea in get_func_item_eas(func_ref):\n        item_eas.append(ea)\n    return item_eas\ndef get_func_set_attrs(fn_start=['sub_'], is_fn_start=True, attrs=['indx','addr','name', 'size', 'attr']):\n    for func_idx, func_addr in enumerate(idautils.Functions()):\n        func_name = ida_shims.get_func_name(func_addr)\n        func_attr = idc.get_func_attr(func_addr, idc.FUNCATTR_FLAGS)\n        func_desc = idaapi.get_func(func_addr)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_set_attrs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_set_attrs(fn_start=['sub_'], is_fn_start=True, attrs=['indx','addr','name', 'size', 'attr']):\n    for func_idx, func_addr in enumerate(idautils.Functions()):\n        func_name = ida_shims.get_func_name(func_addr)\n        func_attr = idc.get_func_attr(func_addr, idc.FUNCATTR_FLAGS)\n        func_desc = idaapi.get_func(func_addr)\n        func_size = ida_shims.calc_func_size(func_desc)\n        if any(func_name.startswith(pat) == is_fn_start for pat in fn_start):  # all ??\n            attr_set = ()\n            if 'indx' in attrs:\n                attr_set += (func_idx,)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_function_solved",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_function_solved(func_ref):\n    EXPL_CALL_ARTS = [\n        'call sub_',\n        'call _',\n        'call ds:',\n        'call nullsub_',\n        'call loc_',\n        'call off_',\n        'call j_j__',\n        'call ??',",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_function_leaf",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_function_leaf(func_ref):\n    func_ea = get_func_ea_by_ref(func_ref)\n    item_eas = [item_ea for item_ea in get_func_item_eas(func_ea)]\n    for item_ea in item_eas:\n        if ida_shims.ua_mnem(item_ea) == 'call':\n            return False\n    else:\n        if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':\n            return False\n        else:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_dir_metrics",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_dir_metrics(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = collections.defaultdict(int)\n    while len(s_folders):\n        curr_path = s_folders.pop()\n        func_dir.chdir(curr_path)\n        status = func_dir.findfirst(ite, \"*\")\n        while status:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_dirs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_dirs(root_dir):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    s_folders = [root_dir]\n    u_folders = [root_dir]\n    while len(s_folders):\n        curr_path = s_folders.pop()\n        func_dir.chdir(curr_path)\n        status = func_dir.findfirst(ite, \"*\")\n        while status:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_dir_funcs",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_dir_funcs(folders, is_root=True):\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    ite = ida_dirtree.dirtree_iterator_t()\n    idx = 0\n    funcs = {}\n    while idx < len(folders):\n        curr_path = folders[idx]\n        func_dir.chdir(curr_path)\n        status = func_dir.findfirst(ite, \"*\")\n        while status:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_name",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_name(func_ref):\n    func_name = None\n    if isinstance(func_ref, str):\n        func_name = func_ref\n    elif isinstance(func_ref, int):\n        func_name = ida_shims.get_func_name(func_ref)\n    else:\n        raise ValueError(\"Invalid func reference\")\n    return func_name\ndef get_folder_norm(folder):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_folder_norm",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_folder_norm(folder):\n    return '' if folder == '/' else folder\ndef set_func_folder(func_ref, folder_src, folder_dst):\n    func_name = get_func_name(func_ref)\n    func_src = '{}/{}'.format(get_folder_norm(folder_src), func_name)\n    func_dst = '{}/{}'.format(get_folder_norm(folder_dst), func_name)\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    func_dir.chdir('/')\n    func_dir.rename(func_src, func_dst)\ndef is_in_interval(addr, func_ivals, is_strict):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "set_func_folder",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def set_func_folder(func_ref, folder_src, folder_dst):\n    func_name = get_func_name(func_ref)\n    func_src = '{}/{}'.format(get_folder_norm(folder_src), func_name)\n    func_dst = '{}/{}'.format(get_folder_norm(folder_dst), func_name)\n    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)\n    func_dir.chdir('/')\n    func_dir.rename(func_src, func_dst)\ndef is_in_interval(addr, func_ivals, is_strict):\n    if is_strict:\n        return any(beg < addr < end for beg, end in func_ivals)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_in_interval",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_in_interval(addr, func_ivals, is_strict):\n    if is_strict:\n        return any(beg < addr < end for beg, end in func_ivals)\n    else:\n        return any(beg <= addr <= end for beg, end in func_ivals)\ndef get_func_ivals(func_addr):\n    return [(func_beg, func_end) for func_beg, func_end in ida_shims.get_chunk_eas(func_addr)]\ndef get_chunk_count(func_addr):\n    num_chunks = len(get_func_ivals(func_addr))\n    return num_chunks",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_func_ivals",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_func_ivals(func_addr):\n    return [(func_beg, func_end) for func_beg, func_end in ida_shims.get_chunk_eas(func_addr)]\ndef get_chunk_count(func_addr):\n    num_chunks = len(get_func_ivals(func_addr))\n    return num_chunks\ndef is_addr_func(addr, func_addr, is_chunks, is_strict):\n    func_ivals = None\n    if is_chunks:\n        func_ivals = get_func_ivals(func_addr)\n    else:",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_chunk_count",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_chunk_count(func_addr):\n    num_chunks = len(get_func_ivals(func_addr))\n    return num_chunks\ndef is_addr_func(addr, func_addr, is_chunks, is_strict):\n    func_ivals = None\n    if is_chunks:\n        func_ivals = get_func_ivals(func_addr)\n    else:\n        func_beg = func_addr\n        func_end = idc.get_func_attr(func_addr, idc.FUNCATTR_END)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_addr_func",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_addr_func(addr, func_addr, is_chunks, is_strict):\n    func_ivals = None\n    if is_chunks:\n        func_ivals = get_func_ivals(func_addr)\n    else:\n        func_beg = func_addr\n        func_end = idc.get_func_attr(func_addr, idc.FUNCATTR_END)\n        func_ivals = [(func_beg, func_end)]\n    return is_in_interval(addr, func_ivals, is_strict)\ndef is_func_wrapper(func_addr, is_precise=True):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_func_wrapper",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_func_wrapper(func_addr, is_precise=True):\n    \"\"\"\n    Wrapper functions are typically short.\n    x86_64 instructions can be up to 15 bytes in length, at average - 4/5;\n    The defined frame is 64b, then a very rough approximation is as follows:\n        15 bytes/instr ->  4 instr/func ->  1- 2 statements (min)\n         5 bytes/instr -> 12 instr/func ->  4- 6 statements\n         4 bytes/instr -> 16 instr/func ->  5- 8 statements\n         2 bytes/instr -> 32 instr/func -> 10-11 statements (max)\n    It is not sufficient to look up solely for function size,",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_func_thunk",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_func_thunk(func_addr):\n    func_flags = ida_shims.get_func_flags(func_addr)\n    return func_flags & idaapi.FUNC_THUNK\ndef get_code_refs_to(addr):\n    return set([cref for cref in idautils.CodeRefsTo(addr, 0)])\ndef get_data_refs_to(addr):\n    return set([dref for dref in idautils.DataRefsTo(addr)])\ndef get_refs_to(addr):\n    return iter(get_code_refs_to(addr).union(get_data_refs_to(addr)))\ndef is_arch64():",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_code_refs_to",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_code_refs_to(addr):\n    return set([cref for cref in idautils.CodeRefsTo(addr, 0)])\ndef get_data_refs_to(addr):\n    return set([dref for dref in idautils.DataRefsTo(addr)])\ndef get_refs_to(addr):\n    return iter(get_code_refs_to(addr).union(get_data_refs_to(addr)))\ndef is_arch64():\n    return bool(idaapi.getseg(ida_shims.get_first_seg()).bitness == 2)\ndef get_ptr_type():\n    return [FF_DWORD, FF_QWORD][is_arch64()]",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_data_refs_to",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_data_refs_to(addr):\n    return set([dref for dref in idautils.DataRefsTo(addr)])\ndef get_refs_to(addr):\n    return iter(get_code_refs_to(addr).union(get_data_refs_to(addr)))\ndef is_arch64():\n    return bool(idaapi.getseg(ida_shims.get_first_seg()).bitness == 2)\ndef get_ptr_type():\n    return [FF_DWORD, FF_QWORD][is_arch64()]\ndef get_ref_off():\n    return [REF_OFF32, REF_OFF64][is_arch64()]",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_refs_to",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_refs_to(addr):\n    return iter(get_code_refs_to(addr).union(get_data_refs_to(addr)))\ndef is_arch64():\n    return bool(idaapi.getseg(ida_shims.get_first_seg()).bitness == 2)\ndef get_ptr_type():\n    return [FF_DWORD, FF_QWORD][is_arch64()]\ndef get_ref_off():\n    return [REF_OFF32, REF_OFF64][is_arch64()]\ndef get_ptr_size():\n    return [4, 8][is_arch64()]",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_arch64",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_arch64():\n    return bool(idaapi.getseg(ida_shims.get_first_seg()).bitness == 2)\ndef get_ptr_type():\n    return [FF_DWORD, FF_QWORD][is_arch64()]\ndef get_ref_off():\n    return [REF_OFF32, REF_OFF64][is_arch64()]\ndef get_ptr_size():\n    return [4, 8][is_arch64()]\ndef get_ptr(addr):\n    return [idaapi.get_32bit, idaapi.get_64bit][is_arch64()](addr)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_ptr_type",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_ptr_type():\n    return [FF_DWORD, FF_QWORD][is_arch64()]\ndef get_ref_off():\n    return [REF_OFF32, REF_OFF64][is_arch64()]\ndef get_ptr_size():\n    return [4, 8][is_arch64()]\ndef get_ptr(addr):\n    return [idaapi.get_32bit, idaapi.get_64bit][is_arch64()](addr)\ndef is_GCC_auto():\n    if get_compiler_name() == 'GNU C++':",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_ref_off",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_ref_off():\n    return [REF_OFF32, REF_OFF64][is_arch64()]\ndef get_ptr_size():\n    return [4, 8][is_arch64()]\ndef get_ptr(addr):\n    return [idaapi.get_32bit, idaapi.get_64bit][is_arch64()](addr)\ndef is_GCC_auto():\n    if get_compiler_name() == 'GNU C++':\n        return True\n    return False",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_ptr_size",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_ptr_size():\n    return [4, 8][is_arch64()]\ndef get_ptr(addr):\n    return [idaapi.get_32bit, idaapi.get_64bit][is_arch64()](addr)\ndef is_GCC_auto():\n    if get_compiler_name() == 'GNU C++':\n        return True\n    return False\ndef is_GCC_manual():\n    gcc_rtti_artifacts = [",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_ptr",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_ptr(addr):\n    return [idaapi.get_32bit, idaapi.get_64bit][is_arch64()](addr)\ndef is_GCC_auto():\n    if get_compiler_name() == 'GNU C++':\n        return True\n    return False\ndef is_GCC_manual():\n    gcc_rtti_artifacts = [\n        \"St9type_info\",\n        \"N10__cxxabiv117__class_type_infoE\",",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_GCC_auto",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_GCC_auto():\n    if get_compiler_name() == 'GNU C++':\n        return True\n    return False\ndef is_GCC_manual():\n    gcc_rtti_artifacts = [\n        \"St9type_info\",\n        \"N10__cxxabiv117__class_type_infoE\",\n        \"N10__cxxabiv120__si_class_type_infoE\",\n        \"N10__cxxabiv121__vmi_class_type_infoE\"",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_GCC_manual",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_GCC_manual():\n    gcc_rtti_artifacts = [\n        \"St9type_info\",\n        \"N10__cxxabiv117__class_type_infoE\",\n        \"N10__cxxabiv120__si_class_type_infoE\",\n        \"N10__cxxabiv121__vmi_class_type_infoE\"\n    ]\n    flag = idaapi.SEARCH_CASE|idaapi.SEARCH_DOWN\n    for art in gcc_rtti_artifacts:\n        gcc_info = ida_shims.find_text(0x0, 0, 0, art, flag)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "is_vtable",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def is_vtable(addr):\n    if addr and has_xref(addr):\n        func_ea = get_ptr(addr)\n        if func_ea and idaapi.getseg(func_ea):\n            if ida_shims.get_segm_attr(func_ea, idc.SEGATTR_TYPE) == idc.SEG_CODE:\n                func_desc = idaapi.get_func(func_ea)\n                if func_desc and func_ea == ida_shims.start_ea(func_desc):\n                    return True\n    return False\ndef has_xref(addr):",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "has_xref",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def has_xref(addr):\n    return ida_shims.has_xref(ida_shims.get_full_flags(addr))\ndef get_compiler_name():\n    inf_cc_id = ida_shims.inf_get_cc_id()\n    return idaapi.get_compiler_name(inf_cc_id)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "get_compiler_name",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.ida_utils",
        "description": "plugins.IdaClu.idaclu.ida_utils",
        "peekOfCode": "def get_compiler_name():\n    inf_cc_id = ida_shims.inf_get_cc_id()\n    return idaapi.get_compiler_name(inf_cc_id)",
        "detail": "plugins.IdaClu.idaclu.ida_utils",
        "documentation": {}
    },
    {
        "label": "ResultNode",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.models",
        "description": "plugins.IdaClu.idaclu.models",
        "peekOfCode": "class ResultNode(object):\n    def __init__(self, data, parent=None):\n        if isinstance(data, tuple):\n            self._data = list(data)\n        elif isinstance(data, str) or not hasattr(data, '__getitem__'):\n            # data is not indexable\n            self._data = [data]\n        else:\n            self._data = data\n        self._col_count = len(self._data)",
        "detail": "plugins.IdaClu.idaclu.models",
        "documentation": {}
    },
    {
        "label": "ResultModel",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.models",
        "description": "plugins.IdaClu.idaclu.models",
        "peekOfCode": "class ResultModel(QAbstractItemModel):\n    def __init__(self, heads, nodes, env_desc):\n        super(ResultModel, self).__init__()\n        self.env = env_desc\n        self.iroot = ResultNode([])\n        self.heads = heads\n        self.bg_col = heads.index('Color') if 'Color' in heads else None\n        for node in nodes:\n            self.iroot.addChild(node)\n    def rowCount(self, parent_idx=QModelIndex()):",
        "detail": "plugins.IdaClu.idaclu.models",
        "documentation": {}
    },
    {
        "label": "PluginPath",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "class PluginPath():\n    def __init__(self, path):\n        self.path = path\n    def __enter__(self):\n        sys.path.insert(0, self.path)\n    def __exit__(self, exc_type, exc_value, traceback):\n        try:\n            sys.path.remove(self.path)\n        except ValueError:\n            pass",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "RgbColor",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "class RgbColor:\n    def __init__(self, color_ref, color_nam='unknown'):\n        ver_py = sys.version_info.major\n        self.palette_val = {\n            13107199: 'blue',    # '#C7FFFF'\n            16777151: 'yellow',  # '#FFFFBF'\n            12582847: 'green',   # '#BFFFBF'\n            16760815: 'pink',    # '#FFBFEF'\n            16777215: 'none'     # '#FFFFFF'\n        }",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "UserCancelledError",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "class UserCancelledError(Exception):\n    pass\ndef from_hex(hex_sv):\n    return int(hex_sv, base=16)\ndef invert_dict(original_dict):\n    inverted_dict = {}\n    for key, value in original_dict.items():\n        if value not in inverted_dict:\n            inverted_dict[value] = []\n        inverted_dict[value].append(key)",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "from_hex",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def from_hex(hex_sv):\n    return int(hex_sv, base=16)\ndef invert_dict(original_dict):\n    inverted_dict = {}\n    for key, value in original_dict.items():\n        if value not in inverted_dict:\n            inverted_dict[value] = []\n        inverted_dict[value].append(key)\n    return inverted_dict\ndef add_prefix(func_name, func_pref, is_shadow=False):",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "invert_dict",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def invert_dict(original_dict):\n    inverted_dict = {}\n    for key, value in original_dict.items():\n        if value not in inverted_dict:\n            inverted_dict[value] = []\n        inverted_dict[value].append(key)\n    return inverted_dict\ndef add_prefix(func_name, func_pref, is_shadow=False):\n    dlim_vars = ['%', '_']\n    dlim_char = dlim_vars[int(is_shadow)]",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def add_prefix(func_name, func_pref, is_shadow=False):\n    dlim_vars = ['%', '_']\n    dlim_char = dlim_vars[int(is_shadow)]\n    pref_norm = func_pref.strip('_')\n    if is_shadow == False:\n        dlim_anti = dlim_vars[int(not is_shadow)] \n        if dlim_anti in pref_norm:\n            pref_norm = pref_norm.replace(dlim_anti, dlim_char)\n    func_name_new = '{}{}{}'.format(pref_norm, dlim_char, func_name)\n    return func_name_new",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "get_folder_tree",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def get_folder_tree(root_folder):\n    folder_structure = {}\n    for folder_name in os.listdir(root_folder):\n        folder_path = os.path.join(root_folder, folder_name)\n        if os.path.isdir(folder_path):\n            folder_structure[folder_name] = get_folder_tree(folder_path)\n        else:\n            folder_structure[folder_name] = \"file\"\n    return folder_structure\ndef get_ordered_folder_tree(root_folder):",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "get_ordered_folder_tree",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def get_ordered_folder_tree(root_folder):\n    return collections.OrderedDict(sorted(get_folder_tree(root_folder).items()))\ndef import_path(path):\n    strpath = str(path)\n    parent_path = os.path.dirname(os.path.abspath(path))\n    sys.path.append(parent_path)\n    module = __import__(os.path.basename(path))\n    sys.path.pop()\n    return module\ndef get_prog_val(base, range, part, whole):",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "import_path",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def import_path(path):\n    strpath = str(path)\n    parent_path = os.path.dirname(os.path.abspath(path))\n    sys.path.append(parent_path)\n    module = __import__(os.path.basename(path))\n    sys.path.pop()\n    return module\ndef get_prog_val(base, range, part, whole):\n    return base + int(range * (part / whole))",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "get_prog_val",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.plg_utils",
        "description": "plugins.IdaClu.idaclu.plg_utils",
        "peekOfCode": "def get_prog_val(base, range, part, whole):\n    return base + int(range * (part / whole))",
        "detail": "plugins.IdaClu.idaclu.plg_utils",
        "documentation": {}
    },
    {
        "label": "get_DescendingOrder",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_DescendingOrder():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.Qt.SortOrder.DescendingOrder\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.Qt.DescendingOrder\ndef get_Signal():\n    if is_ida and is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_Signal",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_Signal():\n    if is_ida and is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.Signal\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.pyqtSignal\ndef get_QAbstractItemModel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QAbstractItemModel",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QAbstractItemModel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QAbstractItemModel\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QAbstractItemModel\ndef get_QAbstractItemView():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QAbstractItemView",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QAbstractItemView():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QAbstractItemView\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QAbstractItemView\ndef get_QAction():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QAction",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QAction():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QAction\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QAction\ndef get_QApplication():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QApplication",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QApplication():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QApplication\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QApplication\ndef get_QBrush():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QBrush",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QBrush():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QBrush\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QBrush\ndef get_QByteArray():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QByteArray",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QByteArray():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QByteArray\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QByteArray\ndef get_QCheckBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QCheckBox",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QCheckBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QCheckBox\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QCheckBox\ndef get_QColor():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QColor",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QColor():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QColor\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QColor\ndef get_QComboBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QComboBox",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QComboBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QComboBox\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QComboBox\ndef get_QCompleter():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QCompleter",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QCompleter():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QCompleter\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QCompleter\ndef get_QCoreApplication():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QCoreApplication",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QCoreApplication():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QCoreApplication\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QCoreApplication\ndef get_QCursor():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QCursor",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QCursor():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QCursor\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QCursor\ndef get_QDialog():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QDialog",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QDialog():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QDialog\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QDialog\ndef get_QEvent():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QEvent",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QEvent():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QEvent\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QEvent\ndef get_QFont():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QFont",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QFont():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QFont\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QFont\ndef get_QFrame():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QFrame",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QFrame():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QFrame\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QFrame\ndef get_QGroupBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QGroupBox",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QGroupBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QGroupBox\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QGroupBox\ndef get_QHeaderView():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QHeaderView",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QHeaderView():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QHeaderView\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QHeaderView\ndef get_QHBoxLayout():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QHBoxLayout",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QHBoxLayout():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QHBoxLayout\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QHBoxLayout\ndef get_QIcon():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QIcon",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QIcon():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QIcon\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QIcon\ndef get_QImage():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QImage",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QImage():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QImage\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QImage\ndef get_QLabel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QLabel",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QLabel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QLabel\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QLabel\ndef get_QLineEdit():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QLineEdit",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QLineEdit():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QLineEdit\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QLineEdit\ndef get_QMainWindow():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QMainWindow",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QMainWindow():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QMainWindow\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QMainWindow\ndef get_QMenu():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QMenu",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QMenu():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QMenu\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QMenu\ndef get_QMessageBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QMessageBox",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QMessageBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QMessageBox\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QMessageBox\ndef get_QMetaObject():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QMetaObject",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QMetaObject():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QMetaObject\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QMetaObject\ndef get_QModelIndex():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QModelIndex",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QModelIndex():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QModelIndex\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QModelIndex\ndef get_QPainter():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QPainter",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QPainter():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QPainter\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QPainter\ndef get_QPixmap():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QPixmap",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QPixmap():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QPixmap\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QPixmap\ndef get_QPoint():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QPoint",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QPoint():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QPoint\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QPoint\ndef get_QPointF():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QPointF",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QPointF():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QPointF\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QPointF\ndef get_QProgressBar():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QProgressBar",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QProgressBar():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QProgressBar\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QProgressBar\ndef get_QPushButton():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QPushButton",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QPushButton():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QPushButton\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QPushButton\ndef get_QRadioButton():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QRadioButton",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QRadioButton():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QRadioButton\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QRadioButton\ndef get_QRect():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QRect",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QRect():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QRect\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QRect\ndef get_QScrollArea():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QScrollArea",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QScrollArea():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QScrollArea\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QScrollArea\ndef get_QSize():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QSize",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QSize():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QSize\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QSize\ndef get_QSizePolicy():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QSizePolicy",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QSizePolicy():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QSizePolicy\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QSizePolicy\ndef get_QSortFilterProxyModel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QSortFilterProxyModel",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QSortFilterProxyModel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QSortFilterProxyModel\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QSortFilterProxyModel\ndef get_QSlider():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QSlider",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QSlider():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QSlider\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QSlider\ndef get_QSpacerItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QSpacerItem",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QSpacerItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QSpacerItem\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QSpacerItem\ndef get_QSplitter():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QSplitter",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QSplitter():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QSplitter\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QSplitter\ndef get_QStandardItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStandardItem",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStandardItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStandardItem\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui.QStandardItem\ndef get_QStringListModel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStringListModel",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStringListModel():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStringListModel\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QStringListModel\ndef get_QStyle():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStyle",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStyle():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStyle\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QStyle\ndef get_QStyledItemDelegate():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStyledItemDelegate",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStyledItemDelegate():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStyledItemDelegate\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QStyledItemDelegate\ndef get_QStyleFactory():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStyleFactory",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStyleFactory():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStyleFactory\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QStyleFactory\ndef get_QStyleOptionComboBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStyleOptionComboBox",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStyleOptionComboBox():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStyleOptionComboBox\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QStyleOptionComboBox\ndef get_QStyleOptionSlider():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QStyleOptionSlider",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QStyleOptionSlider():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QStyleOptionSlider\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QStyleOptionSlider\ndef get_Qt():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_Qt",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_Qt():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.Qt\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.Qt\ndef get_QTableWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTableWidget",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTableWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTableWidget\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTableWidget\ndef get_QTableWidgetItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTableWidgetItem",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTableWidgetItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTableWidgetItem\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTableWidgetItem\ndef get_QTabWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTabWidget",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTabWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTabWidget\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTabWidget\ndef get_QtCore():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QtCore",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QtCore():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore\ndef get_QTextBrowser():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTextBrowser",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTextBrowser():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTextBrowser\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTextBrowser\ndef get_QTextEdit():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTextEdit",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTextEdit():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTextEdit\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTextEdit\ndef get_QtGui():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QtGui",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QtGui():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui\n    else:\n        import PyQt5.QtGui as QtGui\n        return QtGui\ndef get_QThread():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QThread",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QThread():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QThread\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QThread\ndef get_QTranslator():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTranslator",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTranslator():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.QTranslator\n    else:\n        import PyQt5.QtCore as QtCore\n        return QtCore.QTranslator\ndef get_QTreeView():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTreeView",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTreeView():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTreeView\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTreeView\ndef get_QTreeWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTreeWidget",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTreeWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTreeWidget\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTreeWidget\ndef get_QTreeWidgetItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QTreeWidgetItem",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QTreeWidgetItem():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QTreeWidgetItem\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QTreeWidgetItem\ndef get_QtWidgets():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        return None",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QtWidgets",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QtWidgets():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        return None\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets\ndef get_QVBoxLayout():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QVBoxLayout",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QVBoxLayout",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QVBoxLayout():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QVBoxLayout\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QVBoxLayout\ndef get_QWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "get_QWidget",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "def get_QWidget():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtGui as QtGui\n        return QtGui.QWidget\n    else:\n        import PyQt5.QtWidgets as QtWidgets\n        return QtWidgets.QWidget\nDescendingOrder = get_DescendingOrder()\nSignal = get_Signal()\nQAbstractItemModel = get_QAbstractItemModel()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "is_ida",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "is_ida = True\ntry:\n    import idaapi\nexcept ImportError:\n    is_ida = False\ndef get_DescendingOrder():\n    if is_ida and idaapi.IDA_SDK_VERSION <= 680:\n        import PySide.QtCore as QtCore\n        return QtCore.Qt.SortOrder.DescendingOrder\n    else:",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "DescendingOrder",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "DescendingOrder = get_DescendingOrder()\nSignal = get_Signal()\nQAbstractItemModel = get_QAbstractItemModel()\nQAbstractItemView = get_QAbstractItemView()\nQAction = get_QAction()\nQApplication = get_QApplication()\nQBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Signal",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "Signal = get_Signal()\nQAbstractItemModel = get_QAbstractItemModel()\nQAbstractItemView = get_QAbstractItemView()\nQAction = get_QAction()\nQApplication = get_QApplication()\nQBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QAbstractItemModel",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QAbstractItemModel = get_QAbstractItemModel()\nQAbstractItemView = get_QAbstractItemView()\nQAction = get_QAction()\nQApplication = get_QApplication()\nQBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QAbstractItemView",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QAbstractItemView = get_QAbstractItemView()\nQAction = get_QAction()\nQApplication = get_QApplication()\nQBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QAction",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QAction = get_QAction()\nQApplication = get_QApplication()\nQBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QApplication = get_QApplication()\nQBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QBrush = get_QBrush()\nQByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QByteArray",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QByteArray = get_QByteArray()\nQCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCheckBox",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QCheckBox = get_QCheckBox()\nQColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QColor",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QColor = get_QColor()\nQComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QComboBox",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QComboBox = get_QComboBox()\nQCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCompleter",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QCompleter = get_QCompleter()\nQCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCoreApplication",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QCoreApplication = get_QCoreApplication()\nQCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QCursor",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QCursor = get_QCursor()\nQDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QDialog",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QDialog = get_QDialog()\nQEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QEvent",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QEvent = get_QEvent()\nQFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFont",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QFont = get_QFont()\nQFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QFrame",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QFrame = get_QFrame()\nQGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QGroupBox",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QGroupBox = get_QGroupBox()\nQHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QHeaderView",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QHeaderView = get_QHeaderView()\nQHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QHBoxLayout = get_QHBoxLayout()\nQIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QIcon = get_QIcon()\nQImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QImage",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QImage = get_QImage()\nQLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QLabel",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QLabel = get_QLabel()\nQLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QLineEdit",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QLineEdit = get_QLineEdit()\nQMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QMainWindow = get_QMainWindow()\nQMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QMenu = get_QMenu()\nQMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMessageBox",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QMessageBox = get_QMessageBox()\nQMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QMetaObject",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QMetaObject = get_QMetaObject()\nQModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QModelIndex = get_QModelIndex()\nQPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPainter",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QPainter = get_QPainter()\nQPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QPixmap = get_QPixmap()\nQPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPoint",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QPoint = get_QPoint()\nQPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPointF",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QPointF = get_QPointF()\nQProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QProgressBar",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QProgressBar = get_QProgressBar()\nQPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QPushButton = get_QPushButton()\nQRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QRadioButton",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QRadioButton = get_QRadioButton()\nQRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QRect",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QRect = get_QRect()\nQScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QScrollArea",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QScrollArea = get_QScrollArea()\nQSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSize",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QSize = get_QSize()\nQSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QSizePolicy = get_QSizePolicy()\nQSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSortFilterProxyModel",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QSortFilterProxyModel = get_QSortFilterProxyModel()\nQSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSlider",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QSlider = get_QSlider()\nQSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSpacerItem",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QSpacerItem = get_QSpacerItem()\nQSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QSplitter",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QSplitter = get_QSplitter()\nQStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStandardItem",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStandardItem = get_QStandardItem()\nQStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStringListModel",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStringListModel = get_QStringListModel()\nQStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyle",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStyle = get_QStyle()\nQStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyledItemDelegate",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStyledItemDelegate = get_QStyledItemDelegate()\nQStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyleFactory",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStyleFactory = get_QStyleFactory()\nQStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyleOptionComboBox",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStyleOptionComboBox = get_QStyleOptionComboBox()\nQStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QStyleOptionSlider",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QStyleOptionSlider = get_QStyleOptionSlider()\nQt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "Qt",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "Qt = get_Qt()\nQTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTableWidget",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTableWidget = get_QTableWidget()\nQTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTableWidgetItem",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTableWidgetItem = get_QTableWidgetItem()\nQTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTabWidget",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTabWidget = get_QTabWidget()\nQtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QtCore = get_QtCore()\nQTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTextBrowser",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTextBrowser = get_QTextBrowser()\nQTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTextEdit",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTextEdit = get_QTextEdit()\nQtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QtGui = get_QtGui()\nQThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QThread",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QThread = get_QThread()\nQTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTranslator",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTranslator = get_QTranslator()\nQTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTreeView",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTreeView = get_QTreeView()\nQTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTreeWidget",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTreeWidget = get_QTreeWidget()\nQTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QTreeWidgetItem",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QTreeWidgetItem = get_QTreeWidgetItem()\nQtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QtWidgets = get_QtWidgets()\nQVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QVBoxLayout = get_QVBoxLayout()\nQWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu.qt_shims",
        "description": "plugins.IdaClu.idaclu.qt_shims",
        "peekOfCode": "QWidget = get_QWidget()",
        "detail": "plugins.IdaClu.idaclu.qt_shims",
        "documentation": {}
    },
    {
        "label": "i18n",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu.qt_utils",
        "description": "plugins.IdaClu.idaclu.qt_utils",
        "peekOfCode": "def i18n(text, context=\"PluginDialog\"):\n    return QCoreApplication.translate(context, text)",
        "detail": "plugins.IdaClu.idaclu.qt_utils",
        "documentation": {}
    },
    {
        "label": "LabelTool",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class LabelTool(QWidget):\n    PREFIX = 0\n    FOLDER = 1\n    def __init__(self, name, env_desc, parent=None):\n        super(LabelTool, self).__init__(parent)\n        self.env_desc = env_desc\n        self.label_mode = LabelTool.PREFIX\n        self.data = [\n            {'caption': i18n('PREFIX'), 'pholder': i18n('Insert name')},\n            {'caption': i18n('FOLDER'), 'pholder': i18n('Insert name')}",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ProgressIndicator",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class ProgressIndicator(QWidget):\n    def __init__(self, parent=None):\n        super(ProgressIndicator, self).__init__(parent)\n        layout = QVBoxLayout()\n        layout.addWidget(self.initProgressBar(parent))\n        layout.setContentsMargins(0, 0, 0, 0)\n        self.setLayout(layout)\n        self._update_step = 2\n        self.reset()\n        self._worker = Worker()",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ToolButton",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class ToolButton(QPushButton):\n    def __init__(self, name=None, size=(30, 30), parent=None):\n        QPushButton.__init__(self, parent=parent)\n        if name:\n            self.setObjectName(name)\n        self.setMinimumSize(QSize(*size))\n        self.setMaximumSize(QSize(*size))\n        self.setCursor(QCursor(Qt.PointingHandCursor))\nclass ColorButton(ToolButton):\n    def __init__(self, name, size=(30, 30), parent=None):",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ColorButton",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class ColorButton(ToolButton):\n    def __init__(self, name, size=(30, 30), parent=None):\n        ToolButton.__init__(self, name=name, parent=parent)\n        self.setCheckable(True)\nclass Worker(QThread):\n    updateProgress = Signal(int)\n    def __init__(self):\n        QThread.__init__(self)\n    def run(self):\n        for i in range(1, 101):",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "Worker",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class Worker(QThread):\n    updateProgress = Signal(int)\n    def __init__(self):\n        QThread.__init__(self)\n    def run(self):\n        for i in range(1, 101):\n            self.updateProgress.emit(i)\n            # time.sleep(0.01)\nclass PaletteTool(QWidget):\n    COLOR_NAME = 0",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "PaletteTool",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class PaletteTool(QWidget):\n    COLOR_NAME = 0\n    COLOR_VAL = 1\n    def __init__(self, name, size, pref, is_enbl=True, is_excl=True, parent=None):\n        super(PaletteTool, self).__init__(parent)\n        self.colors = [\n            (\"yellow\", (255,255,191)),\n            (\"blue\", (199,255,255)),\n            (\"green\", (191,255,191)),\n            (\"pink\", (255,191,239)),",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "FilterInputGroup",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class FilterInputGroup(QWidget):\n    def __init__(self, names, pholder, env_desc, parent=None):\n        super(FilterInputGroup, self).__init__(parent)\n        self._items = OrderedDict()\n        self.env_desc = env_desc\n        is_unicode = isinstance(names, basestring) if env_desc.ver_py == 2 else isinstance(names, str)\n        if is_unicode:\n            self._has_state = False\n            names = [names]\n        elif isinstance(names, list) and len(names) == 2:",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "CheckableComboBox",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class CheckableComboBox(QComboBox):\n    def __init__(self):\n        super(CheckableComboBox, self).__init__()\n        self.setEditable(True)\n        self.lineEdit().setReadOnly(True)\n        self.closeOnLineEditClick = False\n        self.lineEdit().installEventFilter(self)\n        self.view().viewport().installEventFilter(self)\n        self.model().dataChanged.connect(self.updateLineEditField)\n        self.itemDelegate = QStyledItemDelegate(self)",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "FrameLayout",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class FrameLayout(QWidget):\n    def __init__(self, parent=None, title=None, env=None):\n        self.env_desc = env\n        QWidget.__init__(self, parent=parent)\n        self._is_collasped = True\n        self._title_frame = None\n        self._content, self._content_layout = (None, None)\n        title_frame = self.initTitleFrame(title, self._is_collasped)\n        content_widget = self.initContent(self._is_collasped)\n        self._main_v_layout = QVBoxLayout(self)",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "FilterHeader",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class FilterHeader(QHeaderView):\n    filterChanged = Signal(int)\n    def __init__(self, parent):\n        super().__init__(Qt.Horizontal, parent)\n        self._editors = []\n        self._padding = 4\n        self.filters_visible = False  # Initialize filters_visible\n        self.setStretchLastSection(True)\n        self.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)\n        self.setSortIndicatorShown(False)",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "FilterProxyModel",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class FilterProxyModel(QSortFilterProxyModel):\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setDynamicSortFilter(True)\n        self.filter_texts = {}\n    def setFilterText(self, index, text):\n        self.filter_texts[index] = text.lower()\n        self.invalidateFilter()\n    def filterAcceptsRow(self, source_row, source_parent):\n        model = self.sourceModel()",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "CluTreeView",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class CluTreeView(QTreeView):\n    def __init__(self, env_desc, parent=None):\n        QTreeView.__init__(self, parent=parent)\n        self.setSortingEnabled(True)\n        self.setAlternatingRowColors(True)\n        self.setObjectName(u\"rvTable\")\n        self.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.setEditTriggers(QAbstractItemView.NoEditTriggers)\n        self.setSelectionMode(QAbstractItemView.ExtendedSelection)\n        self.expanded.connect(self.save_expanded_state)",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "ConfigTool",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.qt_widgets",
        "description": "plugins.IdaClu.idaclu.qt_widgets",
        "peekOfCode": "class ConfigTool(QWidget):\n    def __init__(self, parent=None, env=None):\n        QWidget.__init__(self, parent=parent)\n        self.env = env\n        self.is_save = False\n        layout = self.genLayout()\n        self.setLayout(layout)\n        self.setMinimumSize(QSize(32, 30))\n        self.setMaximumSize(QSize(16777215, 30))\n        self._saveBtn.clicked.connect(self.toggleSave)",
        "detail": "plugins.IdaClu.idaclu.qt_widgets",
        "documentation": {}
    },
    {
        "label": "Ui_PluginDialog",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu.ui_idaclu",
        "description": "plugins.IdaClu.idaclu.ui_idaclu",
        "peekOfCode": "class Ui_PluginDialog(object):\n    def __init__(self, env_desc):\n        self.env_desc = env_desc\n    def setupUi(self, PluginDialog):\n        if not PluginDialog.objectName():\n            PluginDialog.setObjectName(u\"PluginDialog\")\n        PluginDialog.resize(1024, 600)\n        icon = QIcon()\n        icon.addFile(u\":/idaclu/icon_64.png\", QSize(), QIcon.Normal, QIcon.Off)\n        PluginDialog.setWindowIcon(icon)",
        "detail": "plugins.IdaClu.idaclu.ui_idaclu",
        "documentation": {}
    },
    {
        "label": "ScriptEnv",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "class ScriptEnv():\n    def __init__(self, is_ida, lib_qt):\n        # generic environment\n        self.is_ida = is_ida\n        self.lib_qt = lib_qt\n        self.run_mode = 'script'\n        self.dir_script = SCRIPT_DIR\n        self.ver_py = sys.version_info[0]\n        # ida-specific environment\n        self.detectEnv()",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "IdaCluForm",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "class IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc\n        self.icon = QIcon(':/idaclu/icon_64.png')\n        self.qss = os.path.join(SCRIPT_DIR, 'idaclu', 'assets', 'style.qss')\n    def OnCreate(self, form):\n        self.env_desc.dump(True)\n        app = QCoreApplication\n        translator = QTranslator()",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "IdaCluPlugin",
        "kind": 6,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "class IdaCluPlugin(plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"Function Clusterization Tool\"\n    help = \"Edit->Plugin->IdaClu or {}.\".format(PLUGIN_HOTKEY)\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_HOTKEY\n    def init(self):\n        super(IdaCluPlugin, self).__init__()\n        self.icon_id = 0\n        ida_shims.msg(\"%s %s loaded\\n\" % (self.wanted_name, PLUGIN_VERSION))",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "common_init",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "def common_init():\n    env_desc = ScriptEnv(is_ida, lib_qt)\n    return env_desc\n__AUTHOR__ = \"Sergejs 'HRLM' Harlamovs\"\nPLUGIN_NAME = \"IdaClu\"\nPLUGIN_HOTKEY = 'Ctrl+Alt+O'\nPLUGIN_VERSION = '1.1'\nPLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)\nPLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "open_form",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "def open_form(env_desc):\n    if env_desc.is_ida:\n        f = IdaCluForm(env_desc)\n        f.Show('IdaClu')\ndef PLUGIN_ENTRY():\n    return IdaCluPlugin()\nclass IdaCluPlugin(plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"Function Clusterization Tool\"\n    help = \"Edit->Plugin->IdaClu or {}.\".format(PLUGIN_HOTKEY)",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return IdaCluPlugin()\nclass IdaCluPlugin(plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"Function Clusterization Tool\"\n    help = \"Edit->Plugin->IdaClu or {}.\".format(PLUGIN_HOTKEY)\n    wanted_name = PLUGIN_NAME\n    wanted_hotkey = PLUGIN_HOTKEY\n    def init(self):\n        super(IdaCluPlugin, self).__init__()",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "def main(env_desc):\n    env_desc.dump(True)\n    if env_desc.is_ida:\n        open_form(env_desc)\n    else:\n        app = QtWidgets.QApplication(sys.argv) if not is_ida else None\n        if app:\n            sys.exit(app.exec_())\nif __name__ == \"__main__\":\n    env_desc = common_init()",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "lib_qt",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "lib_qt = None\ntry:\n    from PyQt5 import QtCore, QtGui, QtWidgets\n    lib_qt = \"pyqt5\"\nexcept ImportError:\n    try:\n        from PySide import QtCore, QtGui\n        from PySide import QtGui as QtWidgets\n        lib_qt = \"pyside\"\n    except ImportError:",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\nfor i, path in enumerate(sys.path):\n    if \"IDA\" in path and os.path.basename(path) == 'plugins':\n        sys.path.insert(i, SCRIPT_DIR)\n        break\nis_ida = True\ntry:  # almost version-agnostic imports\n    import idc\n    import idaapi\n    from idaapi import plugin_t, PluginForm",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "is_ida",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "is_ida = True\ntry:  # almost version-agnostic imports\n    import idc\n    import idaapi\n    from idaapi import plugin_t, PluginForm\n    from idaclu import ida_shims\nexcept ImportError:\n    is_ida = False\n    # standalone-run caps\n    class plugin_t:",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "__AUTHOR__",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "__AUTHOR__ = \"Sergejs 'HRLM' Harlamovs\"\nPLUGIN_NAME = \"IdaClu\"\nPLUGIN_HOTKEY = 'Ctrl+Alt+O'\nPLUGIN_VERSION = '1.1'\nPLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)\nPLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "PLUGIN_NAME = \"IdaClu\"\nPLUGIN_HOTKEY = 'Ctrl+Alt+O'\nPLUGIN_VERSION = '1.1'\nPLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)\nPLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HOTKEY",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "PLUGIN_HOTKEY = 'Ctrl+Alt+O'\nPLUGIN_VERSION = '1.1'\nPLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)\nPLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc\n        self.icon = QIcon(':/idaclu/icon_64.png')",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_VERSION",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "PLUGIN_VERSION = '1.1'\nPLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)\nPLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc\n        self.icon = QIcon(':/idaclu/icon_64.png')\n        self.qss = os.path.join(SCRIPT_DIR, 'idaclu', 'assets', 'style.qss')",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_TITLE",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "PLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)\nPLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc\n        self.icon = QIcon(':/idaclu/icon_64.png')\n        self.qss = os.path.join(SCRIPT_DIR, 'idaclu', 'assets', 'style.qss')\n    def OnCreate(self, form):",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_URL",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "PLUGIN_URL = \"https://github.com/harlamism/IdaClu\"\nPLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc\n        self.icon = QIcon(':/idaclu/icon_64.png')\n        self.qss = os.path.join(SCRIPT_DIR, 'idaclu', 'assets', 'style.qss')\n    def OnCreate(self, form):\n        self.env_desc.dump(True)",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_INFO",
        "kind": 5,
        "importPath": "plugins.IdaClu.idaclu",
        "description": "plugins.IdaClu.idaclu",
        "peekOfCode": "PLUGIN_INFO = 'For usage see: <a href=\"{0}\">{0}</a>'.format(PLUGIN_URL)\nclass IdaCluForm(PluginForm):\n    def __init__(self, env_desc):\n        super(IdaCluForm, self).__init__()\n        self.env_desc = env_desc\n        self.icon = QIcon(':/idaclu/icon_64.png')\n        self.qss = os.path.join(SCRIPT_DIR, 'idaclu', 'assets', 'style.qss')\n    def OnCreate(self, form):\n        self.env_desc.dump(True)\n        app = QCoreApplication",
        "detail": "plugins.IdaClu.idaclu",
        "documentation": {}
    },
    {
        "label": "Keypatch_Asm",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Keypatch_Asm:\n    # supported architectures\n    arch_lists = {\n        \"X86 16-bit\": (KS_ARCH_X86, KS_MODE_16),                # X86 16-bit\n        \"X86 32-bit\": (KS_ARCH_X86, KS_MODE_32),                # X86 32-bit\n        \"X86 64-bit\": (KS_ARCH_X86, KS_MODE_64),                # X86 64-bit\n        \"ARM\": (KS_ARCH_ARM, KS_MODE_ARM),                      # ARM\n        \"ARM Thumb\": (KS_ARCH_ARM, KS_MODE_THUMB),              # ARM Thumb\n        \"ARM64 (ARMV8)\": (KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN),# ARM64\n        \"Hexagon\": (KS_ARCH_HEXAGON, KS_MODE_BIG_ENDIAN),       # Hexagon",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Form",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Keypatch_Form(idaapi.Form):\n    # prepare for form initializing\n    def setup(self, kp_asm, address, assembly=None):\n        self.kp_asm = kp_asm\n        self.address = address\n        # update ordered list of arch and syntax\n        self.syntax_keys = self.kp_asm.dict_to_ordered_list(self.kp_asm.syntax_lists)[0]\n        self.arch_keys = self.kp_asm.dict_to_ordered_list(self.kp_asm.arch_lists)[0]\n        # update current arch & mode\n        self.kp_asm.update_hardware_mode()",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_FillRange",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Keypatch_FillRange(Keypatch_Form):\n    def __init__(self, kp_asm, addr_begin, addr_end, assembly=None, opts=None):\n        self.setup(kp_asm, addr_begin, assembly)\n        self.addr_end = addr_end\n        # create FillRange form\n        super(Keypatch_FillRange, self).__init__(\n            r\"\"\"STARTITEM {id:c_assembly}\nBUTTON YES* Patch\nKEYPATCH:: Fill Range\n            {FormChangeCb}",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Patcher",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Keypatch_Patcher(Keypatch_Form):\n    def __init__(self, kp_asm, address, assembly=None, opts=None):\n        self.setup(kp_asm, address, assembly)\n        # create Patcher form\n        super(Keypatch_Patcher, self).__init__(\n            r\"\"\"STARTITEM {id:c_assembly}\nBUTTON YES* Patch\nKEYPATCH:: Patcher\n            {FormChangeCb}\n            <Endian     :{c_endian}>",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "SearchResultChooser",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class SearchResultChooser(Choose):\n    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):\n        super(SearchResultChooser, self).__init__(\n            title,\n            [[\"Address\", Choose.CHCOL_HEX|40]],\n            flags = flags,\n            width = width,\n            height = height,\n            embedded = embedded)\n        self.n = 0",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Search",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Keypatch_Search(Keypatch_Form):\n    def __init__(self, kp_asm, address, assembly=None):\n        self.setup(kp_asm, address, assembly)\n        # create Search form\n        super(Keypatch_Search, self).__init__(\n            r\"\"\"STARTITEM {id:c_assembly}\nBUTTON YES* Search\nKEYPATCH:: Search\n            {FormChangeCb}\n            <A~r~ch       :{c_arch}>",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "About_Form",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class About_Form(idaapi.Form):\n    def __init__(self, version):\n        # create About form\n        super(About_Form, self).__init__(\n            r\"\"\"STARTITEM 0\nBUTTON YES* Open Keypatch Website\nKEYPATCH:: About\n            {FormChangeCb}\n            Keypatch IDA plugin v%s, using Keystone Engine v%s.\n            (c) Nguyen Anh Quynh + Thanh Nguyen, 2018.",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Update_Form",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Update_Form(idaapi.Form):\n    def __init__(self, version, message):\n        # create Update form\n        super(Update_Form, self).__init__(\n            r\"\"\"STARTITEM 0\nBUTTON YES* Open Keypatch Website\nKEYPATCH:: Check for update\n            {FormChangeCb}\n            Your Keypatch is v%s\n            %s",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        # IDA >= 700 right click widget popup\n        def finish_populating_widget_popup(self, form, popup):\n            if idaapi.get_widget_type(form) == idaapi.BWN_DISASM:\n                try:\n                    idaapi.attach_action_to_popup(form, popup, Kp_MC_Patcher.get_name(), 'Keypatch/')\n                    idaapi.attach_action_to_popup(form, popup, Kp_MC_Fill_Range.get_name(), 'Keypatch/')\n                    idaapi.attach_action_to_popup(form, popup, Kp_MC_Undo.get_name(), 'Keypatch/')\n                    idaapi.attach_action_to_popup(form, popup, \"-\", 'Keypatch/')",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "Keypatch_Plugin_t",
        "kind": 6,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "class Keypatch_Plugin_t(idaapi.plugin_t):\n    comment = \"Keypatch plugin for IDA Pro (using Keystone framework)\"\n    help = \"Find more information on Keypatch at http://keystone-engine.org/keypatch\"\n    wanted_name = \"Keypatch Patcher\"\n    wanted_hotkey = \"Ctrl-Alt-K\"\n    flags = idaapi.PLUGIN_KEEP\n    def load_configuration(self):\n        # default\n        self.opts = {}\n        # load configuration from file",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "to_string",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):\n      return s.decode('latin-1')\n  # python2 unicode\n  elif six.PY2 and isinstance(s, six.text_type):\n      return s.encode('utf-8')\n  return str(s)\ndef to_hexstr(buf, sep=' '):\n    # for python3 bytes",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "to_hexstr",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def to_hexstr(buf, sep=' '):\n    # for python3 bytes\n    if six.PY3 and isinstance(buf, bytes):\n        return sep.join(\"{0:02x}\".format(c) for c in buf).upper()\n    return sep.join(\"{0:02x}\".format(ord(c)) for c in buf).upper()\n#########################################################################################################\n################################ IDA 6/7 Compatibility function #########################################\ndef get_dtype(ea, op_idx):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        insn = idaapi.insn_t()",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "get_dtype",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def get_dtype(ea, op_idx):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        insn = idaapi.insn_t()\n        idaapi.decode_insn(insn, ea)\n        dtype = insn.ops[op_idx].dtype\n        dtyp_size = idaapi.get_dtype_size(dtype)\n    else:\n        dtype = idaapi.cmd.Operands[op_idx].dtyp\n        dtyp_size = idaapi.get_dtyp_size(dtype)\n    return dtype, dtyp_size",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "set_comment",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def set_comment(ea, comment):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        idc.set_cmt(ea, comment, 0)\n    else:\n        idc.MakeComm(ea, comment)\ndef get_comment(ea):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idc.get_cmt(ea, 0)\n    return idc.Comment(ea)\ndef read_range_selection():",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "get_comment",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def get_comment(ea):\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idc.get_cmt(ea, 0)\n    return idc.Comment(ea)\ndef read_range_selection():\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idaapi.read_range_selection(None)\n    return idaapi.read_selection()\n#########################################################################################################\n# return a normalized code, or None if input is invalid",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "read_range_selection",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def read_range_selection():\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idaapi.read_range_selection(None)\n    return idaapi.read_selection()\n#########################################################################################################\n# return a normalized code, or None if input is invalid\ndef convert_hexstr(code):\n    # normalize code\n    code = code.lower()\n    code = code.replace(' ', '')    # remove space",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "convert_hexstr",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def convert_hexstr(code):\n    # normalize code\n    code = code.lower()\n    code = code.replace(' ', '')    # remove space\n    code = code.replace('h', '')    # remove trailing 'h' in 90h\n    code = code.replace('0x', '')   # remove 0x\n    code = code.replace('\\\\x', '')  # remove \\x\n    code = code.replace(',', '')    # remove ,\n    code = code.replace(';', '')    # remove ;\n    code = code.replace('\"', '')    # remove \"",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "url_download",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def url_download(url):\n    # Import for python2\n    try:\n        from urllib2 import Request, urlopen, URLError, HTTPError\n    except:\n        from urllib.request import Request, urlopen\n        from urllib.error import URLError, HTTPError\n    # create the url and the request\n    req = Request(url)\n    # Open the url",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "get_name_value",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def get_name_value(_from, name):\n    \"\"\"\n    Fixed: the return value truncated(32 bit) of get_name_value function that analyzed 64 bit binary file about ida64 for win.\n    eg:\n    type == idaapi.NT_BYTE\n    (type, value) = idaapi.get_name_value(idc.BADADDR, \"wcschr\") # ida64 for win\n    value = 0x14003d3f0L is correct  ida64 > 7.x for macOS\n    value = 0x4003d3f0L is truncated ida64 >= 6.x for win, ida64 == 6.x for macOS\n    :param _from: ea\n    :param name: name string",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return Keypatch_Plugin_t()",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "is_debug",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "is_debug = False\nif is_debug:\n    ''' \n        Install pydevd:\n        1. sudo pip install pydevd\n        or\n        2. Install pycharm-debug.egg, Ensure to use pycharm pro\n        https://www.jetbrains.com/help/pycharm/remote-debugging-with-product.html\n        # import site\n        # site.addsitedir(\"/usr/local/lib/python2.7/site-packages\")",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "VERSION = \"2.2\"\nMAX_INSTRUCTION_STRLEN = 256\nMAX_ENCODING_LEN = 40\nMAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "MAX_INSTRUCTION_STRLEN",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "MAX_INSTRUCTION_STRLEN = 256\nMAX_ENCODING_LEN = 40\nMAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "MAX_ENCODING_LEN",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "MAX_ENCODING_LEN = 40\nMAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "MAX_ADDRESS_LEN",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "MAX_ADDRESS_LEN = 40\nENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "ENCODING_ERR_OUTPUT",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "ENCODING_ERR_OUTPUT = \"...\"\nKP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "KP_GITHUB_VERSION",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "KP_GITHUB_VERSION = \"https://raw.githubusercontent.com/keystone-engine/keypatch/master/VERSION_STABLE\"\nKP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "KP_HOMEPAGE",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "KP_HOMEPAGE = \"http://keystone-engine.org/keypatch\"\nX86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "X86_NOP",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "X86_NOP = \"\\x90\"\n# Configuration file\nKP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "KP_CFGFILE",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "KP_CFGFILE = os.path.join(idaapi.get_user_idadir(), \"keypatch.cfg\")\n# save all the info on patching\npatch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):\n      return s.decode('latin-1')\n  # python2 unicode",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "patch_info",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "patch_info = []\n################################ Python2/3 Compatibility function #######################################\n# Convert unicode/string/bytes to string\ndef to_string(s):\n  # python3 bytes\n  if six.PY3 and isinstance(s, bytes):\n      return s.decode('latin-1')\n  # python2 unicode\n  elif six.PY2 and isinstance(s, six.text_type):\n      return s.encode('utf-8')",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "kp_initialized",
        "kind": 5,
        "importPath": "plugins.keypatch.keypatch",
        "description": "plugins.keypatch.keypatch",
        "peekOfCode": "kp_initialized = False\n#--------------------------------------------------------------------------\n# Plugin\n#--------------------------------------------------------------------------\nclass Keypatch_Plugin_t(idaapi.plugin_t):\n    comment = \"Keypatch plugin for IDA Pro (using Keystone framework)\"\n    help = \"Find more information on Keypatch at http://keystone-engine.org/keypatch\"\n    wanted_name = \"Keypatch Patcher\"\n    wanted_hotkey = \"Ctrl-Alt-K\"\n    flags = idaapi.PLUGIN_KEEP",
        "detail": "plugins.keypatch.keypatch",
        "documentation": {}
    },
    {
        "label": "MemcpyLocation",
        "kind": 6,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "class MemcpyLocation():\n    \"\"\"Internal data that's represented by IDA's listview (Wchooser\")\n    \"\"\"\n    def __init__(self, ea, name, dst, src, n, dst_type, n_max, problems):\n        self.ea = ea\n        self.name = name\n        self.dst = dst\n        self.src = src\n        self.n = n\n        self.dst_type = dst_type",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "MrsPickyListView",
        "kind": 6,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "class MrsPickyListView(idaapi.Choose):\n    \"\"\"Listview that displays results to the user\n    \"\"\"\n    def __init__(self, title, flags=0, width=None, height=None, embedded=False, modal=False):\n        idaapi.Choose.__init__(\n            self,\n            title,\n            [ [\"caller\", 20 | idaapi.CHCOL_FNAME],\n            [\"function\", 8 | idaapi.CHCOL_FNAME],\n            [\"dst\", 8],",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "func_parser_t",
        "kind": 6,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "class func_parser_t(idaapi.ctree_visitor_t):\n    def __init__(self, cfunc):\n        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_FAST)\n        self.cfunc = cfunc\n        self.data = []\n        return\n    # for every expression / cexpr_t of the AST\n    def visit_expr(self, e):\n        # if expression type is call\n        if e.op == idaapi.cot_call:",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "is_min_sdk_ver",
        "kind": 2,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "def is_min_sdk_ver(min_ver_required):\n    return idaapi.IDA_SDK_VERSION >= min_ver_required\n# -----------------------------------------------------------------------------\ndef get_callers(name):\n    for xr in idautils.CodeRefsTo(idaapi.get_name_ea(idaapi.BADADDR, name), True):\n        fn = idaapi.get_func(xr)\n        if fn:\n            yield fn.start_ea\n# -----------------------------------------------------------------------------\ndef run_script():",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "get_callers",
        "kind": 2,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "def get_callers(name):\n    for xr in idautils.CodeRefsTo(idaapi.get_name_ea(idaapi.BADADDR, name), True):\n        fn = idaapi.get_func(xr)\n        if fn:\n            yield fn.start_ea\n# -----------------------------------------------------------------------------\ndef run_script():\n    if not idaapi.init_hexrays_plugin():\n        idaapi.msg(\"This script requires the HexRays decompiler plugin.\")\n    else:",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "run_script",
        "kind": 2,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "def run_script():\n    if not idaapi.init_hexrays_plugin():\n        idaapi.msg(\"This script requires the HexRays decompiler plugin.\")\n    else:\n        func_list = []\n        for name in MEMCPY_FAM:\n            func_list += get_callers(name)\n        func_list = set(func_list)\n        nfuncs = len(func_list)\n        idaapi.msg(\"Checking %d functions.\" % (nfuncs))",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "__author__ = \"Dennis Elser\"\nMEMCPY_FAM = [\"memcpy\", \"memmove\"]\nID_NA = \".\"\n# -----------------------------------------------------------------------------\nclass MemcpyLocation():\n    \"\"\"Internal data that's represented by IDA's listview (Wchooser\")\n    \"\"\"\n    def __init__(self, ea, name, dst, src, n, dst_type, n_max, problems):\n        self.ea = ea\n        self.name = name",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "MEMCPY_FAM",
        "kind": 5,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "MEMCPY_FAM = [\"memcpy\", \"memmove\"]\nID_NA = \".\"\n# -----------------------------------------------------------------------------\nclass MemcpyLocation():\n    \"\"\"Internal data that's represented by IDA's listview (Wchooser\")\n    \"\"\"\n    def __init__(self, ea, name, dst, src, n, dst_type, n_max, problems):\n        self.ea = ea\n        self.name = name\n        self.dst = dst",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "ID_NA",
        "kind": 5,
        "importPath": "plugins.mrspicky.mrspicky",
        "description": "plugins.mrspicky.mrspicky",
        "peekOfCode": "ID_NA = \".\"\n# -----------------------------------------------------------------------------\nclass MemcpyLocation():\n    \"\"\"Internal data that's represented by IDA's listview (Wchooser\")\n    \"\"\"\n    def __init__(self, ea, name, dst, src, n, dst_type, n_max, problems):\n        self.ea = ea\n        self.name = name\n        self.dst = dst\n        self.src = src",
        "detail": "plugins.mrspicky.mrspicky",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "plugins.pybincat.tools.parsers",
        "description": "plugins.pybincat.tools.parsers",
        "peekOfCode": "def memoize(f):\n    \"\"\" Memoization decorator for a function taking a single argument \"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n@memoize\ndef parse_val(s):\n    if s[0] not in '0123456789_?' or '_bincat_tmp' in s:",
        "detail": "plugins.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "parse_val",
        "kind": 2,
        "importPath": "plugins.pybincat.tools.parsers",
        "description": "plugins.pybincat.tools.parsers",
        "peekOfCode": "def parse_val(s):\n    if s[0] not in '0123456789_?' or '_bincat_tmp' in s:\n        # it's a register\n        return s, 0, 0\n    tbvals = dict.fromkeys([\"?\", \"_\"], 0)\n    val = None\n    bdict = {\"0x\": (16, \"f\"),\n             \"0o\": (8, \"7\"),\n             \"0b\": (2, \"1\")}\n    for p in s.split(\",\"):",
        "detail": "plugins.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "val2str",
        "kind": 2,
        "importPath": "plugins.pybincat.tools.parsers",
        "description": "plugins.pybincat.tools.parsers",
        "peekOfCode": "def val2str(val, vtop, vbot, length, base=None, merged=False):\n    if base == 16 or not base:\n        if length == 0 or length is None:\n            fstring = '{0:X}'\n        else:\n            if length % 4 == 0:\n                length = length / 4\n            else:\n                length = (length / 4)+1\n            fstring = ('{0:0>%dX}' % length)",
        "detail": "plugins.pybincat.tools.parsers",
        "documentation": {}
    },
    {
        "label": "PyBinCATParseError",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]\n    _valcache = {}\n    arch = None",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "CFA",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]\n    _valcache = {}\n    arch = None\n    def __init__(self, addr_nodes, edges, nodes, taintsrcs):\n        #: Value (address) -> [node_id]. Nodes marked \"final\" come first.",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class Node(object):\n    \"\"\"\n    Stores node data for a given node_id.\n    1 or more Unrel may be stored, each containg regaddrs, regtypes\n    \"\"\"\n    __slots__ = ['address', 'node_id', 'final', 'statements', 'bytes',\n                 'tainted', 'taintsrc', 'unrels']\n    def __init__(self, node_id, address=None, lazy_init=None):\n        self.address = address\n        #: str",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Value",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class Value(object):\n    __slots__ = ['vtop', 'vbot', 'taint', 'ttop', 'tbot', 'length', 'value', 'region']\n    def __init__(self, region, value, length=None, vtop=0, vbot=0, taint=0,\n                 ttop=0, tbot=0):\n        self.region = region.lower()\n        self.value = value\n        if not length and region == 'reg':\n            self.length = reg_len(value)\n        else:\n            self.length = length",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "Unrel",
        "kind": 6,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "class Unrel(object):\n    \"\"\"\n    Contains memory & registers status for a given (Node, unrel_id)\n    bincat output format examples:\n    reg [eax] = 0xfff488!0\n    111  222    33333333333\n    mem[0x1234, 0x1236] = 0x20, 0x0\n    111 2222222222222222  33333 3333 <-- list of 2 valtaint\n    mem[0x24*32] = 0b????1111!0b????0000\n    111 22222222   3333333333333333333333 <-- list of 1 valtaint",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "reg_len",
        "kind": 2,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "def reg_len(regname):\n    \"\"\"\n    Returns register length in bits. CFA.arch must have been set, either\n    manually or by parsing a bincat output file.\n    \"\"\"\n    if CFA.arch == \"armv8\":\n        return {\n            \"x0\": 64, \"x1\": 64, \"x2\": 64, \"x3\": 64, \"x4\": 64, \"x5\": 64,\n            \"x6\": 64, \"x7\": 64, \"x8\": 64, \"x9\": 64, \"x10\": 64, \"x11\": 64,\n            \"x12\": 64, \"x13\": 64, \"x14\": 64, \"x15\": 64, \"x16\": 64, \"x17\": 64,",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "PRETTY_REGIONS",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "PRETTY_REGIONS = {'': 'global', 'h': 'heap',\n                  'b': 'bottom', 't': 'top'}  # used for pointers only\n#: split src region + address (left of '=')\nRE_REGION_ADDR = re.compile(r\"(?P<region>reg|mem|h[0-9]+)\\[(?P<addr>[^]]+)\\]\")\n#: split value\nRE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_REGION_ADDR",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "RE_REGION_ADDR = re.compile(r\"(?P<region>reg|mem|h[0-9]+)\\[(?P<addr>[^]]+)\\]\")\n#: split value\nRE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_VALTAINT",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "RE_VALTAINT = re.compile(\n    r\"(?P<memreg>([a-zA-Z]?|[hH]\\d+))-?(?P<value>0[xb][0-9a-fA-F_?]+)(!(?P<taint>\\S+)|)?\")\nRE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "RE_NODE_UNREL",
        "kind": 5,
        "importPath": "plugins.pybincat.cfa",
        "description": "plugins.pybincat.cfa",
        "peekOfCode": "RE_NODE_UNREL = re.compile(\n    r\"node (?P<nodeid>\\d+) - unrel (?P<unrelid>\\d+)\")\nclass PyBinCATParseError(PyBinCATException):\n    pass\nclass CFA(object):\n    \"\"\"\n    Holds Node for each defined node_id.\n    Several node_ids may share the same address (ex. loops, partitions)\n    \"\"\"\n    #: Cache to speed up value parsing. (str, length) -> [Value, ...]",
        "detail": "plugins.pybincat.cfa",
        "documentation": {}
    },
    {
        "label": "MyEmuPlugin",
        "kind": 6,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "class MyEmuPlugin(uEmuPlugin):\n    ### uEmuPlugin methods override\n    def __init__(self):\n        hooks = uEmuExtensionHooks()\n        hooks.init_context = self.hook_init_context\n        hooks.trace_log = self.hook_trace_log\n        hooks.emu_step = self.hook_emu_step\n        super(MyEmuPlugin, self).__init__(\"MyEmu\", hooks)\n    def add_custom_menu(self):\n        self.MENU_ITEMS.append(UEMU_HELPERS.MenuItem(self.plugin_name + \":myemu_test\", self.myemu_test,  \"MyEmu\",  \"MyEmu\",  None,  True  ))",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "myemu_log",
        "kind": 2,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "def myemu_log(entry):\n    uemu_log(entry, name = \"MyEmu\")\nclass MyEmuPlugin(uEmuPlugin):\n    ### uEmuPlugin methods override\n    def __init__(self):\n        hooks = uEmuExtensionHooks()\n        hooks.init_context = self.hook_init_context\n        hooks.trace_log = self.hook_trace_log\n        hooks.emu_step = self.hook_emu_step\n        super(MyEmuPlugin, self).__init__(\"MyEmu\", hooks)",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return MyEmuPlugin()\nif MYEMU_USE_AS_SCRIPT:\n    if __name__ == '__main__':\n        MyEmu = MyEmuPlugin()\n        MyEmu.init()\n        MyEmu.run()",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "MYEMU_USE_AS_SCRIPT",
        "kind": 5,
        "importPath": "plugins.uEmu.Extensions.MyEmu",
        "description": "plugins.uEmu.Extensions.MyEmu",
        "peekOfCode": "MYEMU_USE_AS_SCRIPT = True    # Set to `False` if you want to load MyEmu automatically as IDA Plugin\ndef myemu_log(entry):\n    uemu_log(entry, name = \"MyEmu\")\nclass MyEmuPlugin(uEmuPlugin):\n    ### uEmuPlugin methods override\n    def __init__(self):\n        hooks = uEmuExtensionHooks()\n        hooks.init_context = self.hook_init_context\n        hooks.trace_log = self.hook_trace_log\n        hooks.emu_step = self.hook_emu_step",
        "detail": "plugins.uEmu.Extensions.MyEmu",
        "documentation": {}
    },
    {
        "label": "UEMU_CONFIG",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class UEMU_CONFIG:\n    IDAViewColor_PC     = 0x00B3CBFF\n    IDAViewColor_Reset  = 0xFFFFFFFF\n    UnicornPageSize     = 0x1000\n# === Helpers\nclass UEMU_HELPERS:\n    # Menu\n    MenuItem = collections.namedtuple(\"MenuItem\", [\"action\", \"handler\", \"title\", \"tooltip\", \"shortcut\", \"popup\"])\n    class IdaMenuActionHandler(action_handler_t):\n        def __init__(self, handler, action):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "UEMU_HELPERS",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class UEMU_HELPERS:\n    # Menu\n    MenuItem = collections.namedtuple(\"MenuItem\", [\"action\", \"handler\", \"title\", \"tooltip\", \"shortcut\", \"popup\"])\n    class IdaMenuActionHandler(action_handler_t):\n        def __init__(self, handler, action):\n            action_handler_t.__init__(self)\n            self.action_handler = handler\n            self.action_type = action\n        def activate(self, ctx):\n            if ctx.form_type == BWN_DISASM:",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuInitView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuInitView(object):\n    def __init__(self, owner):\n        super(uEmuInitView, self).__init__()\n        self.owner = owner\n# === uEmuCpuContextView\nclass uEmuCpuContextView(simplecustviewer_t):\n    def __init__(self, owner, extended):\n        super(uEmuCpuContextView, self).__init__()\n        self.hooks = None\n        self.owner = owner",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuCpuContextView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuCpuContextView(simplecustviewer_t):\n    def __init__(self, owner, extended):\n        super(uEmuCpuContextView, self).__init__()\n        self.hooks = None\n        self.owner = owner\n        self.extended = extended\n        self.lastAddress = None\n        self.lastContext = {}\n        self.lastArch = None\n        self.columns = None",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMemoryRangeDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMemoryRangeDialog(Form):\n    def __init__(self):\n        Form.__init__(self, r\"\"\"STARTITEM {id:mem_addr}\nBUTTON YES* Add\nBUTTON CANCEL Cancel\nShow Memory Range\nSpecify start address and size of new memory range.\n<##Address\\::{mem_addr}> <##Size\\::{mem_size}>\n<##Comment\\::{mem_cmnt}>\n\"\"\", {",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMemoryView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMemoryView(simplecustviewer_t):\n    def __init__(self, owner, address, size):\n        super(uEmuMemoryView, self).__init__()\n        self.owner = owner\n        self.viewid = address\n        self.address = address\n        self.size = size\n        self.lastContent = []\n    def Create(self, title):\n        if not simplecustviewer_t.Create(self, title):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuStackView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuStackView(simplecustviewer_t):\n    stack_prelines = 12\n    stack_postlines = 52\n    def __init__(self, owner):\n        super(uEmuStackView, self).__init__()\n        self.owner = owner\n        arch = UEMU_HELPERS.get_arch()\n        _, self.uc_reg_sp = UEMU_HELPERS.get_stack_register(arch)\n    def Create(self, title):\n        if not simplecustviewer_t.Create(self, title):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuControlView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuControlView(PluginForm):\n    def __init__(self, owner):\n        self.owner = owner\n        PluginForm.__init__(self)\n    def OnCreate(self, form):\n        self.parent = self.FormToPyQtWidget(form)\n        self.PopulateForm()\n    def PopulateForm(self):\n        btnStart = QPushButton(\"Start\")\n        btnRun = QPushButton(\"Run\")",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMappeduMemoryView",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMappeduMemoryView(IDAAPI_Choose):\n    def __init__(self, owner, memory, flags=0, width=None, height=None, embedded=False):\n        IDAAPI_Choose.__init__(\n            self,\n            \"uEmu Mapped Memory\",\n            [ [\"Start\", 20], [\"End\", 20], [\"Permissions\", 10] ],\n            flags = flags,\n            width = width,\n            height = height,\n            embedded = embedded)",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuSettingsDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuSettingsDialog(Form):\n    def __init__(self):\n        Form.__init__(self, r\"\"\"STARTITEM {id:chk_followpc}\nBUTTON YES* Save\nBUTTON CANCEL Cancel\nuEmu Settings\n<Follow PC:{chk_followpc}>\n<Convert to Code automatically:{chk_forcecode}>\n<Trace instructions:{chk_trace}>\n<Lazy mapping:{chk_lazymapping}>{emu_group}>",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuRegisterValueDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuRegisterValueDialog(Form):\n    def __init__(self, regName):\n        Form.__init__(self, r\"\"\"STARTITEM {id:reg_val}\nBUTTON YES* Save\nBUTTON CANCEL Cancel\nRegister Value\n{reg_label}\n<##:{reg_val}>\n\"\"\", {\n        'reg_label': Form.StringLabel(\"Enter hex value for [ \" + regName + \" ]\"),",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuRegisterValueLHDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuRegisterValueLHDialog(Form):\n    def __init__(self, regName):\n        Form.__init__(self, r\"\"\"STARTITEM {id:reg_valh}\nBUTTON YES* Save\nBUTTON CANCEL Cancel\nRegister Value\n{reg_label}\n<##High\\::{reg_valh}>\n<##Low\\: :{reg_vall}>\n\"\"\", {",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuMapBinaryFileDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuMapBinaryFileDialog(Form):\n    def __init__(self, address):\n        Form.__init__(self, r\"\"\"STARTITEM {id:file_name}\nBUTTON YES* Map\nBUTTON CANCEL Cancel\nMap Binary File\n{form_change_cb}\n<#Select file to open#File\\::{file_name}>\n{note_label}\n<##Address\\:    :{mem_addr}>",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuContextInitDialog",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuContextInitDialog(IDAAPI_Choose):\n    def __init__(self, regs, flags=0, width=None, height=None, embedded=False):\n        IDAAPI_Choose.__init__(\n            self,\n            \"uEmu CPU Context Edit\",\n            [ [\"Register\", 10], [\"Value\", 30] ],\n            flags = flags,\n            width = width,\n            height = height,\n            embedded = embedded)",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuUnicornEngine",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuUnicornEngine(object):\n    mu = None\n    pc = BADADDR\n    emuActive       = False\n    emuRunning      = False\n    emuThread       = None\n    kStepCount_Run  = 0\n    emuStepCount    = 1\n    fix_context     = None\n    extended        = False",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuExtensionHooks",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuExtensionHooks:\n    init_context = None\n    trace_log = None\n    emu_step = None\nclass uEmuPlugin(plugin_t, UI_Hooks):\n    popup_menu_hook = None\n    flags = PLUGIN_HIDE\n    comment = \"\"\n    help = \"Tiny cute emulator\"\n    wanted_name = \"uEmu\"",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uEmuPlugin",
        "kind": 6,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "class uEmuPlugin(plugin_t, UI_Hooks):\n    popup_menu_hook = None\n    flags = PLUGIN_HIDE\n    comment = \"\"\n    help = \"Tiny cute emulator\"\n    wanted_name = \"uEmu\"\n    plugin_name = \"uEmu\"\n    wanted_hotkey = \"\"\n    ext_hooks = None\n    # --- PLUGIN DATA",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "uemu_log",
        "kind": 2,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "def uemu_log(entry, name=\"uEmu\"):\n    msg(\"[\" + name + \"]: \" + entry + \"\\n\")\n# === uEmuInitView\nclass uEmuInitView(object):\n    def __init__(self, owner):\n        super(uEmuInitView, self).__init__()\n        self.owner = owner\n# === uEmuCpuContextView\nclass uEmuCpuContextView(simplecustviewer_t):\n    def __init__(self, owner, extended):",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.uEmu.uEmu",
        "description": "plugins.uEmu.uEmu",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return uEmuPlugin()\nif UEMU_USE_AS_SCRIPT:\n    if __name__ == '__main__':\n        uEmu = uEmuPlugin()\n        uEmu.init()\n        uEmu.run()",
        "detail": "plugins.uEmu.uEmu",
        "documentation": {}
    },
    {
        "label": "AutoLibcFlags",
        "kind": 6,
        "importPath": "plugins.autolibcflags",
        "description": "plugins.autolibcflags",
        "peekOfCode": "class AutoLibcFlags(idaapi.plugin_t):\n    comment = \"Print comment on Flags enum/explanation near libc function call\"\n    help = \"AutoLibcFlags Help\"\n    wanted_name = \"AutoLibcFlags\"\n    flags = idaapi.PLUGIN_KEEP | idaapi.PLUGIN_MOD | idaapi.PLUGIN_PROC\n    wanted_hotkey= \"Ctrl+Shift+F1\"\n    def init(self):\n        global p_initialized\n        if p_initialized is False:\n            p_initialized = True",
        "detail": "plugins.autolibcflags",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.autolibcflags",
        "description": "plugins.autolibcflags",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return AutoLibcFlags()",
        "detail": "plugins.autolibcflags",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.autolibcflags",
        "description": "plugins.autolibcflags",
        "peekOfCode": "p_initialized = False\n#--------------------------------------------------------------------------\n# Plugin\n#--------------------------------------------------------------------------\nclass AutoLibcFlags(idaapi.plugin_t):\n    comment = \"Print comment on Flags enum/explanation near libc function call\"\n    help = \"AutoLibcFlags Help\"\n    wanted_name = \"AutoLibcFlags\"\n    flags = idaapi.PLUGIN_KEEP | idaapi.PLUGIN_MOD | idaapi.PLUGIN_PROC\n    wanted_hotkey= \"Ctrl+Shift+F1\"",
        "detail": "plugins.autolibcflags",
        "documentation": {}
    },
    {
        "label": "AutoReIDPHooks",
        "kind": 6,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "class AutoReIDPHooks(idaapi.IDP_Hooks):\n    \"\"\"\n    Hooks to keep view updated if some function is updated\n    \"\"\"\n    def __init__(self, view, *args):\n        super(AutoReIDPHooks, self).__init__(*args)\n        self._view = view\n    def __on_rename(self, ea, new_name):\n        if not self._view:\n            return",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "AutoREView",
        "kind": 6,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "class AutoREView(idaapi.PluginForm):\n    ADDR_ROLE = QtCore.Qt.UserRole + 1\n    OPT_FORM_PERSIST = idaapi.PluginForm.FORM_PERSIST if hasattr(idaapi.PluginForm, 'FORM_PERSIST') else idaapi.PluginForm.WOPN_PERSIST\n    OPT_FORM_NO_CONTEXT = idaapi.PluginForm.FORM_NO_CONTEXT if hasattr(idaapi.PluginForm, 'FORM_NO_CONTEXT') else idaapi.PluginForm.WCLS_NO_CONTEXT\n    def __init__(self, data):\n        super(AutoREView, self).__init__()\n        self._data = data\n        self.tv = None\n        self._model = None\n        self._idp_hooks = None",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "auto_re_t",
        "kind": 6,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "class auto_re_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"\"\n    help = \"\"\n    wanted_name = \"Auto RE\"\n    wanted_hotkey = \"Ctrl+Shift+M\"\n    _PREFIX_NAME = 'au_re_'\n    _MIN_MAX_MATH_OPS_TO_ALLOW_RENAME = 10\n    _CALLEE_NODE_NAMES = {\n        idaapi.PLFM_MIPS: '$ mips',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "inf_is_64bit",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:\n        insn = idaapi.insn_t()\n        if idaapi.decode_insn(insn, ea) > 0:\n            return insn\n    else:",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "get_addr_width",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:\n        insn = idaapi.insn_t()\n        if idaapi.decode_insn(insn, ea) > 0:\n            return insn\n    else:\n        if idaapi.decode_insn(ea):\n            return idaapi.cmd.copy()",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "decode_insn",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:\n        insn = idaapi.insn_t()\n        if idaapi.decode_insn(insn, ea) > 0:\n            return insn\n    else:\n        if idaapi.decode_insn(ea):\n            return idaapi.cmd.copy()\ndef force_name(ea, new_name):\n    if not ea or ea == idaapi.BADADDR:",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "force_name",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def force_name(ea, new_name):\n    if not ea or ea == idaapi.BADADDR:\n        return\n    if idaapi.IDA_SDK_VERSION >= 700:\n        return idaapi.force_name(ea, new_name, idaapi.SN_NOCHECK)\n    return idaapi.do_name_anyway(ea, new_name, 0)\nclass AutoReIDPHooks(idaapi.IDP_Hooks):\n    \"\"\"\n    Hooks to keep view updated if some function is updated\n    \"\"\"",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return auto_re_t()",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "__author__ = 'Trafimchuk Aliaksandr'\n__version__ = '1.9'\nfrom collections import defaultdict\nimport idaapi\nfrom idautils import FuncItems, CodeRefsTo\nfrom idaapi import o_reg, o_imm, o_far, o_near, o_mem, o_displ\nimport os\nimport re\nimport sys\nimport traceback",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "__version__ = '1.9'\nfrom collections import defaultdict\nimport idaapi\nfrom idautils import FuncItems, CodeRefsTo\nfrom idaapi import o_reg, o_imm, o_far, o_near, o_mem, o_displ\nimport os\nimport re\nimport sys\nimport traceback\nHAS_PYSIDE = idaapi.IDA_SDK_VERSION < 690",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "HAS_PYSIDE",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "HAS_PYSIDE = idaapi.IDA_SDK_VERSION < 690\nif HAS_PYSIDE:\n    from PySide import QtGui, QtCore\n    from PySide.QtGui import QTreeView, QVBoxLayout, QLineEdit, QMenu, QInputDialog, QAction, QTabWidget\nelse:\n    from PyQt5 import QtGui, QtCore\n    from PyQt5.QtWidgets import QTreeView, QVBoxLayout, QLineEdit, QMenu, QInputDialog, QAction, QTabWidget\ntry:\n    # Python 2.\n    xrange",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG = False\n# adjust this value to be a full path to a debug egg\nRDEBUG_EGG = r'c:\\Program Files\\JetBrains\\PyCharm 2017.1.4\\debug-eggs\\pycharm-debug.egg'\nRDEBUG_HOST = 'localhost'\nRDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG_EGG",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG_EGG = r'c:\\Program Files\\JetBrains\\PyCharm 2017.1.4\\debug-eggs\\pycharm-debug.egg'\nRDEBUG_HOST = 'localhost'\nRDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG_HOST",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG_HOST = 'localhost'\nRDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "RDEBUG_PORT",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "RDEBUG_PORT = 12321\nTAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'\n}",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "TAGS_IGNORE_LIST",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "TAGS_IGNORE_LIST = {\n    'OpenProcessToken',\n    'DisconnectNamedPipe'\n}\nIGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'\n}\nTAGS = {",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "IGNORE_CALL_LIST",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "IGNORE_CALL_LIST = {\n    'RtlNtStatusToDosError',\n    'GetLastError',\n    'SetLastError'\n}\nTAGS = {\n    'net': ['WSAStartup', 'socket', 'recv', 'recvfrom', 'send', 'sendto', 'acccept', 'bind', 'listen', 'select',\n            'setsockopt', 'ioctlsocket', 'closesocket', 'WSAAccept', 'WSARecv', 'WSARecvFrom', 'WSASend', 'WSASendTo',\n            'WSASocket', 'WSAConnect', 'ConnectEx', 'TransmitFile', 'HTTPOpenRequest', 'HTTPSendRequest',\n            'URLDownloadToFile', 'InternetCrackUrl', 'InternetOpen', 'InternetOpen', 'InternetConnect',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "TAGS = {\n    'net': ['WSAStartup', 'socket', 'recv', 'recvfrom', 'send', 'sendto', 'acccept', 'bind', 'listen', 'select',\n            'setsockopt', 'ioctlsocket', 'closesocket', 'WSAAccept', 'WSARecv', 'WSARecvFrom', 'WSASend', 'WSASendTo',\n            'WSASocket', 'WSAConnect', 'ConnectEx', 'TransmitFile', 'HTTPOpenRequest', 'HTTPSendRequest',\n            'URLDownloadToFile', 'InternetCrackUrl', 'InternetOpen', 'InternetOpen', 'InternetConnect',\n            'InternetOpenUrl', 'InternetQueryOption', 'InternetSetOption', 'InternetReadFile', 'InternetWriteFile',\n            'InternetGetConnectedState', 'InternetSetStatusCallback', 'DnsQuery', 'getaddrinfo', 'GetAddrInfo',\n            'GetAdaptersInfo', 'GetAdaptersAddresses', 'HttpQueryInfo', 'ObtainUserAgentString', 'WNetGetProviderName',\n            'GetBestInterfaceEx', 'gethostbyname', 'getsockname', 'connect', 'WinHttpOpen', 'WinHttpSetTimeouts',\n            'WinHttpSendRequest', 'WinHttpConnect', 'WinHttpCrackUrl', 'WinHttpReadData', 'WinHttpOpenRequest',",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "STRICT_TAG_NAME_CHECKING",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "STRICT_TAG_NAME_CHECKING = {'file'}\nblacklist = {'@__security_check_cookie@4', '__SEH_prolog4', '__SEH_epilog4'}\nreplacements = [\n    ('??3@YAXPAX@Z', 'alloc'),\n    ('?', '')\n]\ndef inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "blacklist",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "blacklist = {'@__security_check_cookie@4', '__SEH_prolog4', '__SEH_epilog4'}\nreplacements = [\n    ('??3@YAXPAX@Z', 'alloc'),\n    ('?', '')\n]\ndef inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "replacements",
        "kind": 5,
        "importPath": "plugins.auto_re",
        "description": "plugins.auto_re",
        "peekOfCode": "replacements = [\n    ('??3@YAXPAX@Z', 'alloc'),\n    ('?', '')\n]\ndef inf_is_64bit():\n    return (idaapi.inf_is_64bit if idaapi.IDA_SDK_VERSION >= 900 else idaapi.cvar.inf.is_64bit)()\ndef get_addr_width():\n    return '16' if inf_is_64bit() else '8'\ndef decode_insn(ea):\n    if idaapi.IDA_SDK_VERSION >= 700 and sys.maxsize > 2**32:",
        "detail": "plugins.auto_re",
        "documentation": {}
    },
    {
        "label": "AnalyzerUnavailable",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class AnalyzerUnavailable(Exception):\n    pass\nclass BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "BincatPlugin",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class BincatPlugin(idaapi.plugin_t):\n    # variables required by IDA\n    flags = 0  # normal plugin\n    wanted_name = \"BinCAT\"\n    wanted_hotkey = \"Ctrl-Shift-B\"\n    comment = \"Interface to the BinCAT analyzer\"\n    help = \"\"\n    initialized = False\n    def __init__(self):\n        super(BincatPlugin, self).__init__()",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class Analyzer(object):\n    def __init__(self, path, finish_cb):\n        self.path = path\n        self.finish_cb = finish_cb\n    def generate_tnpk(self, fname=None, destfname=None):\n        \"\"\"\n        Generates TNPK file for provided fname. If None, generate one for the\n        binary that is currently being analyzed in IDA, using IDA-provided\n        headers.\n        Returns file path to generated tnpk (string), or None if generation was",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzerTimer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class LocalAnalyzerTimer(object):\n    \"\"\"\n    IDA timer used to kill the BinCAT analyzer if the user\n    cancels the analysis\n    \"\"\"\n    def __init__(self, qprocess):\n        self.interval = 500  # ms\n        self.qprocess = qprocess\n        self.timer = idaapi.register_timer(self.interval, self)\n        if self.timer is None:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "LocalAnalyzer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class LocalAnalyzer(Analyzer, QtCore.QProcess):\n    \"\"\"\n    Runs BinCAT locally using QProcess.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        QtCore.QProcess.__init__(self)\n        Analyzer.__init__(self, *args, **kwargs)\n        # Qprocess signal handlers\n        self.error.connect(self.procanalyzer_on_error)\n        self.stateChanged.connect(self.procanalyzer_on_state_change)",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "WebAnalyzer",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class WebAnalyzer(Analyzer):\n    API_VERSION = \"1.2\"\n    def __init__(self, *args, **kwargs):\n        Analyzer.__init__(self, *args, **kwargs)\n        self.server_url = PluginOptions.get(\"server_url\").rstrip(\"/\")\n        self.reachable_server = False\n        self.check_version()  # raises exception if server is unreachable\n        self.reachable_server = True\n    def check_version(self):\n        try:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class State(object):\n    \"\"\"\n    Container for (static) plugin state related data & methods.\n    \"\"\"\n    def __init__(self):\n        self.current_ea = None\n        self.cfa = None\n        self.current_node = None\n        #: list of node ids (int)\n        self.current_node_ids = []",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "CallbackWrappedList",
        "kind": 6,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "class CallbackWrappedList(MutableSequence):\n    \"\"\"\n    Acts as a List object, wraps write access with calls to properly invalidate\n    models associated with View GUI objects.\n    Should store only immutable objects.\n    \"\"\"\n    def __init__(self):\n        self._data = []\n        #: list of functions to be called prior to updating list\n        self.pre_callbacks = []",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "dedup_loglines",
        "kind": 2,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "def dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:\n                return True\n        if n == 2:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return BincatPlugin()",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "bc_log",
        "kind": 5,
        "importPath": "plugins.bcplugin",
        "description": "plugins.bcplugin",
        "peekOfCode": "bc_log = logging.getLogger('bincat.plugin')\nbc_log.setLevel(logging.INFO)\ndef dedup_loglines(loglines, max=None):\n    res = []\n    staging = None\n    n = 0\n    def flush_staging():\n        if n > 0:\n            res.append(staging)\n            if max and len(res) >= max:",
        "detail": "plugins.bcplugin",
        "documentation": {}
    },
    {
        "label": "cto_func_lister_plugin_t",
        "kind": 6,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "class cto_func_lister_plugin_t(ida_idaapi.plugin_t):\n    flags = ida_idaapi.PLUGIN_KEEP\n    comment = \"CTO Function Lister\"\n    toolbar_displayed_name = cto_base.cto_base.orig_title\n    toolbar_name = toolbar_displayed_name + 'Toolbar'\n    wanted_name = comment\n    wanted_hotkey = \"Alt-Shift-F\"\n    help = \"Press '\" + wanted_hotkey + \"' to display the \" + comment + \" widget.\"\n    action_name = \"cto_func_lister:execute\"\n    menu_path = \"Edit/Plugins/\"",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return cto_func_lister_plugin_t()\ndef main():\n    global g_cto_func_lister\n    g_cto_func_lister = cto_func_lister.exec_cto_function_lister()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "def main():\n    global g_cto_func_lister\n    g_cto_func_lister = cto_func_lister.exec_cto_function_lister()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "dirpath",
        "kind": 5,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "dirpath = os.path.dirname(os.path.abspath(__file__))\ncto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto_func_lister\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nclass cto_func_lister_plugin_t(ida_idaapi.plugin_t):",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "cto_dir",
        "kind": 5,
        "importPath": "plugins.cto_func_lister_plugin",
        "description": "plugins.cto_func_lister_plugin",
        "peekOfCode": "cto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto_func_lister\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nclass cto_func_lister_plugin_t(ida_idaapi.plugin_t):\n    flags = ida_idaapi.PLUGIN_KEEP",
        "detail": "plugins.cto_func_lister_plugin",
        "documentation": {}
    },
    {
        "label": "cto_plugin_t",
        "kind": 6,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "class cto_plugin_t(ida_idaapi.plugin_t):\n    flags = ida_idaapi.PLUGIN_KEEP\n    comment = \"Call Tree Overviewer\"\n    toolbar_displayed_name = cto_base.cto_base.orig_title\n    toolbar_name = toolbar_displayed_name + 'Toolbar'\n    wanted_name = cto.CallTreeOverviewer.orig_title\n    wanted_hotkey = \"Alt-Shift-C\"\n    help = \"Press '\" + wanted_hotkey + \"' to display the \" + wanted_name + \" widget. Then press 'H' to see the help after setting focus to the widget.\"\n    action_name = \"cto:execute\"\n    menu_path = \"Edit/Plugins/\"",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return cto_plugin_t()\ndef main():\n    global g_cto\n    g_cto = cto.exec_cto()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "def main():\n    global g_cto\n    g_cto = cto.exec_cto()\nif __name__ == '__main__':\n    main()",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "dirpath",
        "kind": 5,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "dirpath = os.path.dirname(os.path.abspath(__file__))\ncto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nida_idaapi.require(\"get_func_relation\")",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "cto_dir",
        "kind": 5,
        "importPath": "plugins.cto_plugin",
        "description": "plugins.cto_plugin",
        "peekOfCode": "cto_dir = os.path.join(dirpath, \"cto\")\nif cto_dir not in sys.path:\n    sys.path.append(cto_dir)\nida_idaapi.require(\"cto_base\")\nida_idaapi.require(\"cto\")\nida_idaapi.require(\"icon\")\nida_idaapi.require(\"syncdata\")\nida_idaapi.require(\"qtutils\")\nida_idaapi.require(\"get_func_relation\")\nclass cto_plugin_t(ida_idaapi.plugin_t):",
        "detail": "plugins.cto_plugin",
        "documentation": {}
    },
    {
        "label": "idb_hook_t",
        "kind": 6,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "class idb_hook_t(IDB_Hooks):\n    def __init__(self, hxehook):\n        self.hxehook = hxehook\n        IDB_Hooks.__init__(self)\n    def savebase(self):\n        self.hxehook._reset_all_colors()\n        return 0\n# -----------------------------------------------------------------------\nclass hxe_hook_t(Hexrays_Hooks):\n    def __init__(self):",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "hxe_hook_t",
        "kind": 6,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "class hxe_hook_t(Hexrays_Hooks):\n    def __init__(self):\n        Hexrays_Hooks.__init__(self)\n        self.idbhook = idb_hook_t(self)\n        self.idbhook.hook()\n        self.pseudocode_instances = {}\n        self.n_spaces = 40\n    def close_pseudocode(self, vd):\n        self._reset_colors(vd.view_idx, ignore_vd=True)\n        refresh_idaview_anyway()",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "Dsync",
        "kind": 6,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "class Dsync(ida_idaapi.plugin_t):\n    comment = ''\n    help = ''\n    flags = PLUGIN_MOD\n    wanted_name = 'dsync'\n    wanted_hotkey = 'Ctrl-Shift-S'\n    hxehook = None\n    def init(self):\n        required_ver = 730\n        if not is_ida_version(required_ver) or not init_hexrays_plugin():",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "is_ida_version",
        "kind": 2,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "def is_ida_version(min_ver_required):\n    return IDA_SDK_VERSION >= min_ver_required\n# -----------------------------------------------------------------------\nclass Dsync(ida_idaapi.plugin_t):\n    comment = ''\n    help = ''\n    flags = PLUGIN_MOD\n    wanted_name = 'dsync'\n    wanted_hotkey = 'Ctrl-Shift-S'\n    hxehook = None",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "def PLUGIN_ENTRY():   \n    return Dsync()",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "__author__ = 'https://github.com/patois'\nHL_COLOR = 0xAD8044\n# -----------------------------------------------------------------------\nclass idb_hook_t(IDB_Hooks):\n    def __init__(self, hxehook):\n        self.hxehook = hxehook\n        IDB_Hooks.__init__(self)\n    def savebase(self):\n        self.hxehook._reset_all_colors()\n        return 0",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "HL_COLOR",
        "kind": 5,
        "importPath": "plugins.dsync",
        "description": "plugins.dsync",
        "peekOfCode": "HL_COLOR = 0xAD8044\n# -----------------------------------------------------------------------\nclass idb_hook_t(IDB_Hooks):\n    def __init__(self, hxehook):\n        self.hxehook = hxehook\n        IDB_Hooks.__init__(self)\n    def savebase(self):\n        self.hxehook._reset_all_colors()\n        return 0\n# -----------------------------------------------------------------------",
        "detail": "plugins.dsync",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.gepetto",
        "description": "plugins.gepetto",
        "peekOfCode": "def PLUGIN_ENTRY():\n    gepetto.config.load_config()  # Loads configuration data from gepetto/config.ini\n    # Only import the rest of the code after the translations have been loaded, because the _ function (gettext)\n    # needs to have been imported in the namespace first.\n    from gepetto.ida.ui import GepettoPlugin\n    return GepettoPlugin()",
        "detail": "plugins.gepetto",
        "documentation": {}
    },
    {
        "label": "HashDBError",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class HashDBError(Exception):\n    pass\n#--------------------------------------------------------------------------\n# Worker implementation\n#--------------------------------------------------------------------------\n@dataclass(unsafe_hash=True)\nclass Worker(Thread):\n    \"\"\"The worker implementation for multi-threading support.\"\"\"\n    target: Callable\n    args: tuple = field(default_factory=tuple, compare=False)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "Worker",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class Worker(Thread):\n    \"\"\"The worker implementation for multi-threading support.\"\"\"\n    target: Callable\n    args: tuple = field(default_factory=tuple, compare=False)\n    done_callback: Callable = None\n    error_callback: Callable = None\n    def __post_init__(self):\n        \"\"\"Required to initialize the base class (Thread).\"\"\"\n        super().__init__(target=self.__wrapped_target, args=self.args, daemon=True)\n    def __wrapped_target(self, *args, **kwargs):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hashdb_settings_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class hashdb_settings_t(ida_kernwin.Form):\n    \"\"\"Global settings form for hashdb\"\"\"\n    class algorithm_chooser_t(ida_kernwin.Choose):\n        \"\"\"\n        A simple chooser to be used as an embedded chooser\n        \"\"\"\n        def __init__(self, algo_list):\n            ida_kernwin.Choose.__init__(\n                self,\n                \"\",",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "match_select_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class match_select_t(ida_kernwin.Form):\n    \"\"\"Simple form to select string match during hash collision\"\"\"\n    def __init__(self, collision_strings):\n        self.__n = 0\n        F = ida_kernwin.Form\n        F.__init__(self,\nr\"\"\"BUTTON YES* Ok\nHashDB Hash Collision\n{FormChangeCb}\nMore than one string matches this hash!",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_result_form_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class hunt_result_form_t(ida_kernwin.Form):\n    class algorithm_chooser_t(ida_kernwin.Choose):\n        \"\"\"\n        A simple chooser to be used as an embedded chooser\n        \"\"\"\n        def __init__(self, algo_list):\n            ida_kernwin.Choose.__init__(\n                self,\n                \"\",\n                [",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "api_import_select_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class api_import_select_t(ida_kernwin.Form):\n    \"\"\"Simple form to select module to import apis from\"\"\"\n    def __init__(self, string_value, module_list):\n        self.__n = 0\n        F = ida_kernwin.Form\n        F.__init__(self,\nr\"\"\"BUTTON YES* Import\nBUTTON CANCEL No\nHashDB Bulk Import\n{FormChangeCb}",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "unqualified_name_replace_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class unqualified_name_replace_t(ida_kernwin.Form):\n    def __init__(self, unqualified_name: str, invalid_characters: list) -> None:\n        form = \"BUTTON YES* Replace\\n\" \\\n               \"BUTTON CANCEL Skip\\n\" \\\n               \"HashDB: Please replace the invalid characters\\n\\n\" \\\n               \"{form_change_callback}\\n\" \\\n               \"Some of the characters in the hashed string are invalid (highlighted red):\\n\" \\\n               \"{unqualified_name}\\n\" \\\n               \"<##New name\\\\: :{new_name}>\"\n        invalid_characters_html = \"<span style=\\\"font-size: 16px\\\">{}</span>\"",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HashDB_Plugin_t",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class HashDB_Plugin_t(idaapi.plugin_t):\n    \"\"\"\n    IDA Plugin for HashDB lookup service\n    \"\"\"\n    comment = \"HashDB Lookup Service\"\n    help = \"\"\n    wanted_name = PLUGIN_NAME\n    # We only want a hotkey for the actual hash lookup\n    wanted_hotkey = ''\n    flags = idaapi.PLUGIN_KEEP",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class Hooks(idaapi.UI_Hooks):\n    def finish_populating_widget_popup(self, widget, popup):\n        \"\"\"\n        A right click menu is about to be shown. (IDA 7)\n        \"\"\"\n        inject_actions(widget, popup, idaapi.get_widget_type(widget))\n        return 0\n    def hxe_callback(self, event, *args):\n        \"\"\"\n        HexRays event callback.",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "IDACtxEntry",
        "kind": 6,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "class IDACtxEntry(idaapi.action_handler_t):\n    \"\"\"\n    A basic Context Menu class to utilize IDA's action handlers.\n    \"\"\"\n    def __init__(self, action_function):\n        idaapi.action_handler_t.__init__(self)\n        self.action_function = action_function\n    def activate(self, ctx):\n        \"\"\"\n        Execute the embedded action_function when this context menu is invoked.",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_enum",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_enum(enum_name: str):\n    if IDA_9:\n        return idc.get_enum(enum_name)\n    else:\n        return ida_enum.get_enum(enum_name)\ndef import_type(idx: int, enum_name: str):\n    if IDA_9:\n        return idc.import_type(idx, enum_name)\n    else:\n        return ida_typeinf.import_type(ida_typeinf.get_idati(), idx, enum_name, 0)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "import_type",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def import_type(idx: int, enum_name: str):\n    if IDA_9:\n        return idc.import_type(idx, enum_name)\n    else:\n        return ida_typeinf.import_type(ida_typeinf.get_idati(), idx, enum_name, 0)\ndef attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0):\n    if IDA_9:\n        return ida_kernwin.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)\n    else:\n        return idaapi.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "attach_action_to_popup",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0):\n    if IDA_9:\n        return ida_kernwin.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)\n    else:\n        return idaapi.attach_action_to_popup(widget, popup_handle, name, popuppath, flags)\ndef get_enum_member_by_name(enum_value_name: str):\n    if IDA_9:\n        return idc.get_enum_member_by_name(enum_value_name)\n    else:\n        return ida_enum.get_enum_member_by_name(enum_value_name)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_enum_member_by_name",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_enum_member_by_name(enum_value_name: str):\n    if IDA_9:\n        return idc.get_enum_member_by_name(enum_value_name)\n    else:\n        return ida_enum.get_enum_member_by_name(enum_value_name)\n#--------------------------------------------------------------------------\n# Global exception hook to detect plugin exceptions until\n#  we implement a proper test-driven development setup\n# Note: minimum Python version support is 3.5 \n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hashdb_exception_hook",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hashdb_exception_hook(exception_type, value, traceback_object):\n    is_hashdb_exception = False\n    frame_data = {\n        \"user_data\": {\n            \"platform\": sys.platform,\n            \"python_version\": '.'.join([str(sys.version_info.major), str(sys.version_info.minor), str(sys.version_info.micro)]),\n            \"plugin_version\": VERSION,\n            \"ida\": {\n                \"kernel_version\": ida_kernwin.get_kernel_version(),\n                \"bits\": BITS",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_algorithms",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_algorithms(api_url='https://hashdb.openanalysis.net', timeout=None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    algorithms_url = api_url + '/hash'\n    r = requests.get(algorithms_url, timeout=timeout)\n    if not r.ok:\n        raise HashDBError(\"Get algorithms API request failed, status %s\" % r.status_code)\n    results = r.json()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_strings_from_hash",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_strings_from_hash(algorithm, hash_value, xor_value=0, api_url='https://hashdb.openanalysis.net', timeout=None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    hash_value ^= xor_value\n    hash_url = api_url + '/hash/%s/%d' % (algorithm, hash_value)\n    r = requests.get(hash_url, timeout=timeout)\n    if not r.ok:\n        raise HashDBError(\"Get hash API request failed, status %s\" % r.status_code)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_module_hashes",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_module_hashes(module_name, algorithm, permutation, api_url='https://hashdb.openanalysis.net', timeout=None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    module_url = api_url + '/module/%s/%s/%s' % (module_name, algorithm, permutation)\n    r = requests.get(module_url, timeout=timeout)\n    if not r.ok:\n        raise HashDBError(\"Get hash API request failed, status %s\" % r.status_code)\n    results = r.json()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_hash",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_hash(hash_value, api_url='https://hashdb.openanalysis.net', timeout = None):\n    # Handle an empty timeout\n    global HASHDB_REQUEST_TIMEOUT\n    if timeout is None:\n        timeout = HASHDB_REQUEST_TIMEOUT\n    matches = []\n    hash_list = [hash_value]\n    module_url = api_url + '/hunt'\n    r = requests.post(module_url, json={\"hashes\": hash_list}, timeout=timeout)\n    if not r.ok:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def load_settings():\n    global HASHDB_API_URL \n    global HASHDB_USE_XOR, HASHDB_XOR_VALUE \n    global HASHDB_ALGORITHM, ENUM_PREFIX\n    global NETNODE_NAME\n    node = ida_netnode.netnode(NETNODE_NAME)\n    if ida_netnode.exist(node):\n        if bool(node.hashstr(\"HASHDB_API_URL\")):\n            HASHDB_API_URL = node.hashstr(\"HASHDB_API_URL\")\n        if bool(node.hashstr(\"HASHDB_USE_XOR\")):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "save_settings",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def save_settings():\n    global HASHDB_API_URL \n    global HASHDB_USE_XOR, HASHDB_XOR_VALUE \n    global HASHDB_ALGORITHM, ENUM_PREFIX\n    global NETNODE_NAME\n    # Check if our netnode already exists, otherwise create a new one\n    node = ida_netnode.netnode(NETNODE_NAME)\n    if not ida_netnode.exist(node):\n        node = ida_netnode.netnode()\n        if not node.create(NETNODE_NAME):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_invalid_characters",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_invalid_characters(string: str) -> list:\n    invalid_characters = []\n    # Is the string empty?\n    if not string:\n        return invalid_characters\n    # Is the first character a digit?\n    if string[0].isdigit():\n        invalid_characters.append(0)\n    # Iterate through the characters in the string,\n    #  and check if they are valid using",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "html_format_invalid_characters",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def html_format_invalid_characters(string: str, invalid_characters: list, color: str = \"#F44336\") -> str:\n    # Are there any invalid characters in the string?\n    if not invalid_characters:\n        return string\n    # Format the invalid characters\n    formatted_string = \"\"\n    for index, character in enumerate(string):\n        if index in invalid_characters and color:\n            formatted_string += \"<span style=\\\"color: {}\\\">{}</span>\".format(color, character)\n        else:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "get_existing_enum_values",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def get_existing_enum_values(enum_name):\n    # Check if the enum exists\n    if get_enum(enum_name) == idaapi.BADNODE:\n        return {}\n    # Fetch the type definition\n    values = ida_typeinf.get_named_type(ida_typeinf.get_idati(), enum_name, ida_typeinf.NTF_TYPE)\n    if values is None:\n        return {}\n    _, type_str, fields_str, _, _, _, _ = values\n    type_definition = ida_typeinf.idc_print_type(type_str, fields_str, enum_name, 0)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "add_enums",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def add_enums(enum_name, hash_list):\n    \"\"\"\n    Adds a hash list to an enum by name.\n     IMPORTANT: This function should always be executed on the main thread.\n    The hash list should be a list of tuples with three values:\n     name: str, value: int, is_api: bool\n    \"\"\"\n    fixed_hash_values = get_existing_enum_values(enum_name)  # dict[str, int]\n    for enum_value_name, enum_value, is_api in hash_list:\n        # Fixup the name before appending it to the list",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "generate_enum_name",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def generate_enum_name(prefix: str) -> str:\n    \"\"\"\n    Generates an enum name from a prefix\n    \"\"\"\n    global HASHDB_ALGORITHM\n    return prefix + '_' + HASHDB_ALGORITHM\ndef make_const_enum(enum_id, hash_value):\n    # We are in the disassembler we can set the enum directly\n    ea = idc.here()\n    start = idaapi.get_item_head(ea)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "make_const_enum",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def make_const_enum(enum_id, hash_value):\n    # We are in the disassembler we can set the enum directly\n    ea = idc.here()\n    start = idaapi.get_item_head(ea)\n    # Determind if this is code or data/undefined\n    if idc.is_code(idc.get_full_flags(ea)):\n        # Find the operand position\n        if idc.get_operand_value(ea,0) == hash_value:\n            ida_bytes.op_enum(start, 0, enum_id, 0)\n            return True",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "parse_highlighted_value",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def parse_highlighted_value():\n    current_viewer = ida_kernwin.get_current_viewer()\n    is_range_selected, _, _ = ida_kernwin.read_range_selection(current_viewer)\n    if is_range_selected:\n        raise HashDBError(\"Ranged selections are not supported when parsing highlighted values. \"\n                          \"Were multiple lines selected?\")\n    highlight_result = ida_kernwin.get_highlight(current_viewer)\n    if highlight_result is None:\n        raise HashDBError(\"Invalid selection; nothing was selected.\")\n    identifier, flags = highlight_result",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "determine_highlighted_type_size",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def determine_highlighted_type_size(ea: int) -> int:\n    '''Guess the highlighted type and return the size in bytes.'''\n    type = idaapi.idc_guess_type(ea)\n    if type == '__int64':\n        return 8\n    if type == 'int':\n        return 4\n    if type == '__int16':\n        return 2\n    if type == 'char':",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "read_integer_from_db",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def read_integer_from_db(ea: int, default_size: int = 0) -> int:\n    '''\n    Read the highlighted data from the database.\n    Returns: [value, size, was_type_valid]\n    '''\n    type_size = determine_highlighted_type_size(ea)\n    # 64-bit\n    if type_size == 8 or (not type_size and default_size == 8):\n        return [ida_bytes.get_64bit(ea), 8, bool(type_size)]\n    # 32-bit",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "convert_data_to_integer",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def convert_data_to_integer(ea, size: int = 0) -> int:\n    '''\n    Converts the data into a QWORD, DWORD, WORD, or BYTE based on the size provided\n    '''\n    global HASHDB_ALGORITHM_SIZE\n    if not size:\n        size = HASHDB_ALGORITHM_SIZE // 8\n    if size == 8:\n        ida_bytes.create_qword(ea, size, True)\n    elif size == 4:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "global_settings",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def global_settings():\n    global HASHDB_API_URL\n    global HASHDB_USE_XOR\n    global HASHDB_XOR_VALUE\n    global HASHDB_ALGORITHM\n    global ENUM_PREFIX\n    if HASHDB_ALGORITHM != None:\n        algorithms = [[HASHDB_ALGORITHM, str(HASHDB_ALGORITHM_SIZE)]]\n    else:\n        algorithms = []",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "set_algorithm",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def set_algorithm(algorithm: str, size: int) -> bool:\n    global HASHDB_ALGORITHM\n    global HASHDB_ALGORITHM_SIZE\n    # Type checks to prevent accidental errors\n    if not isinstance(algorithm, str):\n        idaapi.msg(\"HashDB encountered an error while trying to set the algorithm: provided algorithm is a string type: %s\\n\", algorithm)\n        return False\n    if isinstance(size, str):\n        size = int(size)\n    if not isinstance(size, int):",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "determine_algorithm_size",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def determine_algorithm_size(algorithm_type: str) -> str:\n    size = 'Unknown'\n    if algorithm_type is None:\n        return size\n    if algorithm_type == 'unsigned_int':\n        size = '32'\n    elif algorithm_type == 'unsigned_long':\n        size = '64'\n    return size\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "set_xor_key",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def set_xor_key():\n    \"\"\"\n    Set xor key from selection\n    \"\"\"\n    global HASHDB_USE_XOR\n    global HASHDB_XOR_VALUE\n    try:\n        xor_value = parse_highlighted_value()\n        ida_kernwin.msg(f\"HashDB: Set xor value to {xor_value:#x}\\n\")\n    except HashDBError as exception:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_done_handler",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_done_handler(hash_list: Union[None, list], hash_value: int = None):\n    global ENUM_PREFIX\n    def add_enums_wrapper(enum_name, hash_list):\n        nonlocal enum_id\n        enum_id = add_enums(enum_name, hash_list)\n        return 0 # execute_sync dictates an int return value\n    if hash_list is None or hash_value is None:\n        return\n    # Parse the hash list\n    hash_string = None",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_done",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_done(hash_list: Union[None, list] = None, hash_value: int = None):\n    global HASHDB_REQUEST_LOCK\n    hash_lookup_done_handler(hash_list, hash_value)\n    # Release the lock\n    HASHDB_REQUEST_LOCK.release()\ndef hash_lookup_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hash_lookup_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_error",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hash_lookup_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))\n    HASHDB_REQUEST_LOCK.release()\ndef hash_lookup_request(api_url: str, algorithm: str,\n                        hash_value: int, xor_value: Union[None, int],\n                        timeout: Union[int, float]):\n    # Perform the request",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_request",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_request(api_url: str, algorithm: str,\n                        hash_value: int, xor_value: Union[None, int],\n                        timeout: Union[int, float]):\n    # Perform the request\n    hash_results = None\n    try:\n        hash_results = get_strings_from_hash(algorithm, hash_value, xor_value if xor_value is not None else 0, api_url, timeout)\n    except requests.Timeout:\n        idaapi.msg(\"ERROR: HashDB API lookup hash request timed out.\\n\")\n        logging.exception(\"API request to {} timed out:\".format(HASHDB_API_URL))",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup_run",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup_run(timeout: Union[int, float] = 0) -> bool:\n    # Check if an algorithm is selected\n    global HASHDB_ALGORITHM, HASHDB_ALGORITHM_SIZE, HASHDB_API_URL, \\\n           ENUM_PREFIX, HASHDB_USE_XOR, HASHDB_XOR_VALUE\n    if HASHDB_ALGORITHM is None:\n        idaapi.warning(\"Please select a hash algorithm before using HashDB.\")\n        settings_results = hashdb_settings_t.show(api_url=HASHDB_API_URL, \n                                                  enum_prefix=ENUM_PREFIX,\n                                                  use_xor=HASHDB_USE_XOR,\n                                                  xor_value=HASHDB_XOR_VALUE)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_lookup",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_lookup():\n    \"\"\"\n    Lookup a hash value from the highlighted text.\n    The function will spawn a new thread with a timeout (`HASHDB_REQUEST_TIMEOUT`).\n     While executing, the request lock is acquired.\n    \"\"\"\n    # Check if we're already running a request\n    global HASHDB_REQUEST_LOCK, HASHDB_REQUEST_TIMEOUT\n    timeout_string = \"{}\".format(HASHDB_REQUEST_TIMEOUT) + \" second{}\".format('s' if HASHDB_REQUEST_TIMEOUT != 1 else \"\")\n    if HASHDB_REQUEST_LOCK.locked():",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_done",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_done(convert_values: bool = False, hash_list: Union[None, list] = None):\n    global HASHDB_REQUEST_LOCK\n    logging.debug(\"hash_scan_done callback invoked, result: {}\".format(\"none\" if hash_list is None else \"{}\".format(hash_list)))\n    global ENUM_PREFIX\n    def add_enums_wrapper(enum_name: str, hash_list):\n        nonlocal enum_id\n        enum_id = add_enums(enum_name, hash_list)\n        return 0 # execute_sync dictates an int return value\n    # Check if the `hash_scan_request` function failed (a caught exception should return `None`)\n    if hash_list is not None:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "rate_limit_hit",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def rate_limit_hit(seconds):\n    spinner_chars = \"|/-\\\\\"\n    for _ in range(seconds):\n        for char in spinner_chars:\n            sys.stdout.write(f'\\r{char} Waiting 65 seconds to respect the HashDB API limit...')\n            sys.stdout.flush()\n            time.sleep(.25)\ndef hash_scan_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_error",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hash_scan_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))\n    HASHDB_REQUEST_LOCK.release()\ndef hash_scan_request(convert_values: bool, hash_list: list,\n                            api_url: str, algorithm: str, xor_value: int,\n                            timeout: Union[int, float]) -> Union[None, list]:\n    api_calls = 0",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_request",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_request(convert_values: bool, hash_list: list,\n                            api_url: str, algorithm: str, xor_value: int,\n                            timeout: Union[int, float]) -> Union[None, list]:\n    api_calls = 0\n    for hash_entry in hash_list:\n        if api_calls == 99:\n            print('\\n')\n            rate_limit_hit(65) # Wait 65 seconds to respect the API limit\n            print('\\n')\n            api_calls = 0",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan_run",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan_run(convert_values: bool, timeout: Union[int, float] = 0) -> bool:\n    # Only scan for data in the dissassembler\n    if ida_kernwin.get_viewer_place_type(ida_kernwin.get_current_viewer()) != ida_kernwin.TCCPT_IDAPLACE:\n        idaapi.msg(\"ERROR: Scan only available in dissassembler.\\n\")\n        return True # Release the lock\n    # Get the highlighted range\n    start = idc.read_selection_start()\n    end = idc.read_selection_end()\n    if idaapi.BADADDR in (start, end):\n        ea = idc.here()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hash_scan",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hash_scan(convert_values = True):\n    \"\"\"\n    Scan for a dynamic hash table.\n    The function will spawn a new thread with a timeout (`HASHDB_REQUEST_TIMEOUT`).\n     While executing, the request lock is acquired.\n    \"\"\"\n    # Check if we're already running a request\n    global HASHDB_REQUEST_LOCK, HASHDB_REQUEST_TIMEOUT\n    timeout_string = \"{}\".format(HASHDB_REQUEST_TIMEOUT) + \" second{}\".format('s' if HASHDB_REQUEST_TIMEOUT != 1 else \"\")\n    if HASHDB_REQUEST_LOCK.locked():",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_done",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_done(response: Union[None, list] = None):\n    global HASHDB_REQUEST_LOCK\n    logging.debug(\"hunt_algorithm_done callback invoked, result: {}\".format(\"none\" if response is None else \"{}\".format(response)))\n    # Display the result\n    if response is not None:\n        logging.debug(\"Displaying hash_result_form_t.\")\n        hunt_result_form_callable = functools.partial(hunt_result_form_t.show, response)\n        ida_kernwin.execute_sync(hunt_result_form_callable, ida_kernwin.MFF_FAST)\n    else:\n        logging.debug(\"Couldn't find any algorithms that match the provided hash.\")",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_error",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_error(exception: Exception):\n    global HASHDB_REQUEST_LOCK\n    exception_string = traceback.format_exc()\n    logging.critical(\"hunt_algorithm_request errored: {}\".format(exception_string))\n    idaapi.msg(\"ERROR: HashDB hash scan failed: {}\\n\".format(exception_string))\n    HASHDB_REQUEST_LOCK.release()\ndef hunt_algorithm_request(hash_value: int, timeout=None) -> Union[None, list]:\n    \"\"\"\n    Perform the actual request, and provide the results to the\n     `hunt_algorithm_done` callback.",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_request",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_request(hash_value: int, timeout=None) -> Union[None, list]:\n    \"\"\"\n    Perform the actual request, and provide the results to the\n     `hunt_algorithm_done` callback.\n    This function is required to be a coroutine for seamless timeout handling.\n    \"\"\"\n    global HASHDB_REQUEST_LOCK, HASHDB_API_URL\n    # Attempt to find matches\n    match_results = None\n    try:",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm_run",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm_run(timeout: Union[int, float] = 0) -> bool:\n    global HASHDB_REQUEST_LOCK, HASHDB_USE_XOR, HASHDB_XOR_VALUE\n    # Get the selected hash value\n    try:\n        hash_value = parse_highlighted_value()\n    except HashDBError as exception:\n        ida_kernwin.msg(f\"HashDB ERROR: {exception}\\n\")\n        logging.warning(\"Failed to parse a hash value from the highlighted text.\")\n        return True  # Release the lock\n    # Xor option",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "hunt_algorithm",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def hunt_algorithm():\n    \"\"\"\n    Search for an algorithm using a hash value.\n    The function will spawn a new thread with a timeout (`HASHDB_REQUEST_TIMEOUT`).\n     While executing, the request lock is acquired.\n    \"\"\"\n    # Check if we're already running a request\n    global HASHDB_REQUEST_LOCK, HASHDB_REQUEST_TIMEOUT\n    timeout_string = \"{}\".format(HASHDB_REQUEST_TIMEOUT) + \" second{}\".format('s' if HASHDB_REQUEST_TIMEOUT != 1 else \"\")\n    if HASHDB_REQUEST_LOCK.locked():",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "inject_actions",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def inject_actions(form, popup, form_type):\n    \"\"\"\n    Inject actions to popup menu(s) based on context.\n    \"\"\"\n    #\n    # disassembly window\n    #\n    if (form_type == BWN_DISASM) or (form_type == BWN_PSEUDOCODE):\n        # insert the action entry into the menu\n        #",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return HashDB_Plugin_t()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "__AUTHOR__",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "__AUTHOR__ = '@herrcore'\nPLUGIN_NAME = \"HashDB\"\nPLUGIN_HOTKEY = 'Alt+`'\nVERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "PLUGIN_NAME",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "PLUGIN_NAME = \"HashDB\"\nPLUGIN_HOTKEY = 'Alt+`'\nVERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------\nmajor, minor = map(int, idaapi.get_kernel_version().split(\".\"))",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "PLUGIN_HOTKEY",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "PLUGIN_HOTKEY = 'Alt+`'\nVERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------\nmajor, minor = map(int, idaapi.get_kernel_version().split(\".\"))\nassert (major > 6),\"ERROR: HashDB plugin requires IDA v7+\"",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "VERSION = '1.10.0'\nimport sys\nimport time\nimport idaapi\n#--------------------------------------------------------------------------\n# IDA Python version madness\n#--------------------------------------------------------------------------\nmajor, minor = map(int, idaapi.get_kernel_version().split(\".\"))\nassert (major > 6),\"ERROR: HashDB plugin requires IDA v7+\"\nassert (sys.version_info >= (3, 5)), \"ERROR: HashDB plugin requires Python 3.5\"",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "IDA_9",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "IDA_9 = major >= 9\nif IDA_9:\n    import ida_ida\nelse:\n    import ida_enum\nimport idc\nimport ida_kernwin\nimport ida_name\nimport ida_bytes\nimport ida_netnode",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_REPORT_BUG_URL",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_REPORT_BUG_URL = \"https://github.com/OALabs/hashdb-ida/issues/new\"\ndef hashdb_exception_hook(exception_type, value, traceback_object):\n    is_hashdb_exception = False\n    frame_data = {\n        \"user_data\": {\n            \"platform\": sys.platform,\n            \"python_version\": '.'.join([str(sys.version_info.major), str(sys.version_info.minor), str(sys.version_info.micro)]),\n            \"plugin_version\": VERSION,\n            \"ida\": {\n                \"kernel_version\": ida_kernwin.get_kernel_version(),",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "sys.excepthook",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "sys.excepthook = hashdb_exception_hook\n# Rest of the imports\nimport re\nimport functools\nimport requests\nfrom typing import Union\n# These imports are specific to the Worker implementation\nimport inspect\nimport logging\nimport threading",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_USE_XOR",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_USE_XOR = False\nHASHDB_XOR_VALUE = 0\nHASHDB_ALGORITHM = None\nHASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_XOR_VALUE",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_XOR_VALUE = 0\nHASHDB_ALGORITHM = None\nHASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_ALGORITHM",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_ALGORITHM = None\nHASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_ALGORITHM_SIZE",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_ALGORITHM_SIZE = 0\nENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "ENUM_PREFIX",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "ENUM_PREFIX = \"hashdb_strings\"\nNETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "NETNODE_NAME",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "NETNODE_NAME = \"$hashdb\"\n# Variables for async operations\nHASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_REQUEST_TIMEOUT",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_REQUEST_TIMEOUT = 15 # Limit to 15 seconds\nHASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',\n                          b'\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00',\n                          b'\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_REQUEST_LOCK",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_REQUEST_LOCK = threading.Lock()\n#--------------------------------------------------------------------------\n# Setup Icon\n#--------------------------------------------------------------------------\nHASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',\n                          b'\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00',\n                          b'\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00',\n                          b'\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x18(\\xba',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASH_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASH_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08',\n                          b'\\x04\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca',\n                          b'\\x05\\x00\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80',\n                          b'\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00',\n                          b'\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00',\n                          b'\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x18(\\xba',\n                          b'\\xecz-\\x00\\x00\\x01#IDAT(\\xcfm\\xd1\\xbdJ\\x9ba\\x18\\xc6\\xf1_\\xde<\\xd5d\\x08\\xc1',\n                          b'\\xb46\\x967!\\x1d,\\x88\\xd0\\xa1P\\xe8\\x01\\x14\\x0c\\xb8\\xbbt\\xa9\\xa3\\x07\\xd0\\xb9',\n                          b'\\xab \\x1e\\x83s\\x87R\\xa4]K\\xe8\".*NEpJZL\\x9b\\xa2V\\x90\\xc6\\xa4\\xc6\\xc7%\\x92\\xa0',\n                          b'\\xfe\\xd7\\xeb\\xe6\\xe6\\xfa`\\x9c\\x8c\\x82\\x04\\xe4\\xe4\\xdd\\xc3\\xb4\\x0fV\\x95\\xf0',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASH_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASH_ICON = ida_kernwin.load_custom_icon(data=HASH_ICON_DATA, format=\"png\")\nXOR_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                         b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                         b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00',\n                         b'u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff',\n                         b'\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a',\n                         b'\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x0b\";\\xd6\\xd2\\xa1\\x00\\x00\\x00\\xc3',\n                         b'IDAT(\\xcf\\xa5\\xd01N\\x02\\x01\\x14\\x04\\xd0\\x07B01\\x9a\\x10b\\x89%\\t\\x8dg\\xa0\\xd0f-\\xb8',\n                         b'\\x80x\\x86\\x8d\\r\\xd9#X\\xee\\x05(\\x94\\x0b\\xd0\\xd0@A\\xcb\\t4\\xdb\\x98\\xd8Z\\x90\\xacv\\x82',\n                         b'Z,\\xac\\xab1P0\\xdd\\xfc\\xcc\\x9f\\xcc\\x0c\\xfb\\xa2\\xf4\\x8bU\\x9c \\xb5\\xfcOPu\\xe9F\\x0b',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "XOR_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "XOR_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                         b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                         b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00',\n                         b'u0\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff',\n                         b'\\x87\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a',\n                         b'\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x18\\x12\\x0b\";\\xd6\\xd2\\xa1\\x00\\x00\\x00\\xc3',\n                         b'IDAT(\\xcf\\xa5\\xd01N\\x02\\x01\\x14\\x04\\xd0\\x07B01\\x9a\\x10b\\x89%\\t\\x8dg\\xa0\\xd0f-\\xb8',\n                         b'\\x80x\\x86\\x8d\\r\\xd9#X\\xee\\x05(\\x94\\x0b\\xd0\\xd0@A\\xcb\\t4\\xdb\\x98\\xd8Z\\x90\\xacv\\x82',\n                         b'Z,\\xac\\xab1P0\\xdd\\xfc\\xcc\\x9f\\xcc\\x0c\\xfb\\xa2\\xf4\\x8bU\\x9c \\xb5\\xfcOPu\\xe9F\\x0b',\n                         b'\\x89{\\x13\\x1f\\xd9\\xf9 \\xff\\xbd\\x15\\x99;\\xf2.\\x11\\xaa\\x99\\xfb,\\x9a_y\\x12 \\x16#X3',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "XOR_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "XOR_ICON = ida_kernwin.load_custom_icon(data=XOR_ICON_DATA, format=\"png\")\nHUNT_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                          b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                          b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0',\n                          b'\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87',\n                          b'\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18',\n                          b'\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x1d\\x10#\"R\\xd1XW\\x00\\x00\\x01.IDAT(\\xcf\\x8d\\xd1;K\\x9b',\n                          b'\\x01\\x18\\xc5\\xf1\\x9fI\\xa8C\\xbd\\xf1\\x0e\\xdd\\xd2\\xc5NJ\\x07;h\\xd5\\xa1\\xf1\\x0bT\\xd4M',\n                          b'\\x14//\\x82\\xad\\x8b\\x83\\x93`\\xf1\\x02~\\x84\\x08-b\\x1c\\xea\\xe6\\xe2 \\x08^\\x9aAQ\\x07\\x87',\n                          b'R\\x9d:\\x99Atx\\x15\\xab`\\xbc\\xd0\\x0eitS\\xcf\\xf2\\xc0\\xe1\\xf0\\x1c\\xf8\\x9f\\x12\\x0f*Q!@',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HUNT_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HUNT_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04',\n                          b'\\x00\\x00\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00',\n                          b'\\x00\\x00 cHRM\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0',\n                          b'\\x00\\x00\\xea`\\x00\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87',\n                          b'\\x8f\\xcc\\xbf\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18',\n                          b'\\x00\\x00\\x00\\x07tIME\\x07\\xe5\\t\\x1d\\x10#\"R\\xd1XW\\x00\\x00\\x01.IDAT(\\xcf\\x8d\\xd1;K\\x9b',\n                          b'\\x01\\x18\\xc5\\xf1\\x9fI\\xa8C\\xbd\\xf1\\x0e\\xdd\\xd2\\xc5NJ\\x07;h\\xd5\\xa1\\xf1\\x0bT\\xd4M',\n                          b'\\x14//\\x82\\xad\\x8b\\x83\\x93`\\xf1\\x02~\\x84\\x08-b\\x1c\\xea\\xe6\\xe2 \\x08^\\x9aAQ\\x07\\x87',\n                          b'R\\x9d:\\x99Atx\\x15\\xab`\\xbc\\xd0\\x0eitS\\xcf\\xf2\\xc0\\xe1\\xf0\\x1c\\xf8\\x9f\\x12\\x0f*Q!@',\n                          b'\\xe4\\xdc\\xdf\\x07\\xb3xkuz\\xe7\\x05\\xae\\xedY\\xb0_\\x08\\x15\\x02\\t=\\x06l\\xdap\\x89\\x97Z4',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HUNT_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HUNT_ICON = ida_kernwin.load_custom_icon(data=HUNT_ICON_DATA, format=\"png\")\nSCAN_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04\\x00\\x00',\n                          b'\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00\\x00\\x00 cHRM',\n                          b'\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00',\n                          b'\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00',\n                          b'\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07',\n                          b'\\xe5\\n\\x08\\x17\\x1c\\x04\\xfd*<n\\x00\\x00\\x01#IDAT(\\xcfe\\xd1\\xb1K\\xe2\\x01\\x18\\xc6\\xf1\\x8f',\n                          b'\\xf6\\xcb\\xeb\\xd0\\x04\\xc7 \\xa8Ii\\x89\\xa2\\xed~\\x16\\xc4m\\xd6\\xbf\\xd0\\x18\\xed\\xd1m\\x07F-ECK',\n                          b'\\xa0K\\xc49_\\rACk\\x10\\xdc\\x12\\x04\\x91qR\\xd2\\xd0PS\\xd7\\xa0h\\x905\\xe8\\x85\\xd9\\xf7\\x1d\\xdfgx',\n                          b'\\xdf\\xe7K\\x9b@\\xa8\\xa8\\xa2aO\\x9f.\\x02\\x90\\xb2l\\xc9\\x80\\xb2s\\'ZzH)i\\xda\\x17\\x8a\\x8b\\x89',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "SCAN_ICON_DATA",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "SCAN_ICON_DATA = b\"\".join([b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x08\\x04\\x00\\x00',\n                          b'\\x00\\xb5\\xfa7\\xea\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00\\x00\\x00 cHRM',\n                          b'\\x00\\x00z&\\x00\\x00\\x80\\x84\\x00\\x00\\xfa\\x00\\x00\\x00\\x80\\xe8\\x00\\x00u0\\x00\\x00\\xea`\\x00',\n                          b'\\x00:\\x98\\x00\\x00\\x17p\\x9c\\xbaQ<\\x00\\x00\\x00\\x02bKGD\\x00\\xff\\x87\\x8f\\xcc\\xbf\\x00\\x00',\n                          b'\\x00\\tpHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18\\x00\\x00\\x00\\x07tIME\\x07',\n                          b'\\xe5\\n\\x08\\x17\\x1c\\x04\\xfd*<n\\x00\\x00\\x01#IDAT(\\xcfe\\xd1\\xb1K\\xe2\\x01\\x18\\xc6\\xf1\\x8f',\n                          b'\\xf6\\xcb\\xeb\\xd0\\x04\\xc7 \\xa8Ii\\x89\\xa2\\xed~\\x16\\xc4m\\xd6\\xbf\\xd0\\x18\\xed\\xd1m\\x07F-ECK',\n                          b'\\xa0K\\xc49_\\rACk\\x10\\xdc\\x12\\x04\\x91qR\\xd2\\xd0PS\\xd7\\xa0h\\x905\\xe8\\x85\\xd9\\xf7\\x1d\\xdfgx',\n                          b'\\xdf\\xe7K\\x9b@\\xa8\\xa8\\xa2aO\\x9f.\\x02\\x90\\xb2l\\xc9\\x80\\xb2s\\'ZzH)i\\xda\\x17\\x8a\\x8b\\x89',\n                          b'\\xf6\\xae\\xa3\\xd65m\\x88\\xcbXud\\xa57\\x12z\\xf0[\\xc2\\xbc\\xaa\\xbaK?{\\x03EO\\xa6e\\\\\\xbb\\x94',",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "SCAN_ICON",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "SCAN_ICON = ida_kernwin.load_custom_icon(data=SCAN_ICON_DATA, format=\"png\")\n#--------------------------------------------------------------------------\n# Error class\n#--------------------------------------------------------------------------\nclass HashDBError(Exception):\n    pass\n#--------------------------------------------------------------------------\n# Worker implementation\n#--------------------------------------------------------------------------\n@dataclass(unsafe_hash=True)",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "p_initialized",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "p_initialized = False\n# Global plugin object\nHASHDB_PLUGIN_OBJECT = None\n# Register IDA plugin\ndef PLUGIN_ENTRY():\n    return HashDB_Plugin_t()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "HASHDB_PLUGIN_OBJECT",
        "kind": 5,
        "importPath": "plugins.hashdb",
        "description": "plugins.hashdb",
        "peekOfCode": "HASHDB_PLUGIN_OBJECT = None\n# Register IDA plugin\ndef PLUGIN_ENTRY():\n    return HashDB_Plugin_t()",
        "detail": "plugins.hashdb",
        "documentation": {}
    },
    {
        "label": "Hyara_action_handler_t",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class Hyara_action_handler_t(idaapi.action_handler_t):\n    def __init__(self, widget):\n        idaapi.action_handler_t.__init__(self)\n        self.widget = widget\n    def activate(self, ctx):\n        self.widget.setText(hex(idaapi.get_screen_ea()))\n        return 1\n    def update(self, ctx):\n        return idaapi.AST_ENABLE_ALWAYS\nclass Hooks(ida_kernwin.UI_Hooks):",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "Hooks",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class Hooks(ida_kernwin.UI_Hooks):\n    def __init__(self):\n        ida_kernwin.UI_Hooks.__init__(self)\n    def finish_populating_widget_popup(self, widget, popup):\n        ida_kernwin.attach_action_to_popup(widget, popup, \"Hyara:select_start_address\", None)\n        ida_kernwin.attach_action_to_popup(widget, popup, \"Hyara:select_end_address\", None)\nclass HyaraWidget(ida_kernwin.PluginForm):\n    def OnCreate(self, form):\n        self.parent = self.FormToPyQtWidget(form)\n        self.HyaraIDA = HyaraIDA()",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "HyaraWidget",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class HyaraWidget(ida_kernwin.PluginForm):\n    def OnCreate(self, form):\n        self.parent = self.FormToPyQtWidget(form)\n        self.HyaraIDA = HyaraIDA()\n        self.parent.setLayout(self.HyaraIDA.layout)\n        idaapi.register_action(\n            ida_kernwin.action_desc_t(\n                \"Hyara:select_start_address\",\n                \"Hyara - Select Start Address\",\n                Hyara_action_handler_t(self.HyaraIDA._start_address),",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "HyaraPlugin",
        "kind": 6,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "class HyaraPlugin(idaapi.plugin_t):\n    # https://www.hex-rays.com/products/ida/support/sdkdoc/group___p_l_u_g_i_n__.html\n    flags = idaapi.PLUGIN_UNL\n    comment = \"Hyara\"\n    help = \"help\"\n    wanted_name = \"Hyara\"\n    wanted_hotkey = \"Ctrl+Shift+Y\"\n    def init(self):\n        global hooks\n        idaapi.msg(\"[*] Hyara Plugin\\n\")",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.Hyara_IDA",
        "description": "plugins.Hyara_IDA",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return HyaraPlugin()",
        "detail": "plugins.Hyara_IDA",
        "documentation": {}
    },
    {
        "label": "ActionManager",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ActionManager(object):\n    def __init__(self):\n        self.__actions = []\n    def register(self, action):\n        self.__actions.append(action)\n        idaapi.register_action(\n            idaapi.action_desc_t(action.name, action.description, action, action.hotkey)\n        )\n    def initialize(self):\n        pass",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "Action",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class Action(idaapi.action_handler_t):\n    \"\"\"\n    Convenience wrapper with name property allowing to be registered in IDA using ActionManager\n    \"\"\"\n    description = None\n    hotkey = None\n    def __init__(self):\n        super(Action, self).__init__()\n    @property\n    def name(self):",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "Configuration",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class Configuration:\n    def __init__(self) -> None:\n        self.frida_cmd = \"\"\"frida -U --attach-name=\"com.example.app\" -l gen.js --no-pause\"\"\"\n        self.template = default_template\n        if os.path.exists(\"IDAFrida.json\"):\n            self.load()\n    def set_frida_cmd(self, s):\n        self.frida_cmd = s\n        self.store()\n    def set_template(self, s):",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "ConfigurationUI",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ConfigurationUI(QDialog):\n    def __init__(self, conf: Configuration) -> None:\n        super(ConfigurationUI, self).__init__()\n        self.conf = conf\n        self.edit_template = QTextEdit()\n        self.edit_template.setPlainText(self.conf.template)\n        layout = QHBoxLayout()\n        layout.addWidget(self.edit_template)\n        self.setLayout(layout)\n    def closeEvent(self, a0) -> None:",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "ScriptGenerator",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ScriptGenerator:\n    def __init__(self, configuration: Configuration) -> None:\n        self.conf = configuration\n        self.imagebase = idaapi.get_imagebase()\n    @staticmethod\n    def get_idb_filename():\n        return os.path.basename(idaapi.get_input_file_path())\n    @staticmethod\n    def get_idb_path():\n        return os.path.dirname(idaapi.get_input_file_path())",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "Frida",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class Frida:\n    def __init__(self, conf: Configuration) -> None:\n        self.conf = conf\nclass IDAFridaMenuAction(Action):\n    TopDescription = \"IDAFrida\"\n    def __init__(self):\n        super(IDAFridaMenuAction, self).__init__()\n    def activate(self, ctx) -> None:\n        raise NotImplemented\n    def update(self, ctx) -> None:",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "IDAFridaMenuAction",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class IDAFridaMenuAction(Action):\n    TopDescription = \"IDAFrida\"\n    def __init__(self):\n        super(IDAFridaMenuAction, self).__init__()\n    def activate(self, ctx) -> None:\n        raise NotImplemented\n    def update(self, ctx) -> None:\n        if ctx.widget_type == idaapi.BWN_FUNCS or ctx.widget_type==idaapi.BWN_PSEUDOCODE or ctx.widget_type==idaapi.BWN_DISASM:\n            idaapi.attach_action_to_popup(ctx.widget, None, self.name, self.TopDescription + \"/\")\n            return idaapi.AST_ENABLE_FOR_WIDGET",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "GenerateFridaHookScript",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class GenerateFridaHookScript(IDAFridaMenuAction):\n    description = \"Generate Frida Script\"\n    def __init__(self):\n        super(GenerateFridaHookScript, self).__init__()\n    def activate(self, ctx):\n        gen = ScriptGenerator(global_config)\n        idb_path = os.path.dirname(idaapi.get_input_file_path())\n        out_file = os.path.join(idb_path, \"IDAhook.js\")\n        if ctx.widget_type==idaapi.BWN_FUNCS:\n            selected = [idaapi.getn_func(idx).start_ea for idx in ctx.chooser_selection] #from \"idaapi.getn_func(idx - 1)\" to \"idaapi.getn_func(idx)\"",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "RunGeneratedScript",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class RunGeneratedScript(IDAFridaMenuAction):\n    description = \"Run Generated Script\"\n    def __init__(self):\n        super(RunGeneratedScript, self).__init__()\n    def activate(self, ctx):\n        print(\"template\")\nclass ViewFridaTemplate(IDAFridaMenuAction):\n    description = \"View Frida Template\"\n    def __init__(self):\n        super(ViewFridaTemplate, self).__init__()",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "ViewFridaTemplate",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class ViewFridaTemplate(IDAFridaMenuAction):\n    description = \"View Frida Template\"\n    def __init__(self):\n        super(ViewFridaTemplate, self).__init__()\n    def activate(self, ctx):\n        ui = ConfigurationUI(global_config)\n        ui.show()\n        ui.exec_()\nclass SetFridaRunCommand(IDAFridaMenuAction):\n    description = \"Set Frida Command\"",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "SetFridaRunCommand",
        "kind": 6,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "class SetFridaRunCommand(IDAFridaMenuAction):\n    description = \"Set Frida Command\"\n    def __init__(self):\n        super(SetFridaRunCommand, self).__init__()\n    def activate(self, ctx):\n        print(\"template\")\naction_manager.register(GenerateFridaHookScript())\n# action_manager.register(RunGeneratedScript())\naction_manager.register(ViewFridaTemplate())\n# action_manager.register(SetFridaRunCommand())",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "action_manager",
        "kind": 5,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "action_manager = ActionManager()\nclass Action(idaapi.action_handler_t):\n    \"\"\"\n    Convenience wrapper with name property allowing to be registered in IDA using ActionManager\n    \"\"\"\n    description = None\n    hotkey = None\n    def __init__(self):\n        super(Action, self).__init__()\n    @property",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "default_template",
        "kind": 5,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "default_template = \"\"\"\nconst MODULE_NAME=\"[filename]\";\nlet isFoudModule = false;\nlet isHooked = false;\n // @ts-ignore\nfunction print_arg(addr) {\n    try {\n        var module = Process.findRangeByAddress(addr);\n        if (module != null) return \"\\\\n\"+hexdump(addr) + \"\\\\n\";\n        return ptr(addr) + \"\\\\n\";",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "global_config",
        "kind": 5,
        "importPath": "plugins.IDAFrida",
        "description": "plugins.IDAFrida",
        "peekOfCode": "global_config = Configuration()\nclass ConfigurationUI(QDialog):\n    def __init__(self, conf: Configuration) -> None:\n        super(ConfigurationUI, self).__init__()\n        self.conf = conf\n        self.edit_template = QTextEdit()\n        self.edit_template.setPlainText(self.conf.template)\n        layout = QHBoxLayout()\n        layout.addWidget(self.edit_template)\n        self.setLayout(layout)",
        "detail": "plugins.IDAFrida",
        "documentation": {}
    },
    {
        "label": "CBaseTreeViewer",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CBaseTreeViewer(PluginForm):\n  def populate_tree(self, d):\n    # Clear previous items\n    self.tree.clear()\n    # Build the tree\n    for key in d:\n      src_file_item = QtWidgets.QTreeWidgetItem(self.tree)\n      src_file_item.setText(0, key)\n      src_file_item.ea = BADADDR\n      for ea, name, str_data in d[key]:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "command_handler_t",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class command_handler_t(ida_kernwin.action_handler_t):\n  def __init__(self, obj, cmd_id, num_args = 1):\n    self.obj = obj\n    self.cmd_id = cmd_id\n    self.num_args = num_args\n    ida_kernwin.action_handler_t.__init__(self)\n  def activate(self, ctx):\n    if self.num_args == 1:\n      return self.obj.OnCommand(self.cmd_id)\n    return self.obj.OnCommand(self.obj, self.cmd_id)",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CIDAMagicStringsChooser",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CIDAMagicStringsChooser(Choose):\n  def __init__(self, title, columns, options):\n    Choose.__init__(self, title, columns, options)\n    self.actions = []\n  def AddCommand(self, menu_name, shortcut=None):\n    action_name = \"IDAMagicStrings:%s\" % menu_name.replace(\" \", \"\")\n    self.actions.append([len(self.actions), action_name, menu_name, shortcut])\n    return len(self.actions)-1\n  def OnPopup(self, form, popup_handle):\n    for num, action_name, menu_name, shortcut in self.actions:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CSourceFilesChooser",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CSourceFilesChooser(CIDAMagicStringsChooser):\n  def __init__(self, title):\n    columns = [ [\"Line\", 4], [\"Full path\", 20], [\"Filename\", 15], [\"EA\", 16], [\"Function Name\", 18], [\"String data\", 40], ]\n    CIDAMagicStringsChooser.__init__(self, title, columns, Choose.CH_MULTI)\n    self.n = 0\n    self.icon = -1\n    self.selcount = 0\n    self.modal = False\n    self.items = []\n    self.selected_items = []",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CCandidateFunctionNames",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CCandidateFunctionNames(CIDAMagicStringsChooser):\n  def __init__(self, title, final_list):\n    columns = [ [\"Line\", 4], [\"EA\", 16], [\"Function Name\", 25], [\"Candidate\", 25], [\"FP?\", 2], [\"Strings\", 50], ]\n    CIDAMagicStringsChooser.__init__(self, title, columns, Choose.CH_MULTI)\n    self.n = 0\n    self.icon = -1\n    self.selcount = 0\n    self.modal = False\n    self.items = []\n    self.selected_items = []",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CClassXRefsChooser",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CClassXRefsChooser(idaapi.Choose):\n  def __init__(self, title, items):\n    idaapi.Choose.__init__(self, title, [ [\"Address\", 8], [\"String\", 80] ])\n    self.items = items\n  def OnGetLine(self, n):\n    return self.items[n]\n  def OnGetSize(self):\n    return len(self.items)\n#-------------------------------------------------------------------------------\ndef get_string(ea):",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CClassesTreeViewer",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CClassesTreeViewer(PluginForm):\n  def populate_tree(self):\n    # Clear previous items\n    self.tree.clear()\n    self.nodes = {}\n    self.classes = sorted(self.classes, key=lambda x: x[1][0])\n    for ea, tokens in self.classes:\n      for i, node_name in enumerate(tokens):\n        full_name = \"::\".join(tokens[:tokens.index(node_name)+1])\n        if full_name not in self.nodes:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CClassesGraph",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CClassesGraph(idaapi.GraphViewer):\n  def __init__(self, title, classes, final_list):\n    idaapi.GraphViewer.__init__(self, title)\n    self.selected = None\n    self.classes = classes\n    self.final_list = final_list\n    self.nodes = {}\n    self.nodes_ea = {}\n    self.graph = {}\n    self.last_cmd = 0",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "CFakeString",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class CFakeString:\n  def __init__(self, ea, s):\n    self.ea = ea\n    self.s = s\n  def __str__(self):\n    return str(self.s)\n  def __repr__(self):\n    return self.__str__()\n#-------------------------------------------------------------------------------\ndef find_function_names(strings_list):",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "magicstrings",
        "kind": 6,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "class magicstrings(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"IDA Magic Strings plugin\"\n    help = \"This is magicstrings help\"\n    wanted_name = \"Magic Strings\"\n    wanted_hotkey = \"\"\n    def init(self):\n        return idaapi.PLUGIN_OK\n    def run(self, arg):\n        main()",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "nltk_preprocess",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def nltk_preprocess(strings):\n  if not has_nltk:\n    return\n  strings = \"\\n\".join(map(str, list(strings)))\n  tokens = re.findall(FUNCTION_NAMES_REGEXP, strings)\n  l = []\n  for token in tokens:\n    l.append(token[0])\n  word_tags = nltk.pos_tag(l)\n  for word, tag in word_tags:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_strings",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_strings(strtypes = [0, 1]):\n  strings = Strings()\n  strings.setup(strtypes = strtypes)\n  return strings\n#-------------------------------------------------------------------------------\ndef get_lang(full_path):\n  _, file_ext  = os.path.splitext(full_path.lower())\n  file_ext = file_ext.strip(\".\")\n  for key in LANGS:\n    if file_ext in LANGS[key]:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_lang",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_lang(full_path):\n  _, file_ext  = os.path.splitext(full_path.lower())\n  file_ext = file_ext.strip(\".\")\n  for key in LANGS:\n    if file_ext in LANGS[key]:\n      return key\n  return None\n#-------------------------------------------------------------------------------\ndef add_source_file_to(d, src_langs, refs, full_path, s):\n  if full_path not in d:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "add_source_file_to",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def add_source_file_to(d, src_langs, refs, full_path, s):\n  if full_path not in d:\n    d[full_path] = []\n  lang = get_lang(full_path)\n  if lang is not None:\n    src_langs[lang] += 1\n  for ref in refs:\n    d[full_path].append([ref, get_func_name(ref), str(s)])\n  return d, src_langs\n#-------------------------------------------------------------------------------",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_source_strings",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_source_strings(min_len = 4, strtypes = [0, 1]):\n  strings = get_strings(strtypes)\n  # Search string references to source files\n  src_langs = Counter()\n  total_files = 0\n  d = {}\n  for s in strings:\n    if s and s.length > min_len:\n      ret = re.findall(SOURCE_FILES_REGEXP, str(s), re.IGNORECASE)\n      if ret and len(ret) > 0:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def handler(item, column_no):\n  ea = item.ea\n  if is_mapped(ea):\n    jumpto(ea)\n#-------------------------------------------------------------------------------\nclass CBaseTreeViewer(PluginForm):\n  def populate_tree(self, d):\n    # Clear previous items\n    self.tree.clear()\n    # Build the tree",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "basename",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def basename(path):\n  pos1 = path[::-1].find(\"\\\\\")\n  pos2 = path[::-1].find(\"/\")\n  if pos1 == -1: pos1 = len(path)\n  if pos2 == -1: pos2 = len(path)\n  pos = min(pos1, pos2)\n  return path[len(path)-pos:]\n#-------------------------------------------------------------------------------\nclass command_handler_t(ida_kernwin.action_handler_t):\n  def __init__(self, obj, cmd_id, num_args = 1):",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "get_string",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def get_string(ea):\n  tmp = idc.get_strlit_contents(ea, strtype=0)\n  if tmp is None or len(tmp) == 1:\n    unicode_tmp = idc.get_strlit_contents(ea, strtype=1)\n    if unicode_tmp is not None and len(unicode_tmp) > len(tmp):\n      tmp = unicode_tmp\n  if tmp is None:\n    tmp = \"\"\n  elif type(tmp) != str:\n    tmp = tmp.decode(\"utf-8\")",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "classes_handler",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def classes_handler(item, column_no):\n  if item.childCount() == 0:\n    ea = item.ea\n    if is_mapped(ea):\n      jumpto(ea)\n#-------------------------------------------------------------------------------\nclass CClassesTreeViewer(PluginForm):\n  def populate_tree(self):\n    # Clear previous items\n    self.tree.clear()",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "show_tree",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def show_tree(d = None):\n  tree_frm = CBaseTreeViewer()\n  tree_frm.Show(PROGRAM_NAME + \": Source code tree\", d)\n#-------------------------------------------------------------------------------\ndef seems_function_name(candidate):\n  if len(candidate) >= 6 and candidate.lower() not in NOT_FUNCTION_NAMES:\n    if candidate.upper() != candidate:\n      return True\n  return False\n#-------------------------------------------------------------------------------",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "seems_function_name",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def seems_function_name(candidate):\n  if len(candidate) >= 6 and candidate.lower() not in NOT_FUNCTION_NAMES:\n    if candidate.upper() != candidate:\n      return True\n  return False\n#-------------------------------------------------------------------------------\nclass CFakeString:\n  def __init__(self, ea, s):\n    self.ea = ea\n    self.s = s",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "find_function_names",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def find_function_names(strings_list):\n  rarity = {}\n  func_names = {}\n  raw_func_strings = {}\n  class_objects = []\n  class_tmp_names = []\n  for ea, name in Names():\n    func = idaapi.get_func(ea)\n    if func is None:\n      continue",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "show_function_names",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def show_function_names(strings_list):\n  found_func_names = find_function_names(strings_list)\n  func_names, raw_func_strings, rarity, classes = found_func_names\n  final_list = []\n  for key in func_names:\n    candidates = set()\n    for candidate in func_names[key]:\n      if len(rarity[candidate]) == 1:\n        candidates.add(candidate)\n    if len(candidates) == 1:",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return magicstrings()\ndef main():\n  ch = CSourceFilesChooser(PROGRAM_NAME + \": Source code files\")\n  if len(ch.items) > 0:\n    ch.show()\n  d = ch.d\n  if len(d) > 0:\n    show_tree(d)\n  show_function_names(ch.s)",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "def main():\n  ch = CSourceFilesChooser(PROGRAM_NAME + \": Source code files\")\n  if len(ch.items) > 0:\n    ch.show()\n  d = ch.d\n  if len(d) > 0:\n    show_tree(d)\n  show_function_names(ch.s)\nif __name__ == \"__main__\":\n  main()",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "PROGRAM_NAME",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "PROGRAM_NAME = \"IMS\"\n#-------------------------------------------------------------------------------\nSOURCE_FILES_REGEXP = r\"([a-z_\\/\\\\][a-z0-9_/\\\\:\\-\\.@]+\\.(c|cc|cxx|c\\+\\+|cpp|h|hpp|m|rs|go|ml))($|:| )\"\nLANGS = {}\nLANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "SOURCE_FILES_REGEXP",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "SOURCE_FILES_REGEXP = r\"([a-z_\\/\\\\][a-z0-9_/\\\\:\\-\\.@]+\\.(c|cc|cxx|c\\+\\+|cpp|h|hpp|m|rs|go|ml))($|:| )\"\nLANGS = {}\nLANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS = {}\nLANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"C/C++\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"C/C++\"] = [\"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hpp\"]\nLANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"C\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"C\"] = [\"c\"]\nLANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"C++\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"C++\"] = [\"cc\", \"cxx\", \"cpp\", \"hpp\", \"c++\"]\nLANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"Obj-C\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"Obj-C\"] = [\"m\"]\nLANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"Rust\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"Rust\"] = [\"rs\"]\nLANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"Golang\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"Golang\"] = [\"go\"]\nLANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "LANGS[\"OCaml\"]",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "LANGS[\"OCaml\"] = [\"ml\"]\n#-------------------------------------------------------------------------------\nFUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",\n  \"return\", \"libs\", \"home\", \"ambiguous\", \"internal\", \"request\", \"inserting\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "FUNCTION_NAMES_REGEXP",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "FUNCTION_NAMES_REGEXP = r\"([a-z_][a-z0-9_]+((::)+[a-z_][a-z0-9_]+)*)\"\nCLASS_NAMES_REGEXP    = r\"([a-z_][a-z0-9_]+(::(<[a-z0-9_]+>|~{0,1}[a-z0-9_]+))+)\\({0,1}\"\nNOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",\n  \"return\", \"libs\", \"home\", \"ambiguous\", \"internal\", \"request\", \"inserting\",\n  \"deleting\", \"removing\", \"updating\", \"adding\", \"assertion\", \"flags\",\n  \"overflow\", \"enabled\", \"disabled\", \"enable\", \"disable\", \"virtual\", \"client\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "NOT_FUNCTION_NAMES",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "NOT_FUNCTION_NAMES = [\"copyright\", \"char\", \"bool\", \"int\", \"unsigned\", \"long\",\n  \"double\", \"float\", \"signed\", \"license\", \"version\", \"cannot\", \"error\",\n  \"invalid\", \"null\", \"warning\", \"general\", \"argument\", \"written\", \"report\",\n  \"failed\", \"assert\", \"object\", \"integer\", \"unknown\", \"localhost\", \"native\",\n  \"memory\", \"system\", \"write\", \"read\", \"open\", \"close\", \"help\", \"exit\", \"test\",\n  \"return\", \"libs\", \"home\", \"ambiguous\", \"internal\", \"request\", \"inserting\",\n  \"deleting\", \"removing\", \"updating\", \"adding\", \"assertion\", \"flags\",\n  \"overflow\", \"enabled\", \"disabled\", \"enable\", \"disable\", \"virtual\", \"client\",\n  \"server\", \"switch\", \"while\", \"offset\", \"abort\", \"panic\", \"static\", \"updated\",\n  \"pointer\", \"reason\", \"month\", \"year\", \"week\", \"hour\", \"minute\", \"second\",",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "FOUND_TOKENS",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "FOUND_TOKENS = {}\nTOKEN_TYPES = [\"NN\", \"NNS\", \"NNP\", \"JJ\", \"VB\", \"VBD\", \"VBG\", \"VBN\", \"VBP\", \"VBZ\"]\ndef nltk_preprocess(strings):\n  if not has_nltk:\n    return\n  strings = \"\\n\".join(map(str, list(strings)))\n  tokens = re.findall(FUNCTION_NAMES_REGEXP, strings)\n  l = []\n  for token in tokens:\n    l.append(token[0])",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "TOKEN_TYPES",
        "kind": 5,
        "importPath": "plugins.IDAMagicStrings",
        "description": "plugins.IDAMagicStrings",
        "peekOfCode": "TOKEN_TYPES = [\"NN\", \"NNS\", \"NNP\", \"JJ\", \"VB\", \"VBD\", \"VBG\", \"VBN\", \"VBP\", \"VBZ\"]\ndef nltk_preprocess(strings):\n  if not has_nltk:\n    return\n  strings = \"\\n\".join(map(str, list(strings)))\n  tokens = re.findall(FUNCTION_NAMES_REGEXP, strings)\n  l = []\n  for token in tokens:\n    l.append(token[0])\n  word_tags = nltk.pos_tag(l)",
        "detail": "plugins.IDAMagicStrings",
        "documentation": {}
    },
    {
        "label": "FunctionDecompilerHandler",
        "kind": 6,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "class FunctionDecompilerHandler(ida_kernwin.action_handler_t):\n    model = ''\n    selection = False\n    def __init__(self,model,selection=False):\n        self.model = model\n        self.selection = selection\n        logging.debug(f'aiDAPal: {model} {selection}')\n        ida_kernwin.action_handler_t.__init__(self)\n    # This method is called when the menu item is clicked\n    def activate(self, ctx):",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "DataAnalysisHandler",
        "kind": 6,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "class DataAnalysisHandler(ida_kernwin.action_handler_t):\n    model = ''\n    selection = False\n    def __init__(self,model,selection=False):\n        self.model = model\n        self.selection = selection\n        logging.debug(f'aiDAPal: data analysis {model} {selection}')\n        ida_kernwin.action_handler_t.__init__(self)\n    # This method is called when the menu item is clicked\n    def activate(self, ctx):",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "MyHooks",
        "kind": 6,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "class MyHooks(ida_kernwin.UI_Hooks):\n    def finish_populating_widget_popup(self, widget, popup_handle):\n        # Check if the widget is the disassembly view\n        if ida_kernwin.get_widget_type(widget) == ida_kernwin.BWN_PSEUDOCODE:\n            for action in code_actions:\n                model_name = action.split('_')[0]\n                ida_kernwin.attach_action_to_popup(widget, popup_handle, action, f'aiDAPal/{model_name}/')\n        # Check if the widget is the disassembly view\n        if ida_kernwin.get_widget_type(widget) == ida_kernwin.BWN_DISASM:\n            for action in data_actions:",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "aidapal_add_context",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")\ndef aidapal_get_context():\n    '''\n    print the current manual context\n    '''\n    outstr = ''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "aidapal_get_context",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def aidapal_get_context():\n    '''\n    print the current manual context\n    '''\n    outstr = ''\n    for x in aidapal_manual_juice:\n        outstr += f'{x}\\n'\n    return outstr\ndef do_analysis(code,model_name):\n    url = ollama_url",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "do_analysis",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def do_analysis(code,model_name):\n    url = ollama_url\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\" : f\"Bearer {api_token}\"\n    }\n    payload = {\"model\": model_name, \"prompt\": code, \"stream\": False,\"format\":\"json\"}\n    res = requests.post(url, headers=headers, json=payload)\n    try:\n        t = res.json()['response']",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "do_show_ui",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def do_show_ui(result,cur_func,data_address):\n    aiDAPalUI(result,cur_func,data_address)\n    return False\n# examples/core/dump_selection.py\ndef get_hexrays_selection():\n    '''\n    get highlighted text from the hexrays view\n    return None if no selection\n    '''\n    # dump current selection",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_hexrays_selection",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_hexrays_selection():\n    '''\n    get highlighted text from the hexrays view\n    return None if no selection\n    '''\n    # dump current selection\n    p0 = ida_kernwin.twinpos_t()\n    p1 = ida_kernwin.twinpos_t()\n    view = ida_kernwin.get_current_viewer()\n    logging.debug(f'aiDAPal: getting hexrays selection')",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_widget_lines",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_widget_lines(widget, tp0, tp1):\n    \"\"\"\n    get lines between places tp0 and tp1 in widget\n    \"\"\"\n    ud = ida_kernwin.get_viewer_user_data(widget)\n    lnar = ida_kernwin.linearray_t(ud)\n    lnar.set_place(tp0.at)\n    lines = []\n    while True:\n        cur_place = lnar.get_place()",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "async_call",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def async_call(cur_func,model_name,extra_context=None,selected_code=None,data_address=None):\n    # if we have a selection, get the selection, otherwise use the whole function\n    logging.debug(f'aiDAPal: async call {model_name}')\n    if selected_code:\n        logging.debug('aiDAPal: selection')\n        code = selected_code\n    else:\n        code = str(cur_func)\n    logging.debug(f'aiDAPal: {code}')\n    if extra_context:",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_data_references_query",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_data_references_query(target_data_ea):\n    results = []\n    query = ''\n    target_data_name = ida_name.get_name(target_data_ea)\n    # Ensure the decompiler is available\n    if not ida_hexrays.init_hexrays_plugin():\n        logging.error(f'aiDAPal: Hex-Rays decompiler is not available.')\n        return results\n    target_xrefs = []\n    xrefs = idautils.XrefsTo(target_data_ea)",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "get_function_data_ref_comments",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def get_function_data_ref_comments(current_func_ea):\n    '''\n    extracts string that is a c style comment block of comments for any data refs that\n    have a comment\n    '''\n    if current_func_ea is not None:\n        # Get references from the current function - returns a set of them\n        #references = get_references_from_function(current_func_ea)\n        logging.info(f'aiDAPal: gathering data references for {hex(current_func_ea)}')\n        references = context_juicer.gather_unique_data_references(current_func_ea)",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "unload_plugin",
        "kind": 2,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "def unload_plugin():\n    for model in models:\n        ida_kernwin.unregister_action(model)\n    print(\"aiDAPal unloaded\")\n    global hooks\n    if  hooks is not None:\n        hooks.unhook()\n        hooks = None",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "models = ['aidapal:latest']\n# where ollama service is running\nollama_url = \"\"\napi_token = \"\"\n# most important part - zlib compressed ascii art\nload_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "ollama_url",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "ollama_url = \"\"\napi_token = \"\"\n# most important part - zlib compressed ascii art\nload_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "api_token",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "api_token = \"\"\n# most important part - zlib compressed ascii art\nload_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "load_logo",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "load_logo = b'x\\x9c\\x8dW[\\x8e\\xdc0\\x0c\\xfb\\x9fS\\x180\\xfc#A:\\x80\\x01\\x01\\xb9\\xff\\xa9J\\xd2N&3\\x9bnk\\x14\\xeb\\x8cc3\"\\xf5r[\\xfb\\xd7\\xc8\\xcc\\xc9\\x819\\xff\\xb9\\xb9\\xbd~\\x01\\x9aQn\\xd6{\\x1f{\\xe0\\xd1\\xcc+\\xe6/\\xc0\\x7f\\x01\\xccp[8\\x80\\xe8\\x00\\xc1\\xc0\\x8a]\\x8b\\x1e\\xf3\\xff\\x00S`\\xdb\\xa6nA\\xaaX!`\\xe0\\x01?\\xf1v\\xa3z<X\\xfa\\xfa\\xc0\\xe2\\xa8\\x13\\xcdy\\xdaz\\xb5\\x10U\\xfc)\\xbc\\xd47\\xae/\\xd6\\xc7\\xd1O\\xc0Y2\\x83\\xf2C;R\\x9aAs\\x88P\\x16a%|\\x01\\xe2\\x95{\\xcd\\xb5\\x97c\\xfe\\x04<\\xb1\\x08\\xe6\\xd1\\x9af\\x90\\x02\\x98yK\\xb7\\xd9\\xf84!\\x08Fq\\x07\\xe7\\xd3\\x82\\xfa\\x06L\\xfap\\xbb0\\xf1\\x8fN\\x08 \\x98\\xec\\x08Z\\xa8\\xa3Z\\n:I\\xdb\\xce@\\x18#[\\xdd\\x00\\xe7\\x05\\xe8<@\\xfb\\xa2f\\xd2\\x16\\xae}O0;h#\\xd1\\xfd\\t0e\\xa1\\xa2A|\\'\\xfd:\\x13\\xa7\\xca\\xeb\\x8c\\xea5a\\x01\\xaa\\x00\\xb1\\x12\\xdbD\\x7f\\x85Rn\\xd7\\xbc\\x84\\x97\\xb3\\xd9\\xf2,\\x00\\xa0W1)\\x96\\xe8\\xd9$U2t\\x1cb\\n\\xb88\\x979\\xa4qy\\xfc\\xb0\\xc6\\xf0Z\\x80x\\xe8\\xde\\xeaX\\x81\\xd7\\xe6f\\x07\\x88)\\x18hG\\xad\\xf0\\x87\\xe2\\x07\\x85[j\\x80,=%\\xc0j\\xd6\\x85(\\xca\\x10!\\xf3\\xc4\\xf3s\\x808\\xd1BQ\\x020L\\x0c$\\xc6\\xc8\\xac\\xf7\\xa6\\x10b&\\\\pR\\xae\\x01\\xb5\\xf0\\x17>ny\\xee\\xc4G\\x88 \\x82\\xd1T\\x18bG^\\x9b}\\xa9-\"\\r~\\x1e\\xd5\\x10\\x13\\xc3\\t(\\x07[\\xc3i\\xefz\\xbbd>8\\xfc\\xf2\\x05-\\xbc\\xbc\\xe3zI\\x17b7mP6\\xa5\\x8f\\x010X\\xe8\\xf0\\x05XC\\x8e\\x90\\xdb\\x0chC\\x16\\x80\\x0b\\xebBnK)\\x01\\xde\\xd2u\\xb7]8D<\\x03E\\x9a\\x08\\xc0>\"+\\x8byI\\xc2\\xfd8\\x18\\xc3\\xa9BX\\x9d\\xb6 \\x941\\x8a\\x18GW\\x04\\xb0L\\x84\\xe1\\x97H\\x03+\\xa6\\xcf\\x18\\x9d\\x80\\xd9\\x07\\xcb\\x00\\x0c\\x96\\x81@\\xc0\\x07\\x01\\xda\\xf0\\x1e~\\xb3\\xe3c@x\\x1c\\x88\\x86\\xe5@d\\x10\\x11\\xc7`\\x1b\\xfc\\xe5<\\xf0\\xa2\\xc20\\xd5F\\x87\\x02`\\xc43\\xfc\\xbc,dH\\x8d;\\xde`8\\xcbB\\x91 \\x1b\\xa88q\\xd8(\\x1d \\x04H{\\x8b\\xf0%\\xc2\\x90\\xec\\xccp\\x1c\\xfa\\x04d\\x0e\\xec\\x81o\\x92t\\x11pQf`\\x88r\\xc9\\xde\\xc1T\\x02 f\\xf0\\x90j\\x08\\xb3\\xfa\\xa4\\x0c9\\\\\\x8aB\\x1d\\x00\\x91s\\x10\\x90\\x10\\xd5E\\x19l7\\xa0\\x8b>\\x10c\\xd5(V\\xbc\\x15\"\\xa6!\\x13Y\\x19|U\\xb6\\x1a\\n\\x9e$Y\\x01\\x82w{!^\\xc7\\x94\\x8b\\x06#G\\x888v\\xf3+3\\x95\\xe5\\xcf\\xf8\\xf4\\xf6\\xb9\\xebGW\\x0c.\\xca\\x13\\xceb\\x1c6v!5\\xb7\\x8d8p\\xc8\\xde\\xd29\\xaa\\x85O\\xd5\\x82\\xb7\\xcb\\xb5cl<\\x0eB\\xc0\\xc0\\x82\\x86 \\x8a\\x0fD\\xa4\\xb1GLV\\xb7\\xde\\xef\\xbau\\x861\\x83\\xf8s\\x95\\xdb\\x98[\\xf0f\\xc0\\xe7\\xb2\\'Wq \\x7fv\\x11\\xf4\\'\\x95\\x87\\xab\\x15\\x1f\\x8f\\xe3\\xec\\xd1\\x9d\\xa5AQ\\x0c\\x03\\xa7J\\xeeY\\xb1s\\x95w\\xe8\\x8c\\x92T\\xaau\\xe21\\x1e\\xc7\\xa2Xl\\x14\\xec2\\x93M\\x01Oy\\xef)ij\\x92\\xa1\\xa8\\xe7\\xe6Fg\\xda\\x82\\xfd\\x1a\\xc6.\\x0f\\xa1X\\t;\\x9b8\\xd2\\x18V\\xcc\\xaf&U\\xd4\\x1d\\x11\\x8d\\x84\\x03qU.f\\n\\x93&V\\xab\\xa4s\\xafEl0\\x9a\\xca\\xd2K\\xbaW\\xb8\\x9f\\x16\\xae\\xb4\\x88e\\x93\\xb3\\xa7\\xa8\\xfd\\x11c\\xa5E\\xac\\xcc\\xe1\\x02%\\x81\\x0f\\x19~]\\x9c\\xa5^~7z\\x16\\x8d\\xc5\\x89x\\xeb\\xc0\\xb1c\\x99B\\xb0\\xf0\\x9d\\x0b\\xe7\\x06\\xe9\\xdc\\xa3\\xdd\\xc6\\xe7\\xddF\\xce\\x80\\xba2,\\xb6\\x9b\\r\\xf1\\xaa<B&l\\x1f#\\x14\\xb0\\x85Y+\\xbd\\xff\\x0e(\\xcc\\xa9;Q\\xb29\\xb3\\xdd\\x97l/\\xde\\rX=$fk\\xab!\\xce\\xfaq\\x07\\xbb\\x03\\xe6\\xbd\\x01\\xef\\x1b\\xe6\\xfb\\xb2y]:\\xdf\\x1b\\xce)\\x1f\\x01SN\\xacu\\x07\\xa2Ot\\xbb\\xd9}\\x89a\\xcfHUUXO\\xd7\\xbe)=\\x7fzY_g\\x91D\\xe7E\\xd2\"\\xc8\\x99s]%\\xbf\\xb3vr>\\xd0\\x97\\x86\\xa1]c\\x01\\x9d;\\xe3\\xb0e\\xf4\\x93\\x97\\x89\\x87\\xba2\\x80E@TB\\xf4\\x9c\\x89\"\\x8d_\\x8e{\\xc0\\x14 \\xd2\\xda\\x813P|\\xfc\\r\\xf8d![\\xd2a\\xeau!\\xc0\\x80\\x85p:\\x8b\\x06\\x99\"+\\xd8M\\x18\\x87\\xa1\\xc6gG\\x11\\xd9x#\\xc9\\x07\\x0b\\x95\\x00\\xfaZ\\xcc\\xf5\\xb4\\xa3x/\\xcf\\xb86\\xf0q\\xaf\\xef=\\x0fN\\xf9\\x8f\\xff1\\xfc6\\xae\\xe3\\xaf?\\xc7\\xe9%\\xd5'\nprint(zlib.decompress(load_logo).decode('ascii'))\naidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")\ndef aidapal_get_context():\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "aidapal_manual_juice",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "aidapal_manual_juice = []\ndef aidapal_add_context(context_value):\n    '''\n    This function is used to manually add to the global context var aidapal_manual_juice\n    '''\n    aidapal_manual_juice.append(f\"{context_value}\")\ndef aidapal_get_context():\n    '''\n    print the current manual context\n    '''",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "code_actions",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "code_actions = []\ndata_actions = []\nfor model in models:\n    # Register the full function analysis actions\n    action_id = f'{model}_ff'\n    code_actions.append(action_id)\n    action_desc = ida_kernwin.action_desc_t(\n        action_id,   # The unique name of the action\n        f'Full Function', # The label of the menu item\n        FunctionDecompilerHandler(model),    # The action handler class",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "data_actions",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "data_actions = []\nfor model in models:\n    # Register the full function analysis actions\n    action_id = f'{model}_ff'\n    code_actions.append(action_id)\n    action_desc = ida_kernwin.action_desc_t(\n        action_id,   # The unique name of the action\n        f'Full Function', # The label of the menu item\n        FunctionDecompilerHandler(model),    # The action handler class\n        None,                 # Optional shortcut key",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "hooks",
        "kind": 5,
        "importPath": "plugins.idapal",
        "description": "plugins.idapal",
        "peekOfCode": "hooks = MyHooks()\nhooks.hook()\ndef unload_plugin():\n    for model in models:\n        ida_kernwin.unregister_action(model)\n    print(\"aiDAPal unloaded\")\n    global hooks\n    if  hooks is not None:\n        hooks.unhook()\n        hooks = None",
        "detail": "plugins.idapal",
        "documentation": {}
    },
    {
        "label": "FunctionNameWidget",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class FunctionNameWidget(QWidget):\n    accepted = True\n    def __init__(self, function_name):\n        super(FunctionNameWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Function Name\")\n        group_layout = QtWidgets.QHBoxLayout()\n        group_layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_layout.setSpacing(10)",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "CommentWidget",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class CommentWidget(QWidget):\n    accepted = True\n    def __init__(self, comment):\n        super(CommentWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Comment\")\n        group_layout = QtWidgets.QHBoxLayout()\n        group_layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_layout.setSpacing(10)",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "VariableWidget",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class VariableWidget(QWidget):\n    accepted = True\n    def __init__(self, variables):\n        super(VariableWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n        # Create the group box for the variables\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Variables\")\n        group_box_layout = QtWidgets.QVBoxLayout()  # Layout to hold the title and the scroll area\n        # Create the inner grid layout",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "aiDAPalUIForm",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class aiDAPalUIForm(ida_kernwin.PluginForm):\n    ida_pal_results = None\n    current_func = None\n    current_data = None\n    def __init__(self,ida_pal_results,current_func,current_data):\n        super(aiDAPalUIForm, self).__init__()\n        self.ida_pal_results = ida_pal_results\n        self.current_func = current_func\n        self.current_data = current_data\n    def OnCreate(self, form):",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "aiDAPalUI",
        "kind": 6,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "class aiDAPalUI:\n    def __init__(self, ida_pal_results=None,cur_func=None,cur_data=None):\n        if ida_pal_results is None:\n            self.ida_pal_results = example_input\n        else:\n            self.ida_pal_results = ida_pal_results\n        self.plg = aiDAPalUIForm(self.ida_pal_results,cur_func,cur_data)\n        self.plg.Show(\"aiDAPal Results\")",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "example_input",
        "kind": 5,
        "importPath": "plugins.idapal_qt_interface",
        "description": "plugins.idapal_qt_interface",
        "peekOfCode": "example_input = {'function_name': 'ExampleName', 'comment': \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque orci odio, feugiat nec nisi vel, tempus laoreet nunc. Aliquam libero felis, lacinia non imperdiet sit amet, volutpat vitae odio. Phasellus in ligula sit amet nibh posuere malesuada vel sit amet dui. Donec gravida nec elit vitae mollis. Donec sollicitudin, mauris pellentesque tempus sodales, velit orci tempor sapien, at rutrum urna tellus vel mauris. Donec ac rhoncus nisi, vel consequat libero. In dictum neque ligula, sit amet ultricies eros facilisis eu. Donec justo leo, suscipit quis ligula ut, blandit venenatis neque. Duis euismod viverra tellus, quis dapibus purus facilisis condimentum. Donec massa augue, vestibulum nec ipsum vulputate, feugiat volutpat mi. Sed nec nisl ex. Aliquam dapibus ligula ac orci hendrerit, id sodales leo tempus. Aenean vehicula metus vel pellentesque suscipit. Etiam vel dictum massa. Proin vitae varius sapien. Maecenas accumsan nulla rhoncus ipsum consequat, eget commodo sem finibus. Sed sed metus urna. Praesent vel nulla sed nunc feugiat fermentum a a tortor. Etiam auctor sit amet ligula eu tristique. Suspendisse sollicitudin, sem ut tincidunt volutpat, ipsum risus cursus nisl, non aliquet arcu ipsum eget massa. Fusce venenatis, leo eleifend luctus ultrices, quam odio fringilla augue, vitae tempus purus massa eu nulla. Cras a ullamcorper ligula.\", 'variables': [{'original_name': 'a1', 'new_name': 'example1'}, {'original_name': 'a2', 'new_name': 'example2'}, {'original_name': 'a3', 'new_name': 'example3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}, {'original_name': 'v3', 'new_name': 'examplev3'}]}\nclass FunctionNameWidget(QWidget):\n    accepted = True\n    def __init__(self, function_name):\n        super(FunctionNameWidget, self).__init__()\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)\n        group_box = QtWidgets.QGroupBox(\"aiDAPal Function Name\")\n        group_layout = QtWidgets.QHBoxLayout()\n        group_layout.setAlignment(QtCore.Qt.AlignLeft| QtCore.Qt.AlignVCenter)",
        "detail": "plugins.idapal_qt_interface",
        "documentation": {}
    },
    {
        "label": "VulnChoose",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class VulnChoose(idaapi.Choose):\n    \"\"\"\n    Chooser class to display result of format string vuln scan\n    \"\"\"\n    def __init__(self, title, items, icon, embedded=False):\n        idaapi.Choose.__init__(self, title, [[\"Address\", 20], [\"Function\", 30], [\"Format\", 30]], embedded=embedded)\n        self.items = items\n        self.icon = 45\n    def GetItems(self):\n        return self.items",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "hotkey_action_handler_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class hotkey_action_handler_t(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for hotkey actions\n    \"\"\"\n    def __init__(self, action):\n        idaapi.action_handler_t.__init__(self)\n        self.action = action\n    def activate(self, ctx):\n        if self.action == ACTION_COPYEA:\n            ea = idc.get_screen_ea()",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "menu_action_handler_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class menu_action_handler_t(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for menu actions\n    \"\"\"\n    def __init__(self, action):\n        idaapi.action_handler_t.__init__(self)\n        self.action = action\n    def activate(self, ctx):\n        if self.action in ACTION_CONVERT:\n            # convert",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "hexrays_action_handler_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class hexrays_action_handler_t(idaapi.action_handler_t):\n    \"\"\"\n    Action handler for hexrays actions\n    \"\"\"\n    def __init__(self, action):\n        idaapi.action_handler_t.__init__(self)\n        self.action = action\n        self.ret_type = {}\n    def activate(self, ctx):\n        if self.action == ACTION_HX_REMOVERETTYPE:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "UI_Hook",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class UI_Hook(idaapi.UI_Hooks):\n    def __init__(self):\n        idaapi.UI_Hooks.__init__(self)\n    def finish_populating_widget_popup(self, form, popup):\n        form_type = idaapi.get_widget_type(form)\n        if idaapi.IDA_SDK_VERSION >= 900:\n            dump_type = idaapi.BWN_HEXVIEW\n        else:\n            dump_type = idaapi.BWN_DUMP\n        if form_type == idaapi.BWN_DISASM or form_type == dump_type:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "HexRays_Hook",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class HexRays_Hook(object):\n    def callback(self, event, *args):\n        if event == idaapi.hxe_populating_popup:\n            form, phandle, vu = args\n            if vu.item.citype == idaapi.VDI_FUNC or (vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr() and vu.item.e.type.is_funcptr()):\n                idaapi.attach_action_to_popup(form, phandle, ACTION_HX_REMOVERETTYPE, None)\n        elif event == idaapi.hxe_double_click:\n            vu, shift_state = args\n            # auto jump to target if clicked item is xxx->func();\n            if vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr():",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "LazyIDA_t",
        "kind": 6,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "class LazyIDA_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_HIDE\n    comment = \"LazyIDA\"\n    help = \"\"\n    wanted_name = \"LazyIDA\"\n    wanted_hotkey = \"\"\n    def init(self):\n        self.hexrays_inited = False\n        self.registered_actions = []\n        self.registered_hx_actions = []",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "copy_to_clip",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:\n            loc = idc.get_name_ea_simple(loc.encode().strip())",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "clip_text",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:\n            loc = idc.get_name_ea_simple(loc.encode().strip())\n        except:\n            return idaapi.BADADDR",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "parse_location",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:\n            loc = idc.get_name_ea_simple(loc.encode().strip())\n        except:\n            return idaapi.BADADDR\n    return loc\nclass VulnChoose(idaapi.Choose):",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return LazyIDA_t()",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_CONVERT",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_CONVERT = [\"lazyida:convert%d\" % i for i in range(10)]\nACTION_SCANVUL = \"lazyida:scanvul\"\nACTION_COPYEA = \"lazyida:copyea\"\nACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_SCANVUL",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_SCANVUL = \"lazyida:scanvul\"\nACTION_COPYEA = \"lazyida:copyea\"\nACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_COPYEA",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_COPYEA = \"lazyida:copyea\"\nACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_GOTOCLIP",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_GOTOCLIP = \"lazyida:gotoclip\"\nACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_XORDATA",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_XORDATA = \"lazyida:xordata\"\nACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_FILLNOP",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_FILLNOP = \"lazyida:fillnop\"\nACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_REMOVERETTYPE",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_REMOVERETTYPE = \"lazyida:hx_removerettype\"\nACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_COPYEA",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_COPYEA = \"lazyida:hx_copyea\"\nACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_COPYNAME",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_COPYNAME = \"lazyida:hx_copyname\"\nACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ACTION_HX_GOTOCLIP",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ACTION_HX_GOTOCLIP = \"lazyida:hx_gotoclip\"\nu16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "u16",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "u16 = lambda x: unpack(\"<H\", x)[0]\nu32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "u32",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "u32 = lambda x: unpack(\"<I\", x)[0]\nu64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "u64",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "u64 = lambda x: unpack(\"<Q\", x)[0]\nARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "ARCH",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "ARCH = 0\nBITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "BITS",
        "kind": 5,
        "importPath": "plugins.LazyIDA",
        "description": "plugins.LazyIDA",
        "peekOfCode": "BITS = 0\ndef copy_to_clip(data):\n    QApplication.clipboard().setText(data)\ndef clip_text():\n    return QApplication.clipboard().text()\ndef parse_location(loc):\n    try:\n        loc = int(loc, 16)\n    except ValueError:\n        try:",
        "detail": "plugins.LazyIDA",
        "documentation": {}
    },
    {
        "label": "struct_typer_plugin_t",
        "kind": 6,
        "importPath": "plugins.struct_typer_plugin",
        "description": "plugins.struct_typer_plugin",
        "peekOfCode": "class struct_typer_plugin_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_UNL\n    comment = \"This is a comment\"\n    help = \"This is help\"\n    wanted_name = \"StructTyper\"\n    wanted_hotkey = \"\"\n    def init(self):\n        #idaapi.msg(\"StructTyper init() called!\\n\")\n        return idaapi.PLUGIN_OK\n    def run(self, arg):",
        "detail": "plugins.struct_typer_plugin",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.struct_typer_plugin",
        "description": "plugins.struct_typer_plugin",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return struct_typer_plugin_t()",
        "detail": "plugins.struct_typer_plugin",
        "documentation": {}
    },
    {
        "label": "traceNatives",
        "kind": 6,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "class traceNatives(plugin_t):\n    flags = PLUGIN_PROC\n    comment = \"traceNatives\"\n    help = \"\"\n    wanted_name = \"traceNatives\"\n    wanted_hotkey = \"\"\n    def init(self):\n        print(\"traceNatives(v0.1) plugin has been loaded.\")\n        return PLUGIN_OK\n    def run(self, arg):",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "getSoPathAndName",
        "kind": 2,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "def getSoPathAndName():\n    fullpath = ida_nalt.get_input_file_path()\n    filepath,filename = os.path.split(fullpath)\n    return filepath,filename\n# 获取代码段的范围\ndef getSegAddr():\n    textStart = []\n    textEnd = []\n    for seg in idautils.Segments():\n        if (idc.get_segm_name(seg)).lower() == '.text' or (",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "getSegAddr",
        "kind": 2,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "def getSegAddr():\n    textStart = []\n    textEnd = []\n    for seg in idautils.Segments():\n        if (idc.get_segm_name(seg)).lower() == '.text' or (\n        idc.get_segm_name(seg)).lower() == 'text':\n            tempStart = idc.get_segm_start(seg)\n            tempEnd = idc.get_segm_end(seg)\n            textStart.append(tempStart)\n            textEnd.append(tempEnd)",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "PLUGIN_ENTRY",
        "kind": 2,
        "importPath": "plugins.traceNatives",
        "description": "plugins.traceNatives",
        "peekOfCode": "def PLUGIN_ENTRY():\n    return traceNatives()",
        "detail": "plugins.traceNatives",
        "documentation": {}
    },
    {
        "label": "export_structs",
        "kind": 2,
        "importPath": "scripts.export_struct",
        "description": "scripts.export_struct",
        "peekOfCode": "def export_structs():\n    with open(output_file, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:  # 使用 utf-8 编码，并忽略错误\n        # 获取所有结构的数量\n        for idx in range(ida_struct.get_struc_qty()):\n            struct_id = ida_struct.get_struc_by_idx(idx)\n            struct = ida_struct.get_struc(struct_id)\n            if struct:\n                struct_name = ida_struct.get_struc_name(struct_id)\n                f.write(f\"// Structure: {struct_name}\\n\")\n                f.write(f\"struct {struct_name} {{\\n\")",
        "detail": "scripts.export_struct",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "scripts.export_struct",
        "description": "scripts.export_struct",
        "peekOfCode": "output_file = \"C:/Users/jimmy/Projects/flutter-reverse-note/idapro/structures.h\"\ndef export_structs():\n    with open(output_file, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:  # 使用 utf-8 编码，并忽略错误\n        # 获取所有结构的数量\n        for idx in range(ida_struct.get_struc_qty()):\n            struct_id = ida_struct.get_struc_by_idx(idx)\n            struct = ida_struct.get_struc(struct_id)\n            if struct:\n                struct_name = ida_struct.get_struc_name(struct_id)\n                f.write(f\"// Structure: {struct_name}\\n\")",
        "detail": "scripts.export_struct",
        "documentation": {}
    },
    {
        "label": "get_member_name_by_index",
        "kind": 2,
        "importPath": "scripts.find_dartObjectPool_index",
        "description": "scripts.find_dartObjectPool_index",
        "peekOfCode": "def get_member_name_by_index(struct_name, index):\n    struct_id = idc.get_struc_id(struct_name)\n    if struct_id == idc.BADADDR:\n        logger.error(f\"结构体 '{struct_name}' 不存在。\")\n        return None\n    offset = 0\n    while True:\n        member_id = idc.get_member_id(struct_id, offset)\n        if member_id == idc.BADADDR:\n            break",
        "detail": "scripts.find_dartObjectPool_index",
        "documentation": {}
    },
    {
        "label": "search_with_mask",
        "kind": 2,
        "importPath": "scripts.find_dartObjectPool_index",
        "description": "scripts.find_dartObjectPool_index",
        "peekOfCode": "def search_with_mask(start_ea, end_ea, pattern, mask):\n    ea = 0x12FEA90  #start_ea\n    pattern_length = len(pattern)\n    total_size = end_ea - start_ea\n    last_percentage = -1\n    while ea != idaapi.BADADDR and ea < end_ea:\n        # Calculate and log progress percentage\n        current_progress = ea - start_ea\n        current_percentage = int((current_progress / total_size) * 100)\n        if current_percentage != last_percentage and current_percentage % 5 == 0:",
        "detail": "scripts.find_dartObjectPool_index",
        "documentation": {}
    },
    {
        "label": "get_member_name_by_index",
        "kind": 2,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "def get_member_name_by_index(struct_name, index):\n    # 獲取結構體 ID\n    struct_id = idc.get_struc_id(struct_name)\n    if struct_id == idc.BADADDR:\n        print(f\"結構體 '{struct_name}' 不存在。\")\n        return None\n    # 獲取結構體大小\n    struct_size = idc.get_struc_size(struct_id)\n    if index < 0 or index >= struct_size:\n        print(f\"索引 {index} 超出結構體 '{struct_name}' 的範圍（大小為 {struct_size}）。\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "struct_name",
        "kind": 5,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "struct_name = \"DartObjectPool\"\nindex = 0xD9C8  # 替換為您的索引值\nmember_name = get_member_name_by_index(struct_name, index)\nif member_name:\n    print(f\"結構體 '{struct_name}' 中索引 {index} 對應的成員名稱為: {member_name}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 5,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "index = 0xD9C8  # 替換為您的索引值\nmember_name = get_member_name_by_index(struct_name, index)\nif member_name:\n    print(f\"結構體 '{struct_name}' 中索引 {index} 對應的成員名稱為: {member_name}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "member_name",
        "kind": 5,
        "importPath": "scripts.find_dartObjectPool_member",
        "description": "scripts.find_dartObjectPool_member",
        "peekOfCode": "member_name = get_member_name_by_index(struct_name, index)\nif member_name:\n    print(f\"結構體 '{struct_name}' 中索引 {index} 對應的成員名稱為: {member_name}\")",
        "detail": "scripts.find_dartObjectPool_member",
        "documentation": {}
    },
    {
        "label": "WPSearch",
        "kind": 6,
        "importPath": "scripts.wpsearch",
        "description": "scripts.wpsearch",
        "peekOfCode": "class WPSearch(object):\n    '''\n    Searches for immediate values commonly founds in MIPS WPS checksum implementations.\n    May be applicable to other architectures as well.\n    '''\n    IMMEDIATES = {\n                        0x6B5FCA6B : set(),\n                        0x431BDE83 : set(),\n                        0x0A7C5AC5 : set(),\n                        0x10624DD3 : set(),",
        "detail": "scripts.wpsearch",
        "documentation": {}
    },
    {
        "label": "WPSearchFunctionChooser",
        "kind": 6,
        "importPath": "scripts.wpsearch",
        "description": "scripts.wpsearch",
        "peekOfCode": "class WPSearchFunctionChooser(idaapi.Choose2):\n    DELIM_COL_1 = '-' * 50\n    DELIM_COL_2 = '-' * 20\n    DELIM_COL_3 = '-' * 125\n    def __init__(self):\n        idaapi.Choose2.__init__(self,\n                                \"WPS Function Profiles\",\n                                [\n                                    [\"Function\", 15 | idaapi.Choose2.CHCOL_PLAIN],\n                                    [\"Contains checksum algorithm\", 15 | idaapi.Choose2.CHCOL_PLAIN],",
        "detail": "scripts.wpsearch",
        "documentation": {}
    }
]